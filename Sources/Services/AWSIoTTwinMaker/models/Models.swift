// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.BatchPutPropertyError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = self.entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyValueEntry.self, forKey: .entry)
        entry = entryDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An error returned by the BatchPutProperty action.
    public struct BatchPutPropertyError: Swift.Equatable {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var entry: IoTTwinMakerClientTypes.PropertyValueEntry?
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entry: IoTTwinMakerClientTypes.PropertyValueEntry? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for batchputpropertyerror0 in errors {
                try errorsContainer.encode(batchputpropertyerror0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.BatchPutPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTTwinMakerClientTypes.BatchPutPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about errors returned by the BatchPutProperty action.
    public struct BatchPutPropertyErrorEntry: Swift.Equatable {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]?

        public init(
            errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        )
        {
            self.errors = errors
        }
    }

}

extension BatchPutPropertyValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for propertyvalueentry0 in entries {
                try entriesContainer.encode(propertyvalueentry0)
            }
        }
    }
}

extension BatchPutPropertyValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties"
    }
}

public struct BatchPutPropertyValuesInput: Swift.Equatable {
    /// An object that maps strings to the property value entries to set. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
    /// The ID of the workspace that contains the properties to set.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        entries: [IoTTwinMakerClientTypes.PropertyValueEntry]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entries = entries
        self.workspaceId = workspaceId
    }
}

struct BatchPutPropertyValuesInputBody: Swift.Equatable {
    let entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
}

extension BatchPutPropertyValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTTwinMakerClientTypes.PropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTTwinMakerClientTypes.PropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutPropertyValuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutPropertyValuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutPropertyValuesOutput: Swift.Equatable {
    /// Entries that caused errors in the batch put operation.
    /// This member is required.
    public var errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?

    public init(
        errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutPropertyValuesOutputBody: Swift.Equatable {
    let errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?
}

extension BatchPutPropertyValuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchPutPropertyValuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.BundleInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleNames
        case pricingTier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleNames = bundleNames {
            var bundleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleNames)
            for bundlename0 in bundleNames {
                try bundleNamesContainer.encode(bundlename0)
            }
        }
        if let pricingTier = self.pricingTier {
            try encodeContainer.encode(pricingTier.rawValue, forKey: .pricingTier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleNames)
        var bundleNamesDecoded0:[Swift.String]? = nil
        if let bundleNamesContainer = bundleNamesContainer {
            bundleNamesDecoded0 = [Swift.String]()
            for string0 in bundleNamesContainer {
                if let string0 = string0 {
                    bundleNamesDecoded0?.append(string0)
                }
            }
        }
        bundleNames = bundleNamesDecoded0
        let pricingTierDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingTier.self, forKey: .pricingTier)
        pricingTier = pricingTierDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Information about the pricing bundle.
    public struct BundleInformation: Swift.Equatable {
        /// The bundle names.
        /// This member is required.
        public var bundleNames: [Swift.String]?
        /// The pricing tier.
        public var pricingTier: IoTTwinMakerClientTypes.PricingTier?

        public init(
            bundleNames: [Swift.String]? = nil,
            pricingTier: IoTTwinMakerClientTypes.PricingTier? = nil
        )
        {
            self.bundleNames = bundleNames
            self.pricingTier = pricingTier
        }
    }

}

extension CancelMetadataTransferJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metadataTransferJobId = metadataTransferJobId else {
            return nil
        }
        return "/metadata-transfer-jobs/\(metadataTransferJobId.urlPercentEncoding())/cancel"
    }
}

public struct CancelMetadataTransferJobInput: Swift.Equatable {
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?

    public init(
        metadataTransferJobId: Swift.String? = nil
    )
    {
        self.metadataTransferJobId = metadataTransferJobId
    }
}

struct CancelMetadataTransferJobInputBody: Swift.Equatable {
}

extension CancelMetadataTransferJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelMetadataTransferJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelMetadataTransferJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.metadataTransferJobId = output.metadataTransferJobId
            self.progress = output.progress
            self.status = output.status
            self.updateDateTime = output.updateDateTime
        } else {
            self.arn = nil
            self.metadataTransferJobId = nil
            self.progress = nil
            self.status = nil
            self.updateDateTime = nil
        }
    }
}

public struct CancelMetadataTransferJobOutput: Swift.Equatable {
    /// The metadata transfer job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job's progress.
    public var progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
    /// The metadata transfer job's status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
    /// Used to update the DateTime property.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        metadataTransferJobId: Swift.String? = nil,
        progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress? = nil,
        status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.metadataTransferJobId = metadataTransferJobId
        self.progress = progress
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

struct CancelMetadataTransferJobOutputBody: Swift.Equatable {
    let metadataTransferJobId: Swift.String?
    let arn: Swift.String?
    let updateDateTime: ClientRuntime.Date?
    let status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
    let progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
}

extension CancelMetadataTransferJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case metadataTransferJobId
        case progress
        case status
        case updateDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataTransferJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataTransferJobId)
        metadataTransferJobId = metadataTransferJobIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobStatus.self, forKey: .status)
        status = statusDecoded
        let progressDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobProgress.self, forKey: .progress)
        progress = progressDecoded
    }
}

enum CancelMetadataTransferJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.ColumnDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ColumnType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// A description of the column in the query results.
    public struct ColumnDescription: Swift.Equatable {
        /// The name of the column description.
        public var name: Swift.String?
        /// The type of the column description.
        public var type: IoTTwinMakerClientTypes.ColumnType?

        public init(
            name: Swift.String? = nil,
            type: IoTTwinMakerClientTypes.ColumnType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ColumnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case node
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnType] {
            return [
                .edge,
                .node,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .node: return "NODE"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnType(rawValue: rawValue) ?? ColumnType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ComponentPropertyGroupRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case propertyNames
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyGroupUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The component property group request.
    public struct ComponentPropertyGroupRequest: Swift.Equatable {
        /// The group type.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// The property names.
        public var propertyNames: [Swift.String]?
        /// The update type.
        public var updateType: IoTTwinMakerClientTypes.PropertyGroupUpdateType?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            propertyNames: [Swift.String]? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyGroupUpdateType? = nil
        )
        {
            self.groupType = groupType
            self.propertyNames = propertyNames
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentPropertyGroupResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case isInherited
        case propertyNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The component property group response.
    public struct ComponentPropertyGroupResponse: Swift.Equatable {
        /// The group type.
        /// This member is required.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// The names of properties
        /// This member is required.
        public var propertyNames: [Swift.String]?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            isInherited: Swift.Bool? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case description
        case properties
        case propertyGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyRequests0) in properties {
                try propertiesContainer.encode(propertyRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, componentPropertyGroupRequests0) in propertyGroups {
                try propertyGroupsContainer.encode(componentPropertyGroupRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertiesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertiesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        properties = propertiesDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]()
            for (key0, componentpropertygrouprequest0) in propertyGroupsContainer {
                if let componentpropertygrouprequest0 = componentpropertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = componentpropertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a component type create or update request.
    public struct ComponentRequest: Swift.Equatable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component request.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The property groups.
        public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?

        public init(
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areAllCompositeComponentsReturned
        case areAllPropertiesReturned
        case componentName
        case componentTypeId
        case compositeComponents
        case definedIn
        case description
        case properties
        case propertyGroups
        case status
        case syncSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areAllCompositeComponentsReturned = self.areAllCompositeComponentsReturned {
            try encodeContainer.encode(areAllCompositeComponentsReturned, forKey: .areAllCompositeComponentsReturned)
        }
        if let areAllPropertiesReturned = self.areAllPropertiesReturned {
            try encodeContainer.encode(areAllPropertiesReturned, forKey: .areAllPropertiesReturned)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let compositeComponents = compositeComponents {
            var compositeComponentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compositeComponents)
            for (dictKey0, compositeComponentResponse0) in compositeComponents {
                try compositeComponentsContainer.encode(compositeComponentResponse0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let definedIn = self.definedIn {
            try encodeContainer.encode(definedIn, forKey: .definedIn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyResponses0) in properties {
                try propertiesContainer.encode(propertyResponses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, componentPropertyGroupResponses0) in propertyGroups {
                try propertyGroupsContainer.encode(componentPropertyGroupResponses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncSource = self.syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let definedInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definedIn)
        definedIn = definedInDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyResponse?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]()
            for (key0, propertyresponse0) in propertiesContainer {
                if let propertyresponse0 = propertyresponse0 {
                    propertiesDecoded0?[key0] = propertyresponse0
                }
            }
        }
        properties = propertiesDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]()
            for (key0, componentpropertygroupresponse0) in propertyGroupsContainer {
                if let componentpropertygroupresponse0 = componentpropertygroupresponse0 {
                    propertyGroupsDecoded0?[key0] = componentpropertygroupresponse0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let areAllPropertiesReturnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .areAllPropertiesReturned)
        areAllPropertiesReturned = areAllPropertiesReturnedDecoded
        let compositeComponentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentSummary?].self, forKey: .compositeComponents)
        var compositeComponentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentSummary]? = nil
        if let compositeComponentsContainer = compositeComponentsContainer {
            compositeComponentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentSummary]()
            for (key0, componentsummary0) in compositeComponentsContainer {
                if let componentsummary0 = componentsummary0 {
                    compositeComponentsDecoded0?[key0] = componentsummary0
                }
            }
        }
        compositeComponents = compositeComponentsDecoded0
        let areAllCompositeComponentsReturnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .areAllCompositeComponentsReturned)
        areAllCompositeComponentsReturned = areAllCompositeComponentsReturnedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that returns information about a component type create or update request.
    public struct ComponentResponse: Swift.Equatable {
        /// This flag notes whether all compositeComponents are returned in the API response.
        public var areAllCompositeComponentsReturned: Swift.Bool?
        /// This flag notes whether all properties of the component are returned in the API response. The maximum number of properties returned is 800.
        public var areAllPropertiesReturned: Swift.Bool?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// This lists objects that contain information about the compositeComponents.
        public var compositeComponents: [Swift.String:IoTTwinMakerClientTypes.ComponentSummary]?
        /// The name of the property definition set in the request.
        public var definedIn: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]?
        /// The property groups.
        public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]?
        /// The status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public var syncSource: Swift.String?

        public init(
            areAllCompositeComponentsReturned: Swift.Bool? = nil,
            areAllPropertiesReturned: Swift.Bool? = nil,
            componentName: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            compositeComponents: [Swift.String:IoTTwinMakerClientTypes.ComponentSummary]? = nil,
            definedIn: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]? = nil,
            propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            syncSource: Swift.String? = nil
        )
        {
            self.areAllCompositeComponentsReturned = areAllCompositeComponentsReturned
            self.areAllPropertiesReturned = areAllPropertiesReturned
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.compositeComponents = compositeComponents
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case componentTypeId
        case definedIn
        case description
        case propertyGroups
        case status
        case syncSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPath = self.componentPath {
            try encodeContainer.encode(componentPath, forKey: .componentPath)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let definedIn = self.definedIn {
            try encodeContainer.encode(definedIn, forKey: .definedIn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, componentPropertyGroupResponses0) in propertyGroups {
                try propertyGroupsContainer.encode(componentPropertyGroupResponses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncSource = self.syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let definedInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definedIn)
        definedIn = definedInDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]()
            for (key0, componentpropertygroupresponse0) in propertyGroupsContainer {
                if let componentpropertygroupresponse0 = componentpropertygroupresponse0 {
                    propertyGroupsDecoded0?[key0] = componentpropertygroupresponse0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let componentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentPath)
        componentPath = componentPathDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that returns information about a component summary.
    public struct ComponentSummary: Swift.Equatable {
        /// The name of the component.
        /// This member is required.
        public var componentName: Swift.String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public var componentPath: Swift.String?
        /// The ID of the component type.
        /// This member is required.
        public var componentTypeId: Swift.String?
        /// The name of the property definition set in the request.
        public var definedIn: Swift.String?
        /// The description of the component request.
        public var description: Swift.String?
        /// The property groups.
        public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]?
        /// The status of the component type.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public var syncSource: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            componentPath: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            definedIn: Swift.String? = nil,
            description: Swift.String? = nil,
            propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            syncSource: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentPath = componentPath
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case componentTypeName
        case creationDateTime
        case description
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let componentTypeName = self.componentTypeName {
            try encodeContainer.encode(componentTypeName, forKey: .componentTypeName)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a component type.
    public struct ComponentTypeSummary: Swift.Equatable {
        /// The ARN of the component type.
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the component type.
        /// This member is required.
        public var componentTypeId: Swift.String?
        /// The component type name.
        public var componentTypeName: Swift.String?
        /// The date and time when the component type was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the component type.
        public var description: Swift.String?
        /// The current status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The date and time when the component type was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            componentTypeName: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case description
        case propertyGroupUpdates
        case propertyUpdates
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let propertyGroupUpdates = propertyGroupUpdates {
            var propertyGroupUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroupUpdates)
            for (dictKey0, componentPropertyGroupRequests0) in propertyGroupUpdates {
                try propertyGroupUpdatesContainer.encode(componentPropertyGroupRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyUpdates = propertyUpdates {
            var propertyUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyUpdates)
            for (dictKey0, propertyRequests0) in propertyUpdates {
                try propertyUpdatesContainer.encode(propertyRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ComponentUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let propertyUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .propertyUpdates)
        var propertyUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertyUpdatesContainer = propertyUpdatesContainer {
            propertyUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertyUpdatesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertyUpdatesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        propertyUpdates = propertyUpdatesDecoded0
        let propertyGroupUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?].self, forKey: .propertyGroupUpdates)
        var propertyGroupUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        if let propertyGroupUpdatesContainer = propertyGroupUpdatesContainer {
            propertyGroupUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]()
            for (key0, componentpropertygrouprequest0) in propertyGroupUpdatesContainer {
                if let componentpropertygrouprequest0 = componentpropertygrouprequest0 {
                    propertyGroupUpdatesDecoded0?[key0] = componentpropertygrouprequest0
                }
            }
        }
        propertyGroupUpdates = propertyGroupUpdatesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The component update request.
    public struct ComponentUpdateRequest: Swift.Equatable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// The property group updates.
        public var propertyGroupUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public var propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The update type of the component update request.
        public var updateType: IoTTwinMakerClientTypes.ComponentUpdateType?

        public init(
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            propertyGroupUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil,
            propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            updateType: IoTTwinMakerClientTypes.ComponentUpdateType? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ComponentUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentUpdateType(rawValue: rawValue) ?? ComponentUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.CompositeComponentRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case properties
        case propertyGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyRequests0) in properties {
                try propertiesContainer.encode(propertyRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, componentPropertyGroupRequests0) in propertyGroups {
                try propertyGroupsContainer.encode(componentPropertyGroupRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertiesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertiesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        properties = propertiesDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]()
            for (key0, componentpropertygrouprequest0) in propertyGroupsContainer {
                if let componentpropertygrouprequest0 = componentpropertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = componentpropertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about the composite component update request.
    public struct CompositeComponentRequest: Swift.Equatable {
        /// The description of the component type.
        public var description: Swift.String?
        /// This is an object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The property groups.
        public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?

        public init(
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        )
        {
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }
    }

}

extension IoTTwinMakerClientTypes.CompositeComponentTypeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about the composite component types of a component type.
    public struct CompositeComponentTypeRequest: Swift.Equatable {
        /// This is the componentTypeId that the compositeComponentType refers to.
        public var componentTypeId: Swift.String?

        public init(
            componentTypeId: Swift.String? = nil
        )
        {
            self.componentTypeId = componentTypeId
        }
    }

}

extension IoTTwinMakerClientTypes.CompositeComponentTypeResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case isInherited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that returns information about the composite component types of a component type.
    public struct CompositeComponentTypeResponse: Swift.Equatable {
        /// This is the componentTypeId that this compositeComponentType refers to.
        public var componentTypeId: Swift.String?
        /// This boolean indicates whether this compositeComponentType is inherited from its parent.
        public var isInherited: Swift.Bool?

        public init(
            componentTypeId: Swift.String? = nil,
            isInherited: Swift.Bool? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.isInherited = isInherited
        }
    }

}

extension IoTTwinMakerClientTypes.CompositeComponentUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case propertyGroupUpdates
        case propertyUpdates
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let propertyGroupUpdates = propertyGroupUpdates {
            var propertyGroupUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroupUpdates)
            for (dictKey0, componentPropertyGroupRequests0) in propertyGroupUpdates {
                try propertyGroupUpdatesContainer.encode(componentPropertyGroupRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyUpdates = propertyUpdates {
            var propertyUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyUpdates)
            for (dictKey0, propertyRequests0) in propertyUpdates {
                try propertyUpdatesContainer.encode(propertyRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ComponentUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .propertyUpdates)
        var propertyUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertyUpdatesContainer = propertyUpdatesContainer {
            propertyUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertyUpdatesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertyUpdatesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        propertyUpdates = propertyUpdatesDecoded0
        let propertyGroupUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?].self, forKey: .propertyGroupUpdates)
        var propertyGroupUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        if let propertyGroupUpdatesContainer = propertyGroupUpdatesContainer {
            propertyGroupUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]()
            for (key0, componentpropertygrouprequest0) in propertyGroupUpdatesContainer {
                if let componentpropertygrouprequest0 = componentpropertygrouprequest0 {
                    propertyGroupUpdatesDecoded0?[key0] = componentpropertygrouprequest0
                }
            }
        }
        propertyGroupUpdates = propertyGroupUpdatesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about the composite component update request.
    public struct CompositeComponentUpdateRequest: Swift.Equatable {
        /// The description of the component type.
        public var description: Swift.String?
        /// The property group updates.
        public var propertyGroupUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public var propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The update type of the component update request.
        public var updateType: IoTTwinMakerClientTypes.ComponentUpdateType?

        public init(
            description: Swift.String? = nil,
            propertyGroupUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil,
            propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            updateType: IoTTwinMakerClientTypes.ComponentUpdateType? = nil
        )
        {
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A conflict occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConnectorFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The connector failed.
public struct ConnectorFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorFailureException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConnectorFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConnectorTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The connector timed out.
public struct ConnectorTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConnectorTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateComponentTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case compositeComponentTypes
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeName = self.componentTypeName {
            try encodeContainer.encode(componentTypeName, forKey: .componentTypeName)
        }
        if let compositeComponentTypes = compositeComponentTypes {
            var compositeComponentTypesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compositeComponentTypes)
            for (dictKey0, compositeComponentTypesRequest0) in compositeComponentTypes {
                try compositeComponentTypesContainer.encode(compositeComponentTypesRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let extendsFrom = extendsFrom {
            var extendsFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendsFrom)
            for componenttypeid0 in extendsFrom {
                try extendsFromContainer.encode(componenttypeid0)
            }
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functions)
            for (dictKey0, functionsRequest0) in functions {
                try functionsContainer.encode(functionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isSingleton = self.isSingleton {
            try encodeContainer.encode(isSingleton, forKey: .isSingleton)
        }
        if let propertyDefinitions = propertyDefinitions {
            var propertyDefinitionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyDefinitions)
            for (dictKey0, propertyDefinitionsRequest0) in propertyDefinitions {
                try propertyDefinitionsContainer.encode(propertyDefinitionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, propertyGroupsRequest0) in propertyGroups {
                try propertyGroupsContainer.encode(propertyGroupsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct CreateComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// A friendly name for the component type.
    public var componentTypeName: Swift.String?
    /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
    public var compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the parent component type to extend.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    ///
    public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    /// Metadata that you can use to manage the component type.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.compositeComponentTypes = compositeComponentTypes
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateComponentTypeInputBody: Swift.Equatable {
    let isSingleton: Swift.Bool?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    let tags: [Swift.String:Swift.String]?
    let propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    let componentTypeName: Swift.String?
    let compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]?
}

extension CreateComponentTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case compositeComponentTypes
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]()
            for (key0, propertydefinitionrequest0) in propertyDefinitionsContainer {
                if let propertydefinitionrequest0 = propertydefinitionrequest0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionrequest0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionRequest?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]()
            for (key0, functionrequest0) in functionsContainer {
                if let functionrequest0 = functionrequest0 {
                    functionsDecoded0?[key0] = functionrequest0
                }
            }
        }
        functions = functionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]()
            for (key0, propertygrouprequest0) in propertyGroupsContainer {
                if let propertygrouprequest0 = propertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = propertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
        let compositeComponentTypesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeRequest?].self, forKey: .compositeComponentTypes)
        var compositeComponentTypesDecoded0: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]? = nil
        if let compositeComponentTypesContainer = compositeComponentTypesContainer {
            compositeComponentTypesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]()
            for (key0, compositecomponenttyperequest0) in compositeComponentTypesContainer {
                if let compositecomponenttyperequest0 = compositecomponenttyperequest0 {
                    compositeComponentTypesDecoded0?[key0] = compositecomponenttyperequest0
                }
            }
        }
        compositeComponentTypes = compositeComponentTypesDecoded0
    }
}

extension CreateComponentTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateComponentTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.state = nil
        }
    }
}

public struct CreateComponentTypeOutput: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

struct CreateComponentTypeOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension CreateComponentTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateComponentTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case compositeComponents
        case description
        case entityId
        case entityName
        case parentEntityId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .components)
            for (dictKey0, componentsMapRequest0) in components {
                try componentsContainer.encode(componentsMapRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let compositeComponents = compositeComponents {
            var compositeComponentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compositeComponents)
            for (dictKey0, compositeComponentsMapRequest0) in compositeComponents {
                try compositeComponentsContainer.encode(compositeComponentsMapRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let parentEntityId = self.parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities"
    }
}

public struct CreateEntityInput: Swift.Equatable {
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]?
    /// This is an object that maps strings to compositeComponent updates in the request. Each key of the map represents the componentPath of the compositeComponent.
    public var compositeComponents: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// The ID of the entity's parent entity.
    public var parentEntityId: Swift.String?
    /// Metadata that you can use to manage the entity.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]? = nil,
        compositeComponents: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.components = components
        self.compositeComponents = compositeComponents
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityId = parentEntityId
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateEntityInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let entityName: Swift.String?
    let description: Swift.String?
    let components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]?
    let compositeComponents: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentRequest]?
    let parentEntityId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case compositeComponents
        case description
        case entityId
        case entityName
        case parentEntityId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentRequest?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]()
            for (key0, componentrequest0) in componentsContainer {
                if let componentrequest0 = componentrequest0 {
                    componentsDecoded0?[key0] = componentrequest0
                }
            }
        }
        components = componentsDecoded0
        let compositeComponentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.CompositeComponentRequest?].self, forKey: .compositeComponents)
        var compositeComponentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentRequest]? = nil
        if let compositeComponentsContainer = compositeComponentsContainer {
            compositeComponentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.CompositeComponentRequest]()
            for (key0, compositecomponentrequest0) in compositeComponentsContainer {
                if let compositecomponentrequest0 = compositecomponentrequest0 {
                    compositeComponentsDecoded0?[key0] = compositecomponentrequest0
                }
            }
        }
        compositeComponents = compositeComponentsDecoded0
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.entityId = output.entityId
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.entityId = nil
            self.state = nil
        }
    }
}

public struct CreateEntityOutput: Swift.Equatable {
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The current state of the entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.entityId = entityId
        self.state = state
    }
}

struct CreateEntityOutputBody: Swift.Equatable {
    let entityId: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension CreateEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case entityId
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMetadataTransferJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destination
        case metadataTransferJobId
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let metadataTransferJobId = self.metadataTransferJobId {
            try encodeContainer.encode(metadataTransferJobId, forKey: .metadataTransferJobId)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfiguration0 in sources {
                try sourcesContainer.encode(sourceconfiguration0)
            }
        }
    }
}

extension CreateMetadataTransferJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/metadata-transfer-jobs"
    }
}

public struct CreateMetadataTransferJobInput: Swift.Equatable {
    /// The metadata transfer job description.
    public var description: Swift.String?
    /// The metadata transfer job destination.
    /// This member is required.
    public var destination: IoTTwinMakerClientTypes.DestinationConfiguration?
    /// The metadata transfer job Id.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job sources.
    /// This member is required.
    public var sources: [IoTTwinMakerClientTypes.SourceConfiguration]?

    public init(
        description: Swift.String? = nil,
        destination: IoTTwinMakerClientTypes.DestinationConfiguration? = nil,
        metadataTransferJobId: Swift.String? = nil,
        sources: [IoTTwinMakerClientTypes.SourceConfiguration]? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.metadataTransferJobId = metadataTransferJobId
        self.sources = sources
    }
}

struct CreateMetadataTransferJobInputBody: Swift.Equatable {
    let metadataTransferJobId: Swift.String?
    let description: Swift.String?
    let sources: [IoTTwinMakerClientTypes.SourceConfiguration]?
    let destination: IoTTwinMakerClientTypes.DestinationConfiguration?
}

extension CreateMetadataTransferJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destination
        case metadataTransferJobId
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataTransferJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataTransferJobId)
        metadataTransferJobId = metadataTransferJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[IoTTwinMakerClientTypes.SourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [IoTTwinMakerClientTypes.SourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let destinationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DestinationConfiguration.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension CreateMetadataTransferJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMetadataTransferJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.metadataTransferJobId = output.metadataTransferJobId
            self.status = output.status
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.metadataTransferJobId = nil
            self.status = nil
        }
    }
}

public struct CreateMetadataTransferJobOutput: Swift.Equatable {
    /// The metadata transfer job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The The metadata transfer job creation DateTime property.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job response status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        metadataTransferJobId: Swift.String? = nil,
        status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.metadataTransferJobId = metadataTransferJobId
        self.status = status
    }
}

struct CreateMetadataTransferJobOutputBody: Swift.Equatable {
    let metadataTransferJobId: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
}

extension CreateMetadataTransferJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case metadataTransferJobId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataTransferJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataTransferJobId)
        metadataTransferJobId = metadataTransferJobIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateMetadataTransferJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSceneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneId
        case sceneMetadata
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for scenecapability0 in capabilities {
                try capabilitiesContainer.encode(scenecapability0)
            }
        }
        if let contentLocation = self.contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneId = self.sceneId {
            try encodeContainer.encode(sceneId, forKey: .sceneId)
        }
        if let sceneMetadata = sceneMetadata {
            var sceneMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sceneMetadata)
            for (dictKey0, sceneMetadataMap0) in sceneMetadata {
                try sceneMetadataContainer.encode(sceneMetadataMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes"
    }
}

public struct CreateSceneInput: Swift.Equatable {
    /// A list of capabilities that the scene uses to render itself.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The description for this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The request metadata.
    public var sceneMetadata: [Swift.String:Swift.String]?
    /// Metadata that you can use to manage the scene.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        sceneMetadata: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.sceneMetadata = sceneMetadata
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateSceneInputBody: Swift.Equatable {
    let sceneId: Swift.String?
    let contentLocation: Swift.String?
    let description: Swift.String?
    let capabilities: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let sceneMetadata: [Swift.String:Swift.String]?
}

extension CreateSceneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneId
        case sceneMetadata
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let sceneMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sceneMetadata)
        var sceneMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let sceneMetadataContainer = sceneMetadataContainer {
            sceneMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, scenemetadatavalue0) in sceneMetadataContainer {
                if let scenemetadatavalue0 = scenemetadatavalue0 {
                    sceneMetadataDecoded0?[key0] = scenemetadatavalue0
                }
            }
        }
        sceneMetadata = sceneMetadataDecoded0
    }
}

extension CreateSceneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSceneOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
        }
    }
}

public struct CreateSceneOutput: Swift.Equatable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

struct CreateSceneOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateSceneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

enum CreateSceneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSyncJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncRole
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncRole = self.syncRole {
            try encodeContainer.encode(syncRole, forKey: .syncRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let syncSource = syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

public struct CreateSyncJobInput: Swift.Equatable {
    /// The SyncJob IAM role. This IAM role is used by the SyncJob to read from the syncSource, and create, update, or delete the corresponding resources.
    /// This member is required.
    public var syncRole: Swift.String?
    /// The sync source. Currently the only supported syncSoource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The SyncJob tags.
    public var tags: [Swift.String:Swift.String]?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        syncRole: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncRole = syncRole
        self.syncSource = syncSource
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateSyncJobInputBody: Swift.Equatable {
    let syncRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSyncJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncRole
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncRole)
        syncRole = syncRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSyncJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSyncJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.state = nil
        }
    }
}

public struct CreateSyncJobOutput: Swift.Equatable {
    /// The SyncJob ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time for the SyncJob creation.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The SyncJob response state.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.SyncJobState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        state: IoTTwinMakerClientTypes.SyncJobState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

struct CreateSyncJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.SyncJobState?
}

extension CreateSyncJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobState.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateSyncJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct CreateWorkspaceInput: Swift.Equatable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    public var s3Location: Swift.String?
    /// Metadata that you can use to manage the workspace
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let s3Location: Swift.String?
    let role: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
        }
    }
}

public struct CreateWorkspaceOutput: Swift.Equatable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

struct CreateWorkspaceOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

enum CreateWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.DataConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isNative
        case lambda
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isNative = self.isNative {
            try encodeContainer.encode(isNative, forKey: .isNative)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.LambdaFunction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let isNativeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNative)
        isNative = isNativeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The data connector.
    public struct DataConnector: Swift.Equatable {
        /// A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
        public var isNative: Swift.Bool?
        /// The Lambda function associated with this data connector.
        public var lambda: IoTTwinMakerClientTypes.LambdaFunction?

        public init(
            isNative: Swift.Bool? = nil,
            lambda: IoTTwinMakerClientTypes.LambdaFunction? = nil
        )
        {
            self.isNative = isNative
            self.lambda = lambda
        }
    }

}

extension IoTTwinMakerClientTypes.DataType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case nestedType
        case relationship
        case type
        case unitOfMeasure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for datavalue0 in allowedValues {
                try allowedValuesContainer.encode(datavalue0)
            }
        }
        if let nestedType = self.nestedType {
            try encodeContainer.encode(nestedType, forKey: .nestedType)
        }
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship, forKey: .relationship)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let unitOfMeasure = self.unitOfMeasure {
            try encodeContainer.encode(unitOfMeasure, forKey: .unitOfMeasure)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let nestedTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .nestedType)
        nestedType = nestedTypeDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.DataValue?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[IoTTwinMakerClientTypes.DataValue]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [IoTTwinMakerClientTypes.DataValue]()
            for structure0 in allowedValuesContainer {
                if let structure0 = structure0 {
                    allowedValuesDecoded0?.append(structure0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let unitOfMeasureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitOfMeasure)
        unitOfMeasure = unitOfMeasureDecoded
        let relationshipDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Relationship.self, forKey: .relationship)
        relationship = relationshipDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies the data type of a property.
    public struct DataType: Swift.Equatable {
        /// The allowed values for this data type.
        public var allowedValues: [IoTTwinMakerClientTypes.DataValue]?
        /// The nested type in the data type.
        @Indirect public var nestedType: IoTTwinMakerClientTypes.DataType?
        /// A relationship that associates a component with another component.
        public var relationship: IoTTwinMakerClientTypes.Relationship?
        /// The underlying type of the data type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.ModelType?
        /// The unit of measure used in this data type.
        public var unitOfMeasure: Swift.String?

        public init(
            allowedValues: [IoTTwinMakerClientTypes.DataValue]? = nil,
            nestedType: IoTTwinMakerClientTypes.DataType? = nil,
            relationship: IoTTwinMakerClientTypes.Relationship? = nil,
            type: IoTTwinMakerClientTypes.ModelType? = nil,
            unitOfMeasure: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }
    }

}

extension IoTTwinMakerClientTypes.DataValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case expression
        case integerValue
        case listValue
        case longValue
        case mapValue
        case relationshipValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = self.booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = self.doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let integerValue = self.integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let listValue = listValue {
            var listValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listValue)
            for datavalue0 in listValue {
                try listValueContainer.encode(datavalue0)
            }
        }
        if let longValue = self.longValue {
            try encodeContainer.encode(longValue, forKey: .longValue)
        }
        if let mapValue = mapValue {
            var mapValueContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mapValue)
            for (dictKey0, dataValueMap0) in mapValue {
                try mapValueContainer.encode(dataValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let relationshipValue = self.relationshipValue {
            try encodeContainer.encode(relationshipValue, forKey: .relationshipValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let longValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .longValue)
        longValue = longValueDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let listValueContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.DataValue?].self, forKey: .listValue)
        var listValueDecoded0:[IoTTwinMakerClientTypes.DataValue]? = nil
        if let listValueContainer = listValueContainer {
            listValueDecoded0 = [IoTTwinMakerClientTypes.DataValue]()
            for structure0 in listValueContainer {
                if let structure0 = structure0 {
                    listValueDecoded0?.append(structure0)
                }
            }
        }
        listValue = listValueDecoded0
        let mapValueContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.DataValue?].self, forKey: .mapValue)
        var mapValueDecoded0: [Swift.String:IoTTwinMakerClientTypes.DataValue]? = nil
        if let mapValueContainer = mapValueContainer {
            mapValueDecoded0 = [Swift.String:IoTTwinMakerClientTypes.DataValue]()
            for (key0, datavalue0) in mapValueContainer {
                if let datavalue0 = datavalue0 {
                    mapValueDecoded0?[key0] = datavalue0
                }
            }
        }
        mapValue = mapValueDecoded0
        let relationshipValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.RelationshipValue.self, forKey: .relationshipValue)
        relationshipValue = relationshipValueDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies a value for a property.
    public struct DataValue: Swift.Equatable {
        /// A Boolean value.
        public var booleanValue: Swift.Bool?
        /// A double value.
        public var doubleValue: Swift.Double?
        /// An expression that produces the value.
        public var expression: Swift.String?
        /// An integer value.
        public var integerValue: Swift.Int?
        /// A list of multiple values.
        public var listValue: [IoTTwinMakerClientTypes.DataValue]?
        /// A long value.
        public var longValue: Swift.Int?
        /// An object that maps strings to multiple DataValue objects.
        public var mapValue: [Swift.String:IoTTwinMakerClientTypes.DataValue]?
        /// A value that relates a component to another component.
        public var relationshipValue: IoTTwinMakerClientTypes.RelationshipValue?
        /// A string value.
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            expression: Swift.String? = nil,
            integerValue: Swift.Int? = nil,
            listValue: [IoTTwinMakerClientTypes.DataValue]? = nil,
            longValue: Swift.Int? = nil,
            mapValue: [Swift.String:IoTTwinMakerClientTypes.DataValue]? = nil,
            relationshipValue: IoTTwinMakerClientTypes.RelationshipValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }
    }

}

extension DeleteComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct DeleteComponentTypeInput: Swift.Equatable {
    /// The ID of the component type to delete.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

struct DeleteComponentTypeInputBody: Swift.Equatable {
}

extension DeleteComponentTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteComponentTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteComponentTypeOutput: Swift.Equatable {
    /// The current state of the component type to be deleted.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

struct DeleteComponentTypeOutputBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.State?
}

extension DeleteComponentTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteComponentTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEntityInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let isRecursive = isRecursive {
                let isRecursiveQueryItem = ClientRuntime.URLQueryItem(name: "isRecursive".urlPercentEncoding(), value: Swift.String(isRecursive).urlPercentEncoding())
                items.append(isRecursiveQueryItem)
            }
            return items
        }
    }
}

extension DeleteEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct DeleteEntityInput: Swift.Equatable {
    /// The ID of the entity to delete.
    /// This member is required.
    public var entityId: Swift.String?
    /// A Boolean value that specifies whether the operation deletes child entities.
    public var isRecursive: Swift.Bool?
    /// The ID of the workspace that contains the entity to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        isRecursive: Swift.Bool? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.isRecursive = isRecursive
        self.workspaceId = workspaceId
    }
}

struct DeleteEntityInputBody: Swift.Equatable {
}

extension DeleteEntityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteEntityOutput: Swift.Equatable {
    /// The current state of the deleted entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

struct DeleteEntityOutputBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.State?
}

extension DeleteEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct DeleteSceneInput: Swift.Equatable {
    /// The ID of the scene to delete.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct DeleteSceneInputBody: Swift.Equatable {
}

extension DeleteSceneInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSceneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSceneOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSceneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let syncSource = syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

public struct DeleteSyncJobInput: Swift.Equatable {
    /// The sync source. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

struct DeleteSyncJobInputBody: Swift.Equatable {
}

extension DeleteSyncJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSyncJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSyncJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteSyncJobOutput: Swift.Equatable {
    /// The SyncJob response state.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.SyncJobState?

    public init(
        state: IoTTwinMakerClientTypes.SyncJobState? = nil
    )
    {
        self.state = state
    }
}

struct DeleteSyncJobOutputBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.SyncJobState?
}

extension DeleteSyncJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteSyncJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DeleteWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteWorkspaceOutput: Swift.Equatable {
    /// The string that specifies the delete result for the workspace.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteWorkspaceOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotTwinMakerConfiguration
        case s3Configuration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotTwinMakerConfiguration = self.iotTwinMakerConfiguration {
            try encodeContainer.encode(iotTwinMakerConfiguration, forKey: .iotTwinMakerConfiguration)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DestinationType.self, forKey: .type)
        type = typeDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.S3DestinationConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let iotTwinMakerConfigurationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration.self, forKey: .iotTwinMakerConfiguration)
        iotTwinMakerConfiguration = iotTwinMakerConfigurationDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The [link to action] metadata transfer job destination configuration.
    public struct DestinationConfiguration: Swift.Equatable {
        /// The metadata transfer job Amazon Web Services IoT TwinMaker configuration.
        public var iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration?
        /// The metadata transfer job S3 configuration. [need to add S3 entity]
        public var s3Configuration: IoTTwinMakerClientTypes.S3DestinationConfiguration?
        /// The destination type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.DestinationType?

        public init(
            iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration? = nil,
            s3Configuration: IoTTwinMakerClientTypes.S3DestinationConfiguration? = nil,
            type: IoTTwinMakerClientTypes.DestinationType? = nil
        )
        {
            self.iotTwinMakerConfiguration = iotTwinMakerConfiguration
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iotsitewise
        case iottwinmaker
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .iotsitewise,
                .iottwinmaker,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iotsitewise: return "iotsitewise"
            case .iottwinmaker: return "iottwinmaker"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.EntityPropertyReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case entityId
        case externalIdProperty
        case propertyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPath = self.componentPath {
            try encodeContainer.encode(componentPath, forKey: .componentPath)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let externalIdProperty = externalIdProperty {
            var externalIdPropertyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalIdProperty)
            for (dictKey0, externalIdProperty0) in externalIdProperty {
                try externalIdPropertyContainer.encode(externalIdProperty0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentPath)
        componentPath = componentPathDecoded
        let externalIdPropertyContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .externalIdProperty)
        var externalIdPropertyDecoded0: [Swift.String:Swift.String]? = nil
        if let externalIdPropertyContainer = externalIdPropertyContainer {
            externalIdPropertyDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in externalIdPropertyContainer {
                if let string0 = string0 {
                    externalIdPropertyDecoded0?[key0] = string0
                }
            }
        }
        externalIdProperty = externalIdPropertyDecoded0
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that uniquely identifies an entity property.
    public struct EntityPropertyReference: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public var componentPath: Swift.String?
        /// The ID of the entity.
        public var entityId: Swift.String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public var externalIdProperty: [Swift.String:Swift.String]?
        /// The name of the property.
        /// This member is required.
        public var propertyName: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            componentPath: Swift.String? = nil,
            entityId: Swift.String? = nil,
            externalIdProperty: [Swift.String:Swift.String]? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentPath = componentPath
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }
    }

}

extension IoTTwinMakerClientTypes.EntitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case entityId
        case entityName
        case hasChildEntities
        case parentEntityId
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let hasChildEntities = self.hasChildEntities {
            try encodeContainer.encode(hasChildEntities, forKey: .hasChildEntities)
        }
        if let parentEntityId = self.parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hasChildEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasChildEntities)
        hasChildEntities = hasChildEntitiesDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about an entity.
    public struct EntitySummary: Swift.Equatable {
        /// The ARN of the entity.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the entity was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the entity.
        public var description: Swift.String?
        /// The ID of the entity.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the entity.
        /// This member is required.
        public var entityName: Swift.String?
        /// An eventual Boolean value that specifies whether the entity has child entities or not.
        public var hasChildEntities: Swift.Bool?
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The current status of the entity.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The last date and time when the entity was updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityName: Swift.String? = nil,
            hasChildEntities: Swift.Bool? = nil,
            parentEntityId: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compositeComponentFailure
        case internalFailure
        case processingError
        case syncCreatingError
        case syncDeletingError
        case syncInitializingError
        case syncProcessingError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .compositeComponentFailure,
                .internalFailure,
                .processingError,
                .syncCreatingError,
                .syncDeletingError,
                .syncInitializingError,
                .syncProcessingError,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compositeComponentFailure: return "COMPOSITE_COMPONENT_FAILURE"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .processingError: return "PROCESSING_ERROR"
            case .syncCreatingError: return "SYNC_CREATING_ERROR"
            case .syncDeletingError: return "SYNC_DELETING_ERROR"
            case .syncInitializingError: return "SYNC_INITIALIZING_ERROR"
            case .syncProcessingError: return "SYNC_PROCESSING_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The error details.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        public var code: IoTTwinMakerClientTypes.ErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init(
            code: IoTTwinMakerClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension ExecuteQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryStatement
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension ExecuteQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/queries/execution"
    }
}

public struct ExecuteQueryInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 50.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The query statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatement = queryStatement
        self.workspaceId = workspaceId
    }
}

struct ExecuteQueryInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let queryStatement: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ExecuteQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryStatement
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExecuteQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.columnDescriptions = output.columnDescriptions
            self.nextToken = output.nextToken
            self.rows = output.rows
        } else {
            self.columnDescriptions = nil
            self.nextToken = nil
            self.rows = nil
        }
    }
}

public struct ExecuteQueryOutput: Swift.Equatable {
    /// A list of ColumnDescription objects.
    public var columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Represents a single row in the query results.
    public var rows: [IoTTwinMakerClientTypes.Row]?

    public init(
        columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]? = nil,
        nextToken: Swift.String? = nil,
        rows: [IoTTwinMakerClientTypes.Row]? = nil
    )
    {
        self.columnDescriptions = columnDescriptions
        self.nextToken = nextToken
        self.rows = rows
    }
}

struct ExecuteQueryOutputBody: Swift.Equatable {
    let columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]?
    let rows: [IoTTwinMakerClientTypes.Row]?
    let nextToken: Swift.String?
}

extension ExecuteQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescriptions
        case nextToken
        case rows
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDescriptionsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ColumnDescription?].self, forKey: .columnDescriptions)
        var columnDescriptionsDecoded0:[IoTTwinMakerClientTypes.ColumnDescription]? = nil
        if let columnDescriptionsContainer = columnDescriptionsContainer {
            columnDescriptionsDecoded0 = [IoTTwinMakerClientTypes.ColumnDescription]()
            for structure0 in columnDescriptionsContainer {
                if let structure0 = structure0 {
                    columnDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        columnDescriptions = columnDescriptionsDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[IoTTwinMakerClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [IoTTwinMakerClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ExecuteQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryTimeoutException": return try await QueryTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.FilterByAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetExternalId
        case assetId
        case includeAssetModel
        case includeOffspring
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetExternalId = self.assetExternalId {
            try encodeContainer.encode(assetExternalId, forKey: .assetExternalId)
        }
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let includeAssetModel = self.includeAssetModel {
            try encodeContainer.encode(includeAssetModel, forKey: .includeAssetModel)
        }
        if let includeOffspring = self.includeOffspring {
            try encodeContainer.encode(includeOffspring, forKey: .includeOffspring)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetExternalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetExternalId)
        assetExternalId = assetExternalIdDecoded
        let includeOffspringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOffspring)
        includeOffspring = includeOffspringDecoded
        let includeAssetModelDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAssetModel)
        includeAssetModel = includeAssetModelDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Filter by asset. [TwinMaker asset]
    public struct FilterByAsset: Swift.Equatable {
        /// The external-Id property of an asset.
        public var assetExternalId: Swift.String?
        /// Filter by asset Id.
        public var assetId: Swift.String?
        /// Boolean to include the asset model.
        public var includeAssetModel: Swift.Bool?
        /// Includes sub-assets.[need description hekp for this]
        public var includeOffspring: Swift.Bool?

        public init(
            assetExternalId: Swift.String? = nil,
            assetId: Swift.String? = nil,
            includeAssetModel: Swift.Bool? = nil,
            includeOffspring: Swift.Bool? = nil
        )
        {
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.includeAssetModel = includeAssetModel
            self.includeOffspring = includeOffspring
        }
    }

}

extension IoTTwinMakerClientTypes.FilterByAssetModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelExternalId
        case assetModelId
        case includeAssets
        case includeOffspring
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelExternalId = self.assetModelExternalId {
            try encodeContainer.encode(assetModelExternalId, forKey: .assetModelExternalId)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let includeAssets = self.includeAssets {
            try encodeContainer.encode(includeAssets, forKey: .includeAssets)
        }
        if let includeOffspring = self.includeOffspring {
            try encodeContainer.encode(includeOffspring, forKey: .includeOffspring)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelExternalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelExternalId)
        assetModelExternalId = assetModelExternalIdDecoded
        let includeOffspringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOffspring)
        includeOffspring = includeOffspringDecoded
        let includeAssetsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAssets)
        includeAssets = includeAssetsDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Filter by asset model.
    public struct FilterByAssetModel: Swift.Equatable {
        /// The external-Id property of an asset model.
        public var assetModelExternalId: Swift.String?
        /// The asset model Id.
        public var assetModelId: Swift.String?
        /// Bolean to include assets.
        public var includeAssets: Swift.Bool?
        /// Include asset offspring. [need desc.]
        public var includeOffspring: Swift.Bool?

        public init(
            assetModelExternalId: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            includeAssets: Swift.Bool? = nil,
            includeOffspring: Swift.Bool? = nil
        )
        {
            self.assetModelExternalId = assetModelExternalId
            self.assetModelId = assetModelId
            self.includeAssets = includeAssets
            self.includeOffspring = includeOffspring
        }
    }

}

extension IoTTwinMakerClientTypes.FilterByComponentType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Filter by component type.
    public struct FilterByComponentType: Swift.Equatable {
        /// The component type Id.
        /// This member is required.
        public var componentTypeId: Swift.String?

        public init(
            componentTypeId: Swift.String? = nil
        )
        {
            self.componentTypeId = componentTypeId
        }
    }

}

extension IoTTwinMakerClientTypes.FilterByEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Vilter by entity.
    public struct FilterByEntity: Swift.Equatable {
        /// The entity Id.
        /// This member is required.
        public var entityId: Swift.String?

        public init(
            entityId: Swift.String? = nil
        )
        {
            self.entityId = entityId
        }
    }

}

extension IoTTwinMakerClientTypes.FunctionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case implementedBy
        case requiredProperties
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let implementedBy = self.implementedBy {
            try encodeContainer.encode(implementedBy, forKey: .implementedBy)
        }
        if let requiredProperties = requiredProperties {
            var requiredPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredProperties)
            for name0 in requiredProperties {
                try requiredPropertiesContainer.encode(name0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredProperties)
        var requiredPropertiesDecoded0:[Swift.String]? = nil
        if let requiredPropertiesContainer = requiredPropertiesContainer {
            requiredPropertiesDecoded0 = [Swift.String]()
            for string0 in requiredPropertiesContainer {
                if let string0 = string0 {
                    requiredPropertiesDecoded0?.append(string0)
                }
            }
        }
        requiredProperties = requiredPropertiesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let implementedByDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataConnector.self, forKey: .implementedBy)
        implementedBy = implementedByDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The function request body.
    public struct FunctionRequest: Swift.Equatable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// The required properties of the function.
        public var requiredProperties: [Swift.String]?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init(
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            requiredProperties: [Swift.String]? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }

}

extension IoTTwinMakerClientTypes.FunctionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case implementedBy
        case isInherited
        case requiredProperties
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let implementedBy = self.implementedBy {
            try encodeContainer.encode(implementedBy, forKey: .implementedBy)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let requiredProperties = requiredProperties {
            var requiredPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredProperties)
            for name0 in requiredProperties {
                try requiredPropertiesContainer.encode(name0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredProperties)
        var requiredPropertiesDecoded0:[Swift.String]? = nil
        if let requiredPropertiesContainer = requiredPropertiesContainer {
            requiredPropertiesDecoded0 = [Swift.String]()
            for string0 in requiredPropertiesContainer {
                if let string0 = string0 {
                    requiredPropertiesDecoded0?.append(string0)
                }
            }
        }
        requiredProperties = requiredPropertiesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let implementedByDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataConnector.self, forKey: .implementedBy)
        implementedBy = implementedByDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The function response.
    public struct FunctionResponse: Swift.Equatable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// Indicates whether this function is inherited.
        public var isInherited: Swift.Bool?
        /// The required properties of the function.
        public var requiredProperties: [Swift.String]?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init(
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            isInherited: Swift.Bool? = nil,
            requiredProperties: [Swift.String]? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }

}

extension GetComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct GetComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

struct GetComponentTypeInputBody: Swift.Equatable {
}

extension GetComponentTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentTypeId = output.componentTypeId
            self.componentTypeName = output.componentTypeName
            self.compositeComponentTypes = output.compositeComponentTypes
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.extendsFrom = output.extendsFrom
            self.functions = output.functions
            self.isAbstract = output.isAbstract
            self.isSchemaInitialized = output.isSchemaInitialized
            self.isSingleton = output.isSingleton
            self.propertyDefinitions = output.propertyDefinitions
            self.propertyGroups = output.propertyGroups
            self.status = output.status
            self.syncSource = output.syncSource
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.componentTypeId = nil
            self.componentTypeName = nil
            self.compositeComponentTypes = nil
            self.creationDateTime = nil
            self.description = nil
            self.extendsFrom = nil
            self.functions = nil
            self.isAbstract = nil
            self.isSchemaInitialized = nil
            self.isSingleton = nil
            self.propertyDefinitions = nil
            self.propertyGroups = nil
            self.status = nil
            self.syncSource = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetComponentTypeOutput: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The component type name.
    public var componentTypeName: Swift.String?
    /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
    public var compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeResponse]?
    /// The date and time when the component type was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the component type.
    public var description: Swift.String?
    /// The name of the parent component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]?
    /// A Boolean value that specifies whether the component type is abstract.
    public var isAbstract: Swift.Bool?
    /// A Boolean value that specifies whether the component type has a schema initializer and that the schema initializer has run.
    public var isSchemaInitialized: Swift.Bool?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]?
    /// The current status of the component type.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The syncSource of the SyncJob, if this entity was created by a SyncJob.
    public var syncSource: Swift.String?
    /// The date and time when the component was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeResponse]? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]? = nil,
        isAbstract: Swift.Bool? = nil,
        isSchemaInitialized: Swift.Bool? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil,
        propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.compositeComponentTypes = compositeComponentTypes
        self.creationDateTime = creationDateTime
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isAbstract = isAbstract
        self.isSchemaInitialized = isSchemaInitialized
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.status = status
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetComponentTypeOutputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let isSingleton: Swift.Bool?
    let componentTypeId: Swift.String?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let arn: Swift.String?
    let isAbstract: Swift.Bool?
    let isSchemaInitialized: Swift.Bool?
    let status: IoTTwinMakerClientTypes.Status?
    let propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]?
    let syncSource: Swift.String?
    let componentTypeName: Swift.String?
    let compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeResponse]?
}

extension GetComponentTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case componentTypeName
        case compositeComponentTypes
        case creationDateTime
        case description
        case extendsFrom
        case functions
        case isAbstract
        case isSchemaInitialized
        case isSingleton
        case propertyDefinitions
        case propertyGroups
        case status
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionResponse?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]()
            for (key0, propertydefinitionresponse0) in propertyDefinitionsContainer {
                if let propertydefinitionresponse0 = propertydefinitionresponse0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionresponse0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionResponse?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]()
            for (key0, functionresponse0) in functionsContainer {
                if let functionresponse0 = functionresponse0 {
                    functionsDecoded0?[key0] = functionresponse0
                }
            }
        }
        functions = functionsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isAbstractDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAbstract)
        isAbstract = isAbstractDecoded
        let isSchemaInitializedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSchemaInitialized)
        isSchemaInitialized = isSchemaInitializedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyGroupResponse?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]()
            for (key0, propertygroupresponse0) in propertyGroupsContainer {
                if let propertygroupresponse0 = propertygroupresponse0 {
                    propertyGroupsDecoded0?[key0] = propertygroupresponse0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
        let compositeComponentTypesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeResponse?].self, forKey: .compositeComponentTypes)
        var compositeComponentTypesDecoded0: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeResponse]? = nil
        if let compositeComponentTypesContainer = compositeComponentTypesContainer {
            compositeComponentTypesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeResponse]()
            for (key0, compositecomponenttyperesponse0) in compositeComponentTypesContainer {
                if let compositecomponenttyperesponse0 = compositecomponenttyperesponse0 {
                    compositeComponentTypesDecoded0?[key0] = compositecomponenttyperesponse0
                }
            }
        }
        compositeComponentTypes = compositeComponentTypesDecoded0
    }
}

enum GetComponentTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct GetEntityInput: Swift.Equatable {
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.workspaceId = workspaceId
    }
}

struct GetEntityInputBody: Swift.Equatable {
}

extension GetEntityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.areAllComponentsReturned = output.areAllComponentsReturned
            self.arn = output.arn
            self.components = output.components
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.entityId = output.entityId
            self.entityName = output.entityName
            self.hasChildEntities = output.hasChildEntities
            self.parentEntityId = output.parentEntityId
            self.status = output.status
            self.syncSource = output.syncSource
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.areAllComponentsReturned = nil
            self.arn = nil
            self.components = nil
            self.creationDateTime = nil
            self.description = nil
            self.entityId = nil
            self.entityName = nil
            self.hasChildEntities = nil
            self.parentEntityId = nil
            self.status = nil
            self.syncSource = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetEntityOutput: Swift.Equatable {
    /// This flag notes whether all components are returned in the API response. The maximum number of components returned is 30.
    public var areAllComponentsReturned: Swift.Bool?
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// A Boolean value that specifies whether the entity has associated child entities.
    /// This member is required.
    public var hasChildEntities: Swift.Bool?
    /// The ID of the parent entity for this entity.
    /// This member is required.
    public var parentEntityId: Swift.String?
    /// The current status of the entity.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The syncSource of the sync job, if this entity was created by a sync job.
    public var syncSource: Swift.String?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        areAllComponentsReturned: Swift.Bool? = nil,
        arn: Swift.String? = nil,
        components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        hasChildEntities: Swift.Bool? = nil,
        parentEntityId: Swift.String? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.areAllComponentsReturned = areAllComponentsReturned
        self.arn = arn
        self.components = components
        self.creationDateTime = creationDateTime
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.hasChildEntities = hasChildEntities
        self.parentEntityId = parentEntityId
        self.status = status
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetEntityOutputBody: Swift.Equatable {
    let entityId: Swift.String?
    let entityName: Swift.String?
    let arn: Swift.String?
    let status: IoTTwinMakerClientTypes.Status?
    let workspaceId: Swift.String?
    let description: Swift.String?
    let components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]?
    let parentEntityId: Swift.String?
    let hasChildEntities: Swift.Bool?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let syncSource: Swift.String?
    let areAllComponentsReturned: Swift.Bool?
}

extension GetEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areAllComponentsReturned
        case arn
        case components
        case creationDateTime
        case description
        case entityId
        case entityName
        case hasChildEntities
        case parentEntityId
        case status
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentResponse?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]()
            for (key0, componentresponse0) in componentsContainer {
                if let componentresponse0 = componentresponse0 {
                    componentsDecoded0?[key0] = componentresponse0
                }
            }
        }
        components = componentsDecoded0
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let hasChildEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasChildEntities)
        hasChildEntities = hasChildEntitiesDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let areAllComponentsReturnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .areAllComponentsReturned)
        areAllComponentsReturned = areAllComponentsReturnedDecoded
    }
}

enum GetEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMetadataTransferJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metadataTransferJobId = metadataTransferJobId else {
            return nil
        }
        return "/metadata-transfer-jobs/\(metadataTransferJobId.urlPercentEncoding())"
    }
}

public struct GetMetadataTransferJobInput: Swift.Equatable {
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?

    public init(
        metadataTransferJobId: Swift.String? = nil
    )
    {
        self.metadataTransferJobId = metadataTransferJobId
    }
}

struct GetMetadataTransferJobInputBody: Swift.Equatable {
}

extension GetMetadataTransferJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMetadataTransferJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMetadataTransferJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.destination = output.destination
            self.metadataTransferJobId = output.metadataTransferJobId
            self.metadataTransferJobRole = output.metadataTransferJobRole
            self.progress = output.progress
            self.reportUrl = output.reportUrl
            self.sources = output.sources
            self.status = output.status
            self.updateDateTime = output.updateDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.destination = nil
            self.metadataTransferJobId = nil
            self.metadataTransferJobRole = nil
            self.progress = nil
            self.reportUrl = nil
            self.sources = nil
            self.status = nil
            self.updateDateTime = nil
        }
    }
}

public struct GetMetadataTransferJobOutput: Swift.Equatable {
    /// The metadata transfer job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The metadata transfer job's creation DateTime property.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The metadata transfer job description.
    public var description: Swift.String?
    /// The metadata transfer job's destination.
    /// This member is required.
    public var destination: IoTTwinMakerClientTypes.DestinationConfiguration?
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job's role.
    /// This member is required.
    public var metadataTransferJobRole: Swift.String?
    /// The metadata transfer job's progress.
    public var progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
    /// The metadata transfer job's report URL.
    public var reportUrl: Swift.String?
    /// The metadata transfer job's sources.
    /// This member is required.
    public var sources: [IoTTwinMakerClientTypes.SourceConfiguration]?
    /// The metadata transfer job's status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
    /// The metadata transfer job's update DateTime property.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        destination: IoTTwinMakerClientTypes.DestinationConfiguration? = nil,
        metadataTransferJobId: Swift.String? = nil,
        metadataTransferJobRole: Swift.String? = nil,
        progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress? = nil,
        reportUrl: Swift.String? = nil,
        sources: [IoTTwinMakerClientTypes.SourceConfiguration]? = nil,
        status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.destination = destination
        self.metadataTransferJobId = metadataTransferJobId
        self.metadataTransferJobRole = metadataTransferJobRole
        self.progress = progress
        self.reportUrl = reportUrl
        self.sources = sources
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

struct GetMetadataTransferJobOutputBody: Swift.Equatable {
    let metadataTransferJobId: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let sources: [IoTTwinMakerClientTypes.SourceConfiguration]?
    let destination: IoTTwinMakerClientTypes.DestinationConfiguration?
    let metadataTransferJobRole: Swift.String?
    let reportUrl: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
    let progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
}

extension GetMetadataTransferJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case destination
        case metadataTransferJobId
        case metadataTransferJobRole
        case progress
        case reportUrl
        case sources
        case status
        case updateDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataTransferJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataTransferJobId)
        metadataTransferJobId = metadataTransferJobIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[IoTTwinMakerClientTypes.SourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [IoTTwinMakerClientTypes.SourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let destinationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DestinationConfiguration.self, forKey: .destination)
        destination = destinationDecoded
        let metadataTransferJobRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataTransferJobRole)
        metadataTransferJobRole = metadataTransferJobRoleDecoded
        let reportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportUrl)
        reportUrl = reportUrlDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobStatus.self, forKey: .status)
        status = statusDecoded
        let progressDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobProgress.self, forKey: .progress)
        progress = progressDecoded
    }
}

enum GetMetadataTransferJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pricingplan"
    }
}

public struct GetPricingPlanInput: Swift.Equatable {

    public init() { }
}

struct GetPricingPlanInputBody: Swift.Equatable {
}

extension GetPricingPlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPricingPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPricingPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.currentPricingPlan = output.currentPricingPlan
            self.pendingPricingPlan = output.pendingPricingPlan
        } else {
            self.currentPricingPlan = nil
            self.pendingPricingPlan = nil
        }
    }
}

public struct GetPricingPlanOutput: Swift.Equatable {
    /// The chosen pricing plan for the current billing cycle.
    /// This member is required.
    public var currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    /// The pending pricing plan.
    public var pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?

    public init(
        currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil,
        pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil
    )
    {
        self.currentPricingPlan = currentPricingPlan
        self.pendingPricingPlan = pendingPricingPlan
    }
}

struct GetPricingPlanOutputBody: Swift.Equatable {
    let currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    let pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
}

extension GetPricingPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentPricingPlan
        case pendingPricingPlan
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .currentPricingPlan)
        currentPricingPlan = currentPricingPlanDecoded
        let pendingPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .pendingPricingPlan)
        pendingPricingPlan = pendingPricingPlanDecoded
    }
}

enum GetPricingPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPropertyValueHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case componentTypeId
        case endDateTime
        case endTime
        case entityId
        case interpolation
        case maxResults
        case nextToken
        case orderByTime
        case propertyFilters
        case selectedProperties
        case startDateTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPath = self.componentPath {
            try encodeContainer.encode(componentPath, forKey: .componentPath)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let interpolation = self.interpolation {
            try encodeContainer.encode(interpolation, forKey: .interpolation)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderByTime = self.orderByTime {
            try encodeContainer.encode(orderByTime.rawValue, forKey: .orderByTime)
        }
        if let propertyFilters = propertyFilters {
            var propertyFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyFilters)
            for propertyfilter0 in propertyFilters {
                try propertyFiltersContainer.encode(propertyfilter0)
            }
        }
        if let selectedProperties = selectedProperties {
            var selectedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedProperties)
            for string0 in selectedProperties {
                try selectedPropertiesContainer.encode(string0)
            }
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

extension GetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/history"
    }
}

public struct GetPropertyValueHistoryInput: Swift.Equatable {
    /// The name of the component.
    public var componentName: Swift.String?
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID of the component type.
    public var componentTypeId: Swift.String?
    /// The date and time of the latest property value to return.
    @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use endTime instead.")
    public var endDateTime: ClientRuntime.Date?
    /// The ISO8601 DateTime of the latest property value to return. For more information about the ISO8601 DateTime format, see the data type [PropertyValue](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_PropertyValue.html).
    public var endTime: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// An object that specifies the interpolation type and the interval over which to interpolate data.
    public var interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The time direction to use in the result order.
    public var orderByTime: IoTTwinMakerClientTypes.OrderByTime?
    /// A list of objects that filter the property value history request.
    public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    /// A list of properties whose value histories the request retrieves.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The date and time of the earliest property value to return.
    @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use startTime instead.")
    public var startDateTime: ClientRuntime.Date?
    /// The ISO8601 DateTime of the earliest property value to return. For more information about the ISO8601 DateTime format, see the data type [PropertyValue](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_PropertyValue.html).
    public var startTime: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        componentPath: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        endTime: Swift.String? = nil,
        entityId: Swift.String? = nil,
        interpolation: IoTTwinMakerClientTypes.InterpolationParameters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderByTime: IoTTwinMakerClientTypes.OrderByTime? = nil,
        propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil,
        selectedProperties: [Swift.String]? = nil,
        startDateTime: ClientRuntime.Date? = nil,
        startTime: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentPath = componentPath
        self.componentTypeId = componentTypeId
        self.endDateTime = endDateTime
        self.endTime = endTime
        self.entityId = entityId
        self.interpolation = interpolation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderByTime = orderByTime
        self.propertyFilters = propertyFilters
        self.selectedProperties = selectedProperties
        self.startDateTime = startDateTime
        self.startTime = startTime
        self.workspaceId = workspaceId
    }
}

struct GetPropertyValueHistoryInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let componentName: Swift.String?
    let componentPath: Swift.String?
    let componentTypeId: Swift.String?
    let selectedProperties: [Swift.String]?
    let propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let orderByTime: IoTTwinMakerClientTypes.OrderByTime?
    let startTime: Swift.String?
    let endTime: Swift.String?
}

extension GetPropertyValueHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case componentTypeId
        case endDateTime
        case endTime
        case entityId
        case interpolation
        case maxResults
        case nextToken
        case orderByTime
        case propertyFilters
        case selectedProperties
        case startDateTime
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentPath)
        componentPath = componentPathDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let selectedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedProperties)
        var selectedPropertiesDecoded0:[Swift.String]? = nil
        if let selectedPropertiesContainer = selectedPropertiesContainer {
            selectedPropertiesDecoded0 = [Swift.String]()
            for string0 in selectedPropertiesContainer {
                if let string0 = string0 {
                    selectedPropertiesDecoded0?.append(string0)
                }
            }
        }
        selectedProperties = selectedPropertiesDecoded0
        let propertyFiltersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyFilter?].self, forKey: .propertyFilters)
        var propertyFiltersDecoded0:[IoTTwinMakerClientTypes.PropertyFilter]? = nil
        if let propertyFiltersContainer = propertyFiltersContainer {
            propertyFiltersDecoded0 = [IoTTwinMakerClientTypes.PropertyFilter]()
            for structure0 in propertyFiltersContainer {
                if let structure0 = structure0 {
                    propertyFiltersDecoded0?.append(structure0)
                }
            }
        }
        propertyFilters = propertyFiltersDecoded0
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let interpolationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.InterpolationParameters.self, forKey: .interpolation)
        interpolation = interpolationDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let orderByTimeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.OrderByTime.self, forKey: .orderByTime)
        orderByTime = orderByTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GetPropertyValueHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPropertyValueHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.propertyValues = output.propertyValues
        } else {
            self.nextToken = nil
            self.propertyValues = nil
        }
    }
}

public struct GetPropertyValueHistoryOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?

    public init(
        nextToken: Swift.String? = nil,
        propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
    }
}

struct GetPropertyValueHistoryOutputBody: Swift.Equatable {
    let propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?
    let nextToken: Swift.String?
}

extension GetPropertyValueHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case propertyValues
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValueHistory?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValueHistory]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorFailureException": return try await ConnectorFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorTimeoutException": return try await ConnectorTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case componentTypeId
        case entityId
        case maxResults
        case nextToken
        case propertyGroupName
        case selectedProperties
        case tabularConditions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPath = self.componentPath {
            try encodeContainer.encode(componentPath, forKey: .componentPath)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let propertyGroupName = self.propertyGroupName {
            try encodeContainer.encode(propertyGroupName, forKey: .propertyGroupName)
        }
        if let selectedProperties = selectedProperties {
            var selectedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedProperties)
            for string0 in selectedProperties {
                try selectedPropertiesContainer.encode(string0)
            }
        }
        if let tabularConditions = self.tabularConditions {
            try encodeContainer.encode(tabularConditions, forKey: .tabularConditions)
        }
    }
}

extension GetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/value"
    }
}

public struct GetPropertyValueInput: Swift.Equatable {
    /// The name of the component whose property values the operation returns.
    public var componentName: Swift.String?
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID of the component type whose property values the operation returns.
    public var componentTypeId: Swift.String?
    /// The ID of the entity whose property values the operation returns.
    public var entityId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The property group name.
    public var propertyGroupName: Swift.String?
    /// The properties whose values the operation returns.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The tabular conditions.
    public var tabularConditions: IoTTwinMakerClientTypes.TabularConditions?
    /// The ID of the workspace whose values the operation returns.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        componentPath: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyGroupName: Swift.String? = nil,
        selectedProperties: [Swift.String]? = nil,
        tabularConditions: IoTTwinMakerClientTypes.TabularConditions? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentPath = componentPath
        self.componentTypeId = componentTypeId
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyGroupName = propertyGroupName
        self.selectedProperties = selectedProperties
        self.tabularConditions = tabularConditions
        self.workspaceId = workspaceId
    }
}

struct GetPropertyValueInputBody: Swift.Equatable {
    let componentName: Swift.String?
    let componentPath: Swift.String?
    let componentTypeId: Swift.String?
    let entityId: Swift.String?
    let selectedProperties: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let propertyGroupName: Swift.String?
    let tabularConditions: IoTTwinMakerClientTypes.TabularConditions?
}

extension GetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case componentTypeId
        case entityId
        case maxResults
        case nextToken
        case propertyGroupName
        case selectedProperties
        case tabularConditions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentPath)
        componentPath = componentPathDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let selectedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedProperties)
        var selectedPropertiesDecoded0:[Swift.String]? = nil
        if let selectedPropertiesContainer = selectedPropertiesContainer {
            selectedPropertiesDecoded0 = [Swift.String]()
            for string0 in selectedPropertiesContainer {
                if let string0 = string0 {
                    selectedPropertiesDecoded0?.append(string0)
                }
            }
        }
        selectedProperties = selectedPropertiesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let propertyGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyGroupName)
        propertyGroupName = propertyGroupNameDecoded
        let tabularConditionsDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.TabularConditions.self, forKey: .tabularConditions)
        tabularConditions = tabularConditionsDecoded
    }
}

extension GetPropertyValueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPropertyValueOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.propertyValues = output.propertyValues
            self.tabularPropertyValues = output.tabularPropertyValues
        } else {
            self.nextToken = nil
            self.propertyValues = nil
            self.tabularPropertyValues = nil
        }
    }
}

public struct GetPropertyValueOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the properties and latest property values in the response. Each string in the mapping must be unique to this object.
    public var propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]?
    /// A table of property values.
    public var tabularPropertyValues: [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]?

    public init(
        nextToken: Swift.String? = nil,
        propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]? = nil,
        tabularPropertyValues: [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
        self.tabularPropertyValues = tabularPropertyValues
    }
}

struct GetPropertyValueOutputBody: Swift.Equatable {
    let propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]?
    let nextToken: Swift.String?
    let tabularPropertyValues: [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]?
}

extension GetPropertyValueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case propertyValues
        case tabularPropertyValues
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValuesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyLatestValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]()
            for (key0, propertylatestvalue0) in propertyValuesContainer {
                if let propertylatestvalue0 = propertylatestvalue0 {
                    propertyValuesDecoded0?[key0] = propertylatestvalue0
                }
            }
        }
        propertyValues = propertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tabularPropertyValuesContainer = try containerValues.decodeIfPresent([[[Swift.String: IoTTwinMakerClientTypes.DataValue?]?]?].self, forKey: .tabularPropertyValues)
        var tabularPropertyValuesDecoded0:[[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]? = nil
        if let tabularPropertyValuesContainer = tabularPropertyValuesContainer {
            tabularPropertyValuesDecoded0 = [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]()
            for list0 in tabularPropertyValuesContainer {
                var list0Decoded0: [[Swift.String: IoTTwinMakerClientTypes.DataValue]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.String: IoTTwinMakerClientTypes.DataValue]]()
                    for map1 in list0 {
                        var list0Decoded1: [Swift.String: IoTTwinMakerClientTypes.DataValue]? = nil
                        if let map1 = map1 {
                            list0Decoded1 = [Swift.String: IoTTwinMakerClientTypes.DataValue]()
                            for (key2, datavalue2) in map1 {
                                if let datavalue2 = datavalue2 {
                                    list0Decoded1?[key2] = datavalue2
                                }
                            }
                        }
                        if let list0Decoded1 = list0Decoded1 {
                            list0Decoded0?.append(list0Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    tabularPropertyValuesDecoded0?.append(list0Decoded0)
                }
            }
        }
        tabularPropertyValues = tabularPropertyValuesDecoded0
    }
}

enum GetPropertyValueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorFailureException": return try await ConnectorFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorTimeoutException": return try await ConnectorTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct GetSceneInput: Swift.Equatable {
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct GetSceneInputBody: Swift.Equatable {
}

extension GetSceneInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSceneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSceneOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.capabilities = output.capabilities
            self.contentLocation = output.contentLocation
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.error = output.error
            self.generatedSceneMetadata = output.generatedSceneMetadata
            self.sceneId = output.sceneId
            self.sceneMetadata = output.sceneMetadata
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.capabilities = nil
            self.contentLocation = nil
            self.creationDateTime = nil
            self.description = nil
            self.error = nil
            self.generatedSceneMetadata = nil
            self.sceneId = nil
            self.sceneMetadata = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetSceneOutput: Swift.Equatable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the scene.
    public var description: Swift.String?
    /// The SceneResponse error.
    public var error: IoTTwinMakerClientTypes.SceneError?
    /// The generated scene metadata.
    public var generatedSceneMetadata: [Swift.String:Swift.String]?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The response metadata.
    public var sceneMetadata: [Swift.String:Swift.String]?
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        error: IoTTwinMakerClientTypes.SceneError? = nil,
        generatedSceneMetadata: [Swift.String:Swift.String]? = nil,
        sceneId: Swift.String? = nil,
        sceneMetadata: [Swift.String:Swift.String]? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.creationDateTime = creationDateTime
        self.description = description
        self.error = error
        self.generatedSceneMetadata = generatedSceneMetadata
        self.sceneId = sceneId
        self.sceneMetadata = sceneMetadata
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetSceneOutputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let sceneId: Swift.String?
    let contentLocation: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let description: Swift.String?
    let capabilities: [Swift.String]?
    let sceneMetadata: [Swift.String:Swift.String]?
    let generatedSceneMetadata: [Swift.String:Swift.String]?
    let error: IoTTwinMakerClientTypes.SceneError?
}

extension GetSceneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case capabilities
        case contentLocation
        case creationDateTime
        case description
        case error
        case generatedSceneMetadata
        case sceneId
        case sceneMetadata
        case updateDateTime
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let sceneMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sceneMetadata)
        var sceneMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let sceneMetadataContainer = sceneMetadataContainer {
            sceneMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, scenemetadatavalue0) in sceneMetadataContainer {
                if let scenemetadatavalue0 = scenemetadatavalue0 {
                    sceneMetadataDecoded0?[key0] = scenemetadatavalue0
                }
            }
        }
        sceneMetadata = sceneMetadataDecoded0
        let generatedSceneMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .generatedSceneMetadata)
        var generatedSceneMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let generatedSceneMetadataContainer = generatedSceneMetadataContainer {
            generatedSceneMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, scenemetadatavalue0) in generatedSceneMetadataContainer {
                if let scenemetadatavalue0 = scenemetadatavalue0 {
                    generatedSceneMetadataDecoded0?[key0] = scenemetadatavalue0
                }
            }
        }
        generatedSceneMetadata = generatedSceneMetadataDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SceneError.self, forKey: .error)
        error = errorDecoded
    }
}

enum GetSceneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSyncJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let workspaceId = workspaceId {
                let workspaceIdQueryItem = ClientRuntime.URLQueryItem(name: "workspace".urlPercentEncoding(), value: Swift.String(workspaceId).urlPercentEncoding())
                items.append(workspaceIdQueryItem)
            }
            return items
        }
    }
}

extension GetSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let syncSource = syncSource else {
            return nil
        }
        return "/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

public struct GetSyncJobInput: Swift.Equatable {
    /// The sync source. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The workspace ID.
    public var workspaceId: Swift.String?

    public init(
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

struct GetSyncJobInputBody: Swift.Equatable {
}

extension GetSyncJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSyncJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSyncJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.status = output.status
            self.syncRole = output.syncRole
            self.syncSource = output.syncSource
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.status = nil
            self.syncRole = nil
            self.syncSource = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetSyncJobOutput: Swift.Equatable {
    /// The sync job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation date and time.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The SyncJob response status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.SyncJobStatus?
    /// The sync IAM role.
    /// This member is required.
    public var syncRole: Swift.String?
    /// The sync soucre. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The update date and time.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        status: IoTTwinMakerClientTypes.SyncJobStatus? = nil,
        syncRole: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.status = status
        self.syncRole = syncRole
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetSyncJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let workspaceId: Swift.String?
    let syncSource: Swift.String?
    let syncRole: Swift.String?
    let status: IoTTwinMakerClientTypes.SyncJobStatus?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
}

extension GetSyncJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case status
        case syncRole
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let syncRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncRole)
        syncRole = syncRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

enum GetSyncJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct GetWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct GetWorkspaceInputBody: Swift.Equatable {
}

extension GetWorkspaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.linkedServices = output.linkedServices
            self.role = output.role
            self.s3Location = output.s3Location
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.linkedServices = nil
            self.role = nil
            self.s3Location = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetWorkspaceOutput: Swift.Equatable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the workspace.
    public var description: Swift.String?
    /// A list of services that are linked to the workspace.
    public var linkedServices: [Swift.String]?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    public var s3Location: Swift.String?
    /// The date and time when the workspace was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        linkedServices: [Swift.String]? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.linkedServices = linkedServices
        self.role = role
        self.s3Location = s3Location
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetWorkspaceOutputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let linkedServices: [Swift.String]?
    let s3Location: Swift.String?
    let role: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
}

extension GetWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case linkedServices
        case role
        case s3Location
        case updateDateTime
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let linkedServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .linkedServices)
        var linkedServicesDecoded0:[Swift.String]? = nil
        if let linkedServicesContainer = linkedServicesContainer {
            linkedServicesDecoded0 = [Swift.String]()
            for string0 in linkedServicesContainer {
                if let string0 = string0 {
                    linkedServicesDecoded0?.append(string0)
                }
            }
        }
        linkedServices = linkedServicesDecoded0
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

enum GetWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes {
    public enum GroupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupType] {
            return [
                .tabular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupType(rawValue: rawValue) ?? GroupType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.InterpolationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpolationType
        case intervalInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpolationType = self.interpolationType {
            try encodeContainer.encode(interpolationType.rawValue, forKey: .interpolationType)
        }
        if let intervalInSeconds = self.intervalInSeconds {
            try encodeContainer.encode(intervalInSeconds, forKey: .intervalInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolationTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.InterpolationType.self, forKey: .interpolationType)
        interpolationType = interpolationTypeDecoded
        let intervalInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intervalInSeconds)
        intervalInSeconds = intervalInSecondsDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies how to interpolate data in a list.
    public struct InterpolationParameters: Swift.Equatable {
        /// The interpolation type.
        public var interpolationType: IoTTwinMakerClientTypes.InterpolationType?
        /// The interpolation time interval in seconds.
        public var intervalInSeconds: Swift.Int?

        public init(
            interpolationType: IoTTwinMakerClientTypes.InterpolationType? = nil,
            intervalInSeconds: Swift.Int? = nil
        )
        {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum InterpolationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [InterpolationType] {
            return [
                .linear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InterpolationType(rawValue: rawValue) ?? InterpolationType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for iotsitewisesourceconfigurationfilter0 in filters {
                try filtersContainer.encode(iotsitewisesourceconfigurationfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job AWS IoT SiteWise source configuration.
    public struct IotSiteWiseSourceConfiguration: Swift.Equatable {
        /// The AWS IoT SiteWise soucre configuration filters.
        public var filters: [IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter]?

        public init(
            filters: [IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterbyasset = "filterByAsset"
        case filterbyassetmodel = "filterByAssetModel"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .filterbyasset(filterbyasset):
                try container.encode(filterbyasset, forKey: .filterbyasset)
            case let .filterbyassetmodel(filterbyassetmodel):
                try container.encode(filterbyassetmodel, forKey: .filterbyassetmodel)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let filterbyassetmodelDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.FilterByAssetModel.self, forKey: .filterbyassetmodel)
        if let filterbyassetmodel = filterbyassetmodelDecoded {
            self = .filterbyassetmodel(filterbyassetmodel)
            return
        }
        let filterbyassetDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.FilterByAsset.self, forKey: .filterbyasset)
        if let filterbyasset = filterbyassetDecoded {
            self = .filterbyasset(filterbyasset)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// The AWS IoT SiteWise soucre configuration filter.[need held with desc here]
    public enum IotSiteWiseSourceConfigurationFilter: Swift.Equatable {
        /// Filter by asset model.
        case filterbyassetmodel(IoTTwinMakerClientTypes.FilterByAssetModel)
        /// Filter by asset.
        case filterbyasset(IoTTwinMakerClientTypes.FilterByAsset)
        case sdkUnknown(Swift.String)
    }

}

extension IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspace = self.workspace {
            try encodeContainer.encode(workspace, forKey: .workspace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job AWS IoT TwinMaker destination configuration.
    public struct IotTwinMakerDestinationConfiguration: Swift.Equatable {
        /// The IoT TwinMaker workspace.
        /// This member is required.
        public var workspace: Swift.String?

        public init(
            workspace: Swift.String? = nil
        )
        {
            self.workspace = workspace
        }
    }

}

extension IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case workspace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for iottwinmakersourceconfigurationfilter0 in filters {
                try filtersContainer.encode(iottwinmakersourceconfigurationfilter0)
            }
        }
        if let workspace = self.workspace {
            try encodeContainer.encode(workspace, forKey: .workspace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspace)
        workspace = workspaceDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job AWS IoT TwinMaker source configuration.
    public struct IotTwinMakerSourceConfiguration: Swift.Equatable {
        /// The metadata transfer job AWS IoT TwinMaker source configuration filters.
        public var filters: [IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter]?
        /// The IoT TwinMaker workspace.
        /// This member is required.
        public var workspace: Swift.String?

        public init(
            filters: [IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter]? = nil,
            workspace: Swift.String? = nil
        )
        {
            self.filters = filters
            self.workspace = workspace
        }
    }

}

extension IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterbycomponenttype = "filterByComponentType"
        case filterbyentity = "filterByEntity"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .filterbycomponenttype(filterbycomponenttype):
                try container.encode(filterbycomponenttype, forKey: .filterbycomponenttype)
            case let .filterbyentity(filterbyentity):
                try container.encode(filterbyentity, forKey: .filterbyentity)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let filterbycomponenttypeDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.FilterByComponentType.self, forKey: .filterbycomponenttype)
        if let filterbycomponenttype = filterbycomponenttypeDecoded {
            self = .filterbycomponenttype(filterbycomponenttype)
            return
        }
        let filterbyentityDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.FilterByEntity.self, forKey: .filterbyentity)
        if let filterbyentity = filterbyentityDecoded {
            self = .filterbyentity(filterbyentity)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job AWS IoT TwinMaker source configuration filter.
    public enum IotTwinMakerSourceConfigurationFilter: Swift.Equatable {
        /// Filter by component type.
        case filterbycomponenttype(IoTTwinMakerClientTypes.FilterByComponentType)
        /// Filter by entity.
        case filterbyentity(IoTTwinMakerClientTypes.FilterByEntity)
        case sdkUnknown(Swift.String)
    }

}

extension IoTTwinMakerClientTypes.LambdaFunction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The Lambda function.
    public struct LambdaFunction: Swift.Equatable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTTwinMakerClientTypes.ListComponentTypesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extendsfrom = "extendsFrom"
        case isabstract = "isAbstract"
        case namespace
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .extendsfrom(extendsfrom):
                try container.encode(extendsfrom, forKey: .extendsfrom)
            case let .isabstract(isabstract):
                try container.encode(isabstract, forKey: .isabstract)
            case let .namespace(namespace):
                try container.encode(namespace, forKey: .namespace)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let extendsfromDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .extendsfrom)
        if let extendsfrom = extendsfromDecoded {
            self = .extendsfrom(extendsfrom)
            return
        }
        let namespaceDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .namespace)
        if let namespace = namespaceDecoded {
            self = .namespace(namespace)
            return
        }
        let isabstractDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isabstract)
        if let isabstract = isabstractDecoded {
            self = .isabstract(isabstract)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items in a list of component types. Only one object is accepted as a valid input.
    public enum ListComponentTypesFilter: Swift.Equatable {
        /// The component type that the component types in the list extend.
        case extendsfrom(Swift.String)
        /// The namespace to which the component types in the list belong.
        case namespace(Swift.String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isabstract(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension ListComponentTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listcomponenttypesfilter0 in filters {
                try filtersContainer.encode(listcomponenttypesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types-list"
    }
}

public struct ListComponentTypesInput: Swift.Equatable {
    /// A list of objects that filter the request.
    public var filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentTypesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListComponentTypesFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListComponentTypesFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComponentTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentTypeSummaries = output.componentTypeSummaries
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.workspaceId = output.workspaceId
        } else {
            self.componentTypeSummaries = nil
            self.maxResults = nil
            self.nextToken = nil
            self.workspaceId = nil
        }
    }
}

public struct ListComponentTypesOutput: Swift.Equatable {
    /// A list of objects that contain information about the component types.
    /// This member is required.
    public var componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeSummaries = componentTypeSummaries
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentTypesOutputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeSummaries
        case maxResults
        case nextToken
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let componentTypeSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ComponentTypeSummary?].self, forKey: .componentTypeSummaries)
        var componentTypeSummariesDecoded0:[IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil
        if let componentTypeSummariesContainer = componentTypeSummariesContainer {
            componentTypeSummariesDecoded0 = [IoTTwinMakerClientTypes.ComponentTypeSummary]()
            for structure0 in componentTypeSummariesContainer {
                if let structure0 = structure0 {
                    componentTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        componentTypeSummaries = componentTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

enum ListComponentTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentPath
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentPath = self.componentPath {
            try encodeContainer.encode(componentPath, forKey: .componentPath)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())/components-list"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID for the entity whose metadata (component/properties) is returned by the operation.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results returned at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentPath: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentPath = componentPath
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let componentPath: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentPath
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentPath)
        componentPath = componentPathDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentSummaries = output.componentSummaries
            self.nextToken = output.nextToken
        } else {
            self.componentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// A list of objects that contain information about the components.
    /// This member is required.
    public var componentSummaries: [IoTTwinMakerClientTypes.ComponentSummary]?
    /// The string that specifies the next page of component results.
    public var nextToken: Swift.String?

    public init(
        componentSummaries: [IoTTwinMakerClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentSummaries = componentSummaries
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let componentSummaries: [IoTTwinMakerClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ComponentSummary?].self, forKey: .componentSummaries)
        var componentSummariesDecoded0:[IoTTwinMakerClientTypes.ComponentSummary]? = nil
        if let componentSummariesContainer = componentSummariesContainer {
            componentSummariesDecoded0 = [IoTTwinMakerClientTypes.ComponentSummary]()
            for structure0 in componentSummariesContainer {
                if let structure0 = structure0 {
                    componentSummariesDecoded0?.append(structure0)
                }
            }
        }
        componentSummaries = componentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.ListEntitiesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componenttypeid = "componentTypeId"
        case externalid = "externalId"
        case parententityid = "parentEntityId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .componenttypeid(componenttypeid):
                try container.encode(componenttypeid, forKey: .componenttypeid)
            case let .externalid(externalid):
                try container.encode(externalid, forKey: .externalid)
            case let .parententityid(parententityid):
                try container.encode(parententityid, forKey: .parententityid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let parententityidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .parententityid)
        if let parententityid = parententityidDecoded {
            self = .parententityid(parententityid)
            return
        }
        let componenttypeidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .componenttypeid)
        if let componenttypeid = componenttypeidDecoded {
            self = .componenttypeid(componenttypeid)
            return
        }
        let externalidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .externalid)
        if let externalid = externalidDecoded {
            self = .externalid(externalid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items in a list of entities.
    public enum ListEntitiesFilter: Swift.Equatable {
        /// The parent of the entities in the list.
        case parententityid(Swift.String)
        /// The ID of the component type in the entities in the list.
        case componenttypeid(Swift.String)
        /// The external-Id property of a component. The external-Id property is the primary key of an external storage system.
        case externalid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ListEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listentitiesfilter0 in filters {
                try filtersContainer.encode(listentitiesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities-list"
    }
}

public struct ListEntitiesInput: Swift.Equatable {
    /// A list of objects that filter the request. Only one object is accepted as a valid input.
    public var filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListEntitiesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListEntitiesFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListEntitiesFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitySummaries = output.entitySummaries
            self.nextToken = output.nextToken
        } else {
            self.entitySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesOutput: Swift.Equatable {
    /// A list of objects that contain information about the entities.
    public var entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init(
        entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaries = entitySummaries
        self.nextToken = nextToken
    }
}

struct ListEntitiesOutputBody: Swift.Equatable {
    let entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    let nextToken: Swift.String?
}

extension ListEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitySummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitySummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.EntitySummary?].self, forKey: .entitySummaries)
        var entitySummariesDecoded0:[IoTTwinMakerClientTypes.EntitySummary]? = nil
        if let entitySummariesContainer = entitySummariesContainer {
            entitySummariesDecoded0 = [IoTTwinMakerClientTypes.EntitySummary]()
            for structure0 in entitySummariesContainer {
                if let structure0 = structure0 {
                    entitySummariesDecoded0?.append(structure0)
                }
            }
        }
        entitySummaries = entitySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case state
        case workspaceid = "workspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .state(state):
                try container.encode(state.rawValue, forKey: .state)
            case let .workspaceid(workspaceid):
                try container.encode(workspaceid, forKey: .workspaceid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .workspaceid)
        if let workspaceid = workspaceidDecoded {
            self = .workspaceid(workspaceid)
            return
        }
        let stateDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobState.self, forKey: .state)
        if let state = stateDecoded {
            self = .state(state)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// The ListMetadataTransferJobs filter.
    public enum ListMetadataTransferJobsFilter: Swift.Equatable {
        /// The workspace Id.
        case workspaceid(Swift.String)
        /// The filter state.
        case state(IoTTwinMakerClientTypes.MetadataTransferJobState)
        case sdkUnknown(Swift.String)
    }

}

extension ListMetadataTransferJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationType
        case filters
        case maxResults
        case nextToken
        case sourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listmetadatatransferjobsfilter0 in filters {
                try filtersContainer.encode(listmetadatatransferjobsfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }
}

extension ListMetadataTransferJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/metadata-transfer-jobs-list"
    }
}

public struct ListMetadataTransferJobsInput: Swift.Equatable {
    /// The metadata transfer job's destination type.
    /// This member is required.
    public var destinationType: IoTTwinMakerClientTypes.DestinationType?
    /// An object that filters metadata transfer jobs.
    public var filters: [IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The metadata transfer job's source type.
    /// This member is required.
    public var sourceType: IoTTwinMakerClientTypes.SourceType?

    public init(
        destinationType: IoTTwinMakerClientTypes.DestinationType? = nil,
        filters: [IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceType: IoTTwinMakerClientTypes.SourceType? = nil
    )
    {
        self.destinationType = destinationType
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceType = sourceType
    }
}

struct ListMetadataTransferJobsInputBody: Swift.Equatable {
    let sourceType: IoTTwinMakerClientTypes.SourceType?
    let destinationType: IoTTwinMakerClientTypes.DestinationType?
    let filters: [IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMetadataTransferJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationType
        case filters
        case maxResults
        case nextToken
        case sourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMetadataTransferJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMetadataTransferJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metadataTransferJobSummaries = output.metadataTransferJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.metadataTransferJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetadataTransferJobsOutput: Swift.Equatable {
    /// The metadata transfer job summaries.
    /// This member is required.
    public var metadataTransferJobSummaries: [IoTTwinMakerClientTypes.MetadataTransferJobSummary]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init(
        metadataTransferJobSummaries: [IoTTwinMakerClientTypes.MetadataTransferJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metadataTransferJobSummaries = metadataTransferJobSummaries
        self.nextToken = nextToken
    }
}

struct ListMetadataTransferJobsOutputBody: Swift.Equatable {
    let metadataTransferJobSummaries: [IoTTwinMakerClientTypes.MetadataTransferJobSummary]?
    let nextToken: Swift.String?
}

extension ListMetadataTransferJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataTransferJobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataTransferJobSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.MetadataTransferJobSummary?].self, forKey: .metadataTransferJobSummaries)
        var metadataTransferJobSummariesDecoded0:[IoTTwinMakerClientTypes.MetadataTransferJobSummary]? = nil
        if let metadataTransferJobSummariesContainer = metadataTransferJobSummariesContainer {
            metadataTransferJobSummariesDecoded0 = [IoTTwinMakerClientTypes.MetadataTransferJobSummary]()
            for structure0 in metadataTransferJobSummariesContainer {
                if let structure0 = structure0 {
                    metadataTransferJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        metadataTransferJobSummaries = metadataTransferJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMetadataTransferJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case entityId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPath = self.componentPath {
            try encodeContainer.encode(componentPath, forKey: .componentPath)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/properties-list"
    }
}

public struct ListPropertiesInput: Swift.Equatable {
    /// The name of the component whose properties are returned by the operation.
    public var componentName: Swift.String?
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID for the entity whose metadata (component/properties) is returned by the operation.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results returned at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        componentPath: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentPath = componentPath
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListPropertiesInputBody: Swift.Equatable {
    let componentName: Swift.String?
    let componentPath: Swift.String?
    let entityId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentPath
        case entityId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentPath)
        componentPath = componentPathDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPropertiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.propertySummaries = output.propertySummaries
        } else {
            self.nextToken = nil
            self.propertySummaries = nil
        }
    }
}

public struct ListPropertiesOutput: Swift.Equatable {
    /// The string that specifies the next page of property results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the properties.
    /// This member is required.
    public var propertySummaries: [IoTTwinMakerClientTypes.PropertySummary]?

    public init(
        nextToken: Swift.String? = nil,
        propertySummaries: [IoTTwinMakerClientTypes.PropertySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertySummaries = propertySummaries
    }
}

struct ListPropertiesOutputBody: Swift.Equatable {
    let propertySummaries: [IoTTwinMakerClientTypes.PropertySummary]?
    let nextToken: Swift.String?
}

extension ListPropertiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case propertySummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertySummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertySummary?].self, forKey: .propertySummaries)
        var propertySummariesDecoded0:[IoTTwinMakerClientTypes.PropertySummary]? = nil
        if let propertySummariesContainer = propertySummariesContainer {
            propertySummariesDecoded0 = [IoTTwinMakerClientTypes.PropertySummary]()
            for structure0 in propertySummariesContainer {
                if let structure0 = structure0 {
                    propertySummariesDecoded0?.append(structure0)
                }
            }
        }
        propertySummaries = propertySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListScenesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListScenesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes-list"
    }
}

public struct ListScenesInput: Swift.Equatable {
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the scenes.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListScenesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListScenesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListScenesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListScenesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sceneSummaries = output.sceneSummaries
        } else {
            self.nextToken = nil
            self.sceneSummaries = nil
        }
    }
}

public struct ListScenesOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the scenes.
    public var sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sceneSummaries = sceneSummaries
    }
}

struct ListScenesOutputBody: Swift.Equatable {
    let sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?
    let nextToken: Swift.String?
}

extension ListScenesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sceneSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SceneSummary?].self, forKey: .sceneSummaries)
        var sceneSummariesDecoded0:[IoTTwinMakerClientTypes.SceneSummary]? = nil
        if let sceneSummariesContainer = sceneSummariesContainer {
            sceneSummariesDecoded0 = [IoTTwinMakerClientTypes.SceneSummary]()
            for structure0 in sceneSummariesContainer {
                if let structure0 = structure0 {
                    sceneSummariesDecoded0?.append(structure0)
                }
            }
        }
        sceneSummaries = sceneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListScenesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSyncJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSyncJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs-list"
    }
}

public struct ListSyncJobsInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListSyncJobsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSyncJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSyncJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSyncJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.syncJobSummaries = output.syncJobSummaries
        } else {
            self.nextToken = nil
            self.syncJobSummaries = nil
        }
    }
}

public struct ListSyncJobsOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The listed SyncJob summaries.
    public var syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncJobSummaries = syncJobSummaries
    }
}

struct ListSyncJobsOutputBody: Swift.Equatable {
    let syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]?
    let nextToken: Swift.String?
}

extension ListSyncJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case syncJobSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncJobSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SyncJobSummary?].self, forKey: .syncJobSummaries)
        var syncJobSummariesDecoded0:[IoTTwinMakerClientTypes.SyncJobSummary]? = nil
        if let syncJobSummariesContainer = syncJobSummariesContainer {
            syncJobSummariesDecoded0 = [IoTTwinMakerClientTypes.SyncJobSummary]()
            for structure0 in syncJobSummariesContainer {
                if let structure0 = structure0 {
                    syncJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        syncJobSummaries = syncJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSyncJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSyncResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for syncresourcefilter0 in filters {
                try filtersContainer.encode(syncresourcefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSyncResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let syncSource = syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())/resources-list"
    }
}

public struct ListSyncResourcesInput: Swift.Equatable {
    /// A list of objects that filter the request. The following filter combinations are supported:
    ///
    /// * Filter with state
    ///
    /// * Filter with ResourceType and ResourceId
    ///
    /// * Filter with ResourceType and ExternalId
    public var filters: [IoTTwinMakerClientTypes.SyncResourceFilter]?
    /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The sync source. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        filters: [IoTTwinMakerClientTypes.SyncResourceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

struct ListSyncResourcesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.SyncResourceFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSyncResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SyncResourceFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.SyncResourceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.SyncResourceFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSyncResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSyncResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.syncResources = output.syncResources
        } else {
            self.nextToken = nil
            self.syncResources = nil
        }
    }
}

public struct ListSyncResourcesOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The sync resources.
    public var syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncResources = syncResources
    }
}

struct ListSyncResourcesOutputBody: Swift.Equatable {
    let syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]?
    let nextToken: Swift.String?
}

extension ListSyncResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case syncResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncResourcesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SyncResourceSummary?].self, forKey: .syncResources)
        var syncResourcesDecoded0:[IoTTwinMakerClientTypes.SyncResourceSummary]? = nil
        if let syncResourcesContainer = syncResourcesContainer {
            syncResourcesDecoded0 = [IoTTwinMakerClientTypes.SyncResourceSummary]()
            for structure0 in syncResourcesContainer {
                if let structure0 = structure0 {
                    syncResourcesDecoded0?.append(structure0)
                }
            }
        }
        syncResources = syncResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSyncResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags-list"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Metadata that you can use to manage a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces-list"
    }
}

public struct ListWorkspacesInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaceSummaries = output.workspaceSummaries
        } else {
            self.nextToken = nil
            self.workspaceSummaries = nil
        }
    }
}

public struct ListWorkspacesOutput: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the workspaces.
    public var workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceSummaries = workspaceSummaries
    }
}

struct ListWorkspacesOutputBody: Swift.Equatable {
    let workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?
    let nextToken: Swift.String?
}

extension ListWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaceSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.WorkspaceSummary?].self, forKey: .workspaceSummaries)
        var workspaceSummariesDecoded0:[IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
        if let workspaceSummariesContainer = workspaceSummariesContainer {
            workspaceSummariesDecoded0 = [IoTTwinMakerClientTypes.WorkspaceSummary]()
            for structure0 in workspaceSummariesContainer {
                if let structure0 = structure0 {
                    workspaceSummariesDecoded0?.append(structure0)
                }
            }
        }
        workspaceSummaries = workspaceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes.MetadataTransferJobProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedCount
        case skippedCount
        case succeededCount
        case totalCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedCount = self.failedCount {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let skippedCount = self.skippedCount {
            try encodeContainer.encode(skippedCount, forKey: .skippedCount)
        }
        if let succeededCount = self.succeededCount {
            try encodeContainer.encode(succeededCount, forKey: .succeededCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let succeededCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .succeededCount)
        succeededCount = succeededCountDecoded
        let skippedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .skippedCount)
        skippedCount = skippedCountDecoded
        let failedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job's progress.
    public struct MetadataTransferJobProgress: Swift.Equatable {
        /// The failed count.
        public var failedCount: Swift.Int?
        /// The skipped count.
        public var skippedCount: Swift.Int?
        /// The succeeded count.
        public var succeededCount: Swift.Int?
        /// The total count. [of what]
        public var totalCount: Swift.Int?

        public init(
            failedCount: Swift.Int? = nil,
            skippedCount: Swift.Int? = nil,
            succeededCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.failedCount = failedCount
            self.skippedCount = skippedCount
            self.succeededCount = succeededCount
            self.totalCount = totalCount
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum MetadataTransferJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case error
        case pending
        case running
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataTransferJobState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .error,
                .pending,
                .running,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetadataTransferJobState(rawValue: rawValue) ?? MetadataTransferJobState.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.MetadataTransferJobStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case queuedPosition
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let queuedPosition = self.queuedPosition {
            try encodeContainer.encode(queuedPosition, forKey: .queuedPosition)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
        let queuedPositionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedPosition)
        queuedPosition = queuedPositionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job status.
    public struct MetadataTransferJobStatus: Swift.Equatable {
        /// The metadata transfer job error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The queued position.
        public var queuedPosition: Swift.Int?
        /// The metadata transfer job state.
        public var state: IoTTwinMakerClientTypes.MetadataTransferJobState?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            queuedPosition: Swift.Int? = nil,
            state: IoTTwinMakerClientTypes.MetadataTransferJobState? = nil
        )
        {
            self.error = error
            self.queuedPosition = queuedPosition
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes.MetadataTransferJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case metadataTransferJobId
        case progress
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let metadataTransferJobId = self.metadataTransferJobId {
            try encodeContainer.encode(metadataTransferJobId, forKey: .metadataTransferJobId)
        }
        if let progress = self.progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataTransferJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataTransferJobId)
        metadataTransferJobId = metadataTransferJobIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobStatus.self, forKey: .status)
        status = statusDecoded
        let progressDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.MetadataTransferJobProgress.self, forKey: .progress)
        progress = progressDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The metadata transfer job summary.
    public struct MetadataTransferJobSummary: Swift.Equatable {
        /// The metadata transfer job summary ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// The metadata transfer job summary creation DateTime object.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The metadata transfer job summary Id.
        /// This member is required.
        public var metadataTransferJobId: Swift.String?
        /// The metadata transfer job summary progess.
        public var progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
        /// The metadata transfer job summary status.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
        /// The metadata transfer job summary update DateTime object
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            metadataTransferJobId: Swift.String? = nil,
            progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress? = nil,
            status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.metadataTransferJobId = metadataTransferJobId
            self.progress = progress
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.OrderBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order
        case propertyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Order.self, forKey: .order)
        order = orderDecoded
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Filter criteria that orders the return output. It can be sorted in ascending or descending order.
    public struct OrderBy: Swift.Equatable {
        /// The set order that filters results.
        public var order: IoTTwinMakerClientTypes.Order?
        /// The property name.
        /// This member is required.
        public var propertyName: Swift.String?

        public init(
            order: IoTTwinMakerClientTypes.Order? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.order = order
            self.propertyName = propertyName
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum OrderByTime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderByTime] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderByTime(rawValue: rawValue) ?? OrderByTime.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ParentEntityUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parentEntityId
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentEntityId = self.parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ParentEntityUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The parent entity update request.
    public struct ParentEntityUpdateRequest: Swift.Equatable {
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The type of the update.
        /// This member is required.
        public var updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType?

        public init(
            parentEntityId: Swift.String? = nil,
            updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType? = nil
        )
        {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ParentEntityUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ParentEntityUpdateType] {
            return [
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParentEntityUpdateType(rawValue: rawValue) ?? ParentEntityUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes {
    public enum PricingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case standard
        case tieredBundle
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingMode] {
            return [
                .basic,
                .standard,
                .tieredBundle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .standard: return "STANDARD"
            case .tieredBundle: return "TIERED_BUNDLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingMode(rawValue: rawValue) ?? PricingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PricingPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billableEntityCount
        case bundleInformation
        case effectiveDateTime
        case pricingMode
        case updateDateTime
        case updateReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billableEntityCount = self.billableEntityCount {
            try encodeContainer.encode(billableEntityCount, forKey: .billableEntityCount)
        }
        if let bundleInformation = self.bundleInformation {
            try encodeContainer.encode(bundleInformation, forKey: .bundleInformation)
        }
        if let effectiveDateTime = self.effectiveDateTime {
            try encodeContainer.encodeTimestamp(effectiveDateTime, format: .epochSeconds, forKey: .effectiveDateTime)
        }
        if let pricingMode = self.pricingMode {
            try encodeContainer.encode(pricingMode.rawValue, forKey: .pricingMode)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason.rawValue, forKey: .updateReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billableEntityCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .billableEntityCount)
        billableEntityCount = billableEntityCountDecoded
        let bundleInformationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.BundleInformation.self, forKey: .bundleInformation)
        bundleInformation = bundleInformationDecoded
        let effectiveDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .effectiveDateTime)
        effectiveDateTime = effectiveDateTimeDecoded
        let pricingModeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingMode.self, forKey: .pricingMode)
        pricingMode = pricingModeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.UpdateReason.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The pricing plan.
    public struct PricingPlan: Swift.Equatable {
        /// The billable entity count.
        public var billableEntityCount: Swift.Int?
        /// The pricing plan's bundle information.
        public var bundleInformation: IoTTwinMakerClientTypes.BundleInformation?
        /// The effective date and time of the pricing plan.
        /// This member is required.
        public var effectiveDateTime: ClientRuntime.Date?
        /// The pricing mode.
        /// This member is required.
        public var pricingMode: IoTTwinMakerClientTypes.PricingMode?
        /// The set date and time for updating a pricing plan.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?
        /// The update reason for changing a pricing plan.
        /// This member is required.
        public var updateReason: IoTTwinMakerClientTypes.UpdateReason?

        public init(
            billableEntityCount: Swift.Int? = nil,
            bundleInformation: IoTTwinMakerClientTypes.BundleInformation? = nil,
            effectiveDateTime: ClientRuntime.Date? = nil,
            pricingMode: IoTTwinMakerClientTypes.PricingMode? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            updateReason: IoTTwinMakerClientTypes.UpdateReason? = nil
        )
        {
            self.billableEntityCount = billableEntityCount
            self.bundleInformation = bundleInformation
            self.effectiveDateTime = effectiveDateTime
            self.pricingMode = pricingMode
            self.updateDateTime = updateDateTime
            self.updateReason = updateReason
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PricingTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tier1
        case tier2
        case tier3
        case tier4
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingTier] {
            return [
                .tier1,
                .tier2,
                .tier3,
                .tier4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tier1: return "TIER_1"
            case .tier2: return "TIER_2"
            case .tier3: return "TIER_3"
            case .tier4: return "TIER_4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingTier(rawValue: rawValue) ?? PricingTier.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyDefinitionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case dataType
        case defaultValue
        case displayName
        case isExternalId
        case isRequiredInEntity
        case isStoredExternally
        case isTimeSeries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let isExternalId = self.isExternalId {
            try encodeContainer.encode(isExternalId, forKey: .isExternalId)
        }
        if let isRequiredInEntity = self.isRequiredInEntity {
            try encodeContainer.encode(isRequiredInEntity, forKey: .isRequiredInEntity)
        }
        if let isStoredExternally = self.isStoredExternally {
            try encodeContainer.encode(isStoredExternally, forKey: .isStoredExternally)
        }
        if let isTimeSeries = self.isTimeSeries {
            try encodeContainer.encode(isTimeSeries, forKey: .isTimeSeries)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isRequiredInEntityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequiredInEntity)
        isRequiredInEntity = isRequiredInEntityDecoded
        let isExternalIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isExternalId)
        isExternalId = isExternalIdDecoded
        let isStoredExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isStoredExternally)
        isStoredExternally = isStoredExternallyDecoded
        let isTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimeSeries)
        isTimeSeries = isTimeSeriesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in configurationContainer {
                if let value0 = value0 {
                    configurationDecoded0?[key0] = value0
                }
            }
        }
        configuration = configurationDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a property.
    public struct PropertyDefinitionRequest: Swift.Equatable {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public var configuration: [Swift.String:Swift.String]?
        /// An object that contains information about the data type.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A friendly name for the property.
        public var displayName: Swift.String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public var isTimeSeries: Swift.Bool?

        public init(
            configuration: [Swift.String:Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            displayName: Swift.String? = nil,
            isExternalId: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyDefinitionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case dataType
        case defaultValue
        case displayName
        case isExternalId
        case isFinal
        case isImported
        case isInherited
        case isRequiredInEntity
        case isStoredExternally
        case isTimeSeries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let isExternalId = self.isExternalId {
            try encodeContainer.encode(isExternalId, forKey: .isExternalId)
        }
        if let isFinal = self.isFinal {
            try encodeContainer.encode(isFinal, forKey: .isFinal)
        }
        if let isImported = self.isImported {
            try encodeContainer.encode(isImported, forKey: .isImported)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let isRequiredInEntity = self.isRequiredInEntity {
            try encodeContainer.encode(isRequiredInEntity, forKey: .isRequiredInEntity)
        }
        if let isStoredExternally = self.isStoredExternally {
            try encodeContainer.encode(isStoredExternally, forKey: .isStoredExternally)
        }
        if let isTimeSeries = self.isTimeSeries {
            try encodeContainer.encode(isTimeSeries, forKey: .isTimeSeries)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimeSeries)
        isTimeSeries = isTimeSeriesDecoded
        let isRequiredInEntityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequiredInEntity)
        isRequiredInEntity = isRequiredInEntityDecoded
        let isExternalIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isExternalId)
        isExternalId = isExternalIdDecoded
        let isStoredExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isStoredExternally)
        isStoredExternally = isStoredExternallyDecoded
        let isImportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isImported)
        isImported = isImportedDecoded
        let isFinalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isFinal)
        isFinal = isFinalDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in configurationContainer {
                if let value0 = value0 {
                    configurationDecoded0?[key0] = value0
                }
            }
        }
        configuration = configurationDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains response data from a property definition request.
    public struct PropertyDefinitionResponse: Swift.Equatable {
        /// A mapping that specifies configuration information about the property.
        public var configuration: [Swift.String:Swift.String]?
        /// An object that contains information about the data type.
        /// This member is required.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A friendly name for the property.
        public var displayName: Swift.String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        /// This member is required.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property definition can be updated.
        /// This member is required.
        public var isFinal: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        /// This member is required.
        public var isImported: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// A Boolean value that specifies whether the property is required in an entity.
        /// This member is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        /// This member is required.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        /// This member is required.
        public var isTimeSeries: Swift.Bool?

        public init(
            configuration: [Swift.String:Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            displayName: Swift.String? = nil,
            isExternalId: Swift.Bool? = nil,
            isFinal: Swift.Bool? = nil,
            isImported: Swift.Bool? = nil,
            isInherited: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `operator` = "operator"
        case propertyName
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items returned by a property request.
    public struct PropertyFilter: Swift.Equatable {
        /// The operator associated with this property filter.
        public var `operator`: Swift.String?
        /// The property name associated with this property filter.
        public var propertyName: Swift.String?
        /// The value associated with this property filter.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            `operator`: Swift.String? = nil,
            propertyName: Swift.String? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyGroupRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case propertyNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    ///
    public struct PropertyGroupRequest: Swift.Equatable {
        /// The group type.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// The names of properties.
        public var propertyNames: [Swift.String]?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.propertyNames = propertyNames
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyGroupResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case isInherited
        case propertyNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The property group response
    public struct PropertyGroupResponse: Swift.Equatable {
        /// The group types.
        /// This member is required.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// The names of properties.
        /// This member is required.
        public var propertyNames: [Swift.String]?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            isInherited: Swift.Bool? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PropertyGroupUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyGroupUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyGroupUpdateType(rawValue: rawValue) ?? PropertyGroupUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyLatestValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyReference
        case propertyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyReference = self.propertyReference {
            try encodeContainer.encode(propertyReference, forKey: .propertyReference)
        }
        if let propertyValue = self.propertyValue {
            try encodeContainer.encode(propertyValue, forKey: .propertyValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .propertyReference)
        propertyReference = propertyReferenceDecoded
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The latest value of the property.
    public struct PropertyLatestValue: Swift.Equatable {
        /// An object that specifies information about a property.
        /// This member is required.
        public var propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// The value of the property.
        public var propertyValue: IoTTwinMakerClientTypes.DataValue?

        public init(
            propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValue: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case updateType
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionRequest.self, forKey: .definition)
        definition = definitionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a property.
    public struct PropertyRequest: Swift.Equatable {
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest?
        /// The update type of the update property request.
        public var updateType: IoTTwinMakerClientTypes.PropertyUpdateType?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyUpdateType? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areAllPropertyValuesReturned
        case definition
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areAllPropertyValuesReturned = self.areAllPropertyValuesReturned {
            try encodeContainer.encode(areAllPropertyValuesReturned, forKey: .areAllPropertyValuesReturned)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionResponse.self, forKey: .definition)
        definition = definitionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let areAllPropertyValuesReturnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .areAllPropertyValuesReturned)
        areAllPropertyValuesReturned = areAllPropertyValuesReturnedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a property response.
    public struct PropertyResponse: Swift.Equatable {
        /// This flag notes whether all values of a list or map type property are returned in the API response. The maximum number of values per property returned is 50.
        public var areAllPropertyValuesReturned: Swift.Bool?
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            areAllPropertyValuesReturned: Swift.Bool? = nil,
            definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.areAllPropertyValuesReturned = areAllPropertyValuesReturned
            self.definition = definition
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areAllPropertyValuesReturned
        case definition
        case propertyName
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areAllPropertyValuesReturned = self.areAllPropertyValuesReturned {
            try encodeContainer.encode(areAllPropertyValuesReturned, forKey: .areAllPropertyValuesReturned)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionResponse.self, forKey: .definition)
        definition = definitionDecoded
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let areAllPropertyValuesReturnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .areAllPropertyValuesReturned)
        areAllPropertyValuesReturned = areAllPropertyValuesReturnedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// This is an object that contains the information of a property.
    public struct PropertySummary: Swift.Equatable {
        /// This flag notes whether all values of a list or map type property are returned in the API response. The maximum number of values per property returned is 50.
        public var areAllPropertyValuesReturned: Swift.Bool?
        /// This is the schema for the property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse?
        /// This is the name of the property.
        /// This member is required.
        public var propertyName: Swift.String?
        /// This is the value for the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            areAllPropertyValuesReturned: Swift.Bool? = nil,
            definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse? = nil,
            propertyName: Swift.String? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.areAllPropertyValuesReturned = areAllPropertyValuesReturned
            self.definition = definition
            self.propertyName = propertyName
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PropertyUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyUpdateType(rawValue: rawValue) ?? PropertyUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case time
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a value for a time series property.
    public struct PropertyValue: Swift.Equatable {
        /// ISO8601 DateTime of a value for a time series property. The time for when the property value was recorded in ISO 8601 format: YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm].
        ///
        /// * [YYYY]: year
        ///
        /// * [MM]: month
        ///
        /// * [DD]: day
        ///
        /// * [hh]: hour
        ///
        /// * [mm]: minute
        ///
        /// * [ss]: seconds
        ///
        /// * [.SSSSSSSSS]: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.
        ///
        /// * Z: default timezone UTC
        ///
        /// * ± HH:mm: time zone offset in Hours and Minutes.
        ///
        ///
        /// Required sub-fields: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]
        public var time: Swift.String?
        /// The timestamp of a value for a time series property.
        @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use time instead.")
        public var timestamp: ClientRuntime.Date?
        /// An object that specifies a value for a time series property.
        /// This member is required.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            time: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.time = time
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPropertyReference
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityPropertyReference = self.entityPropertyReference {
            try encodeContainer.encode(entityPropertyReference, forKey: .entityPropertyReference)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for propertyvalue0 in propertyValues {
                try propertyValuesContainer.encode(propertyvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPropertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .entityPropertyReference)
        entityPropertyReference = entityPropertyReferenceDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTTwinMakerClientTypes.PropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies information about time series property values. This object is used and consumed by the [BatchPutPropertyValues](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_BatchPutPropertyValues.html) action.
    public struct PropertyValueEntry: Swift.Equatable {
        /// An object that contains information about the entity that has the property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that specify time series property values.
        public var propertyValues: [IoTTwinMakerClientTypes.PropertyValue]?

        public init(
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValues: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyValueHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPropertyReference
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityPropertyReference = self.entityPropertyReference {
            try encodeContainer.encode(entityPropertyReference, forKey: .entityPropertyReference)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for propertyvalue0 in values {
                try valuesContainer.encode(propertyvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPropertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .entityPropertyReference)
        entityPropertyReference = entityPropertyReferenceDecoded
        let valuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValue?].self, forKey: .values)
        var valuesDecoded0:[IoTTwinMakerClientTypes.PropertyValue]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValue]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The history of values for a time series property.
    public struct PropertyValueHistory: Swift.Equatable {
        /// An object that uniquely identifies an entity property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that contain information about the values in the history of a time series property.
        public var values: [IoTTwinMakerClientTypes.PropertyValue]?

        public init(
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            values: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }
    }

}

extension QueryTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The query timeout exception.
public struct QueryTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct QueryTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.Relationship: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relationshipType
        case targetComponentTypeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType, forKey: .relationshipType)
        }
        if let targetComponentTypeId = self.targetComponentTypeId {
            try encodeContainer.encode(targetComponentTypeId, forKey: .targetComponentTypeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetComponentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetComponentTypeId)
        targetComponentTypeId = targetComponentTypeIdDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies a relationship with another component type.
    public struct Relationship: Swift.Equatable {
        /// The type of the relationship.
        public var relationshipType: Swift.String?
        /// The ID of the target component type associated with this relationship.
        public var targetComponentTypeId: Swift.String?

        public init(
            relationshipType: Swift.String? = nil,
            targetComponentTypeId: Swift.String? = nil
        )
        {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }
    }

}

extension IoTTwinMakerClientTypes.RelationshipValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetComponentName
        case targetEntityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetComponentName = self.targetComponentName {
            try encodeContainer.encode(targetComponentName, forKey: .targetComponentName)
        }
        if let targetEntityId = self.targetEntityId {
            try encodeContainer.encode(targetEntityId, forKey: .targetEntityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEntityId)
        targetEntityId = targetEntityIdDecoded
        let targetComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetComponentName)
        targetComponentName = targetComponentNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// A value that associates a component and an entity.
    public struct RelationshipValue: Swift.Equatable {
        /// The name of the target component associated with the relationship value.
        public var targetComponentName: Swift.String?
        /// The ID of the target entity associated with this relationship value.
        public var targetEntityId: Swift.String?

        public init(
            targetComponentName: Swift.String? = nil,
            targetEntityId: Swift.String? = nil
        )
        {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.Row: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rowData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rowData = rowData {
            var rowDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowData)
            for queryresultvalue0 in rowData {
                try rowDataContainer.encode(queryresultvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowDataContainer = try containerValues.decodeIfPresent([ClientRuntime.Document?].self, forKey: .rowData)
        var rowDataDecoded0:[ClientRuntime.Document]? = nil
        if let rowDataContainer = rowDataContainer {
            rowDataDecoded0 = [ClientRuntime.Document]()
            for document0 in rowDataContainer {
                if let document0 = document0 {
                    rowDataDecoded0?.append(document0)
                }
            }
        }
        rowData = rowDataDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// Represents a single row in the query results.
    public struct Row: Swift.Equatable {
        /// The data in a row of query results.
        public var rowData: [ClientRuntime.Document]?

        public init(
            rowData: [ClientRuntime.Document]? = nil
        )
        {
            self.rowData = rowData
        }
    }

}

extension IoTTwinMakerClientTypes.S3DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The S3 destination configuration.
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// The S3 destination configuration location.
        /// This member is required.
        public var location: Swift.String?

        public init(
            location: Swift.String? = nil
        )
        {
            self.location = location
        }
    }

}

extension IoTTwinMakerClientTypes.S3SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The S3 destination source configuration.
    public struct S3SourceConfiguration: Swift.Equatable {
        /// The S3 destination source configuration location.
        /// This member is required.
        public var location: Swift.String?

        public init(
            location: Swift.String? = nil
        )
        {
            self.location = location
        }
    }

}

extension IoTTwinMakerClientTypes.SceneError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SceneErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The scene error.
    public struct SceneError: Swift.Equatable {
        /// The SceneError code.
        public var code: IoTTwinMakerClientTypes.SceneErrorCode?
        /// The SceneError message.
        public var message: Swift.String?

        public init(
            code: IoTTwinMakerClientTypes.SceneErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum SceneErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case matterportError
        case sdkUnknown(Swift.String)

        public static var allCases: [SceneErrorCode] {
            return [
                .matterportError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .matterportError: return "MATTERPORT_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SceneErrorCode(rawValue: rawValue) ?? SceneErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.SceneSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentLocation
        case creationDateTime
        case description
        case sceneId
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentLocation = self.contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneId = self.sceneId {
            try encodeContainer.encode(sceneId, forKey: .sceneId)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a scene.
    public struct SceneSummary: Swift.Equatable {
        /// The ARN of the scene.
        /// This member is required.
        public var arn: Swift.String?
        /// The relative path that specifies the location of the content definition file.
        /// This member is required.
        public var contentLocation: Swift.String?
        /// The date and time when the scene was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The scene description.
        public var description: Swift.String?
        /// The ID of the scene.
        /// This member is required.
        public var sceneId: Swift.String?
        /// The date and time when the scene was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            contentLocation: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            sceneId: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum Scope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entity
        case workspace
        case sdkUnknown(Swift.String)

        public static var allCases: [Scope] {
            return [
                .entity,
                .workspace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entity: return "ENTITY"
            case .workspace: return "WORKSPACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Scope(rawValue: rawValue) ?? Scope.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotSiteWiseConfiguration
        case iotTwinMakerConfiguration
        case s3Configuration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotSiteWiseConfiguration = self.iotSiteWiseConfiguration {
            try encodeContainer.encode(iotSiteWiseConfiguration, forKey: .iotSiteWiseConfiguration)
        }
        if let iotTwinMakerConfiguration = self.iotTwinMakerConfiguration {
            try encodeContainer.encode(iotTwinMakerConfiguration, forKey: .iotTwinMakerConfiguration)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SourceType.self, forKey: .type)
        type = typeDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.S3SourceConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let iotSiteWiseConfigurationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration.self, forKey: .iotSiteWiseConfiguration)
        iotSiteWiseConfiguration = iotSiteWiseConfigurationDecoded
        let iotTwinMakerConfigurationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration.self, forKey: .iotTwinMakerConfiguration)
        iotTwinMakerConfiguration = iotTwinMakerConfigurationDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The source configuration.
    public struct SourceConfiguration: Swift.Equatable {
        /// The source configuration IoT SiteWise configuration.
        public var iotSiteWiseConfiguration: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration?
        /// The source configuration IoT TwinMaker configuration.
        public var iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration?
        /// The source configuration S3 configuration.
        public var s3Configuration: IoTTwinMakerClientTypes.S3SourceConfiguration?
        /// The source configuration type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.SourceType?

        public init(
            iotSiteWiseConfiguration: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration? = nil,
            iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration? = nil,
            s3Configuration: IoTTwinMakerClientTypes.S3SourceConfiguration? = nil,
            type: IoTTwinMakerClientTypes.SourceType? = nil
        )
        {
            self.iotSiteWiseConfiguration = iotSiteWiseConfiguration
            self.iotTwinMakerConfiguration = iotTwinMakerConfiguration
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iotsitewise
        case iottwinmaker
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .iotsitewise,
                .iottwinmaker,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iotsitewise: return "iotsitewise"
            case .iottwinmaker: return "iottwinmaker"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.Status: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that represents the status of an entity, component, component type, or workspace.
    public struct Status: Swift.Equatable {
        /// The error message.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public var state: IoTTwinMakerClientTypes.State?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.State? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum SyncJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case initializing
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncJobState] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .initializing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .initializing: return "INITIALIZING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncJobState(rawValue: rawValue) ?? SyncJobState.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.SyncJobStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The SyncJob status.
    public struct SyncJobStatus: Swift.Equatable {
        /// The SyncJob error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The SyncJob status state.
        public var state: IoTTwinMakerClientTypes.SyncJobState?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.SyncJobState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes.SyncJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case status
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncSource = self.syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The SyncJob summary.
    public struct SyncJobSummary: Swift.Equatable {
        /// The SyncJob summary ARN.
        public var arn: Swift.String?
        /// The creation date and time.
        public var creationDateTime: ClientRuntime.Date?
        /// The SyncJob summaries status.
        public var status: IoTTwinMakerClientTypes.SyncJobStatus?
        /// The sync source.
        public var syncSource: Swift.String?
        /// The update date and time.
        public var updateDateTime: ClientRuntime.Date?
        /// The ID of the workspace that contains the sync job.
        public var workspaceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            status: IoTTwinMakerClientTypes.SyncJobStatus? = nil,
            syncSource: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }

}

extension IoTTwinMakerClientTypes.SyncResourceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalid = "externalId"
        case resourceid = "resourceId"
        case resourcetype = "resourceType"
        case sdkUnknown
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .externalid(externalid):
                try container.encode(externalid, forKey: .externalid)
            case let .resourceid(resourceid):
                try container.encode(resourceid, forKey: .resourceid)
            case let .resourcetype(resourcetype):
                try container.encode(resourcetype.rawValue, forKey: .resourcetype)
            case let .state(state):
                try container.encode(state.rawValue, forKey: .state)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceState.self, forKey: .state)
        if let state = stateDecoded {
            self = .state(state)
            return
        }
        let resourcetypeDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceType.self, forKey: .resourcetype)
        if let resourcetype = resourcetypeDecoded {
            self = .resourcetype(resourcetype)
            return
        }
        let resourceidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .resourceid)
        if let resourceid = resourceidDecoded {
            self = .resourceid(resourceid)
            return
        }
        let externalidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .externalid)
        if let externalid = externalidDecoded {
            self = .externalid(externalid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// The sync resource filter.
    public enum SyncResourceFilter: Swift.Equatable {
        /// The sync resource filter's state.
        case state(IoTTwinMakerClientTypes.SyncResourceState)
        /// The sync resource filter resource type
        case resourcetype(IoTTwinMakerClientTypes.SyncResourceType)
        /// The sync resource filter resource ID.
        case resourceid(Swift.String)
        /// The external ID.
        case externalid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension IoTTwinMakerClientTypes {
    public enum SyncResourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case error
        case initializing
        case inSync
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncResourceState] {
            return [
                .deleted,
                .error,
                .initializing,
                .inSync,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .initializing: return "INITIALIZING"
            case .inSync: return "IN_SYNC"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncResourceState(rawValue: rawValue) ?? SyncResourceState.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.SyncResourceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The sync resource status.
    public struct SyncResourceStatus: Swift.Equatable {
        /// The status error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The sync resource status state.
        public var state: IoTTwinMakerClientTypes.SyncResourceState?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.SyncResourceState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes.SyncResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId
        case resourceId
        case resourceType
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceStatus.self, forKey: .status)
        status = statusDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The sync resource summary.
    public struct SyncResourceSummary: Swift.Equatable {
        /// The external ID.
        public var externalId: Swift.String?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: IoTTwinMakerClientTypes.SyncResourceType?
        /// The sync resource summary status.
        public var status: IoTTwinMakerClientTypes.SyncResourceStatus?
        /// The update date and time.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            externalId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: IoTTwinMakerClientTypes.SyncResourceType? = nil,
            status: IoTTwinMakerClientTypes.SyncResourceStatus? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.externalId = externalId
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum SyncResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case componentType
        case entity
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncResourceType] {
            return [
                .componentType,
                .entity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .componentType: return "COMPONENT_TYPE"
            case .entity: return "ENTITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncResourceType(rawValue: rawValue) ?? SyncResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.TabularConditions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orderBy
        case propertyFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let orderBy = orderBy {
            var orderByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderBy)
            for orderby0 in orderBy {
                try orderByContainer.encode(orderby0)
            }
        }
        if let propertyFilters = propertyFilters {
            var propertyFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyFilters)
            for propertyfilter0 in propertyFilters {
                try propertyFiltersContainer.encode(propertyfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderByContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.OrderBy?].self, forKey: .orderBy)
        var orderByDecoded0:[IoTTwinMakerClientTypes.OrderBy]? = nil
        if let orderByContainer = orderByContainer {
            orderByDecoded0 = [IoTTwinMakerClientTypes.OrderBy]()
            for structure0 in orderByContainer {
                if let structure0 = structure0 {
                    orderByDecoded0?.append(structure0)
                }
            }
        }
        orderBy = orderByDecoded0
        let propertyFiltersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyFilter?].self, forKey: .propertyFilters)
        var propertyFiltersDecoded0:[IoTTwinMakerClientTypes.PropertyFilter]? = nil
        if let propertyFiltersContainer = propertyFiltersContainer {
            propertyFiltersDecoded0 = [IoTTwinMakerClientTypes.PropertyFilter]()
            for structure0 in propertyFiltersContainer {
                if let structure0 = structure0 {
                    propertyFiltersDecoded0?.append(structure0)
                }
            }
        }
        propertyFilters = propertyFiltersDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The tabular conditions.
    public struct TabularConditions: Swift.Equatable {
        /// Filter criteria that orders the output. It can be sorted in ascending or descending order.
        public var orderBy: [IoTTwinMakerClientTypes.OrderBy]?
        /// You can filter the request using various logical operators and a key-value format. For example: {"key": "serverType", "value": "webServer"}
        public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?

        public init(
            orderBy: [IoTTwinMakerClientTypes.OrderBy]? = nil,
            propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil
        )
        {
            self.orderBy = orderBy
            self.propertyFilters = propertyFilters
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Metadata to add to this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of tags exceeds the limit.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case integer
        case list
        case long
        case map
        case relationship
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .boolean,
                .double,
                .integer,
                .list,
                .long,
                .map,
                .relationship,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .list: return "LIST"
            case .long: return "LONG"
            case .map: return "MAP"
            case .relationship: return "RELATIONSHIP"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "resourceARN".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateComponentTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case compositeComponentTypes
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeName = self.componentTypeName {
            try encodeContainer.encode(componentTypeName, forKey: .componentTypeName)
        }
        if let compositeComponentTypes = compositeComponentTypes {
            var compositeComponentTypesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compositeComponentTypes)
            for (dictKey0, compositeComponentTypesRequest0) in compositeComponentTypes {
                try compositeComponentTypesContainer.encode(compositeComponentTypesRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let extendsFrom = extendsFrom {
            var extendsFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendsFrom)
            for componenttypeid0 in extendsFrom {
                try extendsFromContainer.encode(componenttypeid0)
            }
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functions)
            for (dictKey0, functionsRequest0) in functions {
                try functionsContainer.encode(functionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isSingleton = self.isSingleton {
            try encodeContainer.encode(isSingleton, forKey: .isSingleton)
        }
        if let propertyDefinitions = propertyDefinitions {
            var propertyDefinitionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyDefinitions)
            for (dictKey0, propertyDefinitionsRequest0) in propertyDefinitions {
                try propertyDefinitionsContainer.encode(propertyDefinitionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, propertyGroupsRequest0) in propertyGroups {
                try propertyGroupsContainer.encode(propertyGroupsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct UpdateComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The component type name.
    public var componentTypeName: Swift.String?
    /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
    public var compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    /// The property groups.
    public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.compositeComponentTypes = compositeComponentTypes
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.workspaceId = workspaceId
    }
}

struct UpdateComponentTypeInputBody: Swift.Equatable {
    let isSingleton: Swift.Bool?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    let propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    let componentTypeName: Swift.String?
    let compositeComponentTypes: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]?
}

extension UpdateComponentTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case compositeComponentTypes
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]()
            for (key0, propertydefinitionrequest0) in propertyDefinitionsContainer {
                if let propertydefinitionrequest0 = propertydefinitionrequest0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionrequest0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionRequest?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]()
            for (key0, functionrequest0) in functionsContainer {
                if let functionrequest0 = functionrequest0 {
                    functionsDecoded0?[key0] = functionrequest0
                }
            }
        }
        functions = functionsDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]()
            for (key0, propertygrouprequest0) in propertyGroupsContainer {
                if let propertygrouprequest0 = propertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = propertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
        let compositeComponentTypesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeRequest?].self, forKey: .compositeComponentTypes)
        var compositeComponentTypesDecoded0: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]? = nil
        if let compositeComponentTypesContainer = compositeComponentTypesContainer {
            compositeComponentTypesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.CompositeComponentTypeRequest]()
            for (key0, compositecomponenttyperequest0) in compositeComponentTypesContainer {
                if let compositecomponenttyperequest0 = compositecomponenttyperequest0 {
                    compositeComponentTypesDecoded0?[key0] = compositecomponenttyperequest0
                }
            }
        }
        compositeComponentTypes = compositeComponentTypesDecoded0
    }
}

extension UpdateComponentTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateComponentTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentTypeId = output.componentTypeId
            self.state = output.state
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.componentTypeId = nil
            self.state = nil
            self.workspaceId = nil
        }
    }
}

public struct UpdateComponentTypeOutput: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.state = state
        self.workspaceId = workspaceId
    }
}

struct UpdateComponentTypeOutputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let componentTypeId: Swift.String?
    let state: IoTTwinMakerClientTypes.State?
}

extension UpdateComponentTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case state
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

enum UpdateComponentTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdates
        case compositeComponentUpdates
        case description
        case entityName
        case parentEntityUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentUpdates = componentUpdates {
            var componentUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .componentUpdates)
            for (dictKey0, componentUpdatesMapRequest0) in componentUpdates {
                try componentUpdatesContainer.encode(componentUpdatesMapRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let compositeComponentUpdates = compositeComponentUpdates {
            var compositeComponentUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compositeComponentUpdates)
            for (dictKey0, compositeComponentUpdatesMapRequest0) in compositeComponentUpdates {
                try compositeComponentUpdatesContainer.encode(compositeComponentUpdatesMapRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let parentEntityUpdate = self.parentEntityUpdate {
            try encodeContainer.encode(parentEntityUpdate, forKey: .parentEntityUpdate)
        }
    }
}

extension UpdateEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct UpdateEntityInput: Swift.Equatable {
    /// An object that maps strings to the component updates in the request. Each string in the mapping must be unique to this object.
    public var componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    /// This is an object that maps strings to compositeComponent updates in the request. Each key of the map represents the componentPath of the compositeComponent.
    public var compositeComponentUpdates: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    public var entityName: Swift.String?
    /// An object that describes the update request for a parent entity.
    public var parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil,
        compositeComponentUpdates: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentUpdates = componentUpdates
        self.compositeComponentUpdates = compositeComponentUpdates
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityUpdate = parentEntityUpdate
        self.workspaceId = workspaceId
    }
}

struct UpdateEntityInputBody: Swift.Equatable {
    let entityName: Swift.String?
    let description: Swift.String?
    let componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    let compositeComponentUpdates: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]?
    let parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
}

extension UpdateEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdates
        case compositeComponentUpdates
        case description
        case entityName
        case parentEntityUpdate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentUpdateRequest?].self, forKey: .componentUpdates)
        var componentUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil
        if let componentUpdatesContainer = componentUpdatesContainer {
            componentUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]()
            for (key0, componentupdaterequest0) in componentUpdatesContainer {
                if let componentupdaterequest0 = componentupdaterequest0 {
                    componentUpdatesDecoded0?[key0] = componentupdaterequest0
                }
            }
        }
        componentUpdates = componentUpdatesDecoded0
        let compositeComponentUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.CompositeComponentUpdateRequest?].self, forKey: .compositeComponentUpdates)
        var compositeComponentUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]? = nil
        if let compositeComponentUpdatesContainer = compositeComponentUpdatesContainer {
            compositeComponentUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]()
            for (key0, compositecomponentupdaterequest0) in compositeComponentUpdatesContainer {
                if let compositecomponentupdaterequest0 = compositecomponentupdaterequest0 {
                    compositeComponentUpdatesDecoded0?[key0] = compositecomponentupdaterequest0
                }
            }
        }
        compositeComponentUpdates = compositeComponentUpdatesDecoded0
        let parentEntityUpdateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ParentEntityUpdateRequest.self, forKey: .parentEntityUpdate)
        parentEntityUpdate = parentEntityUpdateDecoded
    }
}

extension UpdateEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.updateDateTime = output.updateDateTime
        } else {
            self.state = nil
            self.updateDateTime = nil
        }
    }
}

public struct UpdateEntityOutput: Swift.Equatable {
    /// The current state of the entity update.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        state: IoTTwinMakerClientTypes.State? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.state = state
        self.updateDateTime = updateDateTime
    }
}

struct UpdateEntityOutputBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension UpdateEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case updateDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

enum UpdateEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleNames
        case pricingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleNames = bundleNames {
            var bundleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleNames)
            for bundlename0 in bundleNames {
                try bundleNamesContainer.encode(bundlename0)
            }
        }
        if let pricingMode = self.pricingMode {
            try encodeContainer.encode(pricingMode.rawValue, forKey: .pricingMode)
        }
    }
}

extension UpdatePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pricingplan"
    }
}

public struct UpdatePricingPlanInput: Swift.Equatable {
    /// The bundle names.
    public var bundleNames: [Swift.String]?
    /// The pricing mode.
    /// This member is required.
    public var pricingMode: IoTTwinMakerClientTypes.PricingMode?

    public init(
        bundleNames: [Swift.String]? = nil,
        pricingMode: IoTTwinMakerClientTypes.PricingMode? = nil
    )
    {
        self.bundleNames = bundleNames
        self.pricingMode = pricingMode
    }
}

struct UpdatePricingPlanInputBody: Swift.Equatable {
    let pricingMode: IoTTwinMakerClientTypes.PricingMode?
    let bundleNames: [Swift.String]?
}

extension UpdatePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleNames
        case pricingMode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingModeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingMode.self, forKey: .pricingMode)
        pricingMode = pricingModeDecoded
        let bundleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleNames)
        var bundleNamesDecoded0:[Swift.String]? = nil
        if let bundleNamesContainer = bundleNamesContainer {
            bundleNamesDecoded0 = [Swift.String]()
            for string0 in bundleNamesContainer {
                if let string0 = string0 {
                    bundleNamesDecoded0?.append(string0)
                }
            }
        }
        bundleNames = bundleNamesDecoded0
    }
}

extension UpdatePricingPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePricingPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.currentPricingPlan = output.currentPricingPlan
            self.pendingPricingPlan = output.pendingPricingPlan
        } else {
            self.currentPricingPlan = nil
            self.pendingPricingPlan = nil
        }
    }
}

public struct UpdatePricingPlanOutput: Swift.Equatable {
    /// Update the current pricing plan.
    /// This member is required.
    public var currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    /// Update the pending pricing plan.
    public var pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?

    public init(
        currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil,
        pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil
    )
    {
        self.currentPricingPlan = currentPricingPlan
        self.pendingPricingPlan = pendingPricingPlan
    }
}

struct UpdatePricingPlanOutputBody: Swift.Equatable {
    let currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    let pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
}

extension UpdatePricingPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentPricingPlan
        case pendingPricingPlan
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .currentPricingPlan)
        currentPricingPlan = currentPricingPlanDecoded
        let pendingPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .pendingPricingPlan)
        pendingPricingPlan = pendingPricingPlanDecoded
    }
}

enum UpdatePricingPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTTwinMakerClientTypes {
    public enum UpdateReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case entityCountUpdate
        case overwritten
        case pricingModeUpdate
        case pricingTierUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateReason] {
            return [
                .default,
                .entityCountUpdate,
                .overwritten,
                .pricingModeUpdate,
                .pricingTierUpdate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .entityCountUpdate: return "ENTITY_COUNT_UPDATE"
            case .overwritten: return "OVERWRITTEN"
            case .pricingModeUpdate: return "PRICING_MODE_UPDATE"
            case .pricingTierUpdate: return "PRICING_TIER_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateReason(rawValue: rawValue) ?? UpdateReason.sdkUnknown(rawValue)
        }
    }
}

extension UpdateSceneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for scenecapability0 in capabilities {
                try capabilitiesContainer.encode(scenecapability0)
            }
        }
        if let contentLocation = self.contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneMetadata = sceneMetadata {
            var sceneMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sceneMetadata)
            for (dictKey0, sceneMetadataMap0) in sceneMetadata {
                try sceneMetadataContainer.encode(sceneMetadataMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct UpdateSceneInput: Swift.Equatable {
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    public var contentLocation: Swift.String?
    /// The description of this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The scene metadata.
    public var sceneMetadata: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        sceneMetadata: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.sceneMetadata = sceneMetadata
        self.workspaceId = workspaceId
    }
}

struct UpdateSceneInputBody: Swift.Equatable {
    let contentLocation: Swift.String?
    let description: Swift.String?
    let capabilities: [Swift.String]?
    let sceneMetadata: [Swift.String:Swift.String]?
}

extension UpdateSceneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let sceneMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sceneMetadata)
        var sceneMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let sceneMetadataContainer = sceneMetadataContainer {
            sceneMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, scenemetadatavalue0) in sceneMetadataContainer {
                if let scenemetadatavalue0 = scenemetadatavalue0 {
                    sceneMetadataDecoded0?[key0] = scenemetadatavalue0
                }
            }
        }
        sceneMetadata = sceneMetadataDecoded0
    }
}

extension UpdateSceneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSceneOutputBody = try responseDecoder.decode(responseBody: data)
            self.updateDateTime = output.updateDateTime
        } else {
            self.updateDateTime = nil
        }
    }
}

public struct UpdateSceneOutput: Swift.Equatable {
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

struct UpdateSceneOutputBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
}

extension UpdateSceneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

enum UpdateSceneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }
}

extension UpdateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct UpdateWorkspaceInput: Swift.Equatable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    public var s3Location: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let role: Swift.String?
    let s3Location: Swift.String?
}

extension UpdateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension UpdateWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.updateDateTime = output.updateDateTime
        } else {
            self.updateDateTime = nil
        }
    }
}

public struct UpdateWorkspaceOutput: Swift.Equatable {
    /// The date and time of the current update.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

struct UpdateWorkspaceOutputBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
}

extension UpdateWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

enum UpdateWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Failed
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.WorkspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case linkedServices
        case updateDateTime
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let linkedServices = linkedServices {
            var linkedServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .linkedServices)
            for linkedservice0 in linkedServices {
                try linkedServicesContainer.encode(linkedservice0)
            }
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let linkedServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .linkedServices)
        var linkedServicesDecoded0:[Swift.String]? = nil
        if let linkedServicesContainer = linkedServicesContainer {
            linkedServicesDecoded0 = [Swift.String]()
            for string0 in linkedServicesContainer {
                if let string0 = string0 {
                    linkedServicesDecoded0?.append(string0)
                }
            }
        }
        linkedServices = linkedServicesDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a workspace.
    public struct WorkspaceSummary: Swift.Equatable {
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the workspace was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the workspace.
        public var description: Swift.String?
        /// A list of services that are linked to the workspace.
        public var linkedServices: [Swift.String]?
        /// The date and time when the workspace was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?
        /// The ID of the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            linkedServices: [Swift.String]? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.linkedServices = linkedServices
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }

}
