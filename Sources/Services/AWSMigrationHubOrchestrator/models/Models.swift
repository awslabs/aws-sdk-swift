// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when an attempt to update or delete a resource would cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
        case templateDescription
        case templateName
        case templateSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateDescription = self.templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateSource = self.templateSource {
            try encodeContainer.encode(templateSource, forKey: .templateSource)
        }
    }
}

extension CreateTemplateInput {

    static func urlPathProvider(_ value: CreateTemplateInput) -> Swift.String? {
        return "/template"
    }
}

public struct CreateTemplateInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [Idempotency](https://smithy.io/2.0/spec/behavior-traits.html#idempotencytoken-trait) in the Smithy documentation.
    public var clientToken: Swift.String?
    /// The tags to add to the migration workflow template.
    public var tags: [Swift.String:Swift.String]?
    /// A description of the migration workflow template.
    public var templateDescription: Swift.String?
    /// The name of the migration workflow template.
    /// This member is required.
    public var templateName: Swift.String?
    /// The source of the migration workflow template.
    /// This member is required.
    public var templateSource: MigrationHubOrchestratorClientTypes.TemplateSource?

    public init(
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateDescription: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateSource: MigrationHubOrchestratorClientTypes.TemplateSource? = nil
    )
    {
        self.clientToken = clientToken
        self.tags = tags
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateSource = templateSource
    }
}

struct CreateTemplateInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateDescription: Swift.String?
    let templateSource: MigrationHubOrchestratorClientTypes.TemplateSource?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
        case templateDescription
        case templateName
        case templateSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateSourceDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TemplateSource.self, forKey: .templateSource)
        templateSource = templateSourceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.tags = nil
            self.templateArn = nil
            self.templateId = nil
        }
    }
}

public struct CreateTemplateOutput: Swift.Equatable {
    /// The tags added to the migration workflow template.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) of the migration workflow template. The format for an Migration Hub Orchestrator template ARN is arn:aws:migrationhub-orchestrator:region:account:template/template-abcd1234. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) in the AWS General Reference.
    public var templateArn: Swift.String?
    /// The ID of the migration workflow template.
    public var templateId: Swift.String?

    public init(
        tags: [Swift.String:Swift.String]? = nil,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.tags = tags
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct CreateTemplateOutputBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case templateArn
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkflowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkflowInput(applicationConfigurationId: \(Swift.String(describing: applicationConfigurationId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), stepTargets: \(Swift.String(describing: stepTargets)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), inputParameters: \"CONTENT_REDACTED\")"}
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case description
        case inputParameters
        case name
        case stepTargets
        case tags
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = self.applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            var inputParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputParameters)
            for (dictKey0, stepInputParameters0) in inputParameters {
                try inputParametersContainer.encode(stepInputParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stepTargets = stepTargets {
            var stepTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTargets)
            for stringlistmember0 in stepTargets {
                try stepTargetsContainer.encode(stringlistmember0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, stringMap0) in tags {
                try tagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/migrationworkflow"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// The configuration ID of the application configured in Application Discovery Service.
    public var applicationConfigurationId: Swift.String?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The input parameters required to create a migration workflow.
    /// This member is required.
    public var inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    /// The name of the migration workflow.
    /// This member is required.
    public var name: Swift.String?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?
    /// The tags to add on a migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        applicationConfigurationId: Swift.String? = nil,
        description: Swift.String? = nil,
        inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil,
        name: Swift.String? = nil,
        stepTargets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.description = description
        self.inputParameters = inputParameters
        self.name = name
        self.stepTargets = stepTargets
        self.tags = tags
        self.templateId = templateId
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let applicationConfigurationId: Swift.String?
    let inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case description
        case inputParameters
        case name
        case stepTargets
        case tags
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let inputParametersContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .inputParameters)
        var inputParametersDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let inputParametersContainer = inputParametersContainer {
            inputParametersDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in inputParametersContainer {
                if let stepinput0 = stepinput0 {
                    inputParametersDecoded0?[key0] = stepinput0
                }
            }
        }
        inputParameters = inputParametersDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkflowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkflowOutput(adsApplicationConfigurationId: \(Swift.String(describing: adsApplicationConfigurationId)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), stepTargets: \(Swift.String(describing: stepTargets)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), workflowInputs: \"CONTENT_REDACTED\")"}
}

extension CreateWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.adsApplicationConfigurationId = output.adsApplicationConfigurationId
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.stepTargets = output.stepTargets
            self.tags = output.tags
            self.templateId = output.templateId
            self.workflowInputs = output.workflowInputs
        } else {
            self.adsApplicationConfigurationId = nil
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.stepTargets = nil
            self.tags = nil
            self.templateId = nil
            self.workflowInputs = nil
        }
    }
}

public struct CreateWorkflowOutput: Swift.Equatable {
    /// The configuration ID of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The time at which the migration workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?
    /// The tags to add on a migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The inputs for creating a migration workflow.
    public var workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?

    public init(
        adsApplicationConfigurationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        stepTargets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil,
        workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
    )
    {
        self.adsApplicationConfigurationId = adsApplicationConfigurationId
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.stepTargets = stepTargets
        self.tags = tags
        self.templateId = templateId
        self.workflowInputs = workflowInputs
    }
}

struct CreateWorkflowOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let adsApplicationConfigurationId: Swift.String?
    let workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let creationTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationId
        case arn
        case creationTime
        case description
        case id
        case name
        case status
        case stepTargets
        case tags
        case templateId
        case workflowInputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationId)
        adsApplicationConfigurationId = adsApplicationConfigurationIdDecoded
        let workflowInputsContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .workflowInputs)
        var workflowInputsDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let workflowInputsContainer = workflowInputsContainer {
            workflowInputsDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in workflowInputsContainer {
                if let stepinput0 = stepinput0 {
                    workflowInputsDecoded0?[key0] = stepinput0
                }
            }
        }
        workflowInputs = workflowInputsDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkflowStepGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
        case workflowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension CreateWorkflowStepGroupInput {

    static func urlPathProvider(_ value: CreateWorkflowStepGroupInput) -> Swift.String? {
        return "/workflowstepgroups"
    }
}

public struct CreateWorkflowStepGroupInput: Swift.Equatable {
    /// The description of the step group.
    public var description: Swift.String?
    /// The name of the step group.
    /// This member is required.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The ID of the migration workflow that will contain the step group.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.next = next
        self.previous = previous
        self.workflowId = workflowId
    }
}

struct CreateWorkflowStepGroupInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let next: [Swift.String]?
    let previous: [Swift.String]?
}

extension CreateWorkflowStepGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
    }
}

extension CreateWorkflowStepGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkflowStepGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.next = output.next
            self.previous = output.previous
            self.tools = output.tools
            self.workflowId = output.workflowId
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.next = nil
            self.previous = nil
            self.tools = nil
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowStepGroupOutput: Swift.Equatable {
    /// The time at which the step group is created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The ID of the migration workflow that contains the step group.
    public var workflowId: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.previous = previous
        self.tools = tools
        self.workflowId = workflowId
    }
}

struct CreateWorkflowStepGroupOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let next: [Swift.String]?
    let previous: [Swift.String]?
    let creationTime: ClientRuntime.Date?
}

extension CreateWorkflowStepGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case next
        case previous
        case tools
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateWorkflowStepGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkflowStepInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for workflowstepoutput0 in outputs {
                try outputsContainer.encode(workflowstepoutput0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepGroupId = self.stepGroupId {
            try encodeContainer.encode(stepGroupId, forKey: .stepGroupId)
        }
        if let stepTarget = stepTarget {
            var stepTargetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTarget)
            for stringlistmember0 in stepTarget {
                try stepTargetContainer.encode(stringlistmember0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowStepAutomationConfiguration = self.workflowStepAutomationConfiguration {
            try encodeContainer.encode(workflowStepAutomationConfiguration, forKey: .workflowStepAutomationConfiguration)
        }
    }
}

extension CreateWorkflowStepInput {

    static func urlPathProvider(_ value: CreateWorkflowStepInput) -> Swift.String? {
        return "/workflowstep"
    }
}

public struct CreateWorkflowStepInput: Swift.Equatable {
    /// The description of the step.
    public var description: Swift.String?
    /// The name of the step.
    /// This member is required.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The key value pairs added for the expected output.
    public var outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    /// This member is required.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The servers on which a step will be run.
    public var stepTarget: [Swift.String]?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?
    /// The custom script to run tests on source or target environments.
    public var workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil,
        previous: [Swift.String]? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepGroupId: Swift.String? = nil,
        stepTarget: [Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration? = nil
    )
    {
        self.description = description
        self.name = name
        self.next = next
        self.outputs = outputs
        self.previous = previous
        self.stepActionType = stepActionType
        self.stepGroupId = stepGroupId
        self.stepTarget = stepTarget
        self.workflowId = workflowId
        self.workflowStepAutomationConfiguration = workflowStepAutomationConfiguration
    }
}

struct CreateWorkflowStepInputBody: Swift.Equatable {
    let name: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let description: Swift.String?
    let workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?
    let stepTarget: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
}

extension CreateWorkflowStepInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workflowStepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration.self, forKey: .workflowStepAutomationConfiguration)
        workflowStepAutomationConfiguration = workflowStepAutomationConfigurationDecoded
        let stepTargetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTarget)
        var stepTargetDecoded0:[Swift.String]? = nil
        if let stepTargetContainer = stepTargetContainer {
            stepTargetDecoded0 = [Swift.String]()
            for string0 in stepTargetContainer {
                if let string0 = string0 {
                    stepTargetDecoded0?.append(string0)
                }
            }
        }
        stepTarget = stepTargetDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension CreateWorkflowStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkflowStepOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.stepGroupId = output.stepGroupId
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.name = nil
            self.stepGroupId = nil
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowStepOutput: Swift.Equatable {
    /// The ID of the step.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct CreateWorkflowStepOutputBody: Swift.Equatable {
    let id: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
}

extension CreateWorkflowStepOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case stepGroupId
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateWorkflowStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum DataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case integer
        case string
        case stringlist
        case stringmap
        case sdkUnknown(Swift.String)

        public static var allCases: [DataType] {
            return [
                .integer,
                .string,
                .stringlist,
                .stringmap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case .stringlist: return "STRINGLIST"
            case .stringmap: return "STRINGMAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataType(rawValue: rawValue) ?? DataType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteTemplateInput {

    static func urlPathProvider(_ value: DeleteTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/template/\(id.urlPercentEncoding())"
    }
}

public struct DeleteTemplateInput: Swift.Equatable {
    /// The ID of the request to delete a migration workflow template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteTemplateInputBody: Swift.Equatable {
}

extension DeleteTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
}

extension DeleteWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteWorkflowOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteWorkflowOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
}

extension DeleteWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkflowStepGroupInput {

    static func queryItemProvider(_ value: DeleteWorkflowStepGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension DeleteWorkflowStepGroupInput {

    static func urlPathProvider(_ value: DeleteWorkflowStepGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflowstepgroup/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowStepGroupInput: Swift.Equatable {
    /// The ID of the step group you want to delete.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowStepGroupInputBody: Swift.Equatable {
}

extension DeleteWorkflowStepGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowStepGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkflowStepGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkflowStepGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkflowStepInput {

    static func queryItemProvider(_ value: DeleteWorkflowStepInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let stepGroupId = value.stepGroupId else {
            let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let stepGroupIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
        items.append(stepGroupIdQueryItem)
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension DeleteWorkflowStepInput {

    static func urlPathProvider(_ value: DeleteWorkflowStepInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflowstep/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowStepInput: Swift.Equatable {
    /// The ID of the step you want to delete.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group that contains the step you want to delete.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowStepInputBody: Swift.Equatable {
}

extension DeleteWorkflowStepInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkflowStepOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkflowStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemplateInput {

    static func urlPathProvider(_ value: GetTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/migrationworkflowtemplate/\(id.urlPercentEncoding())"
    }
}

public struct GetTemplateInput: Swift.Equatable {
    /// The ID of the template.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetTemplateInputBody: Swift.Equatable {
}

extension GetTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.inputs = output.inputs
            self.name = output.name
            self.owner = output.owner
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.templateArn = output.templateArn
            self.templateClass = output.templateClass
            self.tools = output.tools
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.inputs = nil
            self.name = nil
            self.owner = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.templateArn = nil
            self.templateClass = nil
            self.tools = nil
        }
    }
}

public struct GetTemplateOutput: Swift.Equatable {
    /// The time at which the template was last created.
    public var creationTime: ClientRuntime.Date?
    /// The time at which the template was last created.
    public var description: Swift.String?
    /// The ID of the template.
    public var id: Swift.String?
    /// The inputs provided for the creation of the migration workflow.
    public var inputs: [MigrationHubOrchestratorClientTypes.TemplateInput]?
    /// The name of the template.
    public var name: Swift.String?
    /// The owner of the migration workflow template.
    public var owner: Swift.String?
    /// The status of the template.
    public var status: MigrationHubOrchestratorClientTypes.TemplateStatus?
    /// The status message of retrieving migration workflow templates.
    public var statusMessage: Swift.String?
    /// The tags added to the migration workflow template.
    public var tags: [Swift.String:Swift.String]?
    /// >The Amazon Resource Name (ARN) of the migration workflow template. The format for an Migration Hub Orchestrator template ARN is arn:aws:migrationhub-orchestrator:region:account:template/template-abcd1234. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) in the AWS General Reference.
    public var templateArn: Swift.String?
    /// The class of the migration workflow template. The available template classes are:
    ///
    /// * A2C
    ///
    /// * MGN
    ///
    /// * SAP_MULTI
    ///
    /// * SQL_EC2
    ///
    /// * SQL_RDS
    ///
    /// * VMIE
    public var templateClass: Swift.String?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        inputs: [MigrationHubOrchestratorClientTypes.TemplateInput]? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.TemplateStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateArn: Swift.String? = nil,
        templateClass: Swift.String? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.inputs = inputs
        self.name = name
        self.owner = owner
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.templateArn = templateArn
        self.templateClass = templateClass
        self.tools = tools
    }
}

struct GetTemplateOutputBody: Swift.Equatable {
    let id: Swift.String?
    let templateArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let inputs: [MigrationHubOrchestratorClientTypes.TemplateInput]?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let creationTime: ClientRuntime.Date?
    let owner: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.TemplateStatus?
    let statusMessage: Swift.String?
    let templateClass: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case inputs
        case name
        case owner
        case status
        case statusMessage
        case tags
        case templateArn
        case templateClass
        case tools
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateInput?].self, forKey: .inputs)
        var inputsDecoded0:[MigrationHubOrchestratorClientTypes.TemplateInput]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateInput]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let templateClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateClass)
        templateClass = templateClassDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemplateStepGroupInput {

    static func urlPathProvider(_ value: GetTemplateStepGroupInput) -> Swift.String? {
        guard let templateId = value.templateId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/templates/\(templateId.urlPercentEncoding())/stepgroups/\(id.urlPercentEncoding())"
    }
}

public struct GetTemplateStepGroupInput: Swift.Equatable {
    /// The ID of the step group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        id: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.id = id
        self.templateId = templateId
    }
}

struct GetTemplateStepGroupInputBody: Swift.Equatable {
}

extension GetTemplateStepGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateStepGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemplateStepGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.next = output.next
            self.previous = output.previous
            self.status = output.status
            self.templateId = output.templateId
            self.tools = output.tools
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.next = nil
            self.previous = nil
            self.status = nil
            self.templateId = nil
            self.tools = nil
        }
    }
}

public struct GetTemplateStepGroupOutput: Swift.Equatable {
    /// The time at which the step group was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The time at which the step group was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The status of the step group.
    public var status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        status: MigrationHubOrchestratorClientTypes.StepGroupStatus? = nil,
        templateId: Swift.String? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.next = next
        self.previous = previous
        self.status = status
        self.templateId = templateId
        self.tools = tools
    }
}

struct GetTemplateStepGroupOutputBody: Swift.Equatable {
    let templateId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
}

extension GetTemplateStepGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case lastModifiedTime
        case name
        case next
        case previous
        case status
        case templateId
        case tools
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepGroupStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

enum GetTemplateStepGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemplateStepInput {

    static func queryItemProvider(_ value: GetTemplateStepInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let stepGroupId = value.stepGroupId else {
            let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let stepGroupIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
        items.append(stepGroupIdQueryItem)
        guard let templateId = value.templateId else {
            let message = "Creating a URL Query Item failed. templateId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let templateIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "templateId".urlPercentEncoding(), value: Swift.String(templateId).urlPercentEncoding())
        items.append(templateIdQueryItem)
        return items
    }
}

extension GetTemplateStepInput {

    static func urlPathProvider(_ value: GetTemplateStepInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/templatestep/\(id.urlPercentEncoding())"
    }
}

public struct GetTemplateStepInput: Swift.Equatable {
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.templateId = templateId
    }
}

struct GetTemplateStepInputBody: Swift.Equatable {
}

extension GetTemplateStepInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemplateStepOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.next = output.next
            self.outputs = output.outputs
            self.previous = output.previous
            self.stepActionType = output.stepActionType
            self.stepAutomationConfiguration = output.stepAutomationConfiguration
            self.stepGroupId = output.stepGroupId
            self.templateId = output.templateId
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.next = nil
            self.outputs = nil
            self.previous = nil
            self.stepActionType = nil
            self.stepAutomationConfiguration = nil
            self.stepGroupId = nil
            self.templateId = nil
        }
    }
}

public struct GetTemplateStepOutput: Swift.Equatable {
    /// The time at which the step was created.
    public var creationTime: Swift.String?
    /// The description of the step.
    public var description: Swift.String?
    /// The ID of the step.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The outputs of the step.
    public var outputs: [MigrationHubOrchestratorClientTypes.StepOutput]?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The custom script to run tests on source or target environments.
    public var stepAutomationConfiguration: MigrationHubOrchestratorClientTypes.StepAutomationConfiguration?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the template.
    public var templateId: Swift.String?

    public init(
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.StepOutput]? = nil,
        previous: [Swift.String]? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepAutomationConfiguration: MigrationHubOrchestratorClientTypes.StepAutomationConfiguration? = nil,
        stepGroupId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.outputs = outputs
        self.previous = previous
        self.stepActionType = stepActionType
        self.stepAutomationConfiguration = stepAutomationConfiguration
        self.stepGroupId = stepGroupId
        self.templateId = templateId
    }
}

struct GetTemplateStepOutputBody: Swift.Equatable {
    let id: Swift.String?
    let stepGroupId: Swift.String?
    let templateId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let creationTime: Swift.String?
    let previous: [Swift.String]?
    let next: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.StepOutput]?
    let stepAutomationConfiguration: MigrationHubOrchestratorClientTypes.StepAutomationConfiguration?
}

extension GetTemplateStepOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case next
        case outputs
        case previous
        case stepActionType
        case stepAutomationConfiguration
        case stepGroupId
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.StepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.StepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.StepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let stepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepAutomationConfiguration.self, forKey: .stepAutomationConfiguration)
        stepAutomationConfiguration = stepAutomationConfigurationDecoded
    }
}

enum GetTemplateStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWorkflowInputBody: Swift.Equatable {
}

extension GetWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkflowOutput(adsApplicationConfigurationId: \(Swift.String(describing: adsApplicationConfigurationId)), adsApplicationName: \(Swift.String(describing: adsApplicationName)), arn: \(Swift.String(describing: arn)), completedSteps: \(Swift.String(describing: completedSteps)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), lastStartTime: \(Swift.String(describing: lastStartTime)), lastStopTime: \(Swift.String(describing: lastStopTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), tools: \(Swift.String(describing: tools)), totalSteps: \(Swift.String(describing: totalSteps)), workflowBucket: \(Swift.String(describing: workflowBucket)), workflowInputs: \"CONTENT_REDACTED\")"}
}

extension GetWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.adsApplicationConfigurationId = output.adsApplicationConfigurationId
            self.adsApplicationName = output.adsApplicationName
            self.arn = output.arn
            self.completedSteps = output.completedSteps
            self.creationTime = output.creationTime
            self.description = output.description
            self.endTime = output.endTime
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.lastStartTime = output.lastStartTime
            self.lastStopTime = output.lastStopTime
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.templateId = output.templateId
            self.tools = output.tools
            self.totalSteps = output.totalSteps
            self.workflowBucket = output.workflowBucket
            self.workflowInputs = output.workflowInputs
        } else {
            self.adsApplicationConfigurationId = nil
            self.adsApplicationName = nil
            self.arn = nil
            self.completedSteps = nil
            self.creationTime = nil
            self.description = nil
            self.endTime = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.lastStartTime = nil
            self.lastStopTime = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.templateId = nil
            self.tools = nil
            self.totalSteps = nil
            self.workflowBucket = nil
            self.workflowInputs = nil
        }
    }
}

public struct GetWorkflowOutput: Swift.Equatable {
    /// The configuration ID of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationId: Swift.String?
    /// The name of the application configured in Application Discovery Service.
    public var adsApplicationName: Swift.String?
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// Get a list of completed steps in the migration workflow.
    public var completedSteps: Swift.Int?
    /// The time at which the migration workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The time at which the migration workflow ended.
    public var endTime: ClientRuntime.Date?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The time at which the migration workflow was last started.
    public var lastStartTime: ClientRuntime.Date?
    /// The time at which the migration workflow was last stopped.
    public var lastStopTime: ClientRuntime.Date?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?
    /// The tags added to the migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The total number of steps in the migration workflow.
    public var totalSteps: Swift.Int?
    /// The Amazon S3 bucket where the migration logs are stored.
    public var workflowBucket: Swift.String?
    /// The inputs required for creating the migration workflow.
    public var workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?

    public init(
        adsApplicationConfigurationId: Swift.String? = nil,
        adsApplicationName: Swift.String? = nil,
        arn: Swift.String? = nil,
        completedSteps: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        lastStopTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        totalSteps: Swift.Int? = nil,
        workflowBucket: Swift.String? = nil,
        workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
    )
    {
        self.adsApplicationConfigurationId = adsApplicationConfigurationId
        self.adsApplicationName = adsApplicationName
        self.arn = arn
        self.completedSteps = completedSteps
        self.creationTime = creationTime
        self.description = description
        self.endTime = endTime
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.lastStartTime = lastStartTime
        self.lastStopTime = lastStopTime
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.templateId = templateId
        self.tools = tools
        self.totalSteps = totalSteps
        self.workflowBucket = workflowBucket
        self.workflowInputs = workflowInputs
    }
}

struct GetWorkflowOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let adsApplicationConfigurationId: Swift.String?
    let adsApplicationName: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastStartTime: ClientRuntime.Date?
    let lastStopTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let totalSteps: Swift.Int?
    let completedSteps: Swift.Int?
    let workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let tags: [Swift.String:Swift.String]?
    let workflowBucket: Swift.String?
}

extension GetWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationId
        case adsApplicationName
        case arn
        case completedSteps
        case creationTime
        case description
        case endTime
        case id
        case lastModifiedTime
        case lastStartTime
        case lastStopTime
        case name
        case status
        case statusMessage
        case tags
        case templateId
        case tools
        case totalSteps
        case workflowBucket
        case workflowInputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationId)
        adsApplicationConfigurationId = adsApplicationConfigurationIdDecoded
        let adsApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationName)
        adsApplicationName = adsApplicationNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let lastStopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStopTime)
        lastStopTime = lastStopTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let totalStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
        let completedStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completedSteps)
        completedSteps = completedStepsDecoded
        let workflowInputsContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .workflowInputs)
        var workflowInputsDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let workflowInputsContainer = workflowInputsContainer {
            workflowInputsDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in workflowInputsContainer {
                if let stepinput0 = stepinput0 {
                    workflowInputsDecoded0?[key0] = stepinput0
                }
            }
        }
        workflowInputs = workflowInputsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workflowBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowBucket)
        workflowBucket = workflowBucketDecoded
    }
}

enum GetWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowStepGroupInput {

    static func queryItemProvider(_ value: GetWorkflowStepGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension GetWorkflowStepGroupInput {

    static func urlPathProvider(_ value: GetWorkflowStepGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflowstepgroup/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowStepGroupInput: Swift.Equatable {
    /// The ID of the step group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepGroupInputBody: Swift.Equatable {
}

extension GetWorkflowStepGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowStepGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowStepGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.endTime = output.endTime
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.next = output.next
            self.owner = output.owner
            self.previous = output.previous
            self.status = output.status
            self.tools = output.tools
            self.workflowId = output.workflowId
        } else {
            self.creationTime = nil
            self.description = nil
            self.endTime = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.next = nil
            self.owner = nil
            self.previous = nil
            self.status = nil
            self.tools = nil
            self.workflowId = nil
        }
    }
}

public struct GetWorkflowStepGroupOutput: Swift.Equatable {
    /// The time at which the step group was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step group.
    public var description: Swift.String?
    /// The time at which the step group ended.
    public var endTime: ClientRuntime.Date?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The time at which the step group was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The owner of the step group.
    public var owner: MigrationHubOrchestratorClientTypes.Owner?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The status of the step group.
    public var status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
        previous: [Swift.String]? = nil,
        status: MigrationHubOrchestratorClientTypes.StepGroupStatus? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.endTime = endTime
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.next = next
        self.owner = owner
        self.previous = previous
        self.status = status
        self.tools = tools
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    let owner: MigrationHubOrchestratorClientTypes.Owner?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
}

extension GetWorkflowStepGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case endTime
        case id
        case lastModifiedTime
        case name
        case next
        case owner
        case previous
        case status
        case tools
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepGroupStatus.self, forKey: .status)
        status = statusDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

enum GetWorkflowStepGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowStepInput {

    static func queryItemProvider(_ value: GetWorkflowStepInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let stepGroupId = value.stepGroupId else {
            let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let stepGroupIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
        items.append(stepGroupIdQueryItem)
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension GetWorkflowStepInput {

    static func urlPathProvider(_ value: GetWorkflowStepInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflowstep/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowStepInput: Swift.Equatable {
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepInputBody: Swift.Equatable {
}

extension GetWorkflowStepInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowStepOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.endTime = output.endTime
            self.lastStartTime = output.lastStartTime
            self.name = output.name
            self.next = output.next
            self.noOfSrvCompleted = output.noOfSrvCompleted
            self.noOfSrvFailed = output.noOfSrvFailed
            self.outputs = output.outputs
            self.owner = output.owner
            self.previous = output.previous
            self.scriptOutputLocation = output.scriptOutputLocation
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.stepActionType = output.stepActionType
            self.stepGroupId = output.stepGroupId
            self.stepId = output.stepId
            self.stepTarget = output.stepTarget
            self.totalNoOfSrv = output.totalNoOfSrv
            self.workflowId = output.workflowId
            self.workflowStepAutomationConfiguration = output.workflowStepAutomationConfiguration
        } else {
            self.creationTime = nil
            self.description = nil
            self.endTime = nil
            self.lastStartTime = nil
            self.name = nil
            self.next = nil
            self.noOfSrvCompleted = nil
            self.noOfSrvFailed = nil
            self.outputs = nil
            self.owner = nil
            self.previous = nil
            self.scriptOutputLocation = nil
            self.status = nil
            self.statusMessage = nil
            self.stepActionType = nil
            self.stepGroupId = nil
            self.stepId = nil
            self.stepTarget = nil
            self.totalNoOfSrv = nil
            self.workflowId = nil
            self.workflowStepAutomationConfiguration = nil
        }
    }
}

public struct GetWorkflowStepOutput: Swift.Equatable {
    /// The time at which the step was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step.
    public var description: Swift.String?
    /// The time at which the step ended.
    public var endTime: ClientRuntime.Date?
    /// The time at which the workflow was last started.
    public var lastStartTime: ClientRuntime.Date?
    /// The name of the step.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The number of servers that have been migrated.
    public var noOfSrvCompleted: Swift.Int?
    /// The number of servers that have failed to migrate.
    public var noOfSrvFailed: Swift.Int?
    /// The outputs of the step.
    public var outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    /// The owner of the step.
    public var owner: MigrationHubOrchestratorClientTypes.Owner?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The output location of the script.
    public var scriptOutputLocation: Swift.String?
    /// The status of the step.
    public var status: MigrationHubOrchestratorClientTypes.StepStatus?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the step.
    public var stepId: Swift.String?
    /// The servers on which a step will be run.
    public var stepTarget: [Swift.String]?
    /// The total number of servers that have been migrated.
    public var totalNoOfSrv: Swift.Int?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?
    /// The custom script to run tests on source or target environments.
    public var workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        noOfSrvCompleted: Swift.Int? = nil,
        noOfSrvFailed: Swift.Int? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil,
        owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
        previous: [Swift.String]? = nil,
        scriptOutputLocation: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
        statusMessage: Swift.String? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepGroupId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        stepTarget: [Swift.String]? = nil,
        totalNoOfSrv: Swift.Int? = nil,
        workflowId: Swift.String? = nil,
        workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.endTime = endTime
        self.lastStartTime = lastStartTime
        self.name = name
        self.next = next
        self.noOfSrvCompleted = noOfSrvCompleted
        self.noOfSrvFailed = noOfSrvFailed
        self.outputs = outputs
        self.owner = owner
        self.previous = previous
        self.scriptOutputLocation = scriptOutputLocation
        self.status = status
        self.statusMessage = statusMessage
        self.stepActionType = stepActionType
        self.stepGroupId = stepGroupId
        self.stepId = stepId
        self.stepTarget = stepTarget
        self.totalNoOfSrv = totalNoOfSrv
        self.workflowId = workflowId
        self.workflowStepAutomationConfiguration = workflowStepAutomationConfiguration
    }
}

struct GetWorkflowStepOutputBody: Swift.Equatable {
    let name: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let stepId: Swift.String?
    let description: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let owner: MigrationHubOrchestratorClientTypes.Owner?
    let workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?
    let stepTarget: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.StepStatus?
    let statusMessage: Swift.String?
    let scriptOutputLocation: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastStartTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let noOfSrvCompleted: Swift.Int?
    let noOfSrvFailed: Swift.Int?
    let totalNoOfSrv: Swift.Int?
}

extension GetWorkflowStepOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case endTime
        case lastStartTime
        case name
        case next
        case noOfSrvCompleted
        case noOfSrvFailed
        case outputs
        case owner
        case previous
        case scriptOutputLocation
        case status
        case statusMessage
        case stepActionType
        case stepGroupId
        case stepId
        case stepTarget
        case totalNoOfSrv
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let workflowStepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration.self, forKey: .workflowStepAutomationConfiguration)
        workflowStepAutomationConfiguration = workflowStepAutomationConfigurationDecoded
        let stepTargetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTarget)
        var stepTargetDecoded0:[Swift.String]? = nil
        if let stepTargetContainer = stepTargetContainer {
            stepTargetDecoded0 = [Swift.String]()
            for string0 in stepTargetContainer {
                if let string0 = string0 {
                    stepTargetDecoded0?.append(string0)
                }
            }
        }
        stepTarget = stepTargetDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let scriptOutputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptOutputLocation)
        scriptOutputLocation = scriptOutputLocationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let noOfSrvCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvCompleted)
        noOfSrvCompleted = noOfSrvCompletedDecoded
        let noOfSrvFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvFailed)
        noOfSrvFailed = noOfSrvFailedDecoded
        let totalNoOfSrvDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNoOfSrv)
        totalNoOfSrv = totalNoOfSrvDecoded
    }
}

enum GetWorkflowStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPluginsInput {

    static func queryItemProvider(_ value: ListPluginsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListPluginsInput {

    static func urlPathProvider(_ value: ListPluginsInput) -> Swift.String? {
        return "/plugins"
    }
}

public struct ListPluginsInput: Swift.Equatable {
    /// The maximum number of plugins that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPluginsInputBody: Swift.Equatable {
}

extension ListPluginsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPluginsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPluginsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.plugins = output.plugins
        } else {
            self.nextToken = nil
            self.plugins = nil
        }
    }
}

public struct ListPluginsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Migration Hub Orchestrator plugins.
    public var plugins: [MigrationHubOrchestratorClientTypes.PluginSummary]?

    public init(
        nextToken: Swift.String? = nil,
        plugins: [MigrationHubOrchestratorClientTypes.PluginSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.plugins = plugins
    }
}

struct ListPluginsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let plugins: [MigrationHubOrchestratorClientTypes.PluginSummary]?
}

extension ListPluginsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case plugins
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pluginsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.PluginSummary?].self, forKey: .plugins)
        var pluginsDecoded0:[MigrationHubOrchestratorClientTypes.PluginSummary]? = nil
        if let pluginsContainer = pluginsContainer {
            pluginsDecoded0 = [MigrationHubOrchestratorClientTypes.PluginSummary]()
            for structure0 in pluginsContainer {
                if let structure0 = structure0 {
                    pluginsDecoded0?.append(structure0)
                }
            }
        }
        plugins = pluginsDecoded0
    }
}

enum ListPluginsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags added to a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTemplateStepGroupsInput {

    static func queryItemProvider(_ value: ListTemplateStepGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTemplateStepGroupsInput {

    static func urlPathProvider(_ value: ListTemplateStepGroupsInput) -> Swift.String? {
        guard let templateId = value.templateId else {
            return nil
        }
        return "/templatestepgroups/\(templateId.urlPercentEncoding())"
    }
}

public struct ListTemplateStepGroupsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateStepGroupsInputBody: Swift.Equatable {
}

extension ListTemplateStepGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateStepGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTemplateStepGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateStepGroupSummary = output.templateStepGroupSummary
        } else {
            self.nextToken = nil
            self.templateStepGroupSummary = nil
        }
    }
}

public struct ListTemplateStepGroupsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of the step group in the template.
    /// This member is required.
    public var templateStepGroupSummary: [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateStepGroupSummary: [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateStepGroupSummary = templateStepGroupSummary
    }
}

struct ListTemplateStepGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateStepGroupSummary: [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]?
}

extension ListTemplateStepGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateStepGroupSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateStepGroupSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary?].self, forKey: .templateStepGroupSummary)
        var templateStepGroupSummaryDecoded0:[MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]? = nil
        if let templateStepGroupSummaryContainer = templateStepGroupSummaryContainer {
            templateStepGroupSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]()
            for structure0 in templateStepGroupSummaryContainer {
                if let structure0 = structure0 {
                    templateStepGroupSummaryDecoded0?.append(structure0)
                }
            }
        }
        templateStepGroupSummary = templateStepGroupSummaryDecoded0
    }
}

enum ListTemplateStepGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTemplateStepsInput {

    static func queryItemProvider(_ value: ListTemplateStepsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let stepGroupId = value.stepGroupId else {
            let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let stepGroupIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
        items.append(stepGroupIdQueryItem)
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let templateId = value.templateId else {
            let message = "Creating a URL Query Item failed. templateId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let templateIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "templateId".urlPercentEncoding(), value: Swift.String(templateId).urlPercentEncoding())
        items.append(templateIdQueryItem)
        return items
    }
}

extension ListTemplateStepsInput {

    static func urlPathProvider(_ value: ListTemplateStepsInput) -> Swift.String? {
        return "/templatesteps"
    }
}

public struct ListTemplateStepsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stepGroupId = stepGroupId
        self.templateId = templateId
    }
}

struct ListTemplateStepsInputBody: Swift.Equatable {
}

extension ListTemplateStepsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateStepsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTemplateStepsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateStepSummaryList = output.templateStepSummaryList
        } else {
            self.nextToken = nil
            self.templateStepSummaryList = nil
        }
    }
}

public struct ListTemplateStepsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The list of summaries of steps in a template.
    public var templateStepSummaryList: [MigrationHubOrchestratorClientTypes.TemplateStepSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateStepSummaryList: [MigrationHubOrchestratorClientTypes.TemplateStepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateStepSummaryList = templateStepSummaryList
    }
}

struct ListTemplateStepsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateStepSummaryList: [MigrationHubOrchestratorClientTypes.TemplateStepSummary]?
}

extension ListTemplateStepsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateStepSummaryList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateStepSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateStepSummary?].self, forKey: .templateStepSummaryList)
        var templateStepSummaryListDecoded0:[MigrationHubOrchestratorClientTypes.TemplateStepSummary]? = nil
        if let templateStepSummaryListContainer = templateStepSummaryListContainer {
            templateStepSummaryListDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateStepSummary]()
            for structure0 in templateStepSummaryListContainer {
                if let structure0 = structure0 {
                    templateStepSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateStepSummaryList = templateStepSummaryListDecoded0
    }
}

enum ListTemplateStepsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTemplatesInput {

    static func queryItemProvider(_ value: ListTemplatesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListTemplatesInput {

    static func urlPathProvider(_ value: ListTemplatesInput) -> Swift.String? {
        return "/migrationworkflowtemplates"
    }
}

public struct ListTemplatesInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The name of the template.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListTemplatesInputBody: Swift.Equatable {
}

extension ListTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateSummary = output.templateSummary
        } else {
            self.nextToken = nil
            self.templateSummary = nil
        }
    }
}

public struct ListTemplatesOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of the template.
    /// This member is required.
    public var templateSummary: [MigrationHubOrchestratorClientTypes.TemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateSummary: [MigrationHubOrchestratorClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummary = templateSummary
    }
}

struct ListTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateSummary: [MigrationHubOrchestratorClientTypes.TemplateSummary]?
}

extension ListTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateSummary?].self, forKey: .templateSummary)
        var templateSummaryDecoded0:[MigrationHubOrchestratorClientTypes.TemplateSummary]? = nil
        if let templateSummaryContainer = templateSummaryContainer {
            templateSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateSummary]()
            for structure0 in templateSummaryContainer {
                if let structure0 = structure0 {
                    templateSummaryDecoded0?.append(structure0)
                }
            }
        }
        templateSummary = templateSummaryDecoded0
    }
}

enum ListTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowStepGroupsInput {

    static func queryItemProvider(_ value: ListWorkflowStepGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension ListWorkflowStepGroupsInput {

    static func urlPathProvider(_ value: ListWorkflowStepGroupsInput) -> Swift.String? {
        return "/workflowstepgroups"
    }
}

public struct ListWorkflowStepGroupsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListWorkflowStepGroupsInputBody: Swift.Equatable {
}

extension ListWorkflowStepGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowStepGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowStepGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowStepGroupsSummary = output.workflowStepGroupsSummary
        } else {
            self.nextToken = nil
            self.workflowStepGroupsSummary = nil
        }
    }
}

public struct ListWorkflowStepGroupsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of step groups in a migration workflow.
    /// This member is required.
    public var workflowStepGroupsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowStepGroupsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowStepGroupsSummary = workflowStepGroupsSummary
    }
}

struct ListWorkflowStepGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowStepGroupsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]?
}

extension ListWorkflowStepGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowStepGroupsSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowStepGroupsSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary?].self, forKey: .workflowStepGroupsSummary)
        var workflowStepGroupsSummaryDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]? = nil
        if let workflowStepGroupsSummaryContainer = workflowStepGroupsSummaryContainer {
            workflowStepGroupsSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]()
            for structure0 in workflowStepGroupsSummaryContainer {
                if let structure0 = structure0 {
                    workflowStepGroupsSummaryDecoded0?.append(structure0)
                }
            }
        }
        workflowStepGroupsSummary = workflowStepGroupsSummaryDecoded0
    }
}

enum ListWorkflowStepGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowStepsInput {

    static func queryItemProvider(_ value: ListWorkflowStepsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkflowStepsInput {

    static func urlPathProvider(_ value: ListWorkflowStepsInput) -> Swift.String? {
        guard let workflowId = value.workflowId else {
            return nil
        }
        guard let stepGroupId = value.stepGroupId else {
            return nil
        }
        return "/workflow/\(workflowId.urlPercentEncoding())/workflowstepgroups/\(stepGroupId.urlPercentEncoding())/workflowsteps"
    }
}

public struct ListWorkflowStepsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct ListWorkflowStepsInputBody: Swift.Equatable {
}

extension ListWorkflowStepsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowStepsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowStepsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowStepsSummary = output.workflowStepsSummary
        } else {
            self.nextToken = nil
            self.workflowStepsSummary = nil
        }
    }
}

public struct ListWorkflowStepsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of steps in a migration workflow.
    /// This member is required.
    public var workflowStepsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowStepsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowStepsSummary = workflowStepsSummary
    }
}

struct ListWorkflowStepsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowStepsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]?
}

extension ListWorkflowStepsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowStepsSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowStepsSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepSummary?].self, forKey: .workflowStepsSummary)
        var workflowStepsSummaryDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepSummary]? = nil
        if let workflowStepsSummaryContainer = workflowStepsSummaryContainer {
            workflowStepsSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]()
            for structure0 in workflowStepsSummaryContainer {
                if let structure0 = structure0 {
                    workflowStepsSummaryDecoded0?.append(structure0)
                }
            }
        }
        workflowStepsSummary = workflowStepsSummaryDecoded0
    }
}

enum ListWorkflowStepsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowsInput {

    static func queryItemProvider(_ value: ListWorkflowsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let adsApplicationConfigurationName = value.adsApplicationConfigurationName {
            let adsApplicationConfigurationNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "adsApplicationConfigurationName".urlPercentEncoding(), value: Swift.String(adsApplicationConfigurationName).urlPercentEncoding())
            items.append(adsApplicationConfigurationNameQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let templateId = value.templateId {
            let templateIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "templateId".urlPercentEncoding(), value: Swift.String(templateId).urlPercentEncoding())
            items.append(templateIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/migrationworkflows"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// The name of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationName: Swift.String?
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The ID of the template.
    public var templateId: Swift.String?

    public init(
        adsApplicationConfigurationName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.adsApplicationConfigurationName = adsApplicationConfigurationName
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.status = status
        self.templateId = templateId
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
}

extension ListWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationWorkflowSummary = output.migrationWorkflowSummary
            self.nextToken = output.nextToken
        } else {
            self.migrationWorkflowSummary = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowsOutput: Swift.Equatable {
    /// The summary of the migration workflow.
    /// This member is required.
    public var migrationWorkflowSummary: [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        migrationWorkflowSummary: [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.migrationWorkflowSummary = migrationWorkflowSummary
        self.nextToken = nextToken
    }
}

struct ListWorkflowsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let migrationWorkflowSummary: [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]?
}

extension ListWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationWorkflowSummary
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let migrationWorkflowSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary?].self, forKey: .migrationWorkflowSummary)
        var migrationWorkflowSummaryDecoded0:[MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]? = nil
        if let migrationWorkflowSummaryContainer = migrationWorkflowSummaryContainer {
            migrationWorkflowSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]()
            for structure0 in migrationWorkflowSummaryContainer {
                if let structure0 = structure0 {
                    migrationWorkflowSummaryDecoded0?.append(structure0)
                }
            }
        }
        migrationWorkflowSummary = migrationWorkflowSummaryDecoded0
    }
}

enum ListWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum MigrationHubOrchestratorClientTypes {}

extension MigrationHubOrchestratorClientTypes {
    public enum MigrationWorkflowStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case creationFailed
        case deleted
        case deleting
        case deletionFailed
        case inProgress
        case notStarted
        case paused
        case pausing
        case pausingFailed
        case starting
        case userAttentionRequired
        case workflowFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [MigrationWorkflowStatusEnum] {
            return [
                .completed,
                .creating,
                .creationFailed,
                .deleted,
                .deleting,
                .deletionFailed,
                .inProgress,
                .notStarted,
                .paused,
                .pausing,
                .pausingFailed,
                .starting,
                .userAttentionRequired,
                .workflowFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .paused: return "PAUSED"
            case .pausing: return "PAUSING"
            case .pausingFailed: return "PAUSING_FAILED"
            case .starting: return "STARTING"
            case .userAttentionRequired: return "USER_ATTENTION_REQUIRED"
            case .workflowFailed: return "WORKFLOW_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MigrationWorkflowStatusEnum(rawValue: rawValue) ?? MigrationWorkflowStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationName
        case completedSteps
        case creationTime
        case endTime
        case id
        case name
        case status
        case statusMessage
        case templateId
        case totalSteps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adsApplicationConfigurationName = self.adsApplicationConfigurationName {
            try encodeContainer.encode(adsApplicationConfigurationName, forKey: .adsApplicationConfigurationName)
        }
        if let completedSteps = self.completedSteps {
            try encodeContainer.encode(completedSteps, forKey: .completedSteps)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
        if let totalSteps = self.totalSteps {
            try encodeContainer.encode(totalSteps, forKey: .totalSteps)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationName)
        adsApplicationConfigurationName = adsApplicationConfigurationNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let completedStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completedSteps)
        completedSteps = completedStepsDecoded
        let totalStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of a migration workflow.
    public struct MigrationWorkflowSummary: Swift.Equatable {
        /// The name of the application configured in Application Discovery Service.
        public var adsApplicationConfigurationName: Swift.String?
        /// The steps completed in the migration workflow.
        public var completedSteps: Swift.Int?
        /// The time at which the migration workflow was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the migration workflow ended.
        public var endTime: ClientRuntime.Date?
        /// The ID of the migration workflow.
        public var id: Swift.String?
        /// The name of the migration workflow.
        public var name: Swift.String?
        /// The status of the migration workflow.
        public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
        /// The status message of the migration workflow.
        public var statusMessage: Swift.String?
        /// The ID of the template.
        public var templateId: Swift.String?
        /// All the steps in a migration workflow.
        public var totalSteps: Swift.Int?

        public init(
            adsApplicationConfigurationName: Swift.String? = nil,
            completedSteps: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
            statusMessage: Swift.String? = nil,
            templateId: Swift.String? = nil,
            totalSteps: Swift.Int? = nil
        )
        {
            self.adsApplicationConfigurationName = adsApplicationConfigurationName
            self.completedSteps = completedSteps
            self.creationTime = creationTime
            self.endTime = endTime
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.templateId = templateId
            self.totalSteps = totalSteps
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum Owner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsmanaged
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [Owner] {
            return [
                .awsmanaged,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsmanaged: return "AWS_MANAGED"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Owner(rawValue: rawValue) ?? Owner.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.PlatformCommand: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linux
        case windows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linux = self.linux {
            try encodeContainer.encode(linux, forKey: .linux)
        }
        if let windows = self.windows {
            try encodeContainer.encode(windows, forKey: .windows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linux)
        linux = linuxDecoded
        let windowsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windows)
        windows = windowsDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// Command to be run on a particular operating system.
    public struct PlatformCommand: Swift.Equatable {
        /// Command for Linux.
        public var linux: Swift.String?
        /// Command for Windows.
        public var windows: Swift.String?

        public init(
            linux: Swift.String? = nil,
            windows: Swift.String? = nil
        )
        {
            self.linux = linux
            self.windows = windows
        }
    }

}

extension MigrationHubOrchestratorClientTypes.PlatformScriptKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linux
        case windows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linux = self.linux {
            try encodeContainer.encode(linux, forKey: .linux)
        }
        if let windows = self.windows {
            try encodeContainer.encode(windows, forKey: .windows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linux)
        linux = linuxDecoded
        let windowsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windows)
        windows = windowsDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The script location for a particular operating system.
    public struct PlatformScriptKey: Swift.Equatable {
        /// The script location for Linux.
        public var linux: Swift.String?
        /// The script location for Windows.
        public var windows: Swift.String?

        public init(
            linux: Swift.String? = nil,
            windows: Swift.String? = nil
        )
        {
            self.linux = linux
            self.windows = windows
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum PluginHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pluginHealthy
        case pluginUnhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginHealth] {
            return [
                .pluginHealthy,
                .pluginUnhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pluginHealthy: return "HEALTHY"
            case .pluginUnhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PluginHealth(rawValue: rawValue) ?? PluginHealth.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.PluginSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case ipAddress
        case pluginId
        case registeredTime
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let pluginId = self.pluginId {
            try encodeContainer.encode(pluginId, forKey: .pluginId)
        }
        if let registeredTime = self.registeredTime {
            try encodeContainer.encode(registeredTime, forKey: .registeredTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PluginHealth.self, forKey: .status)
        status = statusDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let registeredTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the Migration Hub Orchestrator plugin.
    public struct PluginSummary: Swift.Equatable {
        /// The name of the host.
        public var hostname: Swift.String?
        /// The IP address at which the plugin is located.
        public var ipAddress: Swift.String?
        /// The ID of the plugin.
        public var pluginId: Swift.String?
        /// The time at which the plugin was registered.
        public var registeredTime: Swift.String?
        /// The status of the plugin.
        public var status: MigrationHubOrchestratorClientTypes.PluginHealth?
        /// The version of the plugin.
        public var version: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            registeredTime: Swift.String? = nil,
            status: MigrationHubOrchestratorClientTypes.PluginHealth? = nil,
            version: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.ipAddress = ipAddress
            self.pluginId = pluginId
            self.registeredTime = registeredTime
            self.status = status
            self.version = version
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is not available.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryWorkflowStepInput {

    static func queryItemProvider(_ value: RetryWorkflowStepInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let stepGroupId = value.stepGroupId else {
            let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let stepGroupIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
        items.append(stepGroupIdQueryItem)
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension RetryWorkflowStepInput {

    static func urlPathProvider(_ value: RetryWorkflowStepInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/retryworkflowstep/\(id.urlPercentEncoding())"
    }
}

public struct RetryWorkflowStepInput: Swift.Equatable {
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct RetryWorkflowStepInputBody: Swift.Equatable {
}

extension RetryWorkflowStepInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RetryWorkflowStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetryWorkflowStepOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.status = output.status
            self.stepGroupId = output.stepGroupId
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.status = nil
            self.stepGroupId = nil
            self.workflowId = nil
        }
    }
}

public struct RetryWorkflowStepOutput: Swift.Equatable {
    /// The ID of the step.
    public var id: Swift.String?
    /// The status of the step.
    public var status: MigrationHubOrchestratorClientTypes.StepStatus?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.status = status
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct RetryWorkflowStepOutputBody: Swift.Equatable {
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let id: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.StepStatus?
}

extension RetryWorkflowStepOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case status
        case stepGroupId
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum RetryWorkflowStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum RunEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case onpremise
        case sdkUnknown(Swift.String)

        public static var allCases: [RunEnvironment] {
            return [
                .aws,
                .onpremise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .onpremise: return "ONPREMISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunEnvironment(rawValue: rawValue) ?? RunEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension StartWorkflowInput {

    static func urlPathProvider(_ value: StartWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())/start"
    }
}

public struct StartWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartWorkflowInputBody: Swift.Equatable {
}

extension StartWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.lastStartTime = output.lastStartTime
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.arn = nil
            self.id = nil
            self.lastStartTime = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct StartWorkflowOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was last started.
    public var lastStartTime: ClientRuntime.Date?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lastStartTime = lastStartTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct StartWorkflowOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let statusMessage: Swift.String?
    let lastStartTime: ClientRuntime.Date?
}

extension StartWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case lastStartTime
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
    }
}

enum StartWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum StepActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automated
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [StepActionType] {
            return [
                .automated,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automated: return "AUTOMATED"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepActionType(rawValue: rawValue) ?? StepActionType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.StepAutomationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case runEnvironment
        case scriptLocationS3Bucket
        case scriptLocationS3Key
        case targetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let runEnvironment = self.runEnvironment {
            try encodeContainer.encode(runEnvironment.rawValue, forKey: .runEnvironment)
        }
        if let scriptLocationS3Bucket = self.scriptLocationS3Bucket {
            try encodeContainer.encode(scriptLocationS3Bucket, forKey: .scriptLocationS3Bucket)
        }
        if let scriptLocationS3Key = self.scriptLocationS3Key {
            try encodeContainer.encode(scriptLocationS3Key, forKey: .scriptLocationS3Key)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptLocationS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptLocationS3Bucket)
        scriptLocationS3Bucket = scriptLocationS3BucketDecoded
        let scriptLocationS3KeyDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformScriptKey.self, forKey: .scriptLocationS3Key)
        scriptLocationS3Key = scriptLocationS3KeyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformCommand.self, forKey: .command)
        command = commandDecoded
        let runEnvironmentDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.RunEnvironment.self, forKey: .runEnvironment)
        runEnvironment = runEnvironmentDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The custom script to run tests on source or target environments.
    public struct StepAutomationConfiguration: Swift.Equatable {
        /// The command to run the script.
        public var command: MigrationHubOrchestratorClientTypes.PlatformCommand?
        /// The source or target environment.
        public var runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment?
        /// The Amazon S3 bucket where the script is located.
        public var scriptLocationS3Bucket: Swift.String?
        /// The Amazon S3 key for the script location.
        public var scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey?
        /// The servers on which to run the script.
        public var targetType: MigrationHubOrchestratorClientTypes.TargetType?

        public init(
            command: MigrationHubOrchestratorClientTypes.PlatformCommand? = nil,
            runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment? = nil,
            scriptLocationS3Bucket: Swift.String? = nil,
            scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey? = nil,
            targetType: MigrationHubOrchestratorClientTypes.TargetType? = nil
        )
        {
            self.command = command
            self.runEnvironment = runEnvironment
            self.scriptLocationS3Bucket = scriptLocationS3Bucket
            self.scriptLocationS3Key = scriptLocationS3Key
            self.targetType = targetType
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum StepGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingDependencies
        case completed
        case failed
        case inProgress
        case paused
        case pausing
        case ready
        case userAttentionRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [StepGroupStatus] {
            return [
                .awaitingDependencies,
                .completed,
                .failed,
                .inProgress,
                .paused,
                .pausing,
                .ready,
                .userAttentionRequired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingDependencies: return "AWAITING_DEPENDENCIES"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .paused: return "PAUSED"
            case .pausing: return "PAUSING"
            case .ready: return "READY"
            case .userAttentionRequired: return "USER_ATTENTION_REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepGroupStatus(rawValue: rawValue) ?? StepGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.StepInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integervalue = "integerValue"
        case listofstringsvalue = "listOfStringsValue"
        case mapofstringvalue = "mapOfStringValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .integervalue(integervalue):
                try container.encode(integervalue, forKey: .integervalue)
            case let .listofstringsvalue(listofstringsvalue):
                var listofstringsvalueContainer = container.nestedUnkeyedContainer(forKey: .listofstringsvalue)
                for stringlistmember0 in listofstringsvalue {
                    try listofstringsvalueContainer.encode(stringlistmember0)
                }
            case let .mapofstringvalue(mapofstringvalue):
                var mapofstringvalueContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mapofstringvalue)
                for (dictKey0, stringMap0) in mapofstringvalue {
                    try mapofstringvalueContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
                }
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let integervalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .integervalue)
        if let integervalue = integervalueDecoded {
            self = .integervalue(integervalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let listofstringsvalueContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .listofstringsvalue)
        var listofstringsvalueDecoded0:[Swift.String]? = nil
        if let listofstringsvalueContainer = listofstringsvalueContainer {
            listofstringsvalueDecoded0 = [Swift.String]()
            for string0 in listofstringsvalueContainer {
                if let string0 = string0 {
                    listofstringsvalueDecoded0?.append(string0)
                }
            }
        }
        if let listofstringsvalue = listofstringsvalueDecoded0 {
            self = .listofstringsvalue(listofstringsvalue)
            return
        }
        let mapofstringvalueContainer = try values.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .mapofstringvalue)
        var mapofstringvalueDecoded0: [Swift.String:Swift.String]? = nil
        if let mapofstringvalueContainer = mapofstringvalueContainer {
            mapofstringvalueDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in mapofstringvalueContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    mapofstringvalueDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        if let mapofstringvalue = mapofstringvalueDecoded0 {
            self = .mapofstringvalue(mapofstringvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// A map of key value pairs that is generated when you create a migration workflow. The key value pairs will differ based on your selection of the template.
    public enum StepInput: Swift.Equatable {
        /// The value of the integer.
        case integervalue(Swift.Int)
        /// String value.
        case stringvalue(Swift.String)
        /// List of string values.
        case listofstringsvalue([Swift.String])
        /// Map of string values.
        case mapofstringvalue([Swift.String:Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubOrchestratorClientTypes.StepOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case name
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The output of the step.
    public struct StepOutput: Swift.Equatable {
        /// The data type of the step output.
        public var dataType: MigrationHubOrchestratorClientTypes.DataType?
        /// The name of the step.
        public var name: Swift.String?
        /// Determine if an output is required from a step.
        public var `required`: Swift.Bool?

        public init(
            dataType: MigrationHubOrchestratorClientTypes.DataType? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.dataType = dataType
            self.name = name
            self.`required` = `required`
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum StepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingDependencies
        case completed
        case failed
        case inProgress
        case paused
        case ready
        case skipped
        case userAttentionRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [StepStatus] {
            return [
                .awaitingDependencies,
                .completed,
                .failed,
                .inProgress,
                .paused,
                .ready,
                .skipped,
                .userAttentionRequired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingDependencies: return "AWAITING_DEPENDENCIES"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .paused: return "PAUSED"
            case .ready: return "READY"
            case .skipped: return "SKIPPED"
            case .userAttentionRequired: return "USER_ATTENTION_REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepStatus(rawValue: rawValue) ?? StepStatus.sdkUnknown(rawValue)
        }
    }
}

extension StopWorkflowInput {

    static func urlPathProvider(_ value: StopWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())/stop"
    }
}

public struct StopWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopWorkflowInputBody: Swift.Equatable {
}

extension StopWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.lastStopTime = output.lastStopTime
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.arn = nil
            self.id = nil
            self.lastStopTime = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct StopWorkflowOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was stopped.
    public var lastStopTime: ClientRuntime.Date?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastStopTime: ClientRuntime.Date? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lastStopTime = lastStopTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct StopWorkflowOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let statusMessage: Swift.String?
    let lastStopTime: ClientRuntime.Date?
}

extension StopWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case lastStopTime
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastStopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStopTime)
        lastStopTime = lastStopTimeDecoded
    }
}

enum StopWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case single
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .all,
                .none,
                .single,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case .single: return "SINGLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.TemplateInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case inputName
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The input parameters of a template.
    public struct TemplateInput: Swift.Equatable {
        /// The data type of the template input.
        public var dataType: MigrationHubOrchestratorClientTypes.DataType?
        /// The name of the template.
        public var inputName: Swift.String?
        /// Determine if an input is required from the template.
        public var `required`: Swift.Bool?

        public init(
            dataType: MigrationHubOrchestratorClientTypes.DataType? = nil,
            inputName: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.dataType = dataType
            self.inputName = inputName
            self.`required` = `required`
        }
    }

}

extension MigrationHubOrchestratorClientTypes.TemplateSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case workflowid = "workflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .workflowid(workflowid):
                try container.encode(workflowid, forKey: .workflowid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let workflowidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .workflowid)
        if let workflowid = workflowidDecoded {
            self = .workflowid(workflowid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The migration workflow template used as the source for the new template.
    public enum TemplateSource: Swift.Equatable {
        /// The ID of the workflow from the source migration workflow template.
        case workflowid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum TemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case creationFailed
        case pendingCreation
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateStatus] {
            return [
                .created,
                .creating,
                .creationFailed,
                .pendingCreation,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .pendingCreation: return "PENDING_CREATION"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateStatus(rawValue: rawValue) ?? TemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case next
        case previous
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the step group in the template.
    public struct TemplateStepGroupSummary: Swift.Equatable {
        /// The ID of the step group.
        public var id: Swift.String?
        /// The name of the step group.
        public var name: Swift.String?
        /// The next step group.
        public var next: [Swift.String]?
        /// The previous step group.
        public var previous: [Swift.String]?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            previous: [Swift.String]? = nil
        )
        {
            self.id = id
            self.name = name
            self.next = next
            self.previous = previous
        }
    }

}

extension MigrationHubOrchestratorClientTypes.TemplateStepSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case next
        case owner
        case previous
        case stepActionType
        case stepGroupId
        case targetType
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepGroupId = self.stepGroupId {
            try encodeContainer.encode(stepGroupId, forKey: .stepGroupId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the step.
    public struct TemplateStepSummary: Swift.Equatable {
        /// The ID of the step.
        public var id: Swift.String?
        /// The name of the step.
        public var name: Swift.String?
        /// The next step.
        public var next: [Swift.String]?
        /// The owner of the step.
        public var owner: MigrationHubOrchestratorClientTypes.Owner?
        /// The previous step.
        public var previous: [Swift.String]?
        /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
        public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
        /// The ID of the step group.
        public var stepGroupId: Swift.String?
        /// The servers on which to run the script.
        public var targetType: MigrationHubOrchestratorClientTypes.TargetType?
        /// The ID of the template.
        public var templateId: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
            previous: [Swift.String]? = nil,
            stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
            stepGroupId: Swift.String? = nil,
            targetType: MigrationHubOrchestratorClientTypes.TargetType? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.next = next
            self.owner = owner
            self.previous = previous
            self.stepActionType = stepActionType
            self.stepGroupId = stepGroupId
            self.targetType = targetType
            self.templateId = templateId
        }
    }

}

extension MigrationHubOrchestratorClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the template.
    public struct TemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// The description of the template.
        public var description: Swift.String?
        /// The ID of the template.
        public var id: Swift.String?
        /// The name of the template.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubOrchestratorClientTypes.Tool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// List of AWS services utilized in a migration workflow.
    public struct Tool: Swift.Equatable {
        /// The name of an AWS service.
        public var name: Swift.String?
        /// The URL of an AWS service.
        public var url: Swift.String?

        public init(
            name: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag keys. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case templateDescription
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let templateDescription = self.templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension UpdateTemplateInput {

    static func urlPathProvider(_ value: UpdateTemplateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/template/\(id.urlPercentEncoding())"
    }
}

public struct UpdateTemplateInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the request to update a migration workflow template.
    /// This member is required.
    public var id: Swift.String?
    /// The description of the migration workflow template to update.
    public var templateDescription: Swift.String?
    /// The name of the migration workflow template to update.
    public var templateName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        templateDescription: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
        self.templateDescription = templateDescription
        self.templateName = templateName
    }
}

struct UpdateTemplateInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateDescription: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case templateDescription
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.tags = nil
            self.templateArn = nil
            self.templateId = nil
        }
    }
}

public struct UpdateTemplateOutput: Swift.Equatable {
    /// The tags added to the migration workflow template.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the migration workflow template being updated. The format for an Migration Hub Orchestrator template ARN is arn:aws:migrationhub-orchestrator:region:account:template/template-abcd1234. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) in the AWS General Reference.
    public var templateArn: Swift.String?
    /// The ID of the migration workflow template being updated.
    public var templateId: Swift.String?

    public init(
        tags: [Swift.String:Swift.String]? = nil,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.tags = tags
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct UpdateTemplateOutputBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case templateArn
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkflowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkflowInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), stepTargets: \(Swift.String(describing: stepTargets)), inputParameters: \"CONTENT_REDACTED\")"}
}

extension UpdateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case inputParameters
        case name
        case stepTargets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            var inputParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputParameters)
            for (dictKey0, stepInputParameters0) in inputParameters {
                try inputParametersContainer.encode(stepInputParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stepTargets = stepTargets {
            var stepTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTargets)
            for stringlistmember0 in stepTargets {
                try stepTargetsContainer.encode(stringlistmember0)
            }
        }
    }
}

extension UpdateWorkflowInput {

    static func urlPathProvider(_ value: UpdateWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowInput: Swift.Equatable {
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?
    /// The input parameters required to update a migration workflow.
    public var inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil,
        name: Swift.String? = nil,
        stepTargets: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.inputParameters = inputParameters
        self.name = name
        self.stepTargets = stepTargets
    }
}

struct UpdateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
}

extension UpdateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case inputParameters
        case name
        case stepTargets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputParametersContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .inputParameters)
        var inputParametersDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let inputParametersContainer = inputParametersContainer {
            inputParametersDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in inputParametersContainer {
                if let stepinput0 = stepinput0 {
                    inputParametersDecoded0?[key0] = stepinput0
                }
            }
        }
        inputParameters = inputParametersDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
    }
}

extension UpdateWorkflowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkflowOutput(adsApplicationConfigurationId: \(Swift.String(describing: adsApplicationConfigurationId)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), stepTargets: \(Swift.String(describing: stepTargets)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), workflowInputs: \"CONTENT_REDACTED\")"}
}

extension UpdateWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.adsApplicationConfigurationId = output.adsApplicationConfigurationId
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.status = output.status
            self.stepTargets = output.stepTargets
            self.tags = output.tags
            self.templateId = output.templateId
            self.workflowInputs = output.workflowInputs
        } else {
            self.adsApplicationConfigurationId = nil
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.status = nil
            self.stepTargets = nil
            self.tags = nil
            self.templateId = nil
            self.workflowInputs = nil
        }
    }
}

public struct UpdateWorkflowOutput: Swift.Equatable {
    /// The ID of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The time at which the migration workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?
    /// The tags added to the migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The inputs required to update a migration workflow.
    public var workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?

    public init(
        adsApplicationConfigurationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        stepTargets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil,
        workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
    )
    {
        self.adsApplicationConfigurationId = adsApplicationConfigurationId
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
        self.stepTargets = stepTargets
        self.tags = tags
        self.templateId = templateId
        self.workflowInputs = workflowInputs
    }
}

struct UpdateWorkflowOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let adsApplicationConfigurationId: Swift.String?
    let workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationId
        case arn
        case creationTime
        case description
        case id
        case lastModifiedTime
        case name
        case status
        case stepTargets
        case tags
        case templateId
        case workflowInputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationId)
        adsApplicationConfigurationId = adsApplicationConfigurationIdDecoded
        let workflowInputsContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .workflowInputs)
        var workflowInputsDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let workflowInputsContainer = workflowInputsContainer {
            workflowInputsDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in workflowInputsContainer {
                if let stepinput0 = stepinput0 {
                    workflowInputsDecoded0?[key0] = stepinput0
                }
            }
        }
        workflowInputs = workflowInputsDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkflowStepGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
    }
}

extension UpdateWorkflowStepGroupInput {

    static func queryItemProvider(_ value: UpdateWorkflowStepGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let workflowId = value.workflowId else {
            let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let workflowIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
        items.append(workflowIdQueryItem)
        return items
    }
}

extension UpdateWorkflowStepGroupInput {

    static func urlPathProvider(_ value: UpdateWorkflowStepGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflowstepgroup/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowStepGroupInput: Swift.Equatable {
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.previous = previous
        self.workflowId = workflowId
    }
}

struct UpdateWorkflowStepGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let next: [Swift.String]?
    let previous: [Swift.String]?
}

extension UpdateWorkflowStepGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
    }
}

extension UpdateWorkflowStepGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkflowStepGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.next = output.next
            self.previous = output.previous
            self.tools = output.tools
            self.workflowId = output.workflowId
        } else {
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.next = nil
            self.previous = nil
            self.tools = nil
            self.workflowId = nil
        }
    }
}

public struct UpdateWorkflowStepGroupOutput: Swift.Equatable {
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The time at which the step group was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.next = next
        self.previous = previous
        self.tools = tools
        self.workflowId = workflowId
    }
}

struct UpdateWorkflowStepGroupOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let next: [Swift.String]?
    let previous: [Swift.String]?
    let lastModifiedTime: ClientRuntime.Date?
}

extension UpdateWorkflowStepGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case lastModifiedTime
        case name
        case next
        case previous
        case tools
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

enum UpdateWorkflowStepGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkflowStepInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case status
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for workflowstepoutput0 in outputs {
                try outputsContainer.encode(workflowstepoutput0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepGroupId = self.stepGroupId {
            try encodeContainer.encode(stepGroupId, forKey: .stepGroupId)
        }
        if let stepTarget = stepTarget {
            var stepTargetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTarget)
            for stringlistmember0 in stepTarget {
                try stepTargetContainer.encode(stringlistmember0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowStepAutomationConfiguration = self.workflowStepAutomationConfiguration {
            try encodeContainer.encode(workflowStepAutomationConfiguration, forKey: .workflowStepAutomationConfiguration)
        }
    }
}

extension UpdateWorkflowStepInput {

    static func urlPathProvider(_ value: UpdateWorkflowStepInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflowstep/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowStepInput: Swift.Equatable {
    /// The description of the step.
    public var description: Swift.String?
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The outputs of a step.
    public var outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The status of the step.
    public var status: MigrationHubOrchestratorClientTypes.StepStatus?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The servers on which a step will be run.
    public var stepTarget: [Swift.String]?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?
    /// The custom script to run tests on the source and target environments.
    public var workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil,
        previous: [Swift.String]? = nil,
        status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepGroupId: Swift.String? = nil,
        stepTarget: [Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.outputs = outputs
        self.previous = previous
        self.status = status
        self.stepActionType = stepActionType
        self.stepGroupId = stepGroupId
        self.stepTarget = stepTarget
        self.workflowId = workflowId
        self.workflowStepAutomationConfiguration = workflowStepAutomationConfiguration
    }
}

struct UpdateWorkflowStepInputBody: Swift.Equatable {
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?
    let stepTarget: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.StepStatus?
}

extension UpdateWorkflowStepInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case status
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let workflowStepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration.self, forKey: .workflowStepAutomationConfiguration)
        workflowStepAutomationConfiguration = workflowStepAutomationConfigurationDecoded
        let stepTargetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTarget)
        var stepTargetDecoded0:[Swift.String]? = nil
        if let stepTargetContainer = stepTargetContainer {
            stepTargetDecoded0 = [Swift.String]()
            for string0 in stepTargetContainer {
                if let string0 = string0 {
                    stepTargetDecoded0?.append(string0)
                }
            }
        }
        stepTarget = stepTargetDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateWorkflowStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkflowStepOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.stepGroupId = output.stepGroupId
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.name = nil
            self.stepGroupId = nil
            self.workflowId = nil
        }
    }
}

public struct UpdateWorkflowStepOutput: Swift.Equatable {
    /// The ID of the step.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct UpdateWorkflowStepOutputBody: Swift.Equatable {
    let id: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
}

extension UpdateWorkflowStepOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case stepGroupId
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateWorkflowStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case runEnvironment
        case scriptLocationS3Bucket
        case scriptLocationS3Key
        case targetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let runEnvironment = self.runEnvironment {
            try encodeContainer.encode(runEnvironment.rawValue, forKey: .runEnvironment)
        }
        if let scriptLocationS3Bucket = self.scriptLocationS3Bucket {
            try encodeContainer.encode(scriptLocationS3Bucket, forKey: .scriptLocationS3Bucket)
        }
        if let scriptLocationS3Key = self.scriptLocationS3Key {
            try encodeContainer.encode(scriptLocationS3Key, forKey: .scriptLocationS3Key)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptLocationS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptLocationS3Bucket)
        scriptLocationS3Bucket = scriptLocationS3BucketDecoded
        let scriptLocationS3KeyDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformScriptKey.self, forKey: .scriptLocationS3Key)
        scriptLocationS3Key = scriptLocationS3KeyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformCommand.self, forKey: .command)
        command = commandDecoded
        let runEnvironmentDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.RunEnvironment.self, forKey: .runEnvironment)
        runEnvironment = runEnvironmentDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The custom script to run tests on source or target environments.
    public struct WorkflowStepAutomationConfiguration: Swift.Equatable {
        /// The command required to run the script.
        public var command: MigrationHubOrchestratorClientTypes.PlatformCommand?
        /// The source or target environment.
        public var runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment?
        /// The Amazon S3 bucket where the script is located.
        public var scriptLocationS3Bucket: Swift.String?
        /// The Amazon S3 key for the script location.
        public var scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey?
        /// The servers on which to run the script.
        public var targetType: MigrationHubOrchestratorClientTypes.TargetType?

        public init(
            command: MigrationHubOrchestratorClientTypes.PlatformCommand? = nil,
            runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment? = nil,
            scriptLocationS3Bucket: Swift.String? = nil,
            scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey? = nil,
            targetType: MigrationHubOrchestratorClientTypes.TargetType? = nil
        )
        {
            self.command = command
            self.runEnvironment = runEnvironment
            self.scriptLocationS3Bucket = scriptLocationS3Bucket
            self.scriptLocationS3Key = scriptLocationS3Key
            self.targetType = targetType
        }
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case next
        case owner
        case previous
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepGroupStatus.self, forKey: .status)
        status = statusDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of a step group in a workflow.
    public struct WorkflowStepGroupSummary: Swift.Equatable {
        /// The ID of the step group.
        public var id: Swift.String?
        /// The name of the step group.
        public var name: Swift.String?
        /// The next step group.
        public var next: [Swift.String]?
        /// The owner of the step group.
        public var owner: MigrationHubOrchestratorClientTypes.Owner?
        /// The previous step group.
        public var previous: [Swift.String]?
        /// The status of the step group.
        public var status: MigrationHubOrchestratorClientTypes.StepGroupStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
            previous: [Swift.String]? = nil,
            status: MigrationHubOrchestratorClientTypes.StepGroupStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.next = next
            self.owner = owner
            self.previous = previous
            self.status = status
        }
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case name
        case `required` = "required"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let valueDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The output of a step.
    public struct WorkflowStepOutput: Swift.Equatable {
        /// The data type of the output.
        public var dataType: MigrationHubOrchestratorClientTypes.DataType?
        /// The name of the step.
        public var name: Swift.String?
        /// Determine if an output is required from a step.
        public var `required`: Swift.Bool?
        /// The value of the output.
        public var value: MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion?

        public init(
            dataType: MigrationHubOrchestratorClientTypes.DataType? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool? = nil,
            value: MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion? = nil
        )
        {
            self.dataType = dataType
            self.name = name
            self.`required` = `required`
            self.value = value
        }
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integervalue = "integerValue"
        case listofstringvalue = "listOfStringValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .integervalue(integervalue):
                try container.encode(integervalue, forKey: .integervalue)
            case let .listofstringvalue(listofstringvalue):
                var listofstringvalueContainer = container.nestedUnkeyedContainer(forKey: .listofstringvalue)
                for maxstringvalue0 in listofstringvalue {
                    try listofstringvalueContainer.encode(maxstringvalue0)
                }
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let integervalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .integervalue)
        if let integervalue = integervalueDecoded {
            self = .integervalue(integervalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let listofstringvalueContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .listofstringvalue)
        var listofstringvalueDecoded0:[Swift.String]? = nil
        if let listofstringvalueContainer = listofstringvalueContainer {
            listofstringvalueDecoded0 = [Swift.String]()
            for string0 in listofstringvalueContainer {
                if let string0 = string0 {
                    listofstringvalueDecoded0?.append(string0)
                }
            }
        }
        if let listofstringvalue = listofstringvalueDecoded0 {
            self = .listofstringvalue(listofstringvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// A structure to hold multiple values of an output.
    public enum WorkflowStepOutputUnion: Swift.Equatable {
        /// The integer value.
        case integervalue(Swift.Int)
        /// The string value.
        case stringvalue(Swift.String)
        /// The list of string value.
        case listofstringvalue([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case noOfSrvCompleted
        case noOfSrvFailed
        case owner
        case previous
        case scriptLocation
        case status
        case statusMessage
        case stepActionType
        case stepId
        case totalNoOfSrv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let noOfSrvCompleted = self.noOfSrvCompleted {
            try encodeContainer.encode(noOfSrvCompleted, forKey: .noOfSrvCompleted)
        }
        if let noOfSrvFailed = self.noOfSrvFailed {
            try encodeContainer.encode(noOfSrvFailed, forKey: .noOfSrvFailed)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let scriptLocation = self.scriptLocation {
            try encodeContainer.encode(scriptLocation, forKey: .scriptLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let totalNoOfSrv = self.totalNoOfSrv {
            try encodeContainer.encode(totalNoOfSrv, forKey: .totalNoOfSrv)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let noOfSrvCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvCompleted)
        noOfSrvCompleted = noOfSrvCompletedDecoded
        let noOfSrvFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvFailed)
        noOfSrvFailed = noOfSrvFailedDecoded
        let totalNoOfSrvDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNoOfSrv)
        totalNoOfSrv = totalNoOfSrvDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scriptLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptLocation)
        scriptLocation = scriptLocationDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the step in a migration workflow.
    public struct WorkflowStepSummary: Swift.Equatable {
        /// The description of the step.
        public var description: Swift.String?
        /// The name of the step.
        public var name: Swift.String?
        /// The next step.
        public var next: [Swift.String]?
        /// The number of servers that have been migrated.
        public var noOfSrvCompleted: Swift.Int?
        /// The number of servers that have failed to migrate.
        public var noOfSrvFailed: Swift.Int?
        /// The owner of the step.
        public var owner: MigrationHubOrchestratorClientTypes.Owner?
        /// The previous step.
        public var previous: [Swift.String]?
        /// The location of the script.
        public var scriptLocation: Swift.String?
        /// The status of the step.
        public var status: MigrationHubOrchestratorClientTypes.StepStatus?
        /// The status message of the migration workflow.
        public var statusMessage: Swift.String?
        /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
        public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
        /// The ID of the step.
        public var stepId: Swift.String?
        /// The total number of servers that have been migrated.
        public var totalNoOfSrv: Swift.Int?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            noOfSrvCompleted: Swift.Int? = nil,
            noOfSrvFailed: Swift.Int? = nil,
            owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
            previous: [Swift.String]? = nil,
            scriptLocation: Swift.String? = nil,
            status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
            statusMessage: Swift.String? = nil,
            stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
            stepId: Swift.String? = nil,
            totalNoOfSrv: Swift.Int? = nil
        )
        {
            self.description = description
            self.name = name
            self.next = next
            self.noOfSrvCompleted = noOfSrvCompleted
            self.noOfSrvFailed = noOfSrvFailed
            self.owner = owner
            self.previous = previous
            self.scriptLocation = scriptLocation
            self.status = status
            self.statusMessage = statusMessage
            self.stepActionType = stepActionType
            self.stepId = stepId
            self.totalNoOfSrv = totalNoOfSrv
        }
    }

}
