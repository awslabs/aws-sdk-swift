// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateWorkflowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkflowInput(applicationConfigurationId: \(Swift.String(describing: applicationConfigurationId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), stepTargets: \(Swift.String(describing: stepTargets)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), inputParameters: \"CONTENT_REDACTED\")"}
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case description
        case inputParameters
        case name
        case stepTargets
        case tags
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = self.applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            var inputParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputParameters)
            for (dictKey0, stepInputParameters0) in inputParameters {
                try inputParametersContainer.encode(stepInputParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stepTargets = stepTargets {
            var stepTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTargets)
            for stringlistmember0 in stepTargets {
                try stepTargetsContainer.encode(stringlistmember0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, stringMap0) in tags {
                try tagsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

extension CreateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/migrationworkflow"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// The configuration ID of the application configured in Application Discovery Service.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The input parameters required to create a migration workflow.
    /// This member is required.
    public var inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    /// The name of the migration workflow.
    /// This member is required.
    public var name: Swift.String?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?
    /// The tags to add on a migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        applicationConfigurationId: Swift.String? = nil,
        description: Swift.String? = nil,
        inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil,
        name: Swift.String? = nil,
        stepTargets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.description = description
        self.inputParameters = inputParameters
        self.name = name
        self.stepTargets = stepTargets
        self.tags = tags
        self.templateId = templateId
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let applicationConfigurationId: Swift.String?
    let inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case description
        case inputParameters
        case name
        case stepTargets
        case tags
        case templateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let inputParametersContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .inputParameters)
        var inputParametersDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let inputParametersContainer = inputParametersContainer {
            inputParametersDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in inputParametersContainer {
                if let stepinput0 = stepinput0 {
                    inputParametersDecoded0?[key0] = stepinput0
                }
            }
        }
        inputParameters = inputParametersDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkflowOutputResponse(adsApplicationConfigurationId: \(Swift.String(describing: adsApplicationConfigurationId)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), stepTargets: \(Swift.String(describing: stepTargets)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), workflowInputs: \"CONTENT_REDACTED\")"}
}

extension CreateWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adsApplicationConfigurationId = output.adsApplicationConfigurationId
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.stepTargets = output.stepTargets
            self.tags = output.tags
            self.templateId = output.templateId
            self.workflowInputs = output.workflowInputs
        } else {
            self.adsApplicationConfigurationId = nil
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.stepTargets = nil
            self.tags = nil
            self.templateId = nil
            self.workflowInputs = nil
        }
    }
}

public struct CreateWorkflowOutputResponse: Swift.Equatable {
    /// The configuration ID of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The time at which the migration workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?
    /// The tags to add on a migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The inputs for creating a migration workflow.
    public var workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?

    public init (
        adsApplicationConfigurationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        stepTargets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil,
        workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
    )
    {
        self.adsApplicationConfigurationId = adsApplicationConfigurationId
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.stepTargets = stepTargets
        self.tags = tags
        self.templateId = templateId
        self.workflowInputs = workflowInputs
    }
}

struct CreateWorkflowOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let adsApplicationConfigurationId: Swift.String?
    let workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let creationTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationId
        case arn
        case creationTime
        case description
        case id
        case name
        case status
        case stepTargets
        case tags
        case templateId
        case workflowInputs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationId)
        adsApplicationConfigurationId = adsApplicationConfigurationIdDecoded
        let workflowInputsContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .workflowInputs)
        var workflowInputsDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let workflowInputsContainer = workflowInputsContainer {
            workflowInputsDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in workflowInputsContainer {
                if let stepinput0 = stepinput0 {
                    workflowInputsDecoded0?[key0] = stepinput0
                }
            }
        }
        workflowInputs = workflowInputsDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkflowStepGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
        case workflowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension CreateWorkflowStepGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflowstepgroups"
    }
}

public struct CreateWorkflowStepGroupInput: Swift.Equatable {
    /// The description of the step group.
    public var description: Swift.String?
    /// The name of the step group.
    /// This member is required.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The ID of the migration workflow that will contain the step group.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.next = next
        self.previous = previous
        self.workflowId = workflowId
    }
}

struct CreateWorkflowStepGroupInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let next: [Swift.String]?
    let previous: [Swift.String]?
}

extension CreateWorkflowStepGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
    }
}

extension CreateWorkflowStepGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowStepGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkflowStepGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowStepGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkflowStepGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.next = output.next
            self.previous = output.previous
            self.tools = output.tools
            self.workflowId = output.workflowId
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.next = nil
            self.previous = nil
            self.tools = nil
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowStepGroupOutputResponse: Swift.Equatable {
    /// The time at which the step group is created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The ID of the migration workflow that contains the step group.
    public var workflowId: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.previous = previous
        self.tools = tools
        self.workflowId = workflowId
    }
}

struct CreateWorkflowStepGroupOutputResponseBody: Swift.Equatable {
    let workflowId: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let next: [Swift.String]?
    let previous: [Swift.String]?
    let creationTime: ClientRuntime.Date?
}

extension CreateWorkflowStepGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case next
        case previous
        case tools
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CreateWorkflowStepInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for workflowstepoutput0 in outputs {
                try outputsContainer.encode(workflowstepoutput0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepGroupId = self.stepGroupId {
            try encodeContainer.encode(stepGroupId, forKey: .stepGroupId)
        }
        if let stepTarget = stepTarget {
            var stepTargetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTarget)
            for stringlistmember0 in stepTarget {
                try stepTargetContainer.encode(stringlistmember0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowStepAutomationConfiguration = self.workflowStepAutomationConfiguration {
            try encodeContainer.encode(workflowStepAutomationConfiguration, forKey: .workflowStepAutomationConfiguration)
        }
    }
}

extension CreateWorkflowStepInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflowstep"
    }
}

public struct CreateWorkflowStepInput: Swift.Equatable {
    /// The description of the step.
    public var description: Swift.String?
    /// The name of the step.
    /// This member is required.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The key value pairs added for the expected output.
    public var outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    /// This member is required.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The servers on which a step will be run.
    public var stepTarget: [Swift.String]?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?
    /// The custom script to run tests on source or target environments.
    public var workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil,
        previous: [Swift.String]? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepGroupId: Swift.String? = nil,
        stepTarget: [Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration? = nil
    )
    {
        self.description = description
        self.name = name
        self.next = next
        self.outputs = outputs
        self.previous = previous
        self.stepActionType = stepActionType
        self.stepGroupId = stepGroupId
        self.stepTarget = stepTarget
        self.workflowId = workflowId
        self.workflowStepAutomationConfiguration = workflowStepAutomationConfiguration
    }
}

struct CreateWorkflowStepInputBody: Swift.Equatable {
    let name: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let description: Swift.String?
    let workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?
    let stepTarget: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
}

extension CreateWorkflowStepInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workflowStepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration.self, forKey: .workflowStepAutomationConfiguration)
        workflowStepAutomationConfiguration = workflowStepAutomationConfigurationDecoded
        let stepTargetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTarget)
        var stepTargetDecoded0:[Swift.String]? = nil
        if let stepTargetContainer = stepTargetContainer {
            stepTargetDecoded0 = [Swift.String]()
            for string0 in stepTargetContainer {
                if let string0 = string0 {
                    stepTargetDecoded0?.append(string0)
                }
            }
        }
        stepTarget = stepTargetDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension CreateWorkflowStepOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowStepOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkflowStepOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowStepOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkflowStepOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.stepGroupId = output.stepGroupId
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.name = nil
            self.stepGroupId = nil
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowStepOutputResponse: Swift.Equatable {
    /// The ID of the step.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct CreateWorkflowStepOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
}

extension CreateWorkflowStepOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case stepGroupId
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum DataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case integer
        case string
        case stringlist
        case stringmap
        case sdkUnknown(Swift.String)

        public static var allCases: [DataType] {
            return [
                .integer,
                .string,
                .stringlist,
                .stringmap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case .stringlist: return "STRINGLIST"
            case .stringmap: return "STRINGMAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataType(rawValue: rawValue) ?? DataType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
}

extension DeleteWorkflowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteWorkflowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteWorkflowOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
}

extension DeleteWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteWorkflowStepGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension DeleteWorkflowStepGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflowstepgroup/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowStepGroupInput: Swift.Equatable {
    /// The ID of the step group you want to delete.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowStepGroupInputBody: Swift.Equatable {
}

extension DeleteWorkflowStepGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowStepGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowStepGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkflowStepGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowStepGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkflowStepGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkflowStepInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let stepGroupId = stepGroupId else {
                let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let stepGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
            items.append(stepGroupIdQueryItem)
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension DeleteWorkflowStepInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflowstep/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowStepInput: Swift.Equatable {
    /// The ID of the step you want to delete.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group that contains the step you want to delete.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowStepInputBody: Swift.Equatable {
}

extension DeleteWorkflowStepInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowStepOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowStepOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkflowStepOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowStepOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkflowStepOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/migrationworkflowtemplate/\(id.urlPercentEncoding())"
    }
}

public struct GetTemplateInput: Swift.Equatable {
    /// The ID of the template.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetTemplateInputBody: Swift.Equatable {
}

extension GetTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.inputs = output.inputs
            self.name = output.name
            self.status = output.status
            self.tools = output.tools
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.inputs = nil
            self.name = nil
            self.status = nil
            self.tools = nil
        }
    }
}

public struct GetTemplateOutputResponse: Swift.Equatable {
    /// The time at which the template was last created.
    public var creationTime: ClientRuntime.Date?
    /// The time at which the template was last created.
    public var description: Swift.String?
    /// The ID of the template.
    public var id: Swift.String?
    /// The inputs provided for the creation of the migration workflow.
    public var inputs: [MigrationHubOrchestratorClientTypes.TemplateInput]?
    /// The name of the template.
    public var name: Swift.String?
    /// The status of the template.
    public var status: MigrationHubOrchestratorClientTypes.TemplateStatus?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        inputs: [MigrationHubOrchestratorClientTypes.TemplateInput]? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.TemplateStatus? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.inputs = inputs
        self.name = name
        self.status = status
        self.tools = tools
    }
}

struct GetTemplateOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let inputs: [MigrationHubOrchestratorClientTypes.TemplateInput]?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let status: MigrationHubOrchestratorClientTypes.TemplateStatus?
    let creationTime: ClientRuntime.Date?
}

extension GetTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case inputs
        case name
        case status
        case tools
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateInput?].self, forKey: .inputs)
        var inputsDecoded0:[MigrationHubOrchestratorClientTypes.TemplateInput]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateInput]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension GetTemplateStepGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateId = templateId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/templates/\(templateId.urlPercentEncoding())/stepgroups/\(id.urlPercentEncoding())"
    }
}

public struct GetTemplateStepGroupInput: Swift.Equatable {
    /// The ID of the step group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        id: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.id = id
        self.templateId = templateId
    }
}

struct GetTemplateStepGroupInputBody: Swift.Equatable {
}

extension GetTemplateStepGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateStepGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTemplateStepGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTemplateStepGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateStepGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTemplateStepGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.next = output.next
            self.previous = output.previous
            self.status = output.status
            self.templateId = output.templateId
            self.tools = output.tools
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.next = nil
            self.previous = nil
            self.status = nil
            self.templateId = nil
            self.tools = nil
        }
    }
}

public struct GetTemplateStepGroupOutputResponse: Swift.Equatable {
    /// The time at which the step group was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The time at which the step group was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The status of the step group.
    public var status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        status: MigrationHubOrchestratorClientTypes.StepGroupStatus? = nil,
        templateId: Swift.String? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.next = next
        self.previous = previous
        self.status = status
        self.templateId = templateId
        self.tools = tools
    }
}

struct GetTemplateStepGroupOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
}

extension GetTemplateStepGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case lastModifiedTime
        case name
        case next
        case previous
        case status
        case templateId
        case tools
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepGroupStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension GetTemplateStepInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let stepGroupId = stepGroupId else {
                let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let stepGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
            items.append(stepGroupIdQueryItem)
            guard let templateId = templateId else {
                let message = "Creating a URL Query Item failed. templateId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let templateIdQueryItem = ClientRuntime.URLQueryItem(name: "templateId".urlPercentEncoding(), value: Swift.String(templateId).urlPercentEncoding())
            items.append(templateIdQueryItem)
            return items
        }
    }
}

extension GetTemplateStepInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/templatestep/\(id.urlPercentEncoding())"
    }
}

public struct GetTemplateStepInput: Swift.Equatable {
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.templateId = templateId
    }
}

struct GetTemplateStepInputBody: Swift.Equatable {
}

extension GetTemplateStepInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateStepOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTemplateStepOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTemplateStepOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateStepOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTemplateStepOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.next = output.next
            self.outputs = output.outputs
            self.previous = output.previous
            self.stepActionType = output.stepActionType
            self.stepAutomationConfiguration = output.stepAutomationConfiguration
            self.stepGroupId = output.stepGroupId
            self.templateId = output.templateId
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.next = nil
            self.outputs = nil
            self.previous = nil
            self.stepActionType = nil
            self.stepAutomationConfiguration = nil
            self.stepGroupId = nil
            self.templateId = nil
        }
    }
}

public struct GetTemplateStepOutputResponse: Swift.Equatable {
    /// The time at which the step was created.
    public var creationTime: Swift.String?
    /// The description of the step.
    public var description: Swift.String?
    /// The ID of the step.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The outputs of the step.
    public var outputs: [MigrationHubOrchestratorClientTypes.StepOutput]?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The custom script to run tests on source or target environments.
    public var stepAutomationConfiguration: MigrationHubOrchestratorClientTypes.StepAutomationConfiguration?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the template.
    public var templateId: Swift.String?

    public init (
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.StepOutput]? = nil,
        previous: [Swift.String]? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepAutomationConfiguration: MigrationHubOrchestratorClientTypes.StepAutomationConfiguration? = nil,
        stepGroupId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.outputs = outputs
        self.previous = previous
        self.stepActionType = stepActionType
        self.stepAutomationConfiguration = stepAutomationConfiguration
        self.stepGroupId = stepGroupId
        self.templateId = templateId
    }
}

struct GetTemplateStepOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let stepGroupId: Swift.String?
    let templateId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let creationTime: Swift.String?
    let previous: [Swift.String]?
    let next: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.StepOutput]?
    let stepAutomationConfiguration: MigrationHubOrchestratorClientTypes.StepAutomationConfiguration?
}

extension GetTemplateStepOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case next
        case outputs
        case previous
        case stepActionType
        case stepAutomationConfiguration
        case stepGroupId
        case templateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.StepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.StepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.StepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let stepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepAutomationConfiguration.self, forKey: .stepAutomationConfiguration)
        stepAutomationConfiguration = stepAutomationConfigurationDecoded
    }
}

extension GetWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWorkflowInputBody: Swift.Equatable {
}

extension GetWorkflowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkflowOutputResponse(adsApplicationConfigurationId: \(Swift.String(describing: adsApplicationConfigurationId)), adsApplicationName: \(Swift.String(describing: adsApplicationName)), arn: \(Swift.String(describing: arn)), completedSteps: \(Swift.String(describing: completedSteps)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), lastStartTime: \(Swift.String(describing: lastStartTime)), lastStopTime: \(Swift.String(describing: lastStopTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), tools: \(Swift.String(describing: tools)), totalSteps: \(Swift.String(describing: totalSteps)), workflowBucket: \(Swift.String(describing: workflowBucket)), workflowInputs: \"CONTENT_REDACTED\")"}
}

extension GetWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adsApplicationConfigurationId = output.adsApplicationConfigurationId
            self.adsApplicationName = output.adsApplicationName
            self.arn = output.arn
            self.completedSteps = output.completedSteps
            self.creationTime = output.creationTime
            self.description = output.description
            self.endTime = output.endTime
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.lastStartTime = output.lastStartTime
            self.lastStopTime = output.lastStopTime
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.templateId = output.templateId
            self.tools = output.tools
            self.totalSteps = output.totalSteps
            self.workflowBucket = output.workflowBucket
            self.workflowInputs = output.workflowInputs
        } else {
            self.adsApplicationConfigurationId = nil
            self.adsApplicationName = nil
            self.arn = nil
            self.completedSteps = nil
            self.creationTime = nil
            self.description = nil
            self.endTime = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.lastStartTime = nil
            self.lastStopTime = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.templateId = nil
            self.tools = nil
            self.totalSteps = nil
            self.workflowBucket = nil
            self.workflowInputs = nil
        }
    }
}

public struct GetWorkflowOutputResponse: Swift.Equatable {
    /// The configuration ID of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationId: Swift.String?
    /// The name of the application configured in Application Discovery Service.
    public var adsApplicationName: Swift.String?
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// Get a list of completed steps in the migration workflow.
    public var completedSteps: Swift.Int?
    /// The time at which the migration workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The time at which the migration workflow ended.
    public var endTime: ClientRuntime.Date?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The time at which the migration workflow was last started.
    public var lastStartTime: ClientRuntime.Date?
    /// The time at which the migration workflow was last stopped.
    public var lastStopTime: ClientRuntime.Date?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?
    /// The tags added to the migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The total number of steps in the migration workflow.
    public var totalSteps: Swift.Int?
    /// The Amazon S3 bucket where the migration logs are stored.
    public var workflowBucket: Swift.String?
    /// The inputs required for creating the migration workflow.
    public var workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?

    public init (
        adsApplicationConfigurationId: Swift.String? = nil,
        adsApplicationName: Swift.String? = nil,
        arn: Swift.String? = nil,
        completedSteps: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        lastStopTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        totalSteps: Swift.Int? = nil,
        workflowBucket: Swift.String? = nil,
        workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
    )
    {
        self.adsApplicationConfigurationId = adsApplicationConfigurationId
        self.adsApplicationName = adsApplicationName
        self.arn = arn
        self.completedSteps = completedSteps
        self.creationTime = creationTime
        self.description = description
        self.endTime = endTime
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.lastStartTime = lastStartTime
        self.lastStopTime = lastStopTime
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.templateId = templateId
        self.tools = tools
        self.totalSteps = totalSteps
        self.workflowBucket = workflowBucket
        self.workflowInputs = workflowInputs
    }
}

struct GetWorkflowOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let adsApplicationConfigurationId: Swift.String?
    let adsApplicationName: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastStartTime: ClientRuntime.Date?
    let lastStopTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let totalSteps: Swift.Int?
    let completedSteps: Swift.Int?
    let workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let tags: [Swift.String:Swift.String]?
    let workflowBucket: Swift.String?
}

extension GetWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationId
        case adsApplicationName
        case arn
        case completedSteps
        case creationTime
        case description
        case endTime
        case id
        case lastModifiedTime
        case lastStartTime
        case lastStopTime
        case name
        case status
        case statusMessage
        case tags
        case templateId
        case tools
        case totalSteps
        case workflowBucket
        case workflowInputs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationId)
        adsApplicationConfigurationId = adsApplicationConfigurationIdDecoded
        let adsApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationName)
        adsApplicationName = adsApplicationNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let lastStopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStopTime)
        lastStopTime = lastStopTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let totalStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
        let completedStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completedSteps)
        completedSteps = completedStepsDecoded
        let workflowInputsContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .workflowInputs)
        var workflowInputsDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let workflowInputsContainer = workflowInputsContainer {
            workflowInputsDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in workflowInputsContainer {
                if let stepinput0 = stepinput0 {
                    workflowInputsDecoded0?[key0] = stepinput0
                }
            }
        }
        workflowInputs = workflowInputsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workflowBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowBucket)
        workflowBucket = workflowBucketDecoded
    }
}

extension GetWorkflowStepGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension GetWorkflowStepGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflowstepgroup/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowStepGroupInput: Swift.Equatable {
    /// The ID of the step group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepGroupInputBody: Swift.Equatable {
}

extension GetWorkflowStepGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowStepGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowStepGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkflowStepGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowStepGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkflowStepGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.endTime = output.endTime
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.next = output.next
            self.owner = output.owner
            self.previous = output.previous
            self.status = output.status
            self.tools = output.tools
            self.workflowId = output.workflowId
        } else {
            self.creationTime = nil
            self.description = nil
            self.endTime = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.next = nil
            self.owner = nil
            self.previous = nil
            self.status = nil
            self.tools = nil
            self.workflowId = nil
        }
    }
}

public struct GetWorkflowStepGroupOutputResponse: Swift.Equatable {
    /// The time at which the step group was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step group.
    public var description: Swift.String?
    /// The time at which the step group ended.
    public var endTime: ClientRuntime.Date?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The time at which the step group was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The owner of the step group.
    public var owner: MigrationHubOrchestratorClientTypes.Owner?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The status of the step group.
    public var status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
        previous: [Swift.String]? = nil,
        status: MigrationHubOrchestratorClientTypes.StepGroupStatus? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.endTime = endTime
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.next = next
        self.owner = owner
        self.previous = previous
        self.status = status
        self.tools = tools
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepGroupOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.StepGroupStatus?
    let owner: MigrationHubOrchestratorClientTypes.Owner?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
}

extension GetWorkflowStepGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case endTime
        case id
        case lastModifiedTime
        case name
        case next
        case owner
        case previous
        case status
        case tools
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepGroupStatus.self, forKey: .status)
        status = statusDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension GetWorkflowStepInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let stepGroupId = stepGroupId else {
                let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let stepGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
            items.append(stepGroupIdQueryItem)
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension GetWorkflowStepInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflowstep/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowStepInput: Swift.Equatable {
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// desThe ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepInputBody: Swift.Equatable {
}

extension GetWorkflowStepInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowStepOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowStepOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkflowStepOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowStepOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkflowStepOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.endTime = output.endTime
            self.lastStartTime = output.lastStartTime
            self.name = output.name
            self.next = output.next
            self.noOfSrvCompleted = output.noOfSrvCompleted
            self.noOfSrvFailed = output.noOfSrvFailed
            self.outputs = output.outputs
            self.owner = output.owner
            self.previous = output.previous
            self.scriptOutputLocation = output.scriptOutputLocation
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.stepActionType = output.stepActionType
            self.stepGroupId = output.stepGroupId
            self.stepId = output.stepId
            self.stepTarget = output.stepTarget
            self.totalNoOfSrv = output.totalNoOfSrv
            self.workflowId = output.workflowId
            self.workflowStepAutomationConfiguration = output.workflowStepAutomationConfiguration
        } else {
            self.creationTime = nil
            self.description = nil
            self.endTime = nil
            self.lastStartTime = nil
            self.name = nil
            self.next = nil
            self.noOfSrvCompleted = nil
            self.noOfSrvFailed = nil
            self.outputs = nil
            self.owner = nil
            self.previous = nil
            self.scriptOutputLocation = nil
            self.status = nil
            self.statusMessage = nil
            self.stepActionType = nil
            self.stepGroupId = nil
            self.stepId = nil
            self.stepTarget = nil
            self.totalNoOfSrv = nil
            self.workflowId = nil
            self.workflowStepAutomationConfiguration = nil
        }
    }
}

public struct GetWorkflowStepOutputResponse: Swift.Equatable {
    /// The time at which the step was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the step.
    public var description: Swift.String?
    /// The time at which the step ended.
    public var endTime: ClientRuntime.Date?
    /// The time at which the workflow was last started.
    public var lastStartTime: ClientRuntime.Date?
    /// The name of the step.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The number of servers that have been migrated.
    public var noOfSrvCompleted: Swift.Int?
    /// The number of servers that have failed to migrate.
    public var noOfSrvFailed: Swift.Int?
    /// The outputs of the step.
    public var outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    /// The owner of the step.
    public var owner: MigrationHubOrchestratorClientTypes.Owner?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The output location of the script.
    public var scriptOutputLocation: Swift.String?
    /// The status of the step.
    public var status: MigrationHubOrchestratorClientTypes.StepStatus?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the step.
    public var stepId: Swift.String?
    /// The servers on which a step will be run.
    public var stepTarget: [Swift.String]?
    /// The total number of servers that have been migrated.
    public var totalNoOfSrv: Swift.Int?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?
    /// The custom script to run tests on source or target environments.
    public var workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        noOfSrvCompleted: Swift.Int? = nil,
        noOfSrvFailed: Swift.Int? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil,
        owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
        previous: [Swift.String]? = nil,
        scriptOutputLocation: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
        statusMessage: Swift.String? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepGroupId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        stepTarget: [Swift.String]? = nil,
        totalNoOfSrv: Swift.Int? = nil,
        workflowId: Swift.String? = nil,
        workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.endTime = endTime
        self.lastStartTime = lastStartTime
        self.name = name
        self.next = next
        self.noOfSrvCompleted = noOfSrvCompleted
        self.noOfSrvFailed = noOfSrvFailed
        self.outputs = outputs
        self.owner = owner
        self.previous = previous
        self.scriptOutputLocation = scriptOutputLocation
        self.status = status
        self.statusMessage = statusMessage
        self.stepActionType = stepActionType
        self.stepGroupId = stepGroupId
        self.stepId = stepId
        self.stepTarget = stepTarget
        self.totalNoOfSrv = totalNoOfSrv
        self.workflowId = workflowId
        self.workflowStepAutomationConfiguration = workflowStepAutomationConfiguration
    }
}

struct GetWorkflowStepOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let stepId: Swift.String?
    let description: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let owner: MigrationHubOrchestratorClientTypes.Owner?
    let workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?
    let stepTarget: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.StepStatus?
    let statusMessage: Swift.String?
    let scriptOutputLocation: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastStartTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let noOfSrvCompleted: Swift.Int?
    let noOfSrvFailed: Swift.Int?
    let totalNoOfSrv: Swift.Int?
}

extension GetWorkflowStepOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case endTime
        case lastStartTime
        case name
        case next
        case noOfSrvCompleted
        case noOfSrvFailed
        case outputs
        case owner
        case previous
        case scriptOutputLocation
        case status
        case statusMessage
        case stepActionType
        case stepGroupId
        case stepId
        case stepTarget
        case totalNoOfSrv
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let workflowStepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration.self, forKey: .workflowStepAutomationConfiguration)
        workflowStepAutomationConfiguration = workflowStepAutomationConfigurationDecoded
        let stepTargetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTarget)
        var stepTargetDecoded0:[Swift.String]? = nil
        if let stepTargetContainer = stepTargetContainer {
            stepTargetDecoded0 = [Swift.String]()
            for string0 in stepTargetContainer {
                if let string0 = string0 {
                    stepTargetDecoded0?.append(string0)
                }
            }
        }
        stepTarget = stepTargetDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let scriptOutputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptOutputLocation)
        scriptOutputLocation = scriptOutputLocationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let noOfSrvCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvCompleted)
        noOfSrvCompleted = noOfSrvCompletedDecoded
        let noOfSrvFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvFailed)
        noOfSrvFailed = noOfSrvFailedDecoded
        let totalNoOfSrvDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNoOfSrv)
        totalNoOfSrv = totalNoOfSrvDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPluginsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListPluginsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/plugins"
    }
}

public struct ListPluginsInput: Swift.Equatable {
    /// The maximum number of plugins that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPluginsInputBody: Swift.Equatable {
}

extension ListPluginsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPluginsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPluginsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPluginsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPluginsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPluginsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.plugins = output.plugins
        } else {
            self.nextToken = nil
            self.plugins = nil
        }
    }
}

public struct ListPluginsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Migration Hub Orchestrator plugins.
    public var plugins: [MigrationHubOrchestratorClientTypes.PluginSummary]?

    public init (
        nextToken: Swift.String? = nil,
        plugins: [MigrationHubOrchestratorClientTypes.PluginSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.plugins = plugins
    }
}

struct ListPluginsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let plugins: [MigrationHubOrchestratorClientTypes.PluginSummary]?
}

extension ListPluginsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case plugins
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pluginsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.PluginSummary?].self, forKey: .plugins)
        var pluginsDecoded0:[MigrationHubOrchestratorClientTypes.PluginSummary]? = nil
        if let pluginsContainer = pluginsContainer {
            pluginsDecoded0 = [MigrationHubOrchestratorClientTypes.PluginSummary]()
            for structure0 in pluginsContainer {
                if let structure0 = structure0 {
                    pluginsDecoded0?.append(structure0)
                }
            }
        }
        plugins = pluginsDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags added to a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTemplateStepGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTemplateStepGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateId = templateId else {
            return nil
        }
        return "/templatestepgroups/\(templateId.urlPercentEncoding())"
    }
}

public struct ListTemplateStepGroupsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateStepGroupsInputBody: Swift.Equatable {
}

extension ListTemplateStepGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateStepGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateStepGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplateStepGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateStepGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplateStepGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateStepGroupSummary = output.templateStepGroupSummary
        } else {
            self.nextToken = nil
            self.templateStepGroupSummary = nil
        }
    }
}

public struct ListTemplateStepGroupsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of the step group in the template.
    /// This member is required.
    public var templateStepGroupSummary: [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateStepGroupSummary: [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateStepGroupSummary = templateStepGroupSummary
    }
}

struct ListTemplateStepGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateStepGroupSummary: [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]?
}

extension ListTemplateStepGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateStepGroupSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateStepGroupSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary?].self, forKey: .templateStepGroupSummary)
        var templateStepGroupSummaryDecoded0:[MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]? = nil
        if let templateStepGroupSummaryContainer = templateStepGroupSummaryContainer {
            templateStepGroupSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary]()
            for structure0 in templateStepGroupSummaryContainer {
                if let structure0 = structure0 {
                    templateStepGroupSummaryDecoded0?.append(structure0)
                }
            }
        }
        templateStepGroupSummary = templateStepGroupSummaryDecoded0
    }
}

extension ListTemplateStepsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let stepGroupId = stepGroupId else {
                let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let stepGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
            items.append(stepGroupIdQueryItem)
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let templateId = templateId else {
                let message = "Creating a URL Query Item failed. templateId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let templateIdQueryItem = ClientRuntime.URLQueryItem(name: "templateId".urlPercentEncoding(), value: Swift.String(templateId).urlPercentEncoding())
            items.append(templateIdQueryItem)
            return items
        }
    }
}

extension ListTemplateStepsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/templatesteps"
    }
}

public struct ListTemplateStepsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stepGroupId = stepGroupId
        self.templateId = templateId
    }
}

struct ListTemplateStepsInputBody: Swift.Equatable {
}

extension ListTemplateStepsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateStepsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateStepsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplateStepsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateStepsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplateStepsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateStepSummaryList = output.templateStepSummaryList
        } else {
            self.nextToken = nil
            self.templateStepSummaryList = nil
        }
    }
}

public struct ListTemplateStepsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The list of summaries of steps in a template.
    public var templateStepSummaryList: [MigrationHubOrchestratorClientTypes.TemplateStepSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateStepSummaryList: [MigrationHubOrchestratorClientTypes.TemplateStepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateStepSummaryList = templateStepSummaryList
    }
}

struct ListTemplateStepsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateStepSummaryList: [MigrationHubOrchestratorClientTypes.TemplateStepSummary]?
}

extension ListTemplateStepsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateStepSummaryList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateStepSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateStepSummary?].self, forKey: .templateStepSummaryList)
        var templateStepSummaryListDecoded0:[MigrationHubOrchestratorClientTypes.TemplateStepSummary]? = nil
        if let templateStepSummaryListContainer = templateStepSummaryListContainer {
            templateStepSummaryListDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateStepSummary]()
            for structure0 in templateStepSummaryListContainer {
                if let structure0 = structure0 {
                    templateStepSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateStepSummaryList = templateStepSummaryListDecoded0
    }
}

extension ListTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/migrationworkflowtemplates"
    }
}

public struct ListTemplatesInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The name of the template.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListTemplatesInputBody: Swift.Equatable {
}

extension ListTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateSummary = output.templateSummary
        } else {
            self.nextToken = nil
            self.templateSummary = nil
        }
    }
}

public struct ListTemplatesOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of the template.
    /// This member is required.
    public var templateSummary: [MigrationHubOrchestratorClientTypes.TemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateSummary: [MigrationHubOrchestratorClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummary = templateSummary
    }
}

struct ListTemplatesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateSummary: [MigrationHubOrchestratorClientTypes.TemplateSummary]?
}

extension ListTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.TemplateSummary?].self, forKey: .templateSummary)
        var templateSummaryDecoded0:[MigrationHubOrchestratorClientTypes.TemplateSummary]? = nil
        if let templateSummaryContainer = templateSummaryContainer {
            templateSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.TemplateSummary]()
            for structure0 in templateSummaryContainer {
                if let structure0 = structure0 {
                    templateSummaryDecoded0?.append(structure0)
                }
            }
        }
        templateSummary = templateSummaryDecoded0
    }
}

extension ListWorkflowStepGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension ListWorkflowStepGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflowstepgroups"
    }
}

public struct ListWorkflowStepGroupsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListWorkflowStepGroupsInputBody: Swift.Equatable {
}

extension ListWorkflowStepGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowStepGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowStepGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkflowStepGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowStepGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkflowStepGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowStepGroupsSummary = output.workflowStepGroupsSummary
        } else {
            self.nextToken = nil
            self.workflowStepGroupsSummary = nil
        }
    }
}

public struct ListWorkflowStepGroupsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of step groups in a migration workflow.
    /// This member is required.
    public var workflowStepGroupsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workflowStepGroupsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowStepGroupsSummary = workflowStepGroupsSummary
    }
}

struct ListWorkflowStepGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowStepGroupsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]?
}

extension ListWorkflowStepGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowStepGroupsSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowStepGroupsSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary?].self, forKey: .workflowStepGroupsSummary)
        var workflowStepGroupsSummaryDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]? = nil
        if let workflowStepGroupsSummaryContainer = workflowStepGroupsSummaryContainer {
            workflowStepGroupsSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary]()
            for structure0 in workflowStepGroupsSummaryContainer {
                if let structure0 = structure0 {
                    workflowStepGroupsSummaryDecoded0?.append(structure0)
                }
            }
        }
        workflowStepGroupsSummary = workflowStepGroupsSummaryDecoded0
    }
}

extension ListWorkflowStepsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowStepsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowId = workflowId else {
            return nil
        }
        guard let stepGroupId = stepGroupId else {
            return nil
        }
        return "/workflow/\(workflowId.urlPercentEncoding())/workflowstepgroups/\(stepGroupId.urlPercentEncoding())/workflowsteps"
    }
}

public struct ListWorkflowStepsInput: Swift.Equatable {
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct ListWorkflowStepsInputBody: Swift.Equatable {
}

extension ListWorkflowStepsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowStepsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowStepsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkflowStepsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowStepsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkflowStepsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowStepsSummary = output.workflowStepsSummary
        } else {
            self.nextToken = nil
            self.workflowStepsSummary = nil
        }
    }
}

public struct ListWorkflowStepsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The summary of steps in a migration workflow.
    /// This member is required.
    public var workflowStepsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workflowStepsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowStepsSummary = workflowStepsSummary
    }
}

struct ListWorkflowStepsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowStepsSummary: [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]?
}

extension ListWorkflowStepsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowStepsSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowStepsSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepSummary?].self, forKey: .workflowStepsSummary)
        var workflowStepsSummaryDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepSummary]? = nil
        if let workflowStepsSummaryContainer = workflowStepsSummaryContainer {
            workflowStepsSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepSummary]()
            for structure0 in workflowStepsSummaryContainer {
                if let structure0 = structure0 {
                    workflowStepsSummaryDecoded0?.append(structure0)
                }
            }
        }
        workflowStepsSummary = workflowStepsSummaryDecoded0
    }
}

extension ListWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let adsApplicationConfigurationName = adsApplicationConfigurationName {
                let adsApplicationConfigurationNameQueryItem = ClientRuntime.URLQueryItem(name: "adsApplicationConfigurationName".urlPercentEncoding(), value: Swift.String(adsApplicationConfigurationName).urlPercentEncoding())
                items.append(adsApplicationConfigurationNameQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let templateId = templateId {
                let templateIdQueryItem = ClientRuntime.URLQueryItem(name: "templateId".urlPercentEncoding(), value: Swift.String(templateId).urlPercentEncoding())
                items.append(templateIdQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/migrationworkflows"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// The name of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationName: Swift.String?
    /// The maximum number of results that can be returned.
    public var maxResults: Swift.Int
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The ID of the template.
    public var templateId: Swift.String?

    public init (
        adsApplicationConfigurationName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.adsApplicationConfigurationName = adsApplicationConfigurationName
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.status = status
        self.templateId = templateId
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
}

extension ListWorkflowsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkflowsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkflowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.migrationWorkflowSummary = output.migrationWorkflowSummary
            self.nextToken = output.nextToken
        } else {
            self.migrationWorkflowSummary = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowsOutputResponse: Swift.Equatable {
    /// The summary of the migration workflow.
    /// This member is required.
    public var migrationWorkflowSummary: [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        migrationWorkflowSummary: [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.migrationWorkflowSummary = migrationWorkflowSummary
        self.nextToken = nextToken
    }
}

struct ListWorkflowsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let migrationWorkflowSummary: [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]?
}

extension ListWorkflowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationWorkflowSummary
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let migrationWorkflowSummaryContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary?].self, forKey: .migrationWorkflowSummary)
        var migrationWorkflowSummaryDecoded0:[MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]? = nil
        if let migrationWorkflowSummaryContainer = migrationWorkflowSummaryContainer {
            migrationWorkflowSummaryDecoded0 = [MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary]()
            for structure0 in migrationWorkflowSummaryContainer {
                if let structure0 = structure0 {
                    migrationWorkflowSummaryDecoded0?.append(structure0)
                }
            }
        }
        migrationWorkflowSummary = migrationWorkflowSummaryDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum MigrationWorkflowStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case creationFailed
        case deleted
        case deleting
        case deletionFailed
        case inProgress
        case notStarted
        case paused
        case pausing
        case pausingFailed
        case starting
        case userAttentionRequired
        case workflowFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [MigrationWorkflowStatusEnum] {
            return [
                .completed,
                .creating,
                .creationFailed,
                .deleted,
                .deleting,
                .deletionFailed,
                .inProgress,
                .notStarted,
                .paused,
                .pausing,
                .pausingFailed,
                .starting,
                .userAttentionRequired,
                .workflowFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .paused: return "PAUSED"
            case .pausing: return "PAUSING"
            case .pausingFailed: return "PAUSING_FAILED"
            case .starting: return "STARTING"
            case .userAttentionRequired: return "USER_ATTENTION_REQUIRED"
            case .workflowFailed: return "WORKFLOW_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MigrationWorkflowStatusEnum(rawValue: rawValue) ?? MigrationWorkflowStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.MigrationWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationName
        case completedSteps
        case creationTime
        case endTime
        case id
        case name
        case status
        case statusMessage
        case templateId
        case totalSteps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adsApplicationConfigurationName = self.adsApplicationConfigurationName {
            try encodeContainer.encode(adsApplicationConfigurationName, forKey: .adsApplicationConfigurationName)
        }
        if let completedSteps = self.completedSteps {
            try encodeContainer.encode(completedSteps, forKey: .completedSteps)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
        if let totalSteps = self.totalSteps {
            try encodeContainer.encode(totalSteps, forKey: .totalSteps)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationName)
        adsApplicationConfigurationName = adsApplicationConfigurationNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let completedStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completedSteps)
        completedSteps = completedStepsDecoded
        let totalStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of a migration workflow.
    public struct MigrationWorkflowSummary: Swift.Equatable {
        /// The name of the application configured in Application Discovery Service.
        public var adsApplicationConfigurationName: Swift.String?
        /// The steps completed in the migration workflow.
        public var completedSteps: Swift.Int?
        /// The time at which the migration workflow was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the migration workflow ended.
        public var endTime: ClientRuntime.Date?
        /// The ID of the migration workflow.
        public var id: Swift.String?
        /// The name of the migration workflow.
        public var name: Swift.String?
        /// The status of the migration workflow.
        public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
        /// The status message of the migration workflow.
        public var statusMessage: Swift.String?
        /// The ID of the template.
        public var templateId: Swift.String?
        /// All the steps in a migration workflow.
        public var totalSteps: Swift.Int?

        public init (
            adsApplicationConfigurationName: Swift.String? = nil,
            completedSteps: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
            statusMessage: Swift.String? = nil,
            templateId: Swift.String? = nil,
            totalSteps: Swift.Int? = nil
        )
        {
            self.adsApplicationConfigurationName = adsApplicationConfigurationName
            self.completedSteps = completedSteps
            self.creationTime = creationTime
            self.endTime = endTime
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.templateId = templateId
            self.totalSteps = totalSteps
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum Owner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsmanaged
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [Owner] {
            return [
                .awsmanaged,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsmanaged: return "AWS_MANAGED"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Owner(rawValue: rawValue) ?? Owner.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.PlatformCommand: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linux
        case windows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linux = self.linux {
            try encodeContainer.encode(linux, forKey: .linux)
        }
        if let windows = self.windows {
            try encodeContainer.encode(windows, forKey: .windows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linux)
        linux = linuxDecoded
        let windowsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windows)
        windows = windowsDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// Command to be run on a particular operating system.
    public struct PlatformCommand: Swift.Equatable {
        /// Command for Linux.
        public var linux: Swift.String?
        /// Command for Windows.
        public var windows: Swift.String?

        public init (
            linux: Swift.String? = nil,
            windows: Swift.String? = nil
        )
        {
            self.linux = linux
            self.windows = windows
        }
    }

}

extension MigrationHubOrchestratorClientTypes.PlatformScriptKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linux
        case windows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linux = self.linux {
            try encodeContainer.encode(linux, forKey: .linux)
        }
        if let windows = self.windows {
            try encodeContainer.encode(windows, forKey: .windows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linux)
        linux = linuxDecoded
        let windowsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windows)
        windows = windowsDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The script location for a particular operating system.
    public struct PlatformScriptKey: Swift.Equatable {
        /// The script location for Linux.
        public var linux: Swift.String?
        /// The script location for Windows.
        public var windows: Swift.String?

        public init (
            linux: Swift.String? = nil,
            windows: Swift.String? = nil
        )
        {
            self.linux = linux
            self.windows = windows
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum PluginHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pluginHealthy
        case pluginUnhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginHealth] {
            return [
                .pluginHealthy,
                .pluginUnhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pluginHealthy: return "HEALTHY"
            case .pluginUnhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PluginHealth(rawValue: rawValue) ?? PluginHealth.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.PluginSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case ipAddress
        case pluginId
        case registeredTime
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let pluginId = self.pluginId {
            try encodeContainer.encode(pluginId, forKey: .pluginId)
        }
        if let registeredTime = self.registeredTime {
            try encodeContainer.encode(registeredTime, forKey: .registeredTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PluginHealth.self, forKey: .status)
        status = statusDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let registeredTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the Migration Hub Orchestrator plugin.
    public struct PluginSummary: Swift.Equatable {
        /// The name of the host.
        public var hostname: Swift.String?
        /// The IP address at which the plugin is located.
        public var ipAddress: Swift.String?
        /// The ID of the plugin.
        public var pluginId: Swift.String?
        /// The time at which the plugin was registered.
        public var registeredTime: Swift.String?
        /// The status of the plugin.
        public var status: MigrationHubOrchestratorClientTypes.PluginHealth?
        /// The version of the plugin.
        public var version: Swift.String?

        public init (
            hostname: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            registeredTime: Swift.String? = nil,
            status: MigrationHubOrchestratorClientTypes.PluginHealth? = nil,
            version: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.ipAddress = ipAddress
            self.pluginId = pluginId
            self.registeredTime = registeredTime
            self.status = status
            self.version = version
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is not available.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryWorkflowStepInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let stepGroupId = stepGroupId else {
                let message = "Creating a URL Query Item failed. stepGroupId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let stepGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "stepGroupId".urlPercentEncoding(), value: Swift.String(stepGroupId).urlPercentEncoding())
            items.append(stepGroupIdQueryItem)
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension RetryWorkflowStepInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/retryworkflowstep/\(id.urlPercentEncoding())"
    }
}

public struct RetryWorkflowStepInput: Swift.Equatable {
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct RetryWorkflowStepInputBody: Swift.Equatable {
}

extension RetryWorkflowStepInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RetryWorkflowStepOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryWorkflowStepOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetryWorkflowStepOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryWorkflowStepOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetryWorkflowStepOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.status = output.status
            self.stepGroupId = output.stepGroupId
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.status = nil
            self.stepGroupId = nil
            self.workflowId = nil
        }
    }
}

public struct RetryWorkflowStepOutputResponse: Swift.Equatable {
    /// The ID of the step.
    public var id: Swift.String?
    /// The status of the step.
    public var status: MigrationHubOrchestratorClientTypes.StepStatus?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.status = status
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct RetryWorkflowStepOutputResponseBody: Swift.Equatable {
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let id: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.StepStatus?
}

extension RetryWorkflowStepOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case status
        case stepGroupId
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum RunEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case onpremise
        case sdkUnknown(Swift.String)

        public static var allCases: [RunEnvironment] {
            return [
                .aws,
                .onpremise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .onpremise: return "ONPREMISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunEnvironment(rawValue: rawValue) ?? RunEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension StartWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())/start"
    }
}

public struct StartWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartWorkflowInputBody: Swift.Equatable {
}

extension StartWorkflowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.lastStartTime = output.lastStartTime
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.arn = nil
            self.id = nil
            self.lastStartTime = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct StartWorkflowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was last started.
    public var lastStartTime: ClientRuntime.Date?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lastStartTime = lastStartTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct StartWorkflowOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let statusMessage: Swift.String?
    let lastStartTime: ClientRuntime.Date?
}

extension StartWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case lastStartTime
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    public enum StepActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automated
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [StepActionType] {
            return [
                .automated,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automated: return "AUTOMATED"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepActionType(rawValue: rawValue) ?? StepActionType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.StepAutomationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case runEnvironment
        case scriptLocationS3Bucket
        case scriptLocationS3Key
        case targetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let runEnvironment = self.runEnvironment {
            try encodeContainer.encode(runEnvironment.rawValue, forKey: .runEnvironment)
        }
        if let scriptLocationS3Bucket = self.scriptLocationS3Bucket {
            try encodeContainer.encode(scriptLocationS3Bucket, forKey: .scriptLocationS3Bucket)
        }
        if let scriptLocationS3Key = self.scriptLocationS3Key {
            try encodeContainer.encode(scriptLocationS3Key, forKey: .scriptLocationS3Key)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptLocationS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptLocationS3Bucket)
        scriptLocationS3Bucket = scriptLocationS3BucketDecoded
        let scriptLocationS3KeyDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformScriptKey.self, forKey: .scriptLocationS3Key)
        scriptLocationS3Key = scriptLocationS3KeyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformCommand.self, forKey: .command)
        command = commandDecoded
        let runEnvironmentDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.RunEnvironment.self, forKey: .runEnvironment)
        runEnvironment = runEnvironmentDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The custom script to run tests on source or target environments.
    public struct StepAutomationConfiguration: Swift.Equatable {
        /// The command to run the script.
        public var command: MigrationHubOrchestratorClientTypes.PlatformCommand?
        /// The source or target environment.
        public var runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment?
        /// The Amazon S3 bucket where the script is located.
        public var scriptLocationS3Bucket: Swift.String?
        /// The Amazon S3 key for the script location.
        public var scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey?
        /// The servers on which to run the script.
        public var targetType: MigrationHubOrchestratorClientTypes.TargetType?

        public init (
            command: MigrationHubOrchestratorClientTypes.PlatformCommand? = nil,
            runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment? = nil,
            scriptLocationS3Bucket: Swift.String? = nil,
            scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey? = nil,
            targetType: MigrationHubOrchestratorClientTypes.TargetType? = nil
        )
        {
            self.command = command
            self.runEnvironment = runEnvironment
            self.scriptLocationS3Bucket = scriptLocationS3Bucket
            self.scriptLocationS3Key = scriptLocationS3Key
            self.targetType = targetType
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum StepGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingDependencies
        case completed
        case failed
        case inProgress
        case paused
        case pausing
        case ready
        case userAttentionRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [StepGroupStatus] {
            return [
                .awaitingDependencies,
                .completed,
                .failed,
                .inProgress,
                .paused,
                .pausing,
                .ready,
                .userAttentionRequired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingDependencies: return "AWAITING_DEPENDENCIES"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .paused: return "PAUSED"
            case .pausing: return "PAUSING"
            case .ready: return "READY"
            case .userAttentionRequired: return "USER_ATTENTION_REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepGroupStatus(rawValue: rawValue) ?? StepGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.StepInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integervalue = "integerValue"
        case listofstringsvalue = "listOfStringsValue"
        case mapofstringvalue = "mapOfStringValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .integervalue(integervalue):
                try container.encode(integervalue, forKey: .integervalue)
            case let .listofstringsvalue(listofstringsvalue):
                var listofstringsvalueContainer = container.nestedUnkeyedContainer(forKey: .listofstringsvalue)
                for stringlistmember0 in listofstringsvalue {
                    try listofstringsvalueContainer.encode(stringlistmember0)
                }
            case let .mapofstringvalue(mapofstringvalue):
                var mapofstringvalueContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mapofstringvalue)
                for (dictKey0, stringMap0) in mapofstringvalue {
                    try mapofstringvalueContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
                }
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let integervalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .integervalue)
        if let integervalue = integervalueDecoded {
            self = .integervalue(integervalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let listofstringsvalueContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .listofstringsvalue)
        var listofstringsvalueDecoded0:[Swift.String]? = nil
        if let listofstringsvalueContainer = listofstringsvalueContainer {
            listofstringsvalueDecoded0 = [Swift.String]()
            for string0 in listofstringsvalueContainer {
                if let string0 = string0 {
                    listofstringsvalueDecoded0?.append(string0)
                }
            }
        }
        if let listofstringsvalue = listofstringsvalueDecoded0 {
            self = .listofstringsvalue(listofstringsvalue)
            return
        }
        let mapofstringvalueContainer = try values.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .mapofstringvalue)
        var mapofstringvalueDecoded0: [Swift.String:Swift.String]? = nil
        if let mapofstringvalueContainer = mapofstringvalueContainer {
            mapofstringvalueDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in mapofstringvalueContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    mapofstringvalueDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        if let mapofstringvalue = mapofstringvalueDecoded0 {
            self = .mapofstringvalue(mapofstringvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// A map of key value pairs that is generated when you create a migration workflow. The key value pairs will differ based on your selection of the template.
    public enum StepInput: Swift.Equatable {
        /// The value of the integer.
        case integervalue(Swift.Int)
        /// String value.
        case stringvalue(Swift.String)
        /// List of string values.
        case listofstringsvalue([Swift.String])
        /// Map of string values.
        case mapofstringvalue([Swift.String:Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubOrchestratorClientTypes.StepOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case name
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The output of the step.
    public struct StepOutput: Swift.Equatable {
        /// The data type of the step output.
        public var dataType: MigrationHubOrchestratorClientTypes.DataType?
        /// The name of the step.
        public var name: Swift.String?
        /// Determine if an output is required from a step.
        public var `required`: Swift.Bool?

        public init (
            dataType: MigrationHubOrchestratorClientTypes.DataType? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.dataType = dataType
            self.name = name
            self.`required` = `required`
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum StepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingDependencies
        case completed
        case failed
        case inProgress
        case paused
        case ready
        case userAttentionRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [StepStatus] {
            return [
                .awaitingDependencies,
                .completed,
                .failed,
                .inProgress,
                .paused,
                .ready,
                .userAttentionRequired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingDependencies: return "AWAITING_DEPENDENCIES"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .paused: return "PAUSED"
            case .ready: return "READY"
            case .userAttentionRequired: return "USER_ATTENTION_REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepStatus(rawValue: rawValue) ?? StepStatus.sdkUnknown(rawValue)
        }
    }
}

extension StopWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())/stop"
    }
}

public struct StopWorkflowInput: Swift.Equatable {
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopWorkflowInputBody: Swift.Equatable {
}

extension StopWorkflowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.lastStopTime = output.lastStopTime
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.arn = nil
            self.id = nil
            self.lastStopTime = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct StopWorkflowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was stopped.
    public var lastStopTime: ClientRuntime.Date?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The status message of the migration workflow.
    public var statusMessage: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastStopTime: ClientRuntime.Date? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.lastStopTime = lastStopTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct StopWorkflowOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let statusMessage: Swift.String?
    let lastStopTime: ClientRuntime.Date?
}

extension StopWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case lastStopTime
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let lastStopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStopTime)
        lastStopTime = lastStopTimeDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension MigrationHubOrchestratorClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case single
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .all,
                .none,
                .single,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case .single: return "SINGLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.TemplateInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case inputName
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The input parameters of a template.
    public struct TemplateInput: Swift.Equatable {
        /// The data type of the template input.
        public var dataType: MigrationHubOrchestratorClientTypes.DataType?
        /// The name of the template.
        public var inputName: Swift.String?
        /// Determine if an input is required from the template.
        public var `required`: Swift.Bool?

        public init (
            dataType: MigrationHubOrchestratorClientTypes.DataType? = nil,
            inputName: Swift.String? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.dataType = dataType
            self.inputName = inputName
            self.`required` = `required`
        }
    }

}

extension MigrationHubOrchestratorClientTypes {
    public enum TemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateStatus] {
            return [
                .created,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateStatus(rawValue: rawValue) ?? TemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubOrchestratorClientTypes.TemplateStepGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case next
        case previous
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the step group in the template.
    public struct TemplateStepGroupSummary: Swift.Equatable {
        /// The ID of the step group.
        public var id: Swift.String?
        /// The name of the step group.
        public var name: Swift.String?
        /// The next step group.
        public var next: [Swift.String]?
        /// The previous step group.
        public var previous: [Swift.String]?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            previous: [Swift.String]? = nil
        )
        {
            self.id = id
            self.name = name
            self.next = next
            self.previous = previous
        }
    }

}

extension MigrationHubOrchestratorClientTypes.TemplateStepSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case next
        case owner
        case previous
        case stepActionType
        case stepGroupId
        case targetType
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepGroupId = self.stepGroupId {
            try encodeContainer.encode(stepGroupId, forKey: .stepGroupId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the step.
    public struct TemplateStepSummary: Swift.Equatable {
        /// The ID of the step.
        public var id: Swift.String?
        /// The name of the step.
        public var name: Swift.String?
        /// The next step.
        public var next: [Swift.String]?
        /// The owner of the step.
        public var owner: MigrationHubOrchestratorClientTypes.Owner?
        /// The previous step.
        public var previous: [Swift.String]?
        /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
        public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
        /// The ID of the step group.
        public var stepGroupId: Swift.String?
        /// The servers on which to run the script.
        public var targetType: MigrationHubOrchestratorClientTypes.TargetType?
        /// The ID of the template.
        public var templateId: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
            previous: [Swift.String]? = nil,
            stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
            stepGroupId: Swift.String? = nil,
            targetType: MigrationHubOrchestratorClientTypes.TargetType? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.next = next
            self.owner = owner
            self.previous = previous
            self.stepActionType = stepActionType
            self.stepGroupId = stepGroupId
            self.targetType = targetType
            self.templateId = templateId
        }
    }

}

extension MigrationHubOrchestratorClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the template.
    public struct TemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// The description of the template.
        public var description: Swift.String?
        /// The ID of the template.
        public var id: Swift.String?
        /// The name of the template.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubOrchestratorClientTypes.Tool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// List of AWS services utilized in a migration workflow.
    public struct Tool: Swift.Equatable {
        /// The name of an AWS service.
        public var name: Swift.String?
        /// The URL of an AWS service.
        public var url: Swift.String?

        public init (
            name: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag keys. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateWorkflowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkflowInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), stepTargets: \(Swift.String(describing: stepTargets)), inputParameters: \"CONTENT_REDACTED\")"}
}

extension UpdateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case inputParameters
        case name
        case stepTargets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            var inputParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputParameters)
            for (dictKey0, stepInputParameters0) in inputParameters {
                try inputParametersContainer.encode(stepInputParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stepTargets = stepTargets {
            var stepTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTargets)
            for stringlistmember0 in stepTargets {
                try stepTargetsContainer.encode(stringlistmember0)
            }
        }
    }
}

extension UpdateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/migrationworkflow/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowInput: Swift.Equatable {
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The ID of the migration workflow.
    /// This member is required.
    public var id: Swift.String?
    /// The input parameters required to update a migration workflow.
    public var inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil,
        name: Swift.String? = nil,
        stepTargets: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.inputParameters = inputParameters
        self.name = name
        self.stepTargets = stepTargets
    }
}

struct UpdateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let inputParameters: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
}

extension UpdateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case inputParameters
        case name
        case stepTargets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputParametersContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .inputParameters)
        var inputParametersDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let inputParametersContainer = inputParametersContainer {
            inputParametersDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in inputParametersContainer {
                if let stepinput0 = stepinput0 {
                    inputParametersDecoded0?[key0] = stepinput0
                }
            }
        }
        inputParameters = inputParametersDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
    }
}

extension UpdateWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkflowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkflowOutputResponse(adsApplicationConfigurationId: \(Swift.String(describing: adsApplicationConfigurationId)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), stepTargets: \(Swift.String(describing: stepTargets)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), workflowInputs: \"CONTENT_REDACTED\")"}
}

extension UpdateWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adsApplicationConfigurationId = output.adsApplicationConfigurationId
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.status = output.status
            self.stepTargets = output.stepTargets
            self.tags = output.tags
            self.templateId = output.templateId
            self.workflowInputs = output.workflowInputs
        } else {
            self.adsApplicationConfigurationId = nil
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.status = nil
            self.stepTargets = nil
            self.tags = nil
            self.templateId = nil
            self.workflowInputs = nil
        }
    }
}

public struct UpdateWorkflowOutputResponse: Swift.Equatable {
    /// The ID of the application configured in Application Discovery Service.
    public var adsApplicationConfigurationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the migration workflow.
    public var arn: Swift.String?
    /// The time at which the migration workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the migration workflow.
    public var description: Swift.String?
    /// The ID of the migration workflow.
    public var id: Swift.String?
    /// The time at which the migration workflow was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the migration workflow.
    public var name: Swift.String?
    /// The status of the migration workflow.
    public var status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    /// The servers on which a step will be run.
    public var stepTargets: [Swift.String]?
    /// The tags added to the migration workflow.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The inputs required to update a migration workflow.
    public var workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?

    public init (
        adsApplicationConfigurationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum? = nil,
        stepTargets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil,
        workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
    )
    {
        self.adsApplicationConfigurationId = adsApplicationConfigurationId
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
        self.stepTargets = stepTargets
        self.tags = tags
        self.templateId = templateId
        self.workflowInputs = workflowInputs
    }
}

struct UpdateWorkflowOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let adsApplicationConfigurationId: Swift.String?
    let workflowInputs: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]?
    let stepTargets: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adsApplicationConfigurationId
        case arn
        case creationTime
        case description
        case id
        case lastModifiedTime
        case name
        case status
        case stepTargets
        case tags
        case templateId
        case workflowInputs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let adsApplicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adsApplicationConfigurationId)
        adsApplicationConfigurationId = adsApplicationConfigurationIdDecoded
        let workflowInputsContainer = try containerValues.decodeIfPresent([Swift.String: MigrationHubOrchestratorClientTypes.StepInput?].self, forKey: .workflowInputs)
        var workflowInputsDecoded0: [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]? = nil
        if let workflowInputsContainer = workflowInputsContainer {
            workflowInputsDecoded0 = [Swift.String:MigrationHubOrchestratorClientTypes.StepInput]()
            for (key0, stepinput0) in workflowInputsContainer {
                if let stepinput0 = stepinput0 {
                    workflowInputsDecoded0?[key0] = stepinput0
                }
            }
        }
        workflowInputs = workflowInputsDecoded0
        let stepTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTargets)
        var stepTargetsDecoded0:[Swift.String]? = nil
        if let stepTargetsContainer = stepTargetsContainer {
            stepTargetsDecoded0 = [Swift.String]()
            for string0 in stepTargetsContainer {
                if let string0 = string0 {
                    stepTargetsDecoded0?.append(string0)
                }
            }
        }
        stepTargets = stepTargetsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.MigrationWorkflowStatusEnum.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateWorkflowStepGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
    }
}

extension UpdateWorkflowStepGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension UpdateWorkflowStepGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflowstepgroup/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowStepGroupInput: Swift.Equatable {
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.previous = previous
        self.workflowId = workflowId
    }
}

struct UpdateWorkflowStepGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let next: [Swift.String]?
    let previous: [Swift.String]?
}

extension UpdateWorkflowStepGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case previous
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
    }
}

extension UpdateWorkflowStepGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkflowStepGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkflowStepGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkflowStepGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorkflowStepGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.next = output.next
            self.previous = output.previous
            self.tools = output.tools
            self.workflowId = output.workflowId
        } else {
            self.description = nil
            self.id = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.next = nil
            self.previous = nil
            self.tools = nil
            self.workflowId = nil
        }
    }
}

public struct UpdateWorkflowStepGroupOutputResponse: Swift.Equatable {
    /// The description of the step group.
    public var description: Swift.String?
    /// The ID of the step group.
    public var id: Swift.String?
    /// The time at which the step group was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the step group.
    public var name: Swift.String?
    /// The next step group.
    public var next: [Swift.String]?
    /// The previous step group.
    public var previous: [Swift.String]?
    /// List of AWS services utilized in a migration workflow.
    public var tools: [MigrationHubOrchestratorClientTypes.Tool]?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        previous: [Swift.String]? = nil,
        tools: [MigrationHubOrchestratorClientTypes.Tool]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.next = next
        self.previous = previous
        self.tools = tools
        self.workflowId = workflowId
    }
}

struct UpdateWorkflowStepGroupOutputResponseBody: Swift.Equatable {
    let workflowId: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let tools: [MigrationHubOrchestratorClientTypes.Tool]?
    let next: [Swift.String]?
    let previous: [Swift.String]?
    let lastModifiedTime: ClientRuntime.Date?
}

extension UpdateWorkflowStepGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case lastModifiedTime
        case name
        case next
        case previous
        case tools
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let toolsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[MigrationHubOrchestratorClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [MigrationHubOrchestratorClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension UpdateWorkflowStepInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case status
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for workflowstepoutput0 in outputs {
                try outputsContainer.encode(workflowstepoutput0)
            }
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepGroupId = self.stepGroupId {
            try encodeContainer.encode(stepGroupId, forKey: .stepGroupId)
        }
        if let stepTarget = stepTarget {
            var stepTargetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepTarget)
            for stringlistmember0 in stepTarget {
                try stepTargetContainer.encode(stringlistmember0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowStepAutomationConfiguration = self.workflowStepAutomationConfiguration {
            try encodeContainer.encode(workflowStepAutomationConfiguration, forKey: .workflowStepAutomationConfiguration)
        }
    }
}

extension UpdateWorkflowStepInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflowstep/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowStepInput: Swift.Equatable {
    /// The description of the step.
    public var description: Swift.String?
    /// The ID of the step.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The next step.
    public var next: [Swift.String]?
    /// The outputs of a step.
    public var outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    /// The previous step.
    public var previous: [Swift.String]?
    /// The status of the step.
    public var status: MigrationHubOrchestratorClientTypes.StepStatus?
    /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
    public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    /// The ID of the step group.
    /// This member is required.
    public var stepGroupId: Swift.String?
    /// The servers on which a step will be run.
    public var stepTarget: [Swift.String]?
    /// The ID of the migration workflow.
    /// This member is required.
    public var workflowId: Swift.String?
    /// The custom script to run tests on the source and target environments.
    public var workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        next: [Swift.String]? = nil,
        outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil,
        previous: [Swift.String]? = nil,
        status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
        stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
        stepGroupId: Swift.String? = nil,
        stepTarget: [Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.next = next
        self.outputs = outputs
        self.previous = previous
        self.status = status
        self.stepActionType = stepActionType
        self.stepGroupId = stepGroupId
        self.stepTarget = stepTarget
        self.workflowId = workflowId
        self.workflowStepAutomationConfiguration = workflowStepAutomationConfiguration
    }
}

struct UpdateWorkflowStepInputBody: Swift.Equatable {
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
    let workflowStepAutomationConfiguration: MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration?
    let stepTarget: [Swift.String]?
    let outputs: [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]?
    let previous: [Swift.String]?
    let next: [Swift.String]?
    let status: MigrationHubOrchestratorClientTypes.StepStatus?
}

extension UpdateWorkflowStepInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case outputs
        case previous
        case status
        case stepActionType
        case stepGroupId
        case stepTarget
        case workflowId
        case workflowStepAutomationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let workflowStepAutomationConfigurationDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration.self, forKey: .workflowStepAutomationConfiguration)
        workflowStepAutomationConfiguration = workflowStepAutomationConfigurationDecoded
        let stepTargetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stepTarget)
        var stepTargetDecoded0:[Swift.String]? = nil
        if let stepTargetContainer = stepTargetContainer {
            stepTargetDecoded0 = [Swift.String]()
            for string0 in stepTargetContainer {
                if let string0 = string0 {
                    stepTargetDecoded0?.append(string0)
                }
            }
        }
        stepTarget = stepTargetDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([MigrationHubOrchestratorClientTypes.WorkflowStepOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MigrationHubOrchestratorClientTypes.WorkflowStepOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MigrationHubOrchestratorClientTypes.WorkflowStepOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateWorkflowStepOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkflowStepOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkflowStepOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkflowStepOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorkflowStepOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.stepGroupId = output.stepGroupId
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.name = nil
            self.stepGroupId = nil
            self.workflowId = nil
        }
    }
}

public struct UpdateWorkflowStepOutputResponse: Swift.Equatable {
    /// The ID of the step.
    public var id: Swift.String?
    /// The name of the step.
    public var name: Swift.String?
    /// The ID of the step group.
    public var stepGroupId: Swift.String?
    /// The ID of the migration workflow.
    public var workflowId: Swift.String?

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        stepGroupId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.stepGroupId = stepGroupId
        self.workflowId = workflowId
    }
}

struct UpdateWorkflowStepOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let stepGroupId: Swift.String?
    let workflowId: Swift.String?
    let name: Swift.String?
}

extension UpdateWorkflowStepOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case stepGroupId
        case workflowId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stepGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepGroupId)
        stepGroupId = stepGroupIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubOrchestratorClientTypes.WorkflowStepAutomationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case runEnvironment
        case scriptLocationS3Bucket
        case scriptLocationS3Key
        case targetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let runEnvironment = self.runEnvironment {
            try encodeContainer.encode(runEnvironment.rawValue, forKey: .runEnvironment)
        }
        if let scriptLocationS3Bucket = self.scriptLocationS3Bucket {
            try encodeContainer.encode(scriptLocationS3Bucket, forKey: .scriptLocationS3Bucket)
        }
        if let scriptLocationS3Key = self.scriptLocationS3Key {
            try encodeContainer.encode(scriptLocationS3Key, forKey: .scriptLocationS3Key)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptLocationS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptLocationS3Bucket)
        scriptLocationS3Bucket = scriptLocationS3BucketDecoded
        let scriptLocationS3KeyDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformScriptKey.self, forKey: .scriptLocationS3Key)
        scriptLocationS3Key = scriptLocationS3KeyDecoded
        let commandDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.PlatformCommand.self, forKey: .command)
        command = commandDecoded
        let runEnvironmentDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.RunEnvironment.self, forKey: .runEnvironment)
        runEnvironment = runEnvironmentDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The custom script to run tests on source or target environments.
    public struct WorkflowStepAutomationConfiguration: Swift.Equatable {
        /// The command required to run the script.
        public var command: MigrationHubOrchestratorClientTypes.PlatformCommand?
        /// The source or target environment.
        public var runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment?
        /// The Amazon S3 bucket where the script is located.
        public var scriptLocationS3Bucket: Swift.String?
        /// The Amazon S3 key for the script location.
        public var scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey?
        /// The servers on which to run the script.
        public var targetType: MigrationHubOrchestratorClientTypes.TargetType?

        public init (
            command: MigrationHubOrchestratorClientTypes.PlatformCommand? = nil,
            runEnvironment: MigrationHubOrchestratorClientTypes.RunEnvironment? = nil,
            scriptLocationS3Bucket: Swift.String? = nil,
            scriptLocationS3Key: MigrationHubOrchestratorClientTypes.PlatformScriptKey? = nil,
            targetType: MigrationHubOrchestratorClientTypes.TargetType? = nil
        )
        {
            self.command = command
            self.runEnvironment = runEnvironment
            self.scriptLocationS3Bucket = scriptLocationS3Bucket
            self.scriptLocationS3Key = scriptLocationS3Key
            self.targetType = targetType
        }
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case next
        case owner
        case previous
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepGroupStatus.self, forKey: .status)
        status = statusDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of a step group in a workflow.
    public struct WorkflowStepGroupSummary: Swift.Equatable {
        /// The ID of the step group.
        public var id: Swift.String?
        /// The name of the step group.
        public var name: Swift.String?
        /// The next step group.
        public var next: [Swift.String]?
        /// The owner of the step group.
        public var owner: MigrationHubOrchestratorClientTypes.Owner?
        /// The previous step group.
        public var previous: [Swift.String]?
        /// The status of the step group.
        public var status: MigrationHubOrchestratorClientTypes.StepGroupStatus?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
            previous: [Swift.String]? = nil,
            status: MigrationHubOrchestratorClientTypes.StepGroupStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.next = next
            self.owner = owner
            self.previous = previous
            self.status = status
        }
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case name
        case `required` = "required"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let valueDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The output of a step.
    public struct WorkflowStepOutput: Swift.Equatable {
        /// The data type of the output.
        public var dataType: MigrationHubOrchestratorClientTypes.DataType?
        /// The name of the step.
        public var name: Swift.String?
        /// Determine if an output is required from a step.
        public var `required`: Swift.Bool?
        /// The value of the output.
        public var value: MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion?

        public init (
            dataType: MigrationHubOrchestratorClientTypes.DataType? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool? = nil,
            value: MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion? = nil
        )
        {
            self.dataType = dataType
            self.name = name
            self.`required` = `required`
            self.value = value
        }
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepOutputUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integervalue = "integerValue"
        case listofstringvalue = "listOfStringValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .integervalue(integervalue):
                try container.encode(integervalue, forKey: .integervalue)
            case let .listofstringvalue(listofstringvalue):
                var listofstringvalueContainer = container.nestedUnkeyedContainer(forKey: .listofstringvalue)
                for stringlistmember0 in listofstringvalue {
                    try listofstringvalueContainer.encode(stringlistmember0)
                }
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let integervalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .integervalue)
        if let integervalue = integervalueDecoded {
            self = .integervalue(integervalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let listofstringvalueContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .listofstringvalue)
        var listofstringvalueDecoded0:[Swift.String]? = nil
        if let listofstringvalueContainer = listofstringvalueContainer {
            listofstringvalueDecoded0 = [Swift.String]()
            for string0 in listofstringvalueContainer {
                if let string0 = string0 {
                    listofstringvalueDecoded0?.append(string0)
                }
            }
        }
        if let listofstringvalue = listofstringvalueDecoded0 {
            self = .listofstringvalue(listofstringvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// A structure to hold multiple values of an output.
    public enum WorkflowStepOutputUnion: Swift.Equatable {
        /// The integer value.
        case integervalue(Swift.Int)
        /// The string value.
        case stringvalue(Swift.String)
        /// The list of string value.
        case listofstringvalue([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubOrchestratorClientTypes.WorkflowStepSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case next
        case noOfSrvCompleted
        case noOfSrvFailed
        case owner
        case previous
        case scriptLocation
        case status
        case statusMessage
        case stepActionType
        case stepId
        case totalNoOfSrv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            var nextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .next)
            for stringlistmember0 in next {
                try nextContainer.encode(stringlistmember0)
            }
        }
        if let noOfSrvCompleted = self.noOfSrvCompleted {
            try encodeContainer.encode(noOfSrvCompleted, forKey: .noOfSrvCompleted)
        }
        if let noOfSrvFailed = self.noOfSrvFailed {
            try encodeContainer.encode(noOfSrvFailed, forKey: .noOfSrvFailed)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let previous = previous {
            var previousContainer = encodeContainer.nestedUnkeyedContainer(forKey: .previous)
            for stringlistmember0 in previous {
                try previousContainer.encode(stringlistmember0)
            }
        }
        if let scriptLocation = self.scriptLocation {
            try encodeContainer.encode(scriptLocation, forKey: .scriptLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let stepActionType = self.stepActionType {
            try encodeContainer.encode(stepActionType.rawValue, forKey: .stepActionType)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let totalNoOfSrv = self.totalNoOfSrv {
            try encodeContainer.encode(totalNoOfSrv, forKey: .totalNoOfSrv)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepActionTypeDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepActionType.self, forKey: .stepActionType)
        stepActionType = stepActionTypeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let previousContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .previous)
        var previousDecoded0:[Swift.String]? = nil
        if let previousContainer = previousContainer {
            previousDecoded0 = [Swift.String]()
            for string0 in previousContainer {
                if let string0 = string0 {
                    previousDecoded0?.append(string0)
                }
            }
        }
        previous = previousDecoded0
        let nextContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .next)
        var nextDecoded0:[Swift.String]? = nil
        if let nextContainer = nextContainer {
            nextDecoded0 = [Swift.String]()
            for string0 in nextContainer {
                if let string0 = string0 {
                    nextDecoded0?.append(string0)
                }
            }
        }
        next = nextDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubOrchestratorClientTypes.StepStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let noOfSrvCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvCompleted)
        noOfSrvCompleted = noOfSrvCompletedDecoded
        let noOfSrvFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noOfSrvFailed)
        noOfSrvFailed = noOfSrvFailedDecoded
        let totalNoOfSrvDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNoOfSrv)
        totalNoOfSrv = totalNoOfSrvDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scriptLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptLocation)
        scriptLocation = scriptLocationDecoded
    }
}

extension MigrationHubOrchestratorClientTypes {
    /// The summary of the step in a migration workflow.
    public struct WorkflowStepSummary: Swift.Equatable {
        /// The description of the step.
        public var description: Swift.String?
        /// The name of the step.
        public var name: Swift.String?
        /// The next step.
        public var next: [Swift.String]?
        /// The number of servers that have been migrated.
        public var noOfSrvCompleted: Swift.Int?
        /// The number of servers that have failed to migrate.
        public var noOfSrvFailed: Swift.Int?
        /// The owner of the step.
        public var owner: MigrationHubOrchestratorClientTypes.Owner?
        /// The previous step.
        public var previous: [Swift.String]?
        /// The location of the script.
        public var scriptLocation: Swift.String?
        /// The status of the step.
        public var status: MigrationHubOrchestratorClientTypes.StepStatus?
        /// The status message of the migration workflow.
        public var statusMessage: Swift.String?
        /// The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.
        public var stepActionType: MigrationHubOrchestratorClientTypes.StepActionType?
        /// The ID of the step.
        public var stepId: Swift.String?
        /// The total number of servers that have been migrated.
        public var totalNoOfSrv: Swift.Int?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            next: [Swift.String]? = nil,
            noOfSrvCompleted: Swift.Int? = nil,
            noOfSrvFailed: Swift.Int? = nil,
            owner: MigrationHubOrchestratorClientTypes.Owner? = nil,
            previous: [Swift.String]? = nil,
            scriptLocation: Swift.String? = nil,
            status: MigrationHubOrchestratorClientTypes.StepStatus? = nil,
            statusMessage: Swift.String? = nil,
            stepActionType: MigrationHubOrchestratorClientTypes.StepActionType? = nil,
            stepId: Swift.String? = nil,
            totalNoOfSrv: Swift.Int? = nil
        )
        {
            self.description = description
            self.name = name
            self.next = next
            self.noOfSrvCompleted = noOfSrvCompleted
            self.noOfSrvFailed = noOfSrvFailed
            self.owner = owner
            self.previous = previous
            self.scriptLocation = scriptLocation
            self.status = status
            self.statusMessage = statusMessage
            self.stepActionType = stepActionType
            self.stepId = stepId
            self.totalNoOfSrv = totalNoOfSrv
        }
    }

}
