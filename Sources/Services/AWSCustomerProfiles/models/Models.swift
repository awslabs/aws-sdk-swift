// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddProfileKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string1to2550 in values {
                try valuesContainer.encode(string1to2550)
            }
        }
    }
}

extension AddProfileKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/keys"
    }
}

public struct AddProfileKeyInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile. The predefined keys you can use include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
    /// This member is required.
    public var keyName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

struct AddProfileKeyInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let keyName: Swift.String?
    let values: [Swift.String]?
}

extension AddProfileKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AddProfileKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddProfileKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyName = output.keyName
            self.values = output.values
        } else {
            self.keyName = nil
            self.values = nil
        }
    }
}

public struct AddProfileKeyOutput: Swift.Equatable {
    /// A searchable identifier of a customer profile.
    public var keyName: Swift.String?
    /// A list of key values.
    public var values: [Swift.String]?

    public init(
        keyName: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.keyName = keyName
        self.values = values
    }
}

struct AddProfileKeyOutputBody: Swift.Equatable {
    let keyName: Swift.String?
    let values: [Swift.String]?
}

extension AddProfileKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

enum AddProfileKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.AdditionalSearchKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string1to2550 in values {
                try valuesContainer.encode(string1to2550)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// A data type pair that consists of a KeyName and Values list that is used in conjunction with the [KeyName](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html#customerprofiles-SearchProfiles-request-KeyName) and [Values](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html#customerprofiles-SearchProfiles-request-Values) parameters to search for profiles using the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) API.
    public struct AdditionalSearchKey: Swift.Equatable {
        /// A searchable identifier of a customer profile.
        /// This member is required.
        public var keyName: Swift.String?
        /// A list of key values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.keyName = keyName
            self.values = values
        }
    }

}

extension CustomerProfilesClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address1 = "Address1"
        case address2 = "Address2"
        case address3 = "Address3"
        case address4 = "Address4"
        case city = "City"
        case country = "Country"
        case county = "County"
        case postalCode = "PostalCode"
        case province = "Province"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address1 = self.address1 {
            try encodeContainer.encode(address1, forKey: .address1)
        }
        if let address2 = self.address2 {
            try encodeContainer.encode(address2, forKey: .address2)
        }
        if let address3 = self.address3 {
            try encodeContainer.encode(address3, forKey: .address3)
        }
        if let address4 = self.address4 {
            try encodeContainer.encode(address4, forKey: .address4)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let county = self.county {
            try encodeContainer.encode(county, forKey: .county)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let province = self.province {
            try encodeContainer.encode(province, forKey: .province)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let address1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address1)
        address1 = address1Decoded
        let address2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address2)
        address2 = address2Decoded
        let address3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address3)
        address3 = address3Decoded
        let address4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address4)
        address4 = address4Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let countyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .county)
        county = countyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let provinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .province)
        province = provinceDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension CustomerProfilesClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public struct Address: Swift.Equatable {
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            province: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }

}

extension CustomerProfilesClientTypes.AppflowIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batches = "Batches"
        case flowDefinition = "FlowDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batches = batches {
            var batchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .batches)
            for batch0 in batches {
                try batchesContainer.encode(batch0)
            }
        }
        if let flowDefinition = self.flowDefinition {
            try encodeContainer.encode(flowDefinition, forKey: .flowDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDefinitionDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.FlowDefinition.self, forKey: .flowDefinition)
        flowDefinition = flowDefinitionDecoded
        let batchesContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.Batch?].self, forKey: .batches)
        var batchesDecoded0:[CustomerProfilesClientTypes.Batch]? = nil
        if let batchesContainer = batchesContainer {
            batchesDecoded0 = [CustomerProfilesClientTypes.Batch]()
            for structure0 in batchesContainer {
                if let structure0 = structure0 {
                    batchesDecoded0?.append(structure0)
                }
            }
        }
        batches = batchesDecoded0
    }
}

extension CustomerProfilesClientTypes.AppflowIntegration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppflowIntegration(batches: \(Swift.String(describing: batches)), flowDefinition: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {
    /// Details for workflow of type APPFLOW_INTEGRATION.
    public struct AppflowIntegration: Swift.Equatable {
        /// Batches in workflow of type APPFLOW_INTEGRATION.
        public var batches: [CustomerProfilesClientTypes.Batch]?
        /// The configurations that control how Customer Profiles retrieves data from the source, Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of customers.
        /// This member is required.
        public var flowDefinition: CustomerProfilesClientTypes.FlowDefinition?

        public init(
            batches: [CustomerProfilesClientTypes.Batch]? = nil,
            flowDefinition: CustomerProfilesClientTypes.FlowDefinition? = nil
        )
        {
            self.batches = batches
            self.flowDefinition = flowDefinition
        }
    }

}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName = "ConnectorProfileName"
        case roleArn = "RoleArn"
        case sourceConnectorType = "SourceConnectorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sourceConnectorType = self.sourceConnectorType {
            try encodeContainer.encode(sourceConnectorType.rawValue, forKey: .sourceConnectorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceConnectorTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.SourceConnectorType.self, forKey: .sourceConnectorType)
        sourceConnectorType = sourceConnectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Structure holding all APPFLOW_INTEGRATION specific workflow attributes.
    public struct AppflowIntegrationWorkflowAttributes: Swift.Equatable {
        /// The name of the AppFlow connector profile used for ingestion.
        /// This member is required.
        public var connectorProfileName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
        public var roleArn: Swift.String?
        /// Specifies the source connector type, such as Salesforce, ServiceNow, and Marketo. Indicates source of ingestion.
        /// This member is required.
        public var sourceConnectorType: CustomerProfilesClientTypes.SourceConnectorType?

        public init(
            connectorProfileName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sourceConnectorType: CustomerProfilesClientTypes.SourceConnectorType? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.roleArn = roleArn
            self.sourceConnectorType = sourceConnectorType
        }
    }

}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordsProcessed = "RecordsProcessed"
        case stepsCompleted = "StepsCompleted"
        case totalSteps = "TotalSteps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if recordsProcessed != 0 {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
        if stepsCompleted != 0 {
            try encodeContainer.encode(stepsCompleted, forKey: .stepsCompleted)
        }
        if totalSteps != 0 {
            try encodeContainer.encode(totalSteps, forKey: .totalSteps)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed) ?? 0
        recordsProcessed = recordsProcessedDecoded
        let stepsCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stepsCompleted) ?? 0
        stepsCompleted = stepsCompletedDecoded
        let totalStepsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSteps) ?? 0
        totalSteps = totalStepsDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Workflow specific execution metrics for APPFLOW_INTEGRATION workflow.
    public struct AppflowIntegrationWorkflowMetrics: Swift.Equatable {
        /// Number of records processed in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var recordsProcessed: Swift.Int
        /// Total steps completed in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var stepsCompleted: Swift.Int
        /// Total steps in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var totalSteps: Swift.Int

        public init(
            recordsProcessed: Swift.Int = 0,
            stepsCompleted: Swift.Int = 0,
            totalSteps: Swift.Int = 0
        )
        {
            self.recordsProcessed = recordsProcessed
            self.stepsCompleted = stepsCompleted
            self.totalSteps = totalSteps
        }
    }

}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchRecordsEndTime = "BatchRecordsEndTime"
        case batchRecordsStartTime = "BatchRecordsStartTime"
        case createdAt = "CreatedAt"
        case executionMessage = "ExecutionMessage"
        case flowName = "FlowName"
        case lastUpdatedAt = "LastUpdatedAt"
        case recordsProcessed = "RecordsProcessed"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchRecordsEndTime = self.batchRecordsEndTime {
            try encodeContainer.encode(batchRecordsEndTime, forKey: .batchRecordsEndTime)
        }
        if let batchRecordsStartTime = self.batchRecordsStartTime {
            try encodeContainer.encode(batchRecordsStartTime, forKey: .batchRecordsStartTime)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let executionMessage = self.executionMessage {
            try encodeContainer.encode(executionMessage, forKey: .executionMessage)
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if recordsProcessed != 0 {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let executionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionMessage)
        executionMessage = executionMessageDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed) ?? 0
        recordsProcessed = recordsProcessedDecoded
        let batchRecordsStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchRecordsStartTime)
        batchRecordsStartTime = batchRecordsStartTimeDecoded
        let batchRecordsEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchRecordsEndTime)
        batchRecordsEndTime = batchRecordsEndTimeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Workflow step details for APPFLOW_INTEGRATION workflow.
    public struct AppflowIntegrationWorkflowStep: Swift.Equatable {
        /// End datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var batchRecordsEndTime: Swift.String?
        /// Start datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var batchRecordsStartTime: Swift.String?
        /// Creation timestamp of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Message indicating execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var executionMessage: Swift.String?
        /// Name of the flow created during execution of workflow step. APPFLOW_INTEGRATION workflow type creates an appflow flow during workflow step execution on the customers behalf.
        /// This member is required.
        public var flowName: Swift.String?
        /// Last updated timestamp for workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Total number of records processed during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var recordsProcessed: Swift.Int
        /// Workflow step status for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.Status?

        public init(
            batchRecordsEndTime: Swift.String? = nil,
            batchRecordsStartTime: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            executionMessage: Swift.String? = nil,
            flowName: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            recordsProcessed: Swift.Int = 0,
            status: CustomerProfilesClientTypes.Status? = nil
        )
        {
            self.batchRecordsEndTime = batchRecordsEndTime
            self.batchRecordsStartTime = batchRecordsStartTime
            self.createdAt = createdAt
            self.executionMessage = executionMessage
            self.flowName = flowName
            self.lastUpdatedAt = lastUpdatedAt
            self.recordsProcessed = recordsProcessed
            self.status = status
        }
    }

}

extension CustomerProfilesClientTypes.AttributeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributeitem0 in attributes {
                try attributesContainer.encode(attributeitem0)
            }
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.AttributeItem?].self, forKey: .attributes)
        var attributesDecoded0:[CustomerProfilesClientTypes.AttributeItem]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CustomerProfilesClientTypes.AttributeItem]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension CustomerProfilesClientTypes.AttributeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public struct AttributeDetails: Swift.Equatable {
        /// A list of attribute items specified in the mathematical expression.
        /// This member is required.
        public var attributes: [CustomerProfilesClientTypes.AttributeItem]?
        /// Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \"{ObjectTypeName.AttributeName}\".
        /// This member is required.
        public var expression: Swift.String?

        public init(
            attributes: [CustomerProfilesClientTypes.AttributeItem]? = nil,
            expression: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.expression = expression
        }
    }

}

extension CustomerProfilesClientTypes.AttributeItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The details of a single attribute item specified in the mathematical expression.
    public struct AttributeItem: Swift.Equatable {
        /// The name of an attribute defined in a profile object type.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum AttributeMatchingModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeMatchingModel(rawValue: rawValue) ?? AttributeMatchingModel.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.AttributeTypesSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case attributeMatchingModel = "AttributeMatchingModel"
        case emailAddress = "EmailAddress"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            var addressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .address)
            for string1to2550 in address {
                try addressContainer.encode(string1to2550)
            }
        }
        if let attributeMatchingModel = self.attributeMatchingModel {
            try encodeContainer.encode(attributeMatchingModel.rawValue, forKey: .attributeMatchingModel)
        }
        if let emailAddress = emailAddress {
            var emailAddressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailAddress)
            for string1to2550 in emailAddress {
                try emailAddressContainer.encode(string1to2550)
            }
        }
        if let phoneNumber = phoneNumber {
            var phoneNumberContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumber)
            for string1to2550 in phoneNumber {
                try phoneNumberContainer.encode(string1to2550)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeMatchingModelDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeMatchingModel.self, forKey: .attributeMatchingModel)
        attributeMatchingModel = attributeMatchingModelDecoded
        let addressContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .address)
        var addressDecoded0:[Swift.String]? = nil
        if let addressContainer = addressContainer {
            addressDecoded0 = [Swift.String]()
            for string0 in addressContainer {
                if let string0 = string0 {
                    addressDecoded0?.append(string0)
                }
            }
        }
        address = addressDecoded0
        let phoneNumberContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumber)
        var phoneNumberDecoded0:[Swift.String]? = nil
        if let phoneNumberContainer = phoneNumberContainer {
            phoneNumberDecoded0 = [Swift.String]()
            for string0 in phoneNumberContainer {
                if let string0 = string0 {
                    phoneNumberDecoded0?.append(string0)
                }
            }
        }
        phoneNumber = phoneNumberDecoded0
        let emailAddressContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .emailAddress)
        var emailAddressDecoded0:[Swift.String]? = nil
        if let emailAddressContainer = emailAddressContainer {
            emailAddressDecoded0 = [Swift.String]()
            for string0 in emailAddressContainer {
                if let string0 = string0 {
                    emailAddressDecoded0?.append(string0)
                }
            }
        }
        emailAddress = emailAddressDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// Configuration information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles. You can choose how profiles are compared across attribute types and which attribute to use for matching from each type. There are three attribute types you can configure:
    ///
    /// * Email type
    ///
    /// * You can choose from Email, BusinessEmail, and PersonalEmail
    ///
    ///
    ///
    ///
    /// * Phone number type
    ///
    /// * You can choose from Phone, HomePhone, and MobilePhone
    ///
    ///
    ///
    ///
    /// * Address type
    ///
    /// * You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress
    ///
    ///
    ///
    ///
    ///
    /// You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attribute across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
    public struct AttributeTypesSelector: Swift.Equatable {
        /// The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        public var address: [Swift.String]?
        /// Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        /// This member is required.
        public var attributeMatchingModel: CustomerProfilesClientTypes.AttributeMatchingModel?
        /// The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        public var emailAddress: [Swift.String]?
        /// The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        public var phoneNumber: [Swift.String]?

        public init(
            address: [Swift.String]? = nil,
            attributeMatchingModel: CustomerProfilesClientTypes.AttributeMatchingModel? = nil,
            emailAddress: [Swift.String]? = nil,
            phoneNumber: [Swift.String]? = nil
        )
        {
            self.address = address
            self.attributeMatchingModel = attributeMatchingModel
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }
    }

}

extension CustomerProfilesClientTypes.AutoMerging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResolution = "ConflictResolution"
        case consolidation = "Consolidation"
        case enabled = "Enabled"
        case minAllowedConfidenceScoreForMerging = "MinAllowedConfidenceScoreForMerging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let consolidation = self.consolidation {
            try encodeContainer.encode(consolidation, forKey: .consolidation)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let minAllowedConfidenceScoreForMerging = self.minAllowedConfidenceScoreForMerging {
            try encodeContainer.encode(minAllowedConfidenceScoreForMerging, forKey: .minAllowedConfidenceScoreForMerging)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let consolidationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Consolidation.self, forKey: .consolidation)
        consolidation = consolidationDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let minAllowedConfidenceScoreForMergingDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minAllowedConfidenceScoreForMerging)
        minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMergingDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Configuration settings for how to perform the auto-merging of profiles.
    public struct AutoMerging: Swift.Equatable {
        /// How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used?
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        public var consolidation: CustomerProfilesClientTypes.Consolidation?
        /// The flag that enables the auto-merging of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        public var minAllowedConfidenceScoreForMerging: Swift.Double?

        public init(
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            consolidation: CustomerProfilesClientTypes.Consolidation? = nil,
            enabled: Swift.Bool? = nil,
            minAllowedConfidenceScoreForMerging: Swift.Double? = nil
        )
        {
            self.conflictResolution = conflictResolution
            self.consolidation = consolidation
            self.enabled = enabled
            self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input you provided is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomerProfilesClientTypes.Batch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Batch defines the boundaries for ingestion for each step in APPFLOW_INTEGRATION workflow. APPFLOW_INTEGRATION workflow splits ingestion based on these boundaries.
    public struct Batch: Swift.Equatable {
        /// End time of batch to split ingestion.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// Start time of batch to split ingestion.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension CustomerProfilesClientTypes.Conditions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectCount = "ObjectCount"
        case range = "Range"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectCount = self.objectCount {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if let range = self.range {
            try encodeContainer.encode(range, forKey: .range)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Range.self, forKey: .range)
        range = rangeDecoded
        let objectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Threshold.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension CustomerProfilesClientTypes.Conditions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public struct Conditions: Swift.Equatable {
        /// The number of profile objects used for the calculated attribute.
        public var objectCount: Swift.Int?
        /// The relative time period over which data is included in the aggregation.
        public var range: CustomerProfilesClientTypes.Range?
        /// The threshold for the calculated attribute.
        public var threshold: CustomerProfilesClientTypes.Threshold?

        public init(
            objectCount: Swift.Int? = nil,
            range: CustomerProfilesClientTypes.Range? = nil,
            threshold: CustomerProfilesClientTypes.Threshold? = nil
        )
        {
            self.objectCount = objectCount
            self.range = range
            self.threshold = threshold
        }
    }

}

extension CustomerProfilesClientTypes.ConflictResolution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResolvingModel = "ConflictResolvingModel"
        case sourceName = "SourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictResolvingModel = self.conflictResolvingModel {
            try encodeContainer.encode(conflictResolvingModel.rawValue, forKey: .conflictResolvingModel)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictResolvingModelDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ConflictResolvingModel.self, forKey: .conflictResolvingModel)
        conflictResolvingModel = conflictResolvingModelDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// How the auto-merging process should resolve conflicts between different profiles.
    public struct ConflictResolution: Swift.Equatable {
        /// How the auto-merging process should resolve conflicts between different profiles.
        ///
        /// * RECENCY: Uses the data that was most recently updated.
        ///
        /// * SOURCE: Uses the data from a specific source. For example, if a company has been aquired or two departments have merged, data from the specified source is used. If two duplicate profiles are from the same source, then RECENCY is used again.
        /// This member is required.
        public var conflictResolvingModel: CustomerProfilesClientTypes.ConflictResolvingModel?
        /// The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        public var sourceName: Swift.String?

        public init(
            conflictResolvingModel: CustomerProfilesClientTypes.ConflictResolvingModel? = nil,
            sourceName: Swift.String? = nil
        )
        {
            self.conflictResolvingModel = conflictResolvingModel
            self.sourceName = sourceName
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum ConflictResolvingModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case recency
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictResolvingModel] {
            return [
                .recency,
                .source,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .recency: return "RECENCY"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictResolvingModel(rawValue: rawValue) ?? ConflictResolvingModel.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.ConnectorOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo.rawValue, forKey: .marketo)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3.rawValue, forKey: .s3)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce.rawValue, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow.rawValue, forKey: .serviceNow)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk.rawValue, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let marketoDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MarketoConnectorOperator.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.S3ConnectorOperator.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.SalesforceConnectorOperator.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ServiceNowConnectorOperator.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ZendeskConnectorOperator.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The operation to be performed on the provided source fields.
    public struct ConnectorOperator: Swift.Equatable {
        /// The operation to be performed on the provided Marketo source fields.
        public var marketo: CustomerProfilesClientTypes.MarketoConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public var s3: CustomerProfilesClientTypes.S3ConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public var salesforce: CustomerProfilesClientTypes.SalesforceConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public var serviceNow: CustomerProfilesClientTypes.ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public var zendesk: CustomerProfilesClientTypes.ZendeskConnectorOperator?

        public init(
            marketo: CustomerProfilesClientTypes.MarketoConnectorOperator? = nil,
            s3: CustomerProfilesClientTypes.S3ConnectorOperator? = nil,
            salesforce: CustomerProfilesClientTypes.SalesforceConnectorOperator? = nil,
            serviceNow: CustomerProfilesClientTypes.ServiceNowConnectorOperator? = nil,
            zendesk: CustomerProfilesClientTypes.ZendeskConnectorOperator? = nil
        )
        {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }
    }

}

extension CustomerProfilesClientTypes.Consolidation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchingAttributesList = "MatchingAttributesList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchingAttributesList = matchingAttributesList {
            var matchingAttributesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingAttributesList)
            for matchingattributes0 in matchingAttributesList {
                var matchingattributes0Container = matchingAttributesListContainer.nestedUnkeyedContainer()
                for string1to2551 in matchingattributes0 {
                    try matchingattributes0Container.encode(string1to2551)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchingAttributesListContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .matchingAttributesList)
        var matchingAttributesListDecoded0:[[Swift.String]]? = nil
        if let matchingAttributesListContainer = matchingAttributesListContainer {
            matchingAttributesListDecoded0 = [[Swift.String]]()
            for list0 in matchingAttributesListContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    matchingAttributesListDecoded0?.append(list0Decoded0)
                }
            }
        }
        matchingAttributesList = matchingAttributesListDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// The matching criteria to be used during the auto-merging process.
    public struct Consolidation: Swift.Equatable {
        /// A list of matching criteria.
        /// This member is required.
        public var matchingAttributesList: [[Swift.String]]?

        public init(
            matchingAttributesList: [[Swift.String]]? = nil
        )
        {
            self.matchingAttributesList = matchingAttributesList
        }
    }

}

extension CreateCalculatedAttributeDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCalculatedAttributeDefinitionInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension CreateCalculatedAttributeDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDetails = "AttributeDetails"
        case conditions = "Conditions"
        case description = "Description"
        case displayName = "DisplayName"
        case statistic = "Statistic"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDetails = self.attributeDetails {
            try encodeContainer.encode(attributeDetails, forKey: .attributeDetails)
        }
        if let conditions = self.conditions {
            try encodeContainer.encode(conditions, forKey: .conditions)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCalculatedAttributeDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let calculatedAttributeName = calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

public struct CreateCalculatedAttributeDefinitionInput: Swift.Equatable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    /// This member is required.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The aggregation operation to perform for the calculated attribute.
    /// This member is required.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
        self.statistic = statistic
        self.tags = tags
    }
}

struct CreateCalculatedAttributeDefinitionInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    let conditions: CustomerProfilesClientTypes.Conditions?
    let statistic: CustomerProfilesClientTypes.Statistic?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCalculatedAttributeDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDetails = "AttributeDetails"
        case conditions = "Conditions"
        case description = "Description"
        case displayName = "DisplayName"
        case statistic = "Statistic"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributeDetailsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeDetails.self, forKey: .attributeDetails)
        attributeDetails = attributeDetailsDecoded
        let conditionsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension CreateCalculatedAttributeDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCalculatedAttributeDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeDetails = output.attributeDetails
            self.calculatedAttributeName = output.calculatedAttributeName
            self.conditions = output.conditions
            self.createdAt = output.createdAt
            self.description = output.description
            self.displayName = output.displayName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.statistic = output.statistic
            self.tags = output.tags
        } else {
            self.attributeDetails = nil
            self.calculatedAttributeName = nil
            self.conditions = nil
            self.createdAt = nil
            self.description = nil
            self.displayName = nil
            self.lastUpdatedAt = nil
            self.statistic = nil
            self.tags = nil
        }
    }
}

public struct CreateCalculatedAttributeDefinitionOutput: Swift.Equatable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.statistic = statistic
        self.tags = tags
    }
}

struct CreateCalculatedAttributeDefinitionOutputBody: Swift.Equatable {
    let calculatedAttributeName: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    let conditions: CustomerProfilesClientTypes.Conditions?
    let statistic: CustomerProfilesClientTypes.Statistic?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCalculatedAttributeDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDetails = "AttributeDetails"
        case calculatedAttributeName = "CalculatedAttributeName"
        case conditions = "Conditions"
        case createdAt = "CreatedAt"
        case description = "Description"
        case displayName = "DisplayName"
        case lastUpdatedAt = "LastUpdatedAt"
        case statistic = "Statistic"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatedAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatedAttributeName)
        calculatedAttributeName = calculatedAttributeNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributeDetailsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeDetails.self, forKey: .attributeDetails)
        attributeDetails = attributeDetailsDecoded
        let conditionsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateCalculatedAttributeDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterQueueUrl = self.deadLetterQueueUrl {
            try encodeContainer.encode(deadLetterQueueUrl, forKey: .deadLetterQueueUrl)
        }
        if let defaultEncryptionKey = self.defaultEncryptionKey {
            try encodeContainer.encode(defaultEncryptionKey, forKey: .defaultEncryptionKey)
        }
        if let defaultExpirationDays = self.defaultExpirationDays {
            try encodeContainer.encode(defaultExpirationDays, forKey: .defaultExpirationDays)
        }
        if let matching = self.matching {
            try encodeContainer.encode(matching, forKey: .matching)
        }
        if let ruleBasedMatching = self.ruleBasedMatching {
            try encodeContainer.encode(ruleBasedMatching, forKey: .ruleBasedMatching)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    /// This member is required.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingRequest?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        matching: CustomerProfilesClientTypes.MatchingRequest? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let defaultExpirationDays: Swift.Int?
    let defaultEncryptionKey: Swift.String?
    let deadLetterQueueUrl: Swift.String?
    let matching: CustomerProfilesClientTypes.MatchingRequest?
    let ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchingRequest.self, forKey: .matching)
        matching = matchingDecoded
        let ruleBasedMatchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.RuleBasedMatchingRequest.self, forKey: .ruleBasedMatching)
        ruleBasedMatching = ruleBasedMatchingDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.deadLetterQueueUrl = output.deadLetterQueueUrl
            self.defaultEncryptionKey = output.defaultEncryptionKey
            self.defaultExpirationDays = output.defaultExpirationDays
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.matching = output.matching
            self.ruleBasedMatching = output.ruleBasedMatching
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deadLetterQueueUrl = nil
            self.defaultEncryptionKey = nil
            self.defaultExpirationDays = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.matching = nil
            self.ruleBasedMatching = nil
            self.tags = nil
        }
    }
}

public struct CreateDomainOutput: Swift.Equatable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    /// This member is required.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

struct CreateDomainOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let defaultExpirationDays: Swift.Int?
    let defaultEncryptionKey: Swift.String?
    let deadLetterQueueUrl: Swift.String?
    let matching: CustomerProfilesClientTypes.MatchingResponse?
    let ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchingResponse.self, forKey: .matching)
        matching = matchingDecoded
        let ruleBasedMatchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.RuleBasedMatchingResponse.self, forKey: .ruleBasedMatching)
        ruleBasedMatching = ruleBasedMatchingDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension CreateEventStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let eventStreamName = eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

public struct CreateEventStreamInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream.
    /// This member is required.
    public var eventStreamName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
        self.tags = tags
        self.uri = uri
    }
}

struct CreateEventStreamInputBody: Swift.Equatable {
    let uri: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEventStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case uri = "Uri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventStreamArn = output.eventStreamArn
            self.tags = output.tags
        } else {
            self.eventStreamArn = nil
            self.tags = nil
        }
    }
}

public struct CreateEventStreamOutput: Swift.Equatable {
    /// A unique identifier for the event stream.
    /// This member is required.
    public var eventStreamArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        eventStreamArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.eventStreamArn = eventStreamArn
        self.tags = tags
    }
}

struct CreateEventStreamOutputBody: Swift.Equatable {
    let eventStreamArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEventStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventStreamArn = "EventStreamArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventStreamArn)
        eventStreamArn = eventStreamArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateEventStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIntegrationWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationConfig = "IntegrationConfig"
        case objectTypeName = "ObjectTypeName"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case workflowType = "WorkflowType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integrationConfig = self.integrationConfig {
            try encodeContainer.encode(integrationConfig, forKey: .integrationConfig)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowType = self.workflowType {
            try encodeContainer.encode(workflowType.rawValue, forKey: .workflowType)
        }
    }
}

extension CreateIntegrationWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/integrations"
    }
}

public struct CreateIntegrationWorkflowInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration data for integration workflow.
    /// This member is required.
    public var integrationConfig: CustomerProfilesClientTypes.IntegrationConfig?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    /// This member is required.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        domainName: Swift.String? = nil,
        integrationConfig: CustomerProfilesClientTypes.IntegrationConfig? = nil,
        objectTypeName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.domainName = domainName
        self.integrationConfig = integrationConfig
        self.objectTypeName = objectTypeName
        self.roleArn = roleArn
        self.tags = tags
        self.workflowType = workflowType
    }
}

struct CreateIntegrationWorkflowInputBody: Swift.Equatable {
    let workflowType: CustomerProfilesClientTypes.WorkflowType?
    let integrationConfig: CustomerProfilesClientTypes.IntegrationConfig?
    let objectTypeName: Swift.String?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIntegrationWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationConfig = "IntegrationConfig"
        case objectTypeName = "ObjectTypeName"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case workflowType = "WorkflowType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let integrationConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.IntegrationConfig.self, forKey: .integrationConfig)
        integrationConfig = integrationConfigDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIntegrationWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIntegrationWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.workflowId = output.workflowId
        } else {
            self.message = nil
            self.workflowId = nil
        }
    }
}

public struct CreateIntegrationWorkflowOutput: Swift.Equatable {
    /// A message indicating create request was received.
    /// This member is required.
    public var message: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        message: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.message = message
        self.workflowId = workflowId
    }
}

struct CreateIntegrationWorkflowOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let message: Swift.String?
}

extension CreateIntegrationWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum CreateIntegrationWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileInput(domainName: \(Swift.String(describing: domainName)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case genderString = "GenderString"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case partyTypeString = "PartyTypeString"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = self.accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = self.additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = self.billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = self.birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = self.businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = self.businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = self.gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let genderString = self.genderString {
            try encodeContainer.encode(genderString, forKey: .genderString)
        }
        if let homePhoneNumber = self.homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = self.mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = self.middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = self.mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = self.partyType {
            try encodeContainer.encode(partyType.rawValue, forKey: .partyType)
        }
        if let partyTypeString = self.partyTypeString {
            try encodeContainer.encode(partyTypeString, forKey: .partyTypeString)
        }
        if let personalEmailAddress = self.personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// A unique account number that you have given to the customer.
    public var accountNumber: Swift.String?
    /// Any additional information relevant to the customers profile.
    public var additionalInformation: Swift.String?
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public var address: CustomerProfilesClientTypes.Address?
    /// A key value pair of attributes of a customer profile.
    public var attributes: [Swift.String:Swift.String]?
    /// The customers billing address.
    public var billingAddress: CustomerProfilesClientTypes.Address?
    /// The customers birth date.
    public var birthDate: Swift.String?
    /// The customers business email address.
    public var businessEmailAddress: Swift.String?
    /// The name of the customers business.
    public var businessName: Swift.String?
    /// The customers business phone number.
    public var businessPhoneNumber: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customers email address, which has not been specified as a personal or business address.
    public var emailAddress: Swift.String?
    /// The customers first name.
    public var firstName: Swift.String?
    /// The gender with which the customer identifies.
    @available(*, deprecated)
    public var gender: CustomerProfilesClientTypes.Gender?
    /// An alternative to Gender which accepts any string as input.
    public var genderString: Swift.String?
    /// The customers home phone number.
    public var homePhoneNumber: Swift.String?
    /// The customers last name.
    public var lastName: Swift.String?
    /// The customers mailing address.
    public var mailingAddress: CustomerProfilesClientTypes.Address?
    /// The customers middle name.
    public var middleName: Swift.String?
    /// The customers mobile phone number.
    public var mobilePhoneNumber: Swift.String?
    /// The type of profile used to describe the customer.
    @available(*, deprecated)
    public var partyType: CustomerProfilesClientTypes.PartyType?
    /// An alternative to PartyType which accepts any string as input.
    public var partyTypeString: Swift.String?
    /// The customers personal email address.
    public var personalEmailAddress: Swift.String?
    /// The customers phone number, which has not been specified as a mobile, home, or business number.
    public var phoneNumber: Swift.String?
    /// The customers shipping address.
    public var shippingAddress: CustomerProfilesClientTypes.Address?

    public init(
        accountNumber: Swift.String? = nil,
        additionalInformation: Swift.String? = nil,
        address: CustomerProfilesClientTypes.Address? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        billingAddress: CustomerProfilesClientTypes.Address? = nil,
        birthDate: Swift.String? = nil,
        businessEmailAddress: Swift.String? = nil,
        businessName: Swift.String? = nil,
        businessPhoneNumber: Swift.String? = nil,
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        gender: CustomerProfilesClientTypes.Gender? = nil,
        genderString: Swift.String? = nil,
        homePhoneNumber: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailingAddress: CustomerProfilesClientTypes.Address? = nil,
        middleName: Swift.String? = nil,
        mobilePhoneNumber: Swift.String? = nil,
        partyType: CustomerProfilesClientTypes.PartyType? = nil,
        partyTypeString: Swift.String? = nil,
        personalEmailAddress: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        shippingAddress: CustomerProfilesClientTypes.Address? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.genderString = genderString
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.partyTypeString = partyTypeString
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.shippingAddress = shippingAddress
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let accountNumber: Swift.String?
    let additionalInformation: Swift.String?
    let partyType: CustomerProfilesClientTypes.PartyType?
    let businessName: Swift.String?
    let firstName: Swift.String?
    let middleName: Swift.String?
    let lastName: Swift.String?
    let birthDate: Swift.String?
    let gender: CustomerProfilesClientTypes.Gender?
    let phoneNumber: Swift.String?
    let mobilePhoneNumber: Swift.String?
    let homePhoneNumber: Swift.String?
    let businessPhoneNumber: Swift.String?
    let emailAddress: Swift.String?
    let personalEmailAddress: Swift.String?
    let businessEmailAddress: Swift.String?
    let address: CustomerProfilesClientTypes.Address?
    let shippingAddress: CustomerProfilesClientTypes.Address?
    let mailingAddress: CustomerProfilesClientTypes.Address?
    let billingAddress: CustomerProfilesClientTypes.Address?
    let attributes: [Swift.String:Swift.String]?
    let partyTypeString: Swift.String?
    let genderString: Swift.String?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case genderString = "GenderString"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case partyTypeString = "PartyTypeString"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case shippingAddress = "ShippingAddress"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.PartyType.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Gender.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string1to2550) in attributesContainer {
                if let string1to2550 = string1to2550 {
                    attributesDecoded0?[key0] = string1to2550
                }
            }
        }
        attributes = attributesDecoded0
        let partyTypeStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partyTypeString)
        partyTypeString = partyTypeStringDecoded
        let genderStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .genderString)
        genderString = genderStringDecoded
    }
}

extension CreateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct CreateProfileOutput: Swift.Equatable {
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct CreateProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension CreateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

enum CreateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum DataPullMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataPullMode(rawValue: rawValue) ?? DataPullMode.sdkUnknown(rawValue)
        }
    }
}

extension DeleteCalculatedAttributeDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let calculatedAttributeName = calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

public struct DeleteCalculatedAttributeDefinitionInput: Swift.Equatable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
    }
}

struct DeleteCalculatedAttributeDefinitionInputBody: Swift.Equatable {
}

extension DeleteCalculatedAttributeDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCalculatedAttributeDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCalculatedAttributeDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCalculatedAttributeDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteDomainOutput: Swift.Equatable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteDomainOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let eventStreamName = eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

public struct DeleteEventStreamInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream
    /// This member is required.
    public var eventStreamName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
    }
}

struct DeleteEventStreamInputBody: Swift.Equatable {
}

extension DeleteEventStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventStreamOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension DeleteIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations/delete"
    }
}

public struct DeleteIntegrationInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.uri = uri
    }
}

struct DeleteIntegrationInputBody: Swift.Equatable {
    let uri: Swift.String?
}

extension DeleteIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension DeleteIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteIntegrationOutput: Swift.Equatable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteIntegrationOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/delete"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension DeleteProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension DeleteProfileKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string1to2550 in values {
                try valuesContainer.encode(string1to2550)
            }
        }
    }
}

extension DeleteProfileKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/keys/delete"
    }
}

public struct DeleteProfileKeyInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile.
    /// This member is required.
    public var keyName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

struct DeleteProfileKeyInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let keyName: Swift.String?
    let values: [Swift.String]?
}

extension DeleteProfileKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case profileId = "ProfileId"
        case values = "Values"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeleteProfileKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProfileKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileKeyOutput: Swift.Equatable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileKeyOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteProfileKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteProfileKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let profileObjectUniqueKey = self.profileObjectUniqueKey {
            try encodeContainer.encode(profileObjectUniqueKey, forKey: .profileObjectUniqueKey)
        }
    }
}

extension DeleteProfileObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects/delete"
    }
}

public struct DeleteProfileObjectInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The unique identifier of the profile object generated by the service.
    /// This member is required.
    public var profileObjectUniqueKey: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        profileObjectUniqueKey: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
        self.profileId = profileId
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

struct DeleteProfileObjectInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let profileObjectUniqueKey: Swift.String?
    let objectTypeName: Swift.String?
}

extension DeleteProfileObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileObjectUniqueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileObjectUniqueKey)
        profileObjectUniqueKey = profileObjectUniqueKeyDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
    }
}

extension DeleteProfileObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProfileObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileObjectOutput: Swift.Equatable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileObjectOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteProfileObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteProfileObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileObjectTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let objectTypeName = objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

public struct DeleteProfileObjectTypeInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

struct DeleteProfileObjectTypeInputBody: Swift.Equatable {
}

extension DeleteProfileObjectTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfileObjectTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProfileObjectTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileObjectTypeOutput: Swift.Equatable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileObjectTypeOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteProfileObjectTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteProfileObjectTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteProfileOutput: Swift.Equatable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteProfileOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let workflowId = workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
}

extension DeleteWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkflowOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.DestinationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case unhealthySince = "UnhealthySince"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let unhealthySince = self.unhealthySince {
            try encodeContainer.encodeTimestamp(unhealthySince, format: .epochSeconds, forKey: .unhealthySince)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.EventStreamDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let unhealthySinceDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .unhealthySince)
        unhealthySince = unhealthySinceDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Summary information about the Kinesis data stream
    public struct DestinationSummary: Swift.Equatable {
        /// The status of enabling the Kinesis stream as a destination for export.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.EventStreamDestinationStatus?
        /// The timestamp when the status last changed to UNHEALHY.
        public var unhealthySince: ClientRuntime.Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            status: CustomerProfilesClientTypes.EventStreamDestinationStatus? = nil,
            unhealthySince: ClientRuntime.Date? = nil,
            uri: Swift.String? = nil
        )
        {
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }
    }

}

extension CustomerProfilesClientTypes.DomainStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteringProfileCount = "MeteringProfileCount"
        case objectCount = "ObjectCount"
        case profileCount = "ProfileCount"
        case totalSize = "TotalSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if meteringProfileCount != 0 {
            try encodeContainer.encode(meteringProfileCount, forKey: .meteringProfileCount)
        }
        if objectCount != 0 {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if profileCount != 0 {
            try encodeContainer.encode(profileCount, forKey: .profileCount)
        }
        if totalSize != 0 {
            try encodeContainer.encode(totalSize, forKey: .totalSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .profileCount) ?? 0
        profileCount = profileCountDecoded
        let meteringProfileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meteringProfileCount) ?? 0
        meteringProfileCount = meteringProfileCountDecoded
        let objectCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectCount) ?? 0
        objectCount = objectCountDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize) ?? 0
        totalSize = totalSizeDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Usage-specific statistics about the domain.
    public struct DomainStats: Swift.Equatable {
        /// The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        public var meteringProfileCount: Swift.Int
        /// The total number of objects in domain.
        public var objectCount: Swift.Int
        /// The total number of profiles currently in the domain.
        public var profileCount: Swift.Int
        /// The total size, in bytes, of all objects in the domain.
        public var totalSize: Swift.Int

        public init(
            meteringProfileCount: Swift.Int = 0,
            objectCount: Swift.Int = 0,
            profileCount: Swift.Int = 0,
            totalSize: Swift.Int = 0
        )
        {
            self.meteringProfileCount = meteringProfileCount
            self.objectCount = objectCount
            self.profileCount = profileCount
            self.totalSize = totalSize
        }
    }

}

extension CustomerProfilesClientTypes.EventStreamDestinationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
        case unhealthySince = "UnhealthySince"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let unhealthySince = self.unhealthySince {
            try encodeContainer.encodeTimestamp(unhealthySince, format: .epochSeconds, forKey: .unhealthySince)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.EventStreamDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let unhealthySinceDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .unhealthySince)
        unhealthySince = unhealthySinceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Details of the destination being used for the EventStream.
    public struct EventStreamDestinationDetails: Swift.Equatable {
        /// The human-readable string that corresponds to the error or success while enabling the streaming destination.
        public var message: Swift.String?
        /// The status of enabling the Kinesis stream as a destination for export.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.EventStreamDestinationStatus?
        /// The timestamp when the status last changed to UNHEALHY.
        public var unhealthySince: ClientRuntime.Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            message: Swift.String? = nil,
            status: CustomerProfilesClientTypes.EventStreamDestinationStatus? = nil,
            unhealthySince: ClientRuntime.Date? = nil,
            uri: Swift.String? = nil
        )
        {
            self.message = message
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum EventStreamDestinationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStreamDestinationStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventStreamDestinationStatus(rawValue: rawValue) ?? EventStreamDestinationStatus.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum EventStreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStreamState] {
            return [
                .running,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventStreamState(rawValue: rawValue) ?? EventStreamState.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.EventStreamSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSummary = "DestinationSummary"
        case domainName = "DomainName"
        case eventStreamArn = "EventStreamArn"
        case eventStreamName = "EventStreamName"
        case state = "State"
        case stoppedSince = "StoppedSince"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSummary = self.destinationSummary {
            try encodeContainer.encode(destinationSummary, forKey: .destinationSummary)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let eventStreamArn = self.eventStreamArn {
            try encodeContainer.encode(eventStreamArn, forKey: .eventStreamArn)
        }
        if let eventStreamName = self.eventStreamName {
            try encodeContainer.encode(eventStreamName, forKey: .eventStreamName)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stoppedSince = self.stoppedSince {
            try encodeContainer.encodeTimestamp(stoppedSince, format: .epochSeconds, forKey: .stoppedSince)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let eventStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventStreamName)
        eventStreamName = eventStreamNameDecoded
        let eventStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventStreamArn)
        eventStreamArn = eventStreamArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.EventStreamState.self, forKey: .state)
        state = stateDecoded
        let stoppedSinceDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stoppedSince)
        stoppedSince = stoppedSinceDecoded
        let destinationSummaryDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.DestinationSummary.self, forKey: .destinationSummary)
        destinationSummary = destinationSummaryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// An instance of EventStream in a list of EventStreams.
    public struct EventStreamSummary: Swift.Equatable {
        /// Summary information about the Kinesis data stream.
        public var destinationSummary: CustomerProfilesClientTypes.DestinationSummary?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the event stream.
        /// This member is required.
        public var eventStreamArn: Swift.String?
        /// The name of the event stream.
        /// This member is required.
        public var eventStreamName: Swift.String?
        /// The operational state of destination stream for export.
        /// This member is required.
        public var state: CustomerProfilesClientTypes.EventStreamState?
        /// The timestamp when the State changed to STOPPED.
        public var stoppedSince: ClientRuntime.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            destinationSummary: CustomerProfilesClientTypes.DestinationSummary? = nil,
            domainName: Swift.String? = nil,
            eventStreamArn: Swift.String? = nil,
            eventStreamName: Swift.String? = nil,
            state: CustomerProfilesClientTypes.EventStreamState? = nil,
            stoppedSince: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.destinationSummary = destinationSummary
            self.domainName = domainName
            self.eventStreamArn = eventStreamArn
            self.eventStreamName = eventStreamName
            self.state = state
            self.stoppedSince = stoppedSince
            self.tags = tags
        }
    }

}

extension CustomerProfilesClientTypes.ExportingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Exporting = "S3Exporting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Exporting = self.s3Exporting {
            try encodeContainer.encode(s3Exporting, forKey: .s3Exporting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ExportingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.S3ExportingConfig.self, forKey: .s3Exporting)
        s3Exporting = s3ExportingDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
    public struct ExportingConfig: Swift.Equatable {
        /// The S3 location where Identity Resolution Jobs write result files.
        public var s3Exporting: CustomerProfilesClientTypes.S3ExportingConfig?

        public init(
            s3Exporting: CustomerProfilesClientTypes.S3ExportingConfig? = nil
        )
        {
            self.s3Exporting = s3Exporting
        }
    }

}

extension CustomerProfilesClientTypes.ExportingLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Exporting = "S3Exporting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Exporting = self.s3Exporting {
            try encodeContainer.encode(s3Exporting, forKey: .s3Exporting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ExportingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.S3ExportingLocation.self, forKey: .s3Exporting)
        s3Exporting = s3ExportingDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The S3 location where Identity Resolution Jobs write result files.
    public struct ExportingLocation: Swift.Equatable {
        /// Information about the S3 location where Identity Resolution Jobs write result files.
        public var s3Exporting: CustomerProfilesClientTypes.S3ExportingLocation?

        public init(
            s3Exporting: CustomerProfilesClientTypes.S3ExportingLocation? = nil
        )
        {
            self.s3Exporting = s3Exporting
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum FieldContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case emailAddress
        case name
        case number
        case phoneNumber
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldContentType] {
            return [
                .emailAddress,
                .name,
                .number,
                .phoneNumber,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .number: return "NUMBER"
            case .phoneNumber: return "PHONE_NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldContentType(rawValue: rawValue) ?? FieldContentType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.FieldSourceProfileIds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = self.accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = self.additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributeSourceIdMap0) in attributes {
                try attributesContainer.encode(attributeSourceIdMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = self.billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = self.birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = self.businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = self.businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = self.gender {
            try encodeContainer.encode(gender, forKey: .gender)
        }
        if let homePhoneNumber = self.homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = self.mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = self.middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = self.mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = self.partyType {
            try encodeContainer.encode(partyType, forKey: .partyType)
        }
        if let personalEmailAddress = self.personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, uuid0) in attributesContainer {
                if let uuid0 = uuid0 {
                    attributesDecoded0?[key0] = uuid0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// A duplicate customer profile that is to be merged into a main profile.
    public struct FieldSourceProfileIds: Swift.Equatable {
        /// A unique identifier for the account number field to be merged.
        public var accountNumber: Swift.String?
        /// A unique identifier for the additional information field to be merged.
        public var additionalInformation: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var address: Swift.String?
        /// A unique identifier for the attributes field to be merged.
        public var attributes: [Swift.String:Swift.String]?
        /// A unique identifier for the billing type field to be merged.
        public var billingAddress: Swift.String?
        /// A unique identifier for the birthdate field to be merged.
        public var birthDate: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var businessEmailAddress: Swift.String?
        /// A unique identifier for the business name field to be merged.
        public var businessName: Swift.String?
        /// A unique identifier for the business phone number field to be merged.
        public var businessPhoneNumber: Swift.String?
        /// A unique identifier for the email address field to be merged.
        public var emailAddress: Swift.String?
        /// A unique identifier for the first name field to be merged.
        public var firstName: Swift.String?
        /// A unique identifier for the gender field to be merged.
        public var gender: Swift.String?
        /// A unique identifier for the home phone number field to be merged.
        public var homePhoneNumber: Swift.String?
        /// A unique identifier for the last name field to be merged.
        public var lastName: Swift.String?
        /// A unique identifier for the mailing address field to be merged.
        public var mailingAddress: Swift.String?
        /// A unique identifier for the middle name field to be merged.
        public var middleName: Swift.String?
        /// A unique identifier for the mobile phone number field to be merged.
        public var mobilePhoneNumber: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var partyType: Swift.String?
        /// A unique identifier for the personal email address field to be merged.
        public var personalEmailAddress: Swift.String?
        /// A unique identifier for the phone number field to be merged.
        public var phoneNumber: Swift.String?
        /// A unique identifier for the shipping address field to be merged.
        public var shippingAddress: Swift.String?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            billingAddress: Swift.String? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            gender: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress: Swift.String? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: Swift.String? = nil,
            personalEmailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            shippingAddress: Swift.String? = nil
        )
        {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.shippingAddress = shippingAddress
        }
    }

}

extension CustomerProfilesClientTypes.FlowDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case flowName = "FlowName"
        case kmsArn = "KmsArn"
        case sourceFlowConfig = "SourceFlowConfig"
        case tasks = "Tasks"
        case triggerConfig = "TriggerConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let sourceFlowConfig = self.sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for task0 in tasks {
                try tasksContainer.encode(task0)
            }
        }
        if let triggerConfig = self.triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let tasksContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[CustomerProfilesClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [CustomerProfilesClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let triggerConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
    }
}

extension CustomerProfilesClientTypes.FlowDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {
    /// The configurations that control how Customer Profiles retrieves data from the source, Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of customers.
    public struct FlowDefinition: Swift.Equatable {
        /// A description of the flow you want to create.
        public var description: Swift.String?
        /// The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        /// This member is required.
        public var flowName: Swift.String?
        /// The Amazon Resource Name of the AWS Key Management Service (KMS) key you provide for encryption.
        /// This member is required.
        public var kmsArn: Swift.String?
        /// The configuration that controls how Customer Profiles retrieves data from the source.
        /// This member is required.
        public var sourceFlowConfig: CustomerProfilesClientTypes.SourceFlowConfig?
        /// A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        /// This member is required.
        public var tasks: [CustomerProfilesClientTypes.Task]?
        /// The trigger settings that determine how and when the flow runs.
        /// This member is required.
        public var triggerConfig: CustomerProfilesClientTypes.TriggerConfig?

        public init(
            description: Swift.String? = nil,
            flowName: Swift.String? = nil,
            kmsArn: Swift.String? = nil,
            sourceFlowConfig: CustomerProfilesClientTypes.SourceFlowConfig? = nil,
            tasks: [CustomerProfilesClientTypes.Task]? = nil,
            triggerConfig: CustomerProfilesClientTypes.TriggerConfig? = nil
        )
        {
            self.description = description
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }
    }

}

extension CustomerProfilesClientTypes.FoundByKeyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string1to2550 in values {
                try valuesContainer.encode(string1to2550)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// A data type pair that consists of a KeyName and Values list that were used to find a profile returned in response to a [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request.
    public struct FoundByKeyValue: Swift.Equatable {
        /// A searchable identifier of a customer profile.
        public var keyName: Swift.String?
        /// A list of key values.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.keyName = keyName
            self.values = values
        }
    }

}

extension CustomerProfilesClientTypes {
    @available(*, deprecated)
    public enum Gender: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case female
        case male
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [Gender] {
            return [
                .female,
                .male,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .female: return "FEMALE"
            case .male: return "MALE"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Gender(rawValue: rawValue) ?? Gender.sdkUnknown(rawValue)
        }
    }
}

extension GetAutoMergingPreviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResolution = "ConflictResolution"
        case consolidation = "Consolidation"
        case minAllowedConfidenceScoreForMerging = "MinAllowedConfidenceScoreForMerging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let consolidation = self.consolidation {
            try encodeContainer.encode(consolidation, forKey: .consolidation)
        }
        if let minAllowedConfidenceScoreForMerging = self.minAllowedConfidenceScoreForMerging {
            try encodeContainer.encode(minAllowedConfidenceScoreForMerging, forKey: .minAllowedConfidenceScoreForMerging)
        }
    }
}

extension GetAutoMergingPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs/auto-merging-preview"
    }
}

public struct GetAutoMergingPreviewInput: Swift.Equatable {
    /// How the auto-merging process should resolve conflicts between different profiles.
    /// This member is required.
    public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
    /// A list of matching attributes that represent matching criteria.
    /// This member is required.
    public var consolidation: CustomerProfilesClientTypes.Consolidation?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Minimum confidence score required for profiles within a matching group to be merged during the auto-merge process.
    public var minAllowedConfidenceScoreForMerging: Swift.Double?

    public init(
        conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
        consolidation: CustomerProfilesClientTypes.Consolidation? = nil,
        domainName: Swift.String? = nil,
        minAllowedConfidenceScoreForMerging: Swift.Double? = nil
    )
    {
        self.conflictResolution = conflictResolution
        self.consolidation = consolidation
        self.domainName = domainName
        self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
    }
}

struct GetAutoMergingPreviewInputBody: Swift.Equatable {
    let consolidation: CustomerProfilesClientTypes.Consolidation?
    let conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
    let minAllowedConfidenceScoreForMerging: Swift.Double?
}

extension GetAutoMergingPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResolution = "ConflictResolution"
        case consolidation = "Consolidation"
        case minAllowedConfidenceScoreForMerging = "MinAllowedConfidenceScoreForMerging"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consolidationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Consolidation.self, forKey: .consolidation)
        consolidation = consolidationDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let minAllowedConfidenceScoreForMergingDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minAllowedConfidenceScoreForMerging)
        minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMergingDecoded
    }
}

extension GetAutoMergingPreviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAutoMergingPreviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainName = output.domainName
            self.numberOfMatchesInSample = output.numberOfMatchesInSample
            self.numberOfProfilesInSample = output.numberOfProfilesInSample
            self.numberOfProfilesWillBeMerged = output.numberOfProfilesWillBeMerged
        } else {
            self.domainName = nil
            self.numberOfMatchesInSample = 0
            self.numberOfProfilesInSample = 0
            self.numberOfProfilesWillBeMerged = 0
        }
    }
}

public struct GetAutoMergingPreviewOutput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of match groups in the domain that have been reviewed in this preview dry run.
    public var numberOfMatchesInSample: Swift.Int
    /// The number of profiles found in this preview dry run.
    public var numberOfProfilesInSample: Swift.Int
    /// The number of profiles that would be merged if this wasn't a preview dry run.
    public var numberOfProfilesWillBeMerged: Swift.Int

    public init(
        domainName: Swift.String? = nil,
        numberOfMatchesInSample: Swift.Int = 0,
        numberOfProfilesInSample: Swift.Int = 0,
        numberOfProfilesWillBeMerged: Swift.Int = 0
    )
    {
        self.domainName = domainName
        self.numberOfMatchesInSample = numberOfMatchesInSample
        self.numberOfProfilesInSample = numberOfProfilesInSample
        self.numberOfProfilesWillBeMerged = numberOfProfilesWillBeMerged
    }
}

struct GetAutoMergingPreviewOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let numberOfMatchesInSample: Swift.Int
    let numberOfProfilesInSample: Swift.Int
    let numberOfProfilesWillBeMerged: Swift.Int
}

extension GetAutoMergingPreviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case numberOfMatchesInSample = "NumberOfMatchesInSample"
        case numberOfProfilesInSample = "NumberOfProfilesInSample"
        case numberOfProfilesWillBeMerged = "NumberOfProfilesWillBeMerged"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let numberOfMatchesInSampleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMatchesInSample) ?? 0
        numberOfMatchesInSample = numberOfMatchesInSampleDecoded
        let numberOfProfilesInSampleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfProfilesInSample) ?? 0
        numberOfProfilesInSample = numberOfProfilesInSampleDecoded
        let numberOfProfilesWillBeMergedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfProfilesWillBeMerged) ?? 0
        numberOfProfilesWillBeMerged = numberOfProfilesWillBeMergedDecoded
    }
}

enum GetAutoMergingPreviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCalculatedAttributeDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let calculatedAttributeName = calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

public struct GetCalculatedAttributeDefinitionInput: Swift.Equatable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
    }
}

struct GetCalculatedAttributeDefinitionInputBody: Swift.Equatable {
}

extension GetCalculatedAttributeDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension GetCalculatedAttributeDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCalculatedAttributeDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeDetails = output.attributeDetails
            self.calculatedAttributeName = output.calculatedAttributeName
            self.conditions = output.conditions
            self.createdAt = output.createdAt
            self.description = output.description
            self.displayName = output.displayName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.statistic = output.statistic
            self.tags = output.tags
        } else {
            self.attributeDetails = nil
            self.calculatedAttributeName = nil
            self.conditions = nil
            self.createdAt = nil
            self.description = nil
            self.displayName = nil
            self.lastUpdatedAt = nil
            self.statistic = nil
            self.tags = nil
        }
    }
}

public struct GetCalculatedAttributeDefinitionOutput: Swift.Equatable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.statistic = statistic
        self.tags = tags
    }
}

struct GetCalculatedAttributeDefinitionOutputBody: Swift.Equatable {
    let calculatedAttributeName: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let statistic: CustomerProfilesClientTypes.Statistic?
    let conditions: CustomerProfilesClientTypes.Conditions?
    let attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    let tags: [Swift.String:Swift.String]?
}

extension GetCalculatedAttributeDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDetails = "AttributeDetails"
        case calculatedAttributeName = "CalculatedAttributeName"
        case conditions = "Conditions"
        case createdAt = "CreatedAt"
        case description = "Description"
        case displayName = "DisplayName"
        case lastUpdatedAt = "LastUpdatedAt"
        case statistic = "Statistic"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatedAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatedAttributeName)
        calculatedAttributeName = calculatedAttributeNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let conditionsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
        let attributeDetailsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeDetails.self, forKey: .attributeDetails)
        attributeDetails = attributeDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetCalculatedAttributeDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCalculatedAttributeForProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let profileId = profileId else {
            return nil
        }
        guard let calculatedAttributeName = calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile/\(profileId.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

public struct GetCalculatedAttributeForProfileInput: Swift.Equatable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
        self.profileId = profileId
    }
}

struct GetCalculatedAttributeForProfileInputBody: Swift.Equatable {
}

extension GetCalculatedAttributeForProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCalculatedAttributeForProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCalculatedAttributeForProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculatedAttributeName = output.calculatedAttributeName
            self.displayName = output.displayName
            self.isDataPartial = output.isDataPartial
            self.value = output.value
        } else {
            self.calculatedAttributeName = nil
            self.displayName = nil
            self.isDataPartial = nil
            self.value = nil
        }
    }
}

public struct GetCalculatedAttributeForProfileOutput: Swift.Equatable {
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// Indicates whether the calculated attributes value is based on partial data. If data is partial, it is set to true.
    public var isDataPartial: Swift.String?
    /// The value of the calculated attribute.
    public var value: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isDataPartial: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.displayName = displayName
        self.isDataPartial = isDataPartial
        self.value = value
    }
}

struct GetCalculatedAttributeForProfileOutputBody: Swift.Equatable {
    let calculatedAttributeName: Swift.String?
    let displayName: Swift.String?
    let isDataPartial: Swift.String?
    let value: Swift.String?
}

extension GetCalculatedAttributeForProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatedAttributeName = "CalculatedAttributeName"
        case displayName = "DisplayName"
        case isDataPartial = "IsDataPartial"
        case value = "Value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatedAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatedAttributeName)
        calculatedAttributeName = calculatedAttributeNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let isDataPartialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isDataPartial)
        isDataPartial = isDataPartialDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

enum GetCalculatedAttributeForProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

public struct GetDomainInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainInputBody: Swift.Equatable {
}

extension GetDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.deadLetterQueueUrl = output.deadLetterQueueUrl
            self.defaultEncryptionKey = output.defaultEncryptionKey
            self.defaultExpirationDays = output.defaultExpirationDays
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.matching = output.matching
            self.ruleBasedMatching = output.ruleBasedMatching
            self.stats = output.stats
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deadLetterQueueUrl = nil
            self.defaultEncryptionKey = nil
            self.defaultExpirationDays = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.matching = nil
            self.ruleBasedMatching = nil
            self.stats = nil
            self.tags = nil
        }
    }
}

public struct GetDomainOutput: Swift.Equatable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// Usage-specific statistics about the domain.
    public var stats: CustomerProfilesClientTypes.DomainStats?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        stats: CustomerProfilesClientTypes.DomainStats? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.stats = stats
        self.tags = tags
    }
}

struct GetDomainOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let defaultExpirationDays: Swift.Int?
    let defaultEncryptionKey: Swift.String?
    let deadLetterQueueUrl: Swift.String?
    let stats: CustomerProfilesClientTypes.DomainStats?
    let matching: CustomerProfilesClientTypes.MatchingResponse?
    let ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case stats = "Stats"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let statsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.DomainStats.self, forKey: .stats)
        stats = statsDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchingResponse.self, forKey: .matching)
        matching = matchingDecoded
        let ruleBasedMatchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.RuleBasedMatchingResponse.self, forKey: .ruleBasedMatching)
        ruleBasedMatching = ruleBasedMatchingDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let eventStreamName = eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

public struct GetEventStreamInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream provided during create operations.
    /// This member is required.
    public var eventStreamName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
    }
}

struct GetEventStreamInputBody: Swift.Equatable {
}

extension GetEventStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEventStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.destinationDetails = output.destinationDetails
            self.domainName = output.domainName
            self.eventStreamArn = output.eventStreamArn
            self.state = output.state
            self.stoppedSince = output.stoppedSince
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.destinationDetails = nil
            self.domainName = nil
            self.eventStreamArn = nil
            self.state = nil
            self.stoppedSince = nil
            self.tags = nil
        }
    }
}

public struct GetEventStreamOutput: Swift.Equatable {
    /// The timestamp of when the export was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Details regarding the Kinesis stream.
    /// This member is required.
    public var destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A unique identifier for the event stream.
    /// This member is required.
    public var eventStreamArn: Swift.String?
    /// The operational state of destination stream for export.
    /// This member is required.
    public var state: CustomerProfilesClientTypes.EventStreamState?
    /// The timestamp when the State changed to STOPPED.
    public var stoppedSince: ClientRuntime.Date?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails? = nil,
        domainName: Swift.String? = nil,
        eventStreamArn: Swift.String? = nil,
        state: CustomerProfilesClientTypes.EventStreamState? = nil,
        stoppedSince: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationDetails = destinationDetails
        self.domainName = domainName
        self.eventStreamArn = eventStreamArn
        self.state = state
        self.stoppedSince = stoppedSince
        self.tags = tags
    }
}

struct GetEventStreamOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let eventStreamArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let state: CustomerProfilesClientTypes.EventStreamState?
    let stoppedSince: ClientRuntime.Date?
    let destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails?
    let tags: [Swift.String:Swift.String]?
}

extension GetEventStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case destinationDetails = "DestinationDetails"
        case domainName = "DomainName"
        case eventStreamArn = "EventStreamArn"
        case state = "State"
        case stoppedSince = "StoppedSince"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let eventStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventStreamArn)
        eventStreamArn = eventStreamArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.EventStreamState.self, forKey: .state)
        state = stateDecoded
        let stoppedSinceDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stoppedSince)
        stoppedSince = stoppedSinceDecoded
        let destinationDetailsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.EventStreamDestinationDetails.self, forKey: .destinationDetails)
        destinationDetails = destinationDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetEventStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdentityResolutionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetIdentityResolutionJobInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the Identity Resolution Job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.jobId = jobId
    }
}

struct GetIdentityResolutionJobInputBody: Swift.Equatable {
}

extension GetIdentityResolutionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdentityResolutionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdentityResolutionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoMerging = output.autoMerging
            self.domainName = output.domainName
            self.exportingLocation = output.exportingLocation
            self.jobEndTime = output.jobEndTime
            self.jobExpirationTime = output.jobExpirationTime
            self.jobId = output.jobId
            self.jobStartTime = output.jobStartTime
            self.jobStats = output.jobStats
            self.lastUpdatedAt = output.lastUpdatedAt
            self.message = output.message
            self.status = output.status
        } else {
            self.autoMerging = nil
            self.domainName = nil
            self.exportingLocation = nil
            self.jobEndTime = nil
            self.jobExpirationTime = nil
            self.jobId = nil
            self.jobStartTime = nil
            self.jobStats = nil
            self.lastUpdatedAt = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct GetIdentityResolutionJobOutput: Swift.Equatable {
    /// Configuration settings for how to perform the auto-merging of profiles.
    public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
    /// The unique name of the domain.
    public var domainName: Swift.String?
    /// The S3 location where the Identity Resolution Job writes result files.
    public var exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
    /// The timestamp of when the Identity Resolution Job was completed.
    public var jobEndTime: ClientRuntime.Date?
    /// The timestamp of when the Identity Resolution Job will expire.
    public var jobExpirationTime: ClientRuntime.Date?
    /// The unique identifier of the Identity Resolution Job.
    public var jobId: Swift.String?
    /// The timestamp of when the Identity Resolution Job was started or will be started.
    public var jobStartTime: ClientRuntime.Date?
    /// Statistics about the Identity Resolution Job.
    public var jobStats: CustomerProfilesClientTypes.JobStats?
    /// The timestamp of when the Identity Resolution Job was most recently edited.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The error messages that are generated when the Identity Resolution Job runs.
    public var message: Swift.String?
    /// The status of the Identity Resolution Job.
    ///
    /// * PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.
    ///
    /// * PREPROCESSING: The Identity Resolution Job is loading your data.
    ///
    /// * FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.
    ///
    /// * MERGING: The Identity Resolution Job is merging duplicate profiles.
    ///
    /// * COMPLETED: The Identity Resolution Job completed successfully.
    ///
    /// * PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.
    ///
    /// * FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
    public var status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?

    public init(
        autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
        domainName: Swift.String? = nil,
        exportingLocation: CustomerProfilesClientTypes.ExportingLocation? = nil,
        jobEndTime: ClientRuntime.Date? = nil,
        jobExpirationTime: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobStartTime: ClientRuntime.Date? = nil,
        jobStats: CustomerProfilesClientTypes.JobStats? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: CustomerProfilesClientTypes.IdentityResolutionJobStatus? = nil
    )
    {
        self.autoMerging = autoMerging
        self.domainName = domainName
        self.exportingLocation = exportingLocation
        self.jobEndTime = jobEndTime
        self.jobExpirationTime = jobExpirationTime
        self.jobId = jobId
        self.jobStartTime = jobStartTime
        self.jobStats = jobStats
        self.lastUpdatedAt = lastUpdatedAt
        self.message = message
        self.status = status
    }
}

struct GetIdentityResolutionJobOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let jobId: Swift.String?
    let status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?
    let message: Swift.String?
    let jobStartTime: ClientRuntime.Date?
    let jobEndTime: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let jobExpirationTime: ClientRuntime.Date?
    let autoMerging: CustomerProfilesClientTypes.AutoMerging?
    let exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
    let jobStats: CustomerProfilesClientTypes.JobStats?
}

extension GetIdentityResolutionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMerging = "AutoMerging"
        case domainName = "DomainName"
        case exportingLocation = "ExportingLocation"
        case jobEndTime = "JobEndTime"
        case jobExpirationTime = "JobExpirationTime"
        case jobId = "JobId"
        case jobStartTime = "JobStartTime"
        case jobStats = "JobStats"
        case lastUpdatedAt = "LastUpdatedAt"
        case message = "Message"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.IdentityResolutionJobStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let jobStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobStartTime)
        jobStartTime = jobStartTimeDecoded
        let jobEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobEndTime)
        jobEndTime = jobEndTimeDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let jobExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobExpirationTime)
        jobExpirationTime = jobExpirationTimeDecoded
        let autoMergingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AutoMerging.self, forKey: .autoMerging)
        autoMerging = autoMergingDecoded
        let exportingLocationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ExportingLocation.self, forKey: .exportingLocation)
        exportingLocation = exportingLocationDecoded
        let jobStatsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.JobStats.self, forKey: .jobStats)
        jobStats = jobStatsDecoded
    }
}

enum GetIdentityResolutionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension GetIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

public struct GetIntegrationInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.uri = uri
    }
}

struct GetIntegrationInputBody: Swift.Equatable {
    let uri: Swift.String?
}

extension GetIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension GetIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.domainName = output.domainName
            self.isUnstructured = output.isUnstructured
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.objectTypeNames = output.objectTypeNames
            self.tags = output.tags
            self.uri = output.uri
            self.workflowId = output.workflowId
        } else {
            self.createdAt = nil
            self.domainName = nil
            self.isUnstructured = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.objectTypeNames = nil
            self.tags = nil
            self.uri = nil
            self.workflowId = nil
        }
    }
}

public struct GetIntegrationOutput: Swift.Equatable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
    public var isUnstructured: Swift.Bool?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String:Swift.String]?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        domainName: Swift.String? = nil,
        isUnstructured: Swift.Bool? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.isUnstructured = isUnstructured
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.tags = tags
        self.uri = uri
        self.workflowId = workflowId
    }
}

struct GetIntegrationOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let uri: Swift.String?
    let objectTypeName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let objectTypeNames: [Swift.String:Swift.String]?
    let workflowId: Swift.String?
    let isUnstructured: Swift.Bool?
}

extension GetIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case isUnstructured = "IsUnstructured"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case objectTypeNames = "ObjectTypeNames"
        case tags = "Tags"
        case uri = "Uri"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let objectTypeNamesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .objectTypeNames)
        var objectTypeNamesDecoded0: [Swift.String:Swift.String]? = nil
        if let objectTypeNamesContainer = objectTypeNamesContainer {
            objectTypeNamesDecoded0 = [Swift.String:Swift.String]()
            for (key0, typename0) in objectTypeNamesContainer {
                if let typename0 = typename0 {
                    objectTypeNamesDecoded0?[key0] = typename0
                }
            }
        }
        objectTypeNames = objectTypeNamesDecoded0
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let isUnstructuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUnstructured)
        isUnstructured = isUnstructuredDecoded
    }
}

enum GetIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetMatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/matches"
    }
}

public struct GetMatchesInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetMatchesInputBody: Swift.Equatable {
}

extension GetMatchesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchGenerationDate = output.matchGenerationDate
            self.matches = output.matches
            self.nextToken = output.nextToken
            self.potentialMatches = output.potentialMatches
        } else {
            self.matchGenerationDate = nil
            self.matches = nil
            self.nextToken = nil
            self.potentialMatches = nil
        }
    }
}

public struct GetMatchesOutput: Swift.Equatable {
    /// The timestamp this version of Match Result generated.
    public var matchGenerationDate: ClientRuntime.Date?
    /// The list of matched profiles for this instance.
    public var matches: [CustomerProfilesClientTypes.MatchItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The number of potential matches found.
    public var potentialMatches: Swift.Int?

    public init(
        matchGenerationDate: ClientRuntime.Date? = nil,
        matches: [CustomerProfilesClientTypes.MatchItem]? = nil,
        nextToken: Swift.String? = nil,
        potentialMatches: Swift.Int? = nil
    )
    {
        self.matchGenerationDate = matchGenerationDate
        self.matches = matches
        self.nextToken = nextToken
        self.potentialMatches = potentialMatches
    }
}

struct GetMatchesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let matchGenerationDate: ClientRuntime.Date?
    let potentialMatches: Swift.Int?
    let matches: [CustomerProfilesClientTypes.MatchItem]?
}

extension GetMatchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchGenerationDate = "MatchGenerationDate"
        case matches = "Matches"
        case nextToken = "NextToken"
        case potentialMatches = "PotentialMatches"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let matchGenerationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .matchGenerationDate)
        matchGenerationDate = matchGenerationDateDecoded
        let potentialMatchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .potentialMatches)
        potentialMatches = potentialMatchesDecoded
        let matchesContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.MatchItem?].self, forKey: .matches)
        var matchesDecoded0:[CustomerProfilesClientTypes.MatchItem]? = nil
        if let matchesContainer = matchesContainer {
            matchesDecoded0 = [CustomerProfilesClientTypes.MatchItem]()
            for structure0 in matchesContainer {
                if let structure0 = structure0 {
                    matchesDecoded0?.append(structure0)
                }
            }
        }
        matches = matchesDecoded0
    }
}

enum GetMatchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileObjectTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let objectTypeName = objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

public struct GetProfileObjectTypeInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

struct GetProfileObjectTypeInputBody: Swift.Equatable {
}

extension GetProfileObjectTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileObjectTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileObjectTypeOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension GetProfileObjectTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileObjectTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowProfileCreation = output.allowProfileCreation
            self.createdAt = output.createdAt
            self.description = output.description
            self.encryptionKey = output.encryptionKey
            self.expirationDays = output.expirationDays
            self.fields = output.fields
            self.keys = output.keys
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.sourceLastUpdatedTimestampFormat = output.sourceLastUpdatedTimestampFormat
            self.tags = output.tags
            self.templateId = output.templateId
        } else {
            self.allowProfileCreation = false
            self.createdAt = nil
            self.description = nil
            self.encryptionKey = nil
            self.expirationDays = nil
            self.fields = nil
            self.keys = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.sourceLastUpdatedTimestampFormat = nil
            self.tags = nil
            self.templateId = nil
        }
    }
}

public struct GetProfileObjectTypeOutput: Swift.Equatable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// The timestamp of when the domain was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The timestamp of when the domain was most recently edited.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

struct GetProfileObjectTypeOutputBody: Swift.Equatable {
    let objectTypeName: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let expirationDays: Swift.Int?
    let encryptionKey: Swift.String?
    let allowProfileCreation: Swift.Bool
    let sourceLastUpdatedTimestampFormat: Swift.String?
    let fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    let keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetProfileObjectTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let allowProfileCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowProfileCreation) ?? false
        allowProfileCreation = allowProfileCreationDecoded
        let sourceLastUpdatedTimestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLastUpdatedTimestampFormat)
        sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormatDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: CustomerProfilesClientTypes.ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [CustomerProfilesClientTypes.ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [CustomerProfilesClientTypes.ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetProfileObjectTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileObjectTypeTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateId = templateId else {
            return nil
        }
        return "/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct GetProfileObjectTypeTemplateInput: Swift.Equatable {
    /// A unique identifier for the object template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        templateId: Swift.String? = nil
    )
    {
        self.templateId = templateId
    }
}

struct GetProfileObjectTypeTemplateInputBody: Swift.Equatable {
}

extension GetProfileObjectTypeTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileObjectTypeTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileObjectTypeTemplateOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), sourceName: \(Swift.String(describing: sourceName)), sourceObject: \(Swift.String(describing: sourceObject)), templateId: \(Swift.String(describing: templateId)), fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension GetProfileObjectTypeTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileObjectTypeTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowProfileCreation = output.allowProfileCreation
            self.fields = output.fields
            self.keys = output.keys
            self.sourceLastUpdatedTimestampFormat = output.sourceLastUpdatedTimestampFormat
            self.sourceName = output.sourceName
            self.sourceObject = output.sourceObject
            self.templateId = output.templateId
        } else {
            self.allowProfileCreation = false
            self.fields = nil
            self.keys = nil
            self.sourceLastUpdatedTimestampFormat = nil
            self.sourceName = nil
            self.sourceObject = nil
            self.templateId = nil
        }
    }
}

public struct GetProfileObjectTypeTemplateOutput: Swift.Equatable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The name of the source of the object template.
    public var sourceName: Swift.String?
    /// The source of the object template.
    public var sourceObject: Swift.String?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceObject: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.fields = fields
        self.keys = keys
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.sourceName = sourceName
        self.sourceObject = sourceObject
        self.templateId = templateId
    }
}

struct GetProfileObjectTypeTemplateOutputBody: Swift.Equatable {
    let templateId: Swift.String?
    let sourceName: Swift.String?
    let sourceObject: Swift.String?
    let allowProfileCreation: Swift.Bool
    let sourceLastUpdatedTimestampFormat: Swift.String?
    let fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    let keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
}

extension GetProfileObjectTypeTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case fields = "Fields"
        case keys = "Keys"
        case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
        case sourceName = "SourceName"
        case sourceObject = "SourceObject"
        case templateId = "TemplateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceObject)
        sourceObject = sourceObjectDecoded
        let allowProfileCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowProfileCreation) ?? false
        allowProfileCreation = allowProfileCreationDecoded
        let sourceLastUpdatedTimestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLastUpdatedTimestampFormat)
        sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormatDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: CustomerProfilesClientTypes.ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [CustomerProfilesClientTypes.ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [CustomerProfilesClientTypes.ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
    }
}

enum GetProfileObjectTypeTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSimilarProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchType = "MatchType"
        case searchKey = "SearchKey"
        case searchValue = "SearchValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchType = self.matchType {
            try encodeContainer.encode(matchType.rawValue, forKey: .matchType)
        }
        if let searchKey = self.searchKey {
            try encodeContainer.encode(searchKey, forKey: .searchKey)
        }
        if let searchValue = self.searchValue {
            try encodeContainer.encode(searchValue, forKey: .searchValue)
        }
    }
}

extension GetSimilarProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetSimilarProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/matches"
    }
}

public struct GetSimilarProfilesInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Specify the type of matching to get similar profiles for.
    /// This member is required.
    public var matchType: CustomerProfilesClientTypes.MatchType?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous GetSimilarProfiles API call.
    public var nextToken: Swift.String?
    /// The string indicating the search key to be used.
    /// This member is required.
    public var searchKey: Swift.String?
    /// The string based on SearchKey to be searched for similar profiles.
    /// This member is required.
    public var searchValue: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        matchType: CustomerProfilesClientTypes.MatchType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchKey: Swift.String? = nil,
        searchValue: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.matchType = matchType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchKey = searchKey
        self.searchValue = searchValue
    }
}

struct GetSimilarProfilesInputBody: Swift.Equatable {
    let matchType: CustomerProfilesClientTypes.MatchType?
    let searchKey: Swift.String?
    let searchValue: Swift.String?
}

extension GetSimilarProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchType = "MatchType"
        case searchKey = "SearchKey"
        case searchValue = "SearchValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchType.self, forKey: .matchType)
        matchType = matchTypeDecoded
        let searchKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchKey)
        searchKey = searchKeyDecoded
        let searchValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchValue)
        searchValue = searchValueDecoded
    }
}

extension GetSimilarProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSimilarProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.confidenceScore = output.confidenceScore
            self.matchId = output.matchId
            self.matchType = output.matchType
            self.nextToken = output.nextToken
            self.profileIds = output.profileIds
            self.ruleLevel = output.ruleLevel
        } else {
            self.confidenceScore = nil
            self.matchId = nil
            self.matchType = nil
            self.nextToken = nil
            self.profileIds = nil
            self.ruleLevel = nil
        }
    }
}

public struct GetSimilarProfilesOutput: Swift.Equatable {
    /// It only has value when the MatchType is ML_BASED_MATCHING.A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used as an absolute measure of matching quality.
    public var confidenceScore: Swift.Double?
    /// The string matchId that the similar profiles belong to.
    public var matchId: Swift.String?
    /// Specify the type of matching to get similar profiles for.
    public var matchType: CustomerProfilesClientTypes.MatchType?
    /// The pagination token from the previous GetSimilarProfiles API call.
    public var nextToken: Swift.String?
    /// Set of profileIds that belong to the same matching group.
    public var profileIds: [Swift.String]?
    /// The integer rule level that the profiles matched on.
    public var ruleLevel: Swift.Int?

    public init(
        confidenceScore: Swift.Double? = nil,
        matchId: Swift.String? = nil,
        matchType: CustomerProfilesClientTypes.MatchType? = nil,
        nextToken: Swift.String? = nil,
        profileIds: [Swift.String]? = nil,
        ruleLevel: Swift.Int? = nil
    )
    {
        self.confidenceScore = confidenceScore
        self.matchId = matchId
        self.matchType = matchType
        self.nextToken = nextToken
        self.profileIds = profileIds
        self.ruleLevel = ruleLevel
    }
}

struct GetSimilarProfilesOutputBody: Swift.Equatable {
    let profileIds: [Swift.String]?
    let matchId: Swift.String?
    let matchType: CustomerProfilesClientTypes.MatchType?
    let ruleLevel: Swift.Int?
    let confidenceScore: Swift.Double?
    let nextToken: Swift.String?
}

extension GetSimilarProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidenceScore = "ConfidenceScore"
        case matchId = "MatchId"
        case matchType = "MatchType"
        case nextToken = "NextToken"
        case profileIds = "ProfileIds"
        case ruleLevel = "RuleLevel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profileIds)
        var profileIdsDecoded0:[Swift.String]? = nil
        if let profileIdsContainer = profileIdsContainer {
            profileIdsDecoded0 = [Swift.String]()
            for string0 in profileIdsContainer {
                if let string0 = string0 {
                    profileIdsDecoded0?.append(string0)
                }
            }
        }
        profileIds = profileIdsDecoded0
        let matchIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchId)
        matchId = matchIdDecoded
        let matchTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchType.self, forKey: .matchType)
        matchType = matchTypeDecoded
        let ruleLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleLevel)
        ruleLevel = ruleLevelDecoded
        let confidenceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidenceScore)
        confidenceScore = confidenceScoreDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetSimilarProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let workflowId = workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.workflowId = workflowId
    }
}

struct GetWorkflowInputBody: Swift.Equatable {
}

extension GetWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.errorDescription = output.errorDescription
            self.lastUpdatedAt = output.lastUpdatedAt
            self.metrics = output.metrics
            self.startDate = output.startDate
            self.status = output.status
            self.workflowId = output.workflowId
            self.workflowType = output.workflowType
        } else {
            self.attributes = nil
            self.errorDescription = nil
            self.lastUpdatedAt = nil
            self.metrics = nil
            self.startDate = nil
            self.status = nil
            self.workflowId = nil
            self.workflowType = nil
        }
    }
}

public struct GetWorkflowOutput: Swift.Equatable {
    /// Attributes provided for workflow execution.
    public var attributes: CustomerProfilesClientTypes.WorkflowAttributes?
    /// Workflow error messages during execution (if any).
    public var errorDescription: Swift.String?
    /// The timestamp that represents when workflow execution last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// Workflow specific execution metrics.
    public var metrics: CustomerProfilesClientTypes.WorkflowMetrics?
    /// The timestamp that represents when workflow execution started.
    public var startDate: ClientRuntime.Date?
    /// Status of workflow execution.
    public var status: CustomerProfilesClientTypes.Status?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        attributes: CustomerProfilesClientTypes.WorkflowAttributes? = nil,
        errorDescription: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        metrics: CustomerProfilesClientTypes.WorkflowMetrics? = nil,
        startDate: ClientRuntime.Date? = nil,
        status: CustomerProfilesClientTypes.Status? = nil,
        workflowId: Swift.String? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.attributes = attributes
        self.errorDescription = errorDescription
        self.lastUpdatedAt = lastUpdatedAt
        self.metrics = metrics
        self.startDate = startDate
        self.status = status
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

struct GetWorkflowOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let workflowType: CustomerProfilesClientTypes.WorkflowType?
    let status: CustomerProfilesClientTypes.Status?
    let errorDescription: Swift.String?
    let startDate: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let attributes: CustomerProfilesClientTypes.WorkflowAttributes?
    let metrics: CustomerProfilesClientTypes.WorkflowMetrics?
}

extension GetWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case errorDescription = "ErrorDescription"
        case lastUpdatedAt = "LastUpdatedAt"
        case metrics = "Metrics"
        case startDate = "StartDate"
        case status = "Status"
        case workflowId = "WorkflowId"
        case workflowType = "WorkflowType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let errorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDescription)
        errorDescription = errorDescriptionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

enum GetWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowStepsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetWorkflowStepsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let workflowId = workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())/steps"
    }
}

public struct GetWorkflowStepsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct GetWorkflowStepsInputBody: Swift.Equatable {
}

extension GetWorkflowStepsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowStepsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowStepsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
            self.workflowId = output.workflowId
            self.workflowType = output.workflowType
        } else {
            self.items = nil
            self.nextToken = nil
            self.workflowId = nil
            self.workflowType = nil
        }
    }
}

public struct GetWorkflowStepsOutput: Swift.Equatable {
    /// List containing workflow step details.
    public var items: [CustomerProfilesClientTypes.WorkflowStepItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        items: [CustomerProfilesClientTypes.WorkflowStepItem]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

struct GetWorkflowStepsOutputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let workflowType: CustomerProfilesClientTypes.WorkflowType?
    let items: [CustomerProfilesClientTypes.WorkflowStepItem]?
    let nextToken: Swift.String?
}

extension GetWorkflowStepsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
        case workflowType = "WorkflowType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.WorkflowStepItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.WorkflowStepItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.WorkflowStepItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetWorkflowStepsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.IdentityResolutionJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case exportingLocation = "ExportingLocation"
        case jobEndTime = "JobEndTime"
        case jobId = "JobId"
        case jobStartTime = "JobStartTime"
        case jobStats = "JobStats"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let exportingLocation = self.exportingLocation {
            try encodeContainer.encode(exportingLocation, forKey: .exportingLocation)
        }
        if let jobEndTime = self.jobEndTime {
            try encodeContainer.encodeTimestamp(jobEndTime, format: .epochSeconds, forKey: .jobEndTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobStartTime = self.jobStartTime {
            try encodeContainer.encodeTimestamp(jobStartTime, format: .epochSeconds, forKey: .jobStartTime)
        }
        if let jobStats = self.jobStats {
            try encodeContainer.encode(jobStats, forKey: .jobStats)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.IdentityResolutionJobStatus.self, forKey: .status)
        status = statusDecoded
        let jobStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobStartTime)
        jobStartTime = jobStartTimeDecoded
        let jobEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobEndTime)
        jobEndTime = jobEndTimeDecoded
        let jobStatsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.JobStats.self, forKey: .jobStats)
        jobStats = jobStatsDecoded
        let exportingLocationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ExportingLocation.self, forKey: .exportingLocation)
        exportingLocation = exportingLocationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Information about the Identity Resolution Job.
    public struct IdentityResolutionJob: Swift.Equatable {
        /// The unique name of the domain.
        public var domainName: Swift.String?
        /// The S3 location where the Identity Resolution Job writes result files.
        public var exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
        /// The timestamp of when the job was completed.
        public var jobEndTime: ClientRuntime.Date?
        /// The unique identifier of the Identity Resolution Job.
        public var jobId: Swift.String?
        /// The timestamp of when the job was started or will be started.
        public var jobStartTime: ClientRuntime.Date?
        /// Statistics about an Identity Resolution Job.
        public var jobStats: CustomerProfilesClientTypes.JobStats?
        /// The error messages that are generated when the Identity Resolution Job runs.
        public var message: Swift.String?
        /// The status of the Identity Resolution Job.
        ///
        /// * PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.
        ///
        /// * PREPROCESSING: The Identity Resolution Job is loading your data.
        ///
        /// * FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.
        ///
        /// * MERGING: The Identity Resolution Job is merging duplicate profiles.
        ///
        /// * COMPLETED: The Identity Resolution Job completed successfully.
        ///
        /// * PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.
        ///
        /// * FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
        public var status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?

        public init(
            domainName: Swift.String? = nil,
            exportingLocation: CustomerProfilesClientTypes.ExportingLocation? = nil,
            jobEndTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobStartTime: ClientRuntime.Date? = nil,
            jobStats: CustomerProfilesClientTypes.JobStats? = nil,
            message: Swift.String? = nil,
            status: CustomerProfilesClientTypes.IdentityResolutionJobStatus? = nil
        )
        {
            self.domainName = domainName
            self.exportingLocation = exportingLocation
            self.jobEndTime = jobEndTime
            self.jobId = jobId
            self.jobStartTime = jobStartTime
            self.jobStats = jobStats
            self.message = message
            self.status = status
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum IdentityResolutionJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case findMatching
        case merging
        case partialSuccess
        case pending
        case preprocessing
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityResolutionJobStatus] {
            return [
                .completed,
                .failed,
                .findMatching,
                .merging,
                .partialSuccess,
                .pending,
                .preprocessing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .findMatching: return "FIND_MATCHING"
            case .merging: return "MERGING"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .pending: return "PENDING"
            case .preprocessing: return "PREPROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityResolutionJobStatus(rawValue: rawValue) ?? IdentityResolutionJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.IncrementalPullConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetimeTypeFieldName = "DatetimeTypeFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetimeTypeFieldName = self.datetimeTypeFieldName {
            try encodeContainer.encode(datetimeTypeFieldName, forKey: .datetimeTypeFieldName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datetimeTypeFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datetimeTypeFieldName)
        datetimeTypeFieldName = datetimeTypeFieldNameDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Specifies the configuration used when importing incremental records from the source.
    public struct IncrementalPullConfig: Swift.Equatable {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public var datetimeTypeFieldName: Swift.String?

        public init(
            datetimeTypeFieldName: Swift.String? = nil
        )
        {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }

}

extension CustomerProfilesClientTypes.IntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appflowIntegration = "AppflowIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appflowIntegration = self.appflowIntegration {
            try encodeContainer.encode(appflowIntegration, forKey: .appflowIntegration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appflowIntegrationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AppflowIntegration.self, forKey: .appflowIntegration)
        appflowIntegration = appflowIntegrationDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Configuration data for integration workflow.
    public struct IntegrationConfig: Swift.Equatable {
        /// Configuration data for APPFLOW_INTEGRATION workflow type.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegration?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegration? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomerProfilesClientTypes.JobSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfTheWeek = "DayOfTheWeek"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfTheWeek = self.dayOfTheWeek {
            try encodeContainer.encode(dayOfTheWeek.rawValue, forKey: .dayOfTheWeek)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfTheWeekDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.JobScheduleDayOfTheWeek.self, forKey: .dayOfTheWeek)
        dayOfTheWeek = dayOfTheWeekDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The day and time when do you want to start the Identity Resolution Job every week.
    public struct JobSchedule: Swift.Equatable {
        /// The day when the Identity Resolution Job should run every week.
        /// This member is required.
        public var dayOfTheWeek: CustomerProfilesClientTypes.JobScheduleDayOfTheWeek?
        /// The time when the Identity Resolution Job should run every week.
        /// This member is required.
        public var time: Swift.String?

        public init(
            dayOfTheWeek: CustomerProfilesClientTypes.JobScheduleDayOfTheWeek? = nil,
            time: Swift.String? = nil
        )
        {
            self.dayOfTheWeek = dayOfTheWeek
            self.time = time
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum JobScheduleDayOfTheWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [JobScheduleDayOfTheWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobScheduleDayOfTheWeek(rawValue: rawValue) ?? JobScheduleDayOfTheWeek.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.JobStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfMatchesFound = "NumberOfMatchesFound"
        case numberOfMergesDone = "NumberOfMergesDone"
        case numberOfProfilesReviewed = "NumberOfProfilesReviewed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfMatchesFound != 0 {
            try encodeContainer.encode(numberOfMatchesFound, forKey: .numberOfMatchesFound)
        }
        if numberOfMergesDone != 0 {
            try encodeContainer.encode(numberOfMergesDone, forKey: .numberOfMergesDone)
        }
        if numberOfProfilesReviewed != 0 {
            try encodeContainer.encode(numberOfProfilesReviewed, forKey: .numberOfProfilesReviewed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfProfilesReviewedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfProfilesReviewed) ?? 0
        numberOfProfilesReviewed = numberOfProfilesReviewedDecoded
        let numberOfMatchesFoundDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMatchesFound) ?? 0
        numberOfMatchesFound = numberOfMatchesFoundDecoded
        let numberOfMergesDoneDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMergesDone) ?? 0
        numberOfMergesDone = numberOfMergesDoneDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Statistics about the Identity Resolution Job.
    public struct JobStats: Swift.Equatable {
        /// The number of matches found.
        public var numberOfMatchesFound: Swift.Int
        /// The number of merges completed.
        public var numberOfMergesDone: Swift.Int
        /// The number of profiles reviewed.
        public var numberOfProfilesReviewed: Swift.Int

        public init(
            numberOfMatchesFound: Swift.Int = 0,
            numberOfMergesDone: Swift.Int = 0,
            numberOfProfilesReviewed: Swift.Int = 0
        )
        {
            self.numberOfMatchesFound = numberOfMatchesFound
            self.numberOfMergesDone = numberOfMergesDone
            self.numberOfProfilesReviewed = numberOfProfilesReviewed
        }
    }

}

extension ListAccountIntegrationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension ListAccountIntegrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeHidden = includeHidden {
                let includeHiddenQueryItem = ClientRuntime.URLQueryItem(name: "include-hidden".urlPercentEncoding(), value: Swift.String(includeHidden).urlPercentEncoding())
                items.append(includeHiddenQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAccountIntegrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/integrations"
    }
}

public struct ListAccountIntegrationsInput: Swift.Equatable {
    /// Boolean to indicate if hidden integration should be returned. Defaults to False.
    public var includeHidden: Swift.Bool?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListAccountIntegrations API call.
    public var nextToken: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        includeHidden: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        uri: Swift.String? = nil
    )
    {
        self.includeHidden = includeHidden
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.uri = uri
    }
}

struct ListAccountIntegrationsInputBody: Swift.Equatable {
    let uri: Swift.String?
}

extension ListAccountIntegrationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension ListAccountIntegrationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountIntegrationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountIntegrationsOutput: Swift.Equatable {
    /// The list of ListAccountIntegration instances.
    public var items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    /// The pagination token from the previous ListAccountIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListIntegrationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAccountIntegrationsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    let nextToken: Swift.String?
}

extension ListAccountIntegrationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListIntegrationItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListIntegrationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListIntegrationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountIntegrationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatedAttributeName = "CalculatedAttributeName"
        case createdAt = "CreatedAt"
        case description = "Description"
        case displayName = "DisplayName"
        case lastUpdatedAt = "LastUpdatedAt"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatedAttributeName = self.calculatedAttributeName {
            try encodeContainer.encode(calculatedAttributeName, forKey: .calculatedAttributeName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatedAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatedAttributeName)
        calculatedAttributeName = calculatedAttributeNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// The details of a single calculated attribute definition.
    public struct ListCalculatedAttributeDefinitionItem: Swift.Equatable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The threshold for the calculated attribute.
        public var createdAt: ClientRuntime.Date?
        /// The threshold for the calculated attribute.
        public var description: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.calculatedAttributeName = calculatedAttributeName
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }
    }

}

extension ListCalculatedAttributeDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCalculatedAttributeDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes"
    }
}

public struct ListCalculatedAttributeDefinitionsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of calculated attribute definitions returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCalculatedAttributeDefinitionsInputBody: Swift.Equatable {
}

extension ListCalculatedAttributeDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCalculatedAttributeDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCalculatedAttributeDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListCalculatedAttributeDefinitionsOutput: Swift.Equatable {
    /// The list of calculated attribute definitions.
    public var items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]?
    /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListCalculatedAttributeDefinitionsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]?
    let nextToken: Swift.String?
}

extension ListCalculatedAttributeDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCalculatedAttributeDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatedAttributeName = "CalculatedAttributeName"
        case displayName = "DisplayName"
        case isDataPartial = "IsDataPartial"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatedAttributeName = self.calculatedAttributeName {
            try encodeContainer.encode(calculatedAttributeName, forKey: .calculatedAttributeName)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let isDataPartial = self.isDataPartial {
            try encodeContainer.encode(isDataPartial, forKey: .isDataPartial)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatedAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatedAttributeName)
        calculatedAttributeName = calculatedAttributeNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let isDataPartialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isDataPartial)
        isDataPartial = isDataPartialDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The details of a single calculated attribute for a profile.
    public struct ListCalculatedAttributeForProfileItem: Swift.Equatable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// Indicates whether the calculated attributes value is based on partial data. If data is partial, it is set to true.
        public var isDataPartial: Swift.String?
        /// The value of the calculated attribute.
        public var value: Swift.String?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            displayName: Swift.String? = nil,
            isDataPartial: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.value = value
        }
    }

}

extension ListCalculatedAttributesForProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCalculatedAttributesForProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let profileId = profileId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile/\(profileId.urlPercentEncoding())/calculated-attributes"
    }
}

public struct ListCalculatedAttributesForProfileInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of calculated attributes returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
    public var nextToken: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
    }
}

struct ListCalculatedAttributesForProfileInputBody: Swift.Equatable {
}

extension ListCalculatedAttributesForProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCalculatedAttributesForProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCalculatedAttributesForProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListCalculatedAttributesForProfileOutput: Swift.Equatable {
    /// The list of calculated attributes.
    public var items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]?
    /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListCalculatedAttributesForProfileOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]?
    let nextToken: Swift.String?
}

extension ListCalculatedAttributesForProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCalculatedAttributesForProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.ListDomainItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// An object in a list that represents a domain.
    public struct ListDomainItem: Swift.Equatable {
        /// The timestamp of when the domain was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The timestamp of when the domain was most recently edited.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }
    }

}

extension ListDomainsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListDomain API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// The list of ListDomains instances.
    public var items: [CustomerProfilesClientTypes.ListDomainItem]?
    /// The pagination token from the previous ListDomains API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListDomainItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListDomainItem]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListDomainItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListDomainItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListDomainItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventStreamsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEventStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams"
    }
}

public struct ListEventStreamsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventStreamsInputBody: Swift.Equatable {
}

extension ListEventStreamsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEventStreamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventStreamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventStreamsOutput: Swift.Equatable {
    /// Contains summary information about an EventStream.
    public var items: [CustomerProfilesClientTypes.EventStreamSummary]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.EventStreamSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEventStreamsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.EventStreamSummary]?
    let nextToken: Swift.String?
}

extension ListEventStreamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.EventStreamSummary?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.EventStreamSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.EventStreamSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventStreamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdentityResolutionJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdentityResolutionJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs"
    }
}

public struct ListIdentityResolutionJobsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityResolutionJobsInputBody: Swift.Equatable {
}

extension ListIdentityResolutionJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdentityResolutionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentityResolutionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityResolutionJobsList = output.identityResolutionJobsList
            self.nextToken = output.nextToken
        } else {
            self.identityResolutionJobsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityResolutionJobsOutput: Swift.Equatable {
    /// A list of Identity Resolution Jobs.
    public var identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityResolutionJobsList = identityResolutionJobsList
        self.nextToken = nextToken
    }
}

struct ListIdentityResolutionJobsOutputBody: Swift.Equatable {
    let identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]?
    let nextToken: Swift.String?
}

extension ListIdentityResolutionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityResolutionJobsList = "IdentityResolutionJobsList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityResolutionJobsListContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.IdentityResolutionJob?].self, forKey: .identityResolutionJobsList)
        var identityResolutionJobsListDecoded0:[CustomerProfilesClientTypes.IdentityResolutionJob]? = nil
        if let identityResolutionJobsListContainer = identityResolutionJobsListContainer {
            identityResolutionJobsListDecoded0 = [CustomerProfilesClientTypes.IdentityResolutionJob]()
            for structure0 in identityResolutionJobsListContainer {
                if let structure0 = structure0 {
                    identityResolutionJobsListDecoded0?.append(structure0)
                }
            }
        }
        identityResolutionJobsList = identityResolutionJobsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdentityResolutionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.ListIntegrationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case isUnstructured = "IsUnstructured"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case objectTypeNames = "ObjectTypeNames"
        case tags = "Tags"
        case uri = "Uri"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let isUnstructured = self.isUnstructured {
            try encodeContainer.encode(isUnstructured, forKey: .isUnstructured)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let objectTypeNames = objectTypeNames {
            var objectTypeNamesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .objectTypeNames)
            for (dictKey0, objectTypeNames0) in objectTypeNames {
                try objectTypeNamesContainer.encode(objectTypeNames0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let objectTypeNamesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .objectTypeNames)
        var objectTypeNamesDecoded0: [Swift.String:Swift.String]? = nil
        if let objectTypeNamesContainer = objectTypeNamesContainer {
            objectTypeNamesDecoded0 = [Swift.String:Swift.String]()
            for (key0, typename0) in objectTypeNamesContainer {
                if let typename0 = typename0 {
                    objectTypeNamesDecoded0?[key0] = typename0
                }
            }
        }
        objectTypeNames = objectTypeNamesDecoded0
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let isUnstructuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUnstructured)
        isUnstructured = isUnstructuredDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// An integration in list of integrations.
    public struct ListIntegrationItem: Swift.Equatable {
        /// The timestamp of when the domain was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
        public var isUnstructured: Swift.Bool?
        /// The timestamp of when the domain was most recently edited.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the profile object type.
        public var objectTypeName: Swift.String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public var objectTypeNames: [Swift.String:Swift.String]?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The URI of the S3 bucket or any other type of data source.
        /// This member is required.
        public var uri: Swift.String?
        /// Unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil,
            isUnstructured: Swift.Bool? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            objectTypeName: Swift.String? = nil,
            objectTypeNames: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            uri: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.domainName = domainName
            self.isUnstructured = isUnstructured
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.tags = tags
            self.uri = uri
            self.workflowId = workflowId
        }
    }

}

extension ListIntegrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeHidden = includeHidden {
                let includeHiddenQueryItem = ClientRuntime.URLQueryItem(name: "include-hidden".urlPercentEncoding(), value: Swift.String(includeHidden).urlPercentEncoding())
                items.append(includeHiddenQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIntegrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

public struct ListIntegrationsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean to indicate if hidden integration should be returned. Defaults to False.
    public var includeHidden: Swift.Bool?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        includeHidden: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.includeHidden = includeHidden
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIntegrationsInputBody: Swift.Equatable {
}

extension ListIntegrationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIntegrationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIntegrationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntegrationsOutput: Swift.Equatable {
    /// The list of ListIntegrations instances.
    public var items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    /// The pagination token from the previous ListIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListIntegrationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListIntegrationsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    let nextToken: Swift.String?
}

extension ListIntegrationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListIntegrationItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListIntegrationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListIntegrationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIntegrationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectTypeItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// A ProfileObjectType instance.
    public struct ListProfileObjectTypeItem: Swift.Equatable {
        /// The timestamp of when the domain was created.
        public var createdAt: ClientRuntime.Date?
        /// Description of the profile object type.
        /// This member is required.
        public var description: Swift.String?
        /// The timestamp of when the domain was most recently edited.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the profile object type.
        /// This member is required.
        public var objectTypeName: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            objectTypeName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
        }
    }

}

extension CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceName = "SourceName"
        case sourceObject = "SourceObject"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceObject = self.sourceObject {
            try encodeContainer.encode(sourceObject, forKey: .sourceObject)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceObject)
        sourceObject = sourceObjectDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// A ProfileObjectTypeTemplate in a list of ProfileObjectTypeTemplates.
    public struct ListProfileObjectTypeTemplateItem: Swift.Equatable {
        /// The name of the source of the object template.
        public var sourceName: Swift.String?
        /// The source of the object template.
        public var sourceObject: Swift.String?
        /// A unique identifier for the object template.
        public var templateId: Swift.String?

        public init(
            sourceName: Swift.String? = nil,
            sourceObject: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }
    }

}

extension ListProfileObjectTypeTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProfileObjectTypeTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/templates"
    }
}

public struct ListProfileObjectTypeTemplatesInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListObjectTypeTemplates API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypeTemplatesInputBody: Swift.Equatable {
}

extension ListProfileObjectTypeTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfileObjectTypeTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfileObjectTypeTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProfileObjectTypeTemplatesOutput: Swift.Equatable {
    /// The list of ListProfileObjectType template instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]?
    /// The pagination token from the previous ListObjectTypeTemplates API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypeTemplatesOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]?
    let nextToken: Swift.String?
}

extension ListProfileObjectTypeTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfileObjectTypeTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfileObjectTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProfileObjectTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types"
    }
}

public struct ListProfileObjectTypesInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypesInputBody: Swift.Equatable {
}

extension ListProfileObjectTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfileObjectTypesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileObjectTypesOutput(nextToken: \(Swift.String(describing: nextToken)), items: \"CONTENT_REDACTED\")"}
}

extension ListProfileObjectTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfileObjectTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProfileObjectTypesOutput: Swift.Equatable {
    /// The list of ListProfileObjectTypes instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProfileObjectTypesOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]?
    let nextToken: Swift.String?
}

extension ListProfileObjectTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListProfileObjectTypeItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListProfileObjectTypeItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListProfileObjectTypeItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfileObjectTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfileObjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectFilter = "ObjectFilter"
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectFilter = self.objectFilter {
            try encodeContainer.encode(objectFilter, forKey: .objectFilter)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }
}

extension ListProfileObjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProfileObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects"
    }
}

public struct ListProfileObjectsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListProfileObjects.
    public var nextToken: Swift.String?
    /// Applies a filter to the response to include profile objects with the specified index values.
    public var objectFilter: CustomerProfilesClientTypes.ObjectFilter?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectFilter: CustomerProfilesClientTypes.ObjectFilter? = nil,
        objectTypeName: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectFilter = objectFilter
        self.objectTypeName = objectTypeName
        self.profileId = profileId
    }
}

struct ListProfileObjectsInputBody: Swift.Equatable {
    let objectTypeName: Swift.String?
    let profileId: Swift.String?
    let objectFilter: CustomerProfilesClientTypes.ObjectFilter?
}

extension ListProfileObjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectFilter = "ObjectFilter"
        case objectTypeName = "ObjectTypeName"
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let objectFilterDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ObjectFilter.self, forKey: .objectFilter)
        objectFilter = objectFilterDecoded
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectsItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object = "Object"
        case objectTypeName = "ObjectTypeName"
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let profileObjectUniqueKey = self.profileObjectUniqueKey {
            try encodeContainer.encode(profileObjectUniqueKey, forKey: .profileObjectUniqueKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let profileObjectUniqueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileObjectUniqueKey)
        profileObjectUniqueKey = profileObjectUniqueKeyDecoded
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectsItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileObjectsItem(objectTypeName: \(Swift.String(describing: objectTypeName)), profileObjectUniqueKey: \(Swift.String(describing: profileObjectUniqueKey)), object: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {
    /// A ProfileObject in a list of ProfileObjects.
    public struct ListProfileObjectsItem: Swift.Equatable {
        /// A JSON representation of a ProfileObject that belongs to a profile.
        public var object: Swift.String?
        /// Specifies the kind of object being added to a profile, such as "Salesforce-Account."
        public var objectTypeName: Swift.String?
        /// The unique identifier of the ProfileObject generated by the service.
        public var profileObjectUniqueKey: Swift.String?

        public init(
            object: Swift.String? = nil,
            objectTypeName: Swift.String? = nil,
            profileObjectUniqueKey: Swift.String? = nil
        )
        {
            self.object = object
            self.objectTypeName = objectTypeName
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }
    }

}

extension ListProfileObjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfileObjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProfileObjectsOutput: Swift.Equatable {
    /// The list of ListProfileObject instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectsItem]?
    /// The pagination token from the previous call to ListProfileObjects.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectsItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProfileObjectsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListProfileObjectsItem]?
    let nextToken: Swift.String?
}

extension ListProfileObjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListProfileObjectsItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListProfileObjectsItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListProfileObjectsItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfileObjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRuleBasedMatchesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRuleBasedMatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/ruleBasedMatches"
    }
}

public struct ListRuleBasedMatchesInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of MatchIds returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListRuleBasedMatches API call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRuleBasedMatchesInputBody: Swift.Equatable {
}

extension ListRuleBasedMatchesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRuleBasedMatchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRuleBasedMatchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchIds = output.matchIds
            self.nextToken = output.nextToken
        } else {
            self.matchIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListRuleBasedMatchesOutput: Swift.Equatable {
    /// The list of MatchIds for the given domain.
    public var matchIds: [Swift.String]?
    /// The pagination token from the previous ListRuleBasedMatches API call.
    public var nextToken: Swift.String?

    public init(
        matchIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.matchIds = matchIds
        self.nextToken = nextToken
    }
}

struct ListRuleBasedMatchesOutputBody: Swift.Equatable {
    let matchIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListRuleBasedMatchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchIds = "MatchIds"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchIds)
        var matchIdsDecoded0:[Swift.String]? = nil
        if let matchIdsContainer = matchIdsContainer {
            matchIdsDecoded0 = [Swift.String]()
            for string0 in matchIdsContainer {
                if let string0 = string0 {
                    matchIdsDecoded0?.append(string0)
                }
            }
        }
        matchIds = matchIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRuleBasedMatchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryEndDate = "QueryEndDate"
        case queryStartDate = "QueryStartDate"
        case status = "Status"
        case workflowType = "WorkflowType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryEndDate = self.queryEndDate {
            try encodeContainer.encodeTimestamp(queryEndDate, format: .epochSeconds, forKey: .queryEndDate)
        }
        if let queryStartDate = self.queryStartDate {
            try encodeContainer.encodeTimestamp(queryStartDate, format: .epochSeconds, forKey: .queryStartDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workflowType = self.workflowType {
            try encodeContainer.encode(workflowType.rawValue, forKey: .workflowType)
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Retrieve workflows ended after timestamp.
    public var queryEndDate: ClientRuntime.Date?
    /// Retrieve workflows started after timestamp.
    public var queryStartDate: ClientRuntime.Date?
    /// Status of workflow execution.
    public var status: CustomerProfilesClientTypes.Status?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryEndDate: ClientRuntime.Date? = nil,
        queryStartDate: ClientRuntime.Date? = nil,
        status: CustomerProfilesClientTypes.Status? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryEndDate = queryEndDate
        self.queryStartDate = queryStartDate
        self.status = status
        self.workflowType = workflowType
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
    let workflowType: CustomerProfilesClientTypes.WorkflowType?
    let status: CustomerProfilesClientTypes.Status?
    let queryStartDate: ClientRuntime.Date?
    let queryEndDate: ClientRuntime.Date?
}

extension ListWorkflowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryEndDate = "QueryEndDate"
        case queryStartDate = "QueryStartDate"
        case status = "Status"
        case workflowType = "WorkflowType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let queryStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .queryStartDate)
        queryStartDate = queryStartDateDecoded
        let queryEndDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .queryEndDate)
        queryEndDate = queryEndDateDecoded
    }
}

extension CustomerProfilesClientTypes.ListWorkflowsItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case lastUpdatedAt = "LastUpdatedAt"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case workflowId = "WorkflowId"
        case workflowType = "WorkflowType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDescription = self.statusDescription {
            try encodeContainer.encode(statusDescription, forKey: .statusDescription)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowType = self.workflowType {
            try encodeContainer.encode(workflowType.rawValue, forKey: .workflowType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// A workflow in list of workflows.
    public struct ListWorkflowsItem: Swift.Equatable {
        /// Creation timestamp for workflow.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Last updated timestamp for workflow.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Status of workflow execution.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.Status?
        /// Description for workflow execution status.
        /// This member is required.
        public var statusDescription: Swift.String?
        /// Unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        /// This member is required.
        public var workflowType: CustomerProfilesClientTypes.WorkflowType?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: CustomerProfilesClientTypes.Status? = nil,
            statusDescription: Swift.String? = nil,
            workflowId: Swift.String? = nil,
            workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
        )
        {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusDescription = statusDescription
            self.workflowId = workflowId
            self.workflowType = workflowType
        }
    }

}

extension ListWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowsOutput: Swift.Equatable {
    /// List containing workflow details.
    public var items: [CustomerProfilesClientTypes.ListWorkflowsItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListWorkflowsItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWorkflowsOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.ListWorkflowsItem]?
    let nextToken: Swift.String?
}

extension ListWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.ListWorkflowsItem?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.ListWorkflowsItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.ListWorkflowsItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum LogicalOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .or,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogicalOperator(rawValue: rawValue) ?? LogicalOperator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum MarketoConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MarketoConnectorOperator(rawValue: rawValue) ?? MarketoConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.MarketoSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object = "Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The properties that are applied when Marketo is being used as a source.
    public struct MarketoSourceProperties: Swift.Equatable {
        /// The object specified in the Marketo flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension CustomerProfilesClientTypes.MatchItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidenceScore = "ConfidenceScore"
        case matchId = "MatchId"
        case profileIds = "ProfileIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidenceScore = self.confidenceScore {
            try encodeContainer.encode(confidenceScore, forKey: .confidenceScore)
        }
        if let matchId = self.matchId {
            try encodeContainer.encode(matchId, forKey: .matchId)
        }
        if let profileIds = profileIds {
            var profileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileIds)
            for uuid0 in profileIds {
                try profileIdsContainer.encode(uuid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchId)
        matchId = matchIdDecoded
        let profileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profileIds)
        var profileIdsDecoded0:[Swift.String]? = nil
        if let profileIdsContainer = profileIdsContainer {
            profileIdsDecoded0 = [Swift.String]()
            for string0 in profileIdsContainer {
                if let string0 = string0 {
                    profileIdsDecoded0?.append(string0)
                }
            }
        }
        profileIds = profileIdsDecoded0
        let confidenceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidenceScore)
        confidenceScore = confidenceScoreDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The Match group object.
    public struct MatchItem: Swift.Equatable {
        /// A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used an absolute measure of matching quality.
        public var confidenceScore: Swift.Double?
        /// The unique identifiers for this group of profiles that match.
        public var matchId: Swift.String?
        /// A list of identifiers for profiles that match.
        public var profileIds: [Swift.String]?

        public init(
            confidenceScore: Swift.Double? = nil,
            matchId: Swift.String? = nil,
            profileIds: [Swift.String]? = nil
        )
        {
            self.confidenceScore = confidenceScore
            self.matchId = matchId
            self.profileIds = profileIds
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum MatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mlBasedMatching
        case ruleBasedMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchType] {
            return [
                .mlBasedMatching,
                .ruleBasedMatching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mlBasedMatching: return "ML_BASED_MATCHING"
            case .ruleBasedMatching: return "RULE_BASED_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MatchType(rawValue: rawValue) ?? MatchType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.MatchingRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMerging = "AutoMerging"
        case enabled = "Enabled"
        case exportingConfig = "ExportingConfig"
        case jobSchedule = "JobSchedule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoMerging = self.autoMerging {
            try encodeContainer.encode(autoMerging, forKey: .autoMerging)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let exportingConfig = self.exportingConfig {
            try encodeContainer.encode(exportingConfig, forKey: .exportingConfig)
        }
        if let jobSchedule = self.jobSchedule {
            try encodeContainer.encode(jobSchedule, forKey: .jobSchedule)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let jobScheduleDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.JobSchedule.self, forKey: .jobSchedule)
        jobSchedule = jobScheduleDecoded
        let autoMergingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AutoMerging.self, forKey: .autoMerging)
        autoMerging = autoMergingDecoded
        let exportingConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ExportingConfig.self, forKey: .exportingConfig)
        exportingConfig = exportingConfigDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The flag that enables the matching process of duplicate profiles.
    public struct MatchingRequest: Swift.Equatable {
        /// Configuration information about the auto-merging process.
        public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public var jobSchedule: CustomerProfilesClientTypes.JobSchedule?

        public init(
            autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            jobSchedule: CustomerProfilesClientTypes.JobSchedule? = nil
        )
        {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }
    }

}

extension CustomerProfilesClientTypes.MatchingResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMerging = "AutoMerging"
        case enabled = "Enabled"
        case exportingConfig = "ExportingConfig"
        case jobSchedule = "JobSchedule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoMerging = self.autoMerging {
            try encodeContainer.encode(autoMerging, forKey: .autoMerging)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let exportingConfig = self.exportingConfig {
            try encodeContainer.encode(exportingConfig, forKey: .exportingConfig)
        }
        if let jobSchedule = self.jobSchedule {
            try encodeContainer.encode(jobSchedule, forKey: .jobSchedule)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let jobScheduleDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.JobSchedule.self, forKey: .jobSchedule)
        jobSchedule = jobScheduleDecoded
        let autoMergingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AutoMerging.self, forKey: .autoMerging)
        autoMerging = autoMergingDecoded
        let exportingConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ExportingConfig.self, forKey: .exportingConfig)
        exportingConfig = exportingConfigDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The flag that enables the matching process of duplicate profiles.
    public struct MatchingResponse: Swift.Equatable {
        /// Configuration information about the auto-merging process.
        public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        public var enabled: Swift.Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public var jobSchedule: CustomerProfilesClientTypes.JobSchedule?

        public init(
            autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            jobSchedule: CustomerProfilesClientTypes.JobSchedule? = nil
        )
        {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }
    }

}

extension CustomerProfilesClientTypes.MatchingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rule = rule {
            var ruleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rule)
            for string1to2550 in rule {
                try ruleContainer.encode(string1to2550)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rule)
        var ruleDecoded0:[Swift.String]? = nil
        if let ruleContainer = ruleContainer {
            ruleDecoded0 = [Swift.String]()
            for string0 in ruleContainer {
                if let string0 = string0 {
                    ruleDecoded0?.append(string0)
                }
            }
        }
        rule = ruleDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// Specifies how does the rule-based matching process should match profiles. You can choose from the following attributes to build the matching Rule:
    ///
    /// * AccountNumber
    ///
    /// * Address.Address
    ///
    /// * Address.City
    ///
    /// * Address.Country
    ///
    /// * Address.County
    ///
    /// * Address.PostalCode
    ///
    /// * Address.State
    ///
    /// * Address.Province
    ///
    /// * BirthDate
    ///
    /// * BusinessName
    ///
    /// * EmailAddress
    ///
    /// * FirstName
    ///
    /// * Gender
    ///
    /// * LastName
    ///
    /// * MiddleName
    ///
    /// * PhoneNumber
    ///
    /// * Any customized profile attributes that start with the Attributes
    public struct MatchingRule: Swift.Equatable {
        /// A single rule level of the MatchRules. Configures how the rule-based matching process should match profiles.
        /// This member is required.
        public var rule: [Swift.String]?

        public init(
            rule: [Swift.String]? = nil
        )
        {
            self.rule = rule
        }
    }

}

extension MergeProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldSourceProfileIds = "FieldSourceProfileIds"
        case mainProfileId = "MainProfileId"
        case profileIdsToBeMerged = "ProfileIdsToBeMerged"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSourceProfileIds = self.fieldSourceProfileIds {
            try encodeContainer.encode(fieldSourceProfileIds, forKey: .fieldSourceProfileIds)
        }
        if let mainProfileId = self.mainProfileId {
            try encodeContainer.encode(mainProfileId, forKey: .mainProfileId)
        }
        if let profileIdsToBeMerged = profileIdsToBeMerged {
            var profileIdsToBeMergedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileIdsToBeMerged)
            for uuid0 in profileIdsToBeMerged {
                try profileIdsToBeMergedContainer.encode(uuid0)
            }
        }
    }
}

extension MergeProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects/merge"
    }
}

public struct MergeProfilesInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The identifiers of the fields in the profile that has the information you want to apply to the merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the identifier of the EmailAddress field in Profile1.
    public var fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds?
    /// The identifier of the profile to be taken.
    /// This member is required.
    public var mainProfileId: Swift.String?
    /// The identifier of the profile to be merged into MainProfileId.
    /// This member is required.
    public var profileIdsToBeMerged: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds? = nil,
        mainProfileId: Swift.String? = nil,
        profileIdsToBeMerged: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.fieldSourceProfileIds = fieldSourceProfileIds
        self.mainProfileId = mainProfileId
        self.profileIdsToBeMerged = profileIdsToBeMerged
    }
}

struct MergeProfilesInputBody: Swift.Equatable {
    let mainProfileId: Swift.String?
    let profileIdsToBeMerged: [Swift.String]?
    let fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds?
}

extension MergeProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldSourceProfileIds = "FieldSourceProfileIds"
        case mainProfileId = "MainProfileId"
        case profileIdsToBeMerged = "ProfileIdsToBeMerged"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mainProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mainProfileId)
        mainProfileId = mainProfileIdDecoded
        let profileIdsToBeMergedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profileIdsToBeMerged)
        var profileIdsToBeMergedDecoded0:[Swift.String]? = nil
        if let profileIdsToBeMergedContainer = profileIdsToBeMergedContainer {
            profileIdsToBeMergedDecoded0 = [Swift.String]()
            for string0 in profileIdsToBeMergedContainer {
                if let string0 = string0 {
                    profileIdsToBeMergedDecoded0?.append(string0)
                }
            }
        }
        profileIdsToBeMerged = profileIdsToBeMergedDecoded0
        let fieldSourceProfileIdsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.FieldSourceProfileIds.self, forKey: .fieldSourceProfileIds)
        fieldSourceProfileIds = fieldSourceProfileIdsDecoded
    }
}

extension MergeProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergeProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct MergeProfilesOutput: Swift.Equatable {
    /// A message that indicates the merge request is complete.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MergeProfilesOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension MergeProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum MergeProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.ObjectFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName = "KeyName"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string1to2550 in values {
                try valuesContainer.encode(string1to2550)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// The filter applied to ListProfileObjects response to include profile objects with the specified index values.
    public struct ObjectFilter: Swift.Equatable {
        /// A searchable identifier of a profile object. The predefined keys you can use to search for _asset include: _assetId, _assetName, and _serialNumber. The predefined keys you can use to search for _case include: _caseId. The predefined keys you can use to search for _order include: _orderId.
        /// This member is required.
        public var keyName: Swift.String?
        /// A list of key values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.keyName = keyName
            self.values = values
        }
    }

}

extension CustomerProfilesClientTypes.ObjectTypeField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case source = "Source"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.FieldContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Represents a field in a ProfileObjectType.
    public struct ObjectTypeField: Swift.Equatable {
        /// The content type of the field. Used for determining equality when searching.
        public var contentType: CustomerProfilesClientTypes.FieldContentType?
        /// A field of a ProfileObject. For example: _source.FirstName, where _source is a ProfileObjectType of a Zendesk user and FirstName is a field in that ObjectType.
        public var source: Swift.String?
        /// The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        public var target: Swift.String?

        public init(
            contentType: CustomerProfilesClientTypes.FieldContentType? = nil,
            source: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.source = source
            self.target = target
        }
    }

}

extension CustomerProfilesClientTypes.ObjectTypeKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldNames = "FieldNames"
        case standardIdentifiers = "StandardIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldNames = fieldNames {
            var fieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldNames)
            for name0 in fieldNames {
                try fieldNamesContainer.encode(name0)
            }
        }
        if let standardIdentifiers = standardIdentifiers {
            var standardIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardIdentifiers)
            for standardidentifier0 in standardIdentifiers {
                try standardIdentifiersContainer.encode(standardidentifier0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardIdentifiersContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.StandardIdentifier?].self, forKey: .standardIdentifiers)
        var standardIdentifiersDecoded0:[CustomerProfilesClientTypes.StandardIdentifier]? = nil
        if let standardIdentifiersContainer = standardIdentifiersContainer {
            standardIdentifiersDecoded0 = [CustomerProfilesClientTypes.StandardIdentifier]()
            for enum0 in standardIdentifiersContainer {
                if let enum0 = enum0 {
                    standardIdentifiersDecoded0?.append(enum0)
                }
            }
        }
        standardIdentifiers = standardIdentifiersDecoded0
        let fieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fieldNames)
        var fieldNamesDecoded0:[Swift.String]? = nil
        if let fieldNamesContainer = fieldNamesContainer {
            fieldNamesDecoded0 = [Swift.String]()
            for string0 in fieldNamesContainer {
                if let string0 = string0 {
                    fieldNamesDecoded0?.append(string0)
                }
            }
        }
        fieldNames = fieldNamesDecoded0
    }
}

extension CustomerProfilesClientTypes {
    /// An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
    public struct ObjectTypeKey: Swift.Equatable {
        /// The reference for the key name of the fields map.
        public var fieldNames: [Swift.String]?
        /// The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE, ASSET, CASE, or ORDER means that this key can be used to tie an object to a PROFILE, ASSET, CASE, or ORDER respectively. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        public var standardIdentifiers: [CustomerProfilesClientTypes.StandardIdentifier]?

        public init(
            fieldNames: [Swift.String]? = nil,
            standardIdentifiers: [CustomerProfilesClientTypes.StandardIdentifier]? = nil
        )
        {
            self.fieldNames = fieldNames
            self.standardIdentifiers = standardIdentifiers
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case notEqualTo
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan,
                .notEqualTo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum OperatorPropertiesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatorPropertiesKeys(rawValue: rawValue) ?? OperatorPropertiesKeys.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    @available(*, deprecated)
    public enum PartyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case business
        case individual
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [PartyType] {
            return [
                .business,
                .individual,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .business: return "BUSINESS"
            case .individual: return "INDIVIDUAL"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartyType(rawValue: rawValue) ?? PartyType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.Profile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case foundByItems = "FoundByItems"
        case gender = "Gender"
        case genderString = "GenderString"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case partyTypeString = "PartyTypeString"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case profileId = "ProfileId"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = self.accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = self.additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = self.billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = self.birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = self.businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = self.businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let foundByItems = foundByItems {
            var foundByItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .foundByItems)
            for foundbykeyvalue0 in foundByItems {
                try foundByItemsContainer.encode(foundbykeyvalue0)
            }
        }
        if let gender = self.gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let genderString = self.genderString {
            try encodeContainer.encode(genderString, forKey: .genderString)
        }
        if let homePhoneNumber = self.homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = self.mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = self.middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = self.mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = self.partyType {
            try encodeContainer.encode(partyType.rawValue, forKey: .partyType)
        }
        if let partyTypeString = self.partyTypeString {
            try encodeContainer.encode(partyTypeString, forKey: .partyTypeString)
        }
        if let personalEmailAddress = self.personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let accountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.PartyType.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Gender.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Address.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string1to2550) in attributesContainer {
                if let string1to2550 = string1to2550 {
                    attributesDecoded0?[key0] = string1to2550
                }
            }
        }
        attributes = attributesDecoded0
        let foundByItemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.FoundByKeyValue?].self, forKey: .foundByItems)
        var foundByItemsDecoded0:[CustomerProfilesClientTypes.FoundByKeyValue]? = nil
        if let foundByItemsContainer = foundByItemsContainer {
            foundByItemsDecoded0 = [CustomerProfilesClientTypes.FoundByKeyValue]()
            for structure0 in foundByItemsContainer {
                if let structure0 = structure0 {
                    foundByItemsDecoded0?.append(structure0)
                }
            }
        }
        foundByItems = foundByItemsDecoded0
        let partyTypeStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partyTypeString)
        partyTypeString = partyTypeStringDecoded
        let genderStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .genderString)
        genderString = genderStringDecoded
    }
}

extension CustomerProfilesClientTypes.Profile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Profile(foundByItems: \(Swift.String(describing: foundByItems)), profileId: \(Swift.String(describing: profileId)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {
    /// The standard profile of a customer.
    public struct Profile: Swift.Equatable {
        /// A unique account number that you have given to the customer.
        public var accountNumber: Swift.String?
        /// Any additional information relevant to the customers profile.
        public var additionalInformation: Swift.String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public var address: CustomerProfilesClientTypes.Address?
        /// A key value pair of attributes of a customer profile.
        public var attributes: [Swift.String:Swift.String]?
        /// The customers billing address.
        public var billingAddress: CustomerProfilesClientTypes.Address?
        /// The customers birth date.
        public var birthDate: Swift.String?
        /// The customers business email address.
        public var businessEmailAddress: Swift.String?
        /// The name of the customers business.
        public var businessName: Swift.String?
        /// The customers home phone number.
        public var businessPhoneNumber: Swift.String?
        /// The customers email address, which has not been specified as a personal or business address.
        public var emailAddress: Swift.String?
        /// The customers first name.
        public var firstName: Swift.String?
        /// A list of items used to find a profile returned in a [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) response. An item is a key-value(s) pair that matches an attribute in the profile. If the optional AdditionalSearchKeys parameter was included in the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request, the FoundByItems list should be interpreted based on the LogicalOperator used in the request:
        ///
        /// * AND - The profile included in the response matched all of the search keys specified in the request. The FoundByItems will include all of the key-value(s) pairs that were specified in the request (as this is a requirement of AND search logic).
        ///
        /// * OR - The profile included in the response matched at least one of the search keys specified in the request. The FoundByItems will include each of the key-value(s) pairs that the profile was found by.
        ///
        ///
        /// The OR relationship is the default behavior if the LogicalOperator parameter is not included in the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request.
        public var foundByItems: [CustomerProfilesClientTypes.FoundByKeyValue]?
        /// The gender with which the customer identifies.
        @available(*, deprecated)
        public var gender: CustomerProfilesClientTypes.Gender?
        /// An alternative to Gender which accepts any string as input.
        public var genderString: Swift.String?
        /// The customers home phone number.
        public var homePhoneNumber: Swift.String?
        /// The customers last name.
        public var lastName: Swift.String?
        /// The customers mailing address.
        public var mailingAddress: CustomerProfilesClientTypes.Address?
        /// The customers middle name.
        public var middleName: Swift.String?
        /// The customers mobile phone number.
        public var mobilePhoneNumber: Swift.String?
        /// The type of profile used to describe the customer.
        @available(*, deprecated)
        public var partyType: CustomerProfilesClientTypes.PartyType?
        /// An alternative to PartyType which accepts any string as input.
        public var partyTypeString: Swift.String?
        /// The customers personal email address.
        public var personalEmailAddress: Swift.String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public var phoneNumber: Swift.String?
        /// The unique identifier of a customer profile.
        public var profileId: Swift.String?
        /// The customers shipping address.
        public var shippingAddress: CustomerProfilesClientTypes.Address?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address: CustomerProfilesClientTypes.Address? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            billingAddress: CustomerProfilesClientTypes.Address? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            foundByItems: [CustomerProfilesClientTypes.FoundByKeyValue]? = nil,
            gender: CustomerProfilesClientTypes.Gender? = nil,
            genderString: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress: CustomerProfilesClientTypes.Address? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: CustomerProfilesClientTypes.PartyType? = nil,
            partyTypeString: Swift.String? = nil,
            personalEmailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            profileId: Swift.String? = nil,
            shippingAddress: CustomerProfilesClientTypes.Address? = nil
        )
        {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.foundByItems = foundByItems
            self.gender = gender
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.shippingAddress = shippingAddress
        }
    }

}

extension PutIntegrationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutIntegrationInput(domainName: \(Swift.String(describing: domainName)), objectTypeName: \(Swift.String(describing: objectTypeName)), objectTypeNames: \(Swift.String(describing: objectTypeNames)), tags: \(Swift.String(describing: tags)), uri: \(Swift.String(describing: uri)), flowDefinition: \"CONTENT_REDACTED\")"}
}

extension PutIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowDefinition = "FlowDefinition"
        case objectTypeName = "ObjectTypeName"
        case objectTypeNames = "ObjectTypeNames"
        case tags = "Tags"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowDefinition = self.flowDefinition {
            try encodeContainer.encode(flowDefinition, forKey: .flowDefinition)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
        if let objectTypeNames = objectTypeNames {
            var objectTypeNamesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .objectTypeNames)
            for (dictKey0, objectTypeNames0) in objectTypeNames {
                try objectTypeNamesContainer.encode(objectTypeNames0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension PutIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

public struct PutIntegrationInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The configuration that controls how Customer Profiles retrieves data from the source.
    public var flowDefinition: CustomerProfilesClientTypes.FlowDefinition?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String:Swift.String]?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        flowDefinition: CustomerProfilesClientTypes.FlowDefinition? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.flowDefinition = flowDefinition
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.tags = tags
        self.uri = uri
    }
}

struct PutIntegrationInputBody: Swift.Equatable {
    let uri: Swift.String?
    let objectTypeName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let flowDefinition: CustomerProfilesClientTypes.FlowDefinition?
    let objectTypeNames: [Swift.String:Swift.String]?
}

extension PutIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowDefinition = "FlowDefinition"
        case objectTypeName = "ObjectTypeName"
        case objectTypeNames = "ObjectTypeNames"
        case tags = "Tags"
        case uri = "Uri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let flowDefinitionDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.FlowDefinition.self, forKey: .flowDefinition)
        flowDefinition = flowDefinitionDecoded
        let objectTypeNamesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .objectTypeNames)
        var objectTypeNamesDecoded0: [Swift.String:Swift.String]? = nil
        if let objectTypeNamesContainer = objectTypeNamesContainer {
            objectTypeNamesDecoded0 = [Swift.String:Swift.String]()
            for (key0, typename0) in objectTypeNamesContainer {
                if let typename0 = typename0 {
                    objectTypeNamesDecoded0?[key0] = typename0
                }
            }
        }
        objectTypeNames = objectTypeNamesDecoded0
    }
}

extension PutIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.domainName = output.domainName
            self.isUnstructured = output.isUnstructured
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.objectTypeNames = output.objectTypeNames
            self.tags = output.tags
            self.uri = output.uri
            self.workflowId = output.workflowId
        } else {
            self.createdAt = nil
            self.domainName = nil
            self.isUnstructured = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.objectTypeNames = nil
            self.tags = nil
            self.uri = nil
            self.workflowId = nil
        }
    }
}

public struct PutIntegrationOutput: Swift.Equatable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
    public var isUnstructured: Swift.Bool?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String:Swift.String]?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        domainName: Swift.String? = nil,
        isUnstructured: Swift.Bool? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.isUnstructured = isUnstructured
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.tags = tags
        self.uri = uri
        self.workflowId = workflowId
    }
}

struct PutIntegrationOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let uri: Swift.String?
    let objectTypeName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let objectTypeNames: [Swift.String:Swift.String]?
    let workflowId: Swift.String?
    let isUnstructured: Swift.Bool?
}

extension PutIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case isUnstructured = "IsUnstructured"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case objectTypeNames = "ObjectTypeNames"
        case tags = "Tags"
        case uri = "Uri"
        case workflowId = "WorkflowId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let objectTypeNamesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .objectTypeNames)
        var objectTypeNamesDecoded0: [Swift.String:Swift.String]? = nil
        if let objectTypeNamesContainer = objectTypeNamesContainer {
            objectTypeNamesDecoded0 = [Swift.String:Swift.String]()
            for (key0, typename0) in objectTypeNamesContainer {
                if let typename0 = typename0 {
                    objectTypeNamesDecoded0?[key0] = typename0
                }
            }
        }
        objectTypeNames = objectTypeNamesDecoded0
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let isUnstructuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUnstructured)
        isUnstructured = isUnstructuredDecoded
    }
}

enum PutIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutProfileObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectInput(domainName: \(Swift.String(describing: domainName)), objectTypeName: \(Swift.String(describing: objectTypeName)), object: \"CONTENT_REDACTED\")"}
}

extension PutProfileObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object = "Object"
        case objectTypeName = "ObjectTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
    }
}

extension PutProfileObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects"
    }
}

public struct PutProfileObjectInput: Swift.Equatable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A string that is serialized from a JSON object.
    /// This member is required.
    public var object: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        object: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.object = object
        self.objectTypeName = objectTypeName
    }
}

struct PutProfileObjectInputBody: Swift.Equatable {
    let objectTypeName: Swift.String?
    let object: Swift.String?
}

extension PutProfileObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object = "Object"
        case objectTypeName = "ObjectTypeName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension PutProfileObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutProfileObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileObjectUniqueKey = output.profileObjectUniqueKey
        } else {
            self.profileObjectUniqueKey = nil
        }
    }
}

public struct PutProfileObjectOutput: Swift.Equatable {
    /// The unique identifier of the profile object generated by the service.
    public var profileObjectUniqueKey: Swift.String?

    public init(
        profileObjectUniqueKey: Swift.String? = nil
    )
    {
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

struct PutProfileObjectOutputBody: Swift.Equatable {
    let profileObjectUniqueKey: Swift.String?
}

extension PutProfileObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileObjectUniqueKey = "ProfileObjectUniqueKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileObjectUniqueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileObjectUniqueKey)
        profileObjectUniqueKey = profileObjectUniqueKeyDecoded
    }
}

enum PutProfileObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutProfileObjectTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectTypeInput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), domainName: \(Swift.String(describing: domainName)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension PutProfileObjectTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowProfileCreation = self.allowProfileCreation {
            try encodeContainer.encode(allowProfileCreation, forKey: .allowProfileCreation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let expirationDays = self.expirationDays {
            try encodeContainer.encode(expirationDays, forKey: .expirationDays)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldMap0) in fields {
                try fieldsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .keys)
            for (dictKey0, keyMap0) in keys {
                var keyMap0Container = keysContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for objecttypekey1 in keyMap0 {
                    try keyMap0Container.encode(objecttypekey1)
                }
            }
        }
        if let sourceLastUpdatedTimestampFormat = self.sourceLastUpdatedTimestampFormat {
            try encodeContainer.encode(sourceLastUpdatedTimestampFormat, forKey: .sourceLastUpdatedTimestampFormat)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

extension PutProfileObjectTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let objectTypeName = objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

public struct PutProfileObjectTypeInput: Swift.Equatable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool?
    /// Description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// A unique identifier for the object template. For some attributes in the request, the service will use the default value from the object template when TemplateId is present. If these attributes are present in the request, the service may return a BadRequestException. These attributes include: AllowProfileCreation, SourceLastUpdatedTimestampFormat, Fields, and Keys. For example, if AllowProfileCreation is set to true when TemplateId is set, the service may return a BadRequestException.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.description = description
        self.domainName = domainName
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

struct PutProfileObjectTypeInputBody: Swift.Equatable {
    let description: Swift.String?
    let templateId: Swift.String?
    let expirationDays: Swift.Int?
    let encryptionKey: Swift.String?
    let allowProfileCreation: Swift.Bool?
    let sourceLastUpdatedTimestampFormat: Swift.String?
    let fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    let keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    let tags: [Swift.String:Swift.String]?
}

extension PutProfileObjectTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let allowProfileCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowProfileCreation)
        allowProfileCreation = allowProfileCreationDecoded
        let sourceLastUpdatedTimestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLastUpdatedTimestampFormat)
        sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormatDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: CustomerProfilesClientTypes.ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [CustomerProfilesClientTypes.ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [CustomerProfilesClientTypes.ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutProfileObjectTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectTypeOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension PutProfileObjectTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutProfileObjectTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowProfileCreation = output.allowProfileCreation
            self.createdAt = output.createdAt
            self.description = output.description
            self.encryptionKey = output.encryptionKey
            self.expirationDays = output.expirationDays
            self.fields = output.fields
            self.keys = output.keys
            self.lastUpdatedAt = output.lastUpdatedAt
            self.objectTypeName = output.objectTypeName
            self.sourceLastUpdatedTimestampFormat = output.sourceLastUpdatedTimestampFormat
            self.tags = output.tags
            self.templateId = output.templateId
        } else {
            self.allowProfileCreation = false
            self.createdAt = nil
            self.description = nil
            self.encryptionKey = nil
            self.expirationDays = nil
            self.fields = nil
            self.keys = nil
            self.lastUpdatedAt = nil
            self.objectTypeName = nil
            self.sourceLastUpdatedTimestampFormat = nil
            self.tags = nil
            self.templateId = nil
        }
    }
}

public struct PutProfileObjectTypeOutput: Swift.Equatable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// The timestamp of when the domain was created.
    public var createdAt: ClientRuntime.Date?
    /// Description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The timestamp of when the domain was most recently edited.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up in fields that were parsed using [SimpleDateFormat](https://docs.oracle.com/javase/10/docs/api/java/text/SimpleDateFormat.html). If you have sourceLastUpdatedTimestamp in your field, you must set up sourceLastUpdatedTimestampFormat.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

struct PutProfileObjectTypeOutputBody: Swift.Equatable {
    let objectTypeName: Swift.String?
    let description: Swift.String?
    let templateId: Swift.String?
    let expirationDays: Swift.Int?
    let encryptionKey: Swift.String?
    let allowProfileCreation: Swift.Bool
    let sourceLastUpdatedTimestampFormat: Swift.String?
    let fields: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]?
    let keys: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension PutProfileObjectTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowProfileCreation = "AllowProfileCreation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case expirationDays = "ExpirationDays"
        case fields = "Fields"
        case keys = "Keys"
        case lastUpdatedAt = "LastUpdatedAt"
        case objectTypeName = "ObjectTypeName"
        case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
        case tags = "Tags"
        case templateId = "TemplateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let allowProfileCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowProfileCreation) ?? false
        allowProfileCreation = allowProfileCreationDecoded
        let sourceLastUpdatedTimestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLastUpdatedTimestampFormat)
        sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormatDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: CustomerProfilesClientTypes.ObjectTypeField?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:CustomerProfilesClientTypes.ObjectTypeField]()
            for (key0, objecttypefield0) in fieldsContainer {
                if let objecttypefield0 = objecttypefield0 {
                    fieldsDecoded0?[key0] = objecttypefield0
                }
            }
        }
        fields = fieldsDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey?]?].self, forKey: .keys)
        var keysDecoded0: [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String:[CustomerProfilesClientTypes.ObjectTypeKey]]()
            for (key0, objecttypekeylist0) in keysContainer {
                var objecttypekeylist0Decoded0: [CustomerProfilesClientTypes.ObjectTypeKey]? = nil
                if let objecttypekeylist0 = objecttypekeylist0 {
                    objecttypekeylist0Decoded0 = [CustomerProfilesClientTypes.ObjectTypeKey]()
                    for structure1 in objecttypekeylist0 {
                        if let structure1 = structure1 {
                            objecttypekeylist0Decoded0?.append(structure1)
                        }
                    }
                }
                keysDecoded0?[key0] = objecttypekeylist0Decoded0
            }
        }
        keys = keysDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum PutProfileObjectTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.Range: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The relative time period over which data is included in the aggregation.
    public struct Range: Swift.Equatable {
        /// The unit of time.
        /// This member is required.
        public var unit: CustomerProfilesClientTypes.Unit?
        /// The amount of time of the specified unit.
        /// This member is required.
        public var value: Swift.Int

        public init(
            unit: CustomerProfilesClientTypes.Unit? = nil,
            value: Swift.Int = 0
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomerProfilesClientTypes.RuleBasedMatchingRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeTypesSelector = "AttributeTypesSelector"
        case conflictResolution = "ConflictResolution"
        case enabled = "Enabled"
        case exportingConfig = "ExportingConfig"
        case matchingRules = "MatchingRules"
        case maxAllowedRuleLevelForMatching = "MaxAllowedRuleLevelForMatching"
        case maxAllowedRuleLevelForMerging = "MaxAllowedRuleLevelForMerging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeTypesSelector = self.attributeTypesSelector {
            try encodeContainer.encode(attributeTypesSelector, forKey: .attributeTypesSelector)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let exportingConfig = self.exportingConfig {
            try encodeContainer.encode(exportingConfig, forKey: .exportingConfig)
        }
        if let matchingRules = matchingRules {
            var matchingRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingRules)
            for matchingrule0 in matchingRules {
                try matchingRulesContainer.encode(matchingrule0)
            }
        }
        if let maxAllowedRuleLevelForMatching = self.maxAllowedRuleLevelForMatching {
            try encodeContainer.encode(maxAllowedRuleLevelForMatching, forKey: .maxAllowedRuleLevelForMatching)
        }
        if let maxAllowedRuleLevelForMerging = self.maxAllowedRuleLevelForMerging {
            try encodeContainer.encode(maxAllowedRuleLevelForMerging, forKey: .maxAllowedRuleLevelForMerging)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingRulesContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.MatchingRule?].self, forKey: .matchingRules)
        var matchingRulesDecoded0:[CustomerProfilesClientTypes.MatchingRule]? = nil
        if let matchingRulesContainer = matchingRulesContainer {
            matchingRulesDecoded0 = [CustomerProfilesClientTypes.MatchingRule]()
            for structure0 in matchingRulesContainer {
                if let structure0 = structure0 {
                    matchingRulesDecoded0?.append(structure0)
                }
            }
        }
        matchingRules = matchingRulesDecoded0
        let maxAllowedRuleLevelForMergingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllowedRuleLevelForMerging)
        maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMergingDecoded
        let maxAllowedRuleLevelForMatchingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllowedRuleLevelForMatching)
        maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatchingDecoded
        let attributeTypesSelectorDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeTypesSelector.self, forKey: .attributeTypesSelector)
        attributeTypesSelector = attributeTypesSelectorDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let exportingConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ExportingConfig.self, forKey: .exportingConfig)
        exportingConfig = exportingConfigDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The request to enable the rule-based matching.
    public struct RuleBasedMatchingRequest: Swift.Equatable {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public var attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector?
        /// How the auto-merging process should resolve conflicts between different profiles.
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public var matchingRules: [CustomerProfilesClientTypes.MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public var maxAllowedRuleLevelForMatching: Swift.Int?
        /// [MatchingRule](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_MatchingRule.html)
        public var maxAllowedRuleLevelForMerging: Swift.Int?

        public init(
            attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector? = nil,
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            matchingRules: [CustomerProfilesClientTypes.MatchingRule]? = nil,
            maxAllowedRuleLevelForMatching: Swift.Int? = nil,
            maxAllowedRuleLevelForMerging: Swift.Int? = nil
        )
        {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
        }
    }

}

extension CustomerProfilesClientTypes.RuleBasedMatchingResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeTypesSelector = "AttributeTypesSelector"
        case conflictResolution = "ConflictResolution"
        case enabled = "Enabled"
        case exportingConfig = "ExportingConfig"
        case matchingRules = "MatchingRules"
        case maxAllowedRuleLevelForMatching = "MaxAllowedRuleLevelForMatching"
        case maxAllowedRuleLevelForMerging = "MaxAllowedRuleLevelForMerging"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeTypesSelector = self.attributeTypesSelector {
            try encodeContainer.encode(attributeTypesSelector, forKey: .attributeTypesSelector)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let exportingConfig = self.exportingConfig {
            try encodeContainer.encode(exportingConfig, forKey: .exportingConfig)
        }
        if let matchingRules = matchingRules {
            var matchingRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingRules)
            for matchingrule0 in matchingRules {
                try matchingRulesContainer.encode(matchingrule0)
            }
        }
        if let maxAllowedRuleLevelForMatching = self.maxAllowedRuleLevelForMatching {
            try encodeContainer.encode(maxAllowedRuleLevelForMatching, forKey: .maxAllowedRuleLevelForMatching)
        }
        if let maxAllowedRuleLevelForMerging = self.maxAllowedRuleLevelForMerging {
            try encodeContainer.encode(maxAllowedRuleLevelForMerging, forKey: .maxAllowedRuleLevelForMerging)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingRulesContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.MatchingRule?].self, forKey: .matchingRules)
        var matchingRulesDecoded0:[CustomerProfilesClientTypes.MatchingRule]? = nil
        if let matchingRulesContainer = matchingRulesContainer {
            matchingRulesDecoded0 = [CustomerProfilesClientTypes.MatchingRule]()
            for structure0 in matchingRulesContainer {
                if let structure0 = structure0 {
                    matchingRulesDecoded0?.append(structure0)
                }
            }
        }
        matchingRules = matchingRulesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.RuleBasedMatchingStatus.self, forKey: .status)
        status = statusDecoded
        let maxAllowedRuleLevelForMergingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllowedRuleLevelForMerging)
        maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMergingDecoded
        let maxAllowedRuleLevelForMatchingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllowedRuleLevelForMatching)
        maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatchingDecoded
        let attributeTypesSelectorDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeTypesSelector.self, forKey: .attributeTypesSelector)
        attributeTypesSelector = attributeTypesSelectorDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let exportingConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ExportingConfig.self, forKey: .exportingConfig)
        exportingConfig = exportingConfigDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The response of the Rule-based matching request.
    public struct RuleBasedMatchingResponse: Swift.Equatable {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public var attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector?
        /// How the auto-merging process should resolve conflicts between different profiles.
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        public var enabled: Swift.Bool?
        /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public var matchingRules: [CustomerProfilesClientTypes.MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public var maxAllowedRuleLevelForMatching: Swift.Int?
        /// [MatchingRule](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_MatchingRule.html)
        public var maxAllowedRuleLevelForMerging: Swift.Int?
        /// PENDING
        ///
        /// * The first status after configuration a rule-based matching rule. If it is an existing domain, the rule-based Identity Resolution waits one hour before creating the matching rule. If it is a new domain, the system will skip the PENDING stage.
        ///
        ///
        /// IN_PROGRESS
        ///
        /// * The system is creating the rule-based matching rule. Under this status, the system is evaluating the existing data and you can no longer change the Rule-based matching configuration.
        ///
        ///
        /// ACTIVE
        ///
        /// * The rule is ready to use. You can change the rule a day after the status is in ACTIVE.
        public var status: CustomerProfilesClientTypes.RuleBasedMatchingStatus?

        public init(
            attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector? = nil,
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            matchingRules: [CustomerProfilesClientTypes.MatchingRule]? = nil,
            maxAllowedRuleLevelForMatching: Swift.Int? = nil,
            maxAllowedRuleLevelForMerging: Swift.Int? = nil,
            status: CustomerProfilesClientTypes.RuleBasedMatchingStatus? = nil
        )
        {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
            self.status = status
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum RuleBasedMatchingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleBasedMatchingStatus] {
            return [
                .active,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleBasedMatchingStatus(rawValue: rawValue) ?? RuleBasedMatchingStatus.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum S3ConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ConnectorOperator(rawValue: rawValue) ?? S3ConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.S3ExportingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3KeyName = "S3KeyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyName = self.s3KeyName {
            try encodeContainer.encode(s3KeyName, forKey: .s3KeyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyName)
        s3KeyName = s3KeyNameDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Configuration information about the S3 bucket where Identity Resolution Jobs write result files.
    public struct S3ExportingConfig: Swift.Equatable {
        /// The name of the S3 bucket where Identity Resolution Jobs write result files.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public var s3KeyName: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyName: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }
    }

}

extension CustomerProfilesClientTypes.S3ExportingLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3KeyName = "S3KeyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyName = self.s3KeyName {
            try encodeContainer.encode(s3KeyName, forKey: .s3KeyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyName)
        s3KeyName = s3KeyNameDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The S3 location where Identity Resolution Jobs write result files.
    public struct S3ExportingLocation: Swift.Equatable {
        /// The name of the S3 bucket name where Identity Resolution Jobs write result files.
        public var s3BucketName: Swift.String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public var s3KeyName: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyName: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }
    }

}

extension CustomerProfilesClientTypes.S3SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case bucketPrefix = "BucketPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The properties that are applied when Amazon S3 is being used as the flow source.
    public struct S3SourceProperties: Swift.Equatable {
        /// The Amazon S3 bucket name where the source files are stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public var bucketPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum SalesforceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceConnectorOperator(rawValue: rawValue) ?? SalesforceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.SalesforceSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDynamicFieldUpdate = "EnableDynamicFieldUpdate"
        case includeDeletedRecords = "IncludeDeletedRecords"
        case object = "Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDynamicFieldUpdate != false {
            try encodeContainer.encode(enableDynamicFieldUpdate, forKey: .enableDynamicFieldUpdate)
        }
        if includeDeletedRecords != false {
            try encodeContainer.encode(includeDeletedRecords, forKey: .includeDeletedRecords)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let enableDynamicFieldUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDynamicFieldUpdate) ?? false
        enableDynamicFieldUpdate = enableDynamicFieldUpdateDecoded
        let includeDeletedRecordsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDeletedRecords) ?? false
        includeDeletedRecords = includeDeletedRecordsDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The properties that are applied when Salesforce is being used as a source.
    public struct SalesforceSourceProperties: Swift.Equatable {
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public var enableDynamicFieldUpdate: Swift.Bool
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public var includeDeletedRecords: Swift.Bool
        /// The object specified in the Salesforce flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }

}

extension CustomerProfilesClientTypes.ScheduledTriggerProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullMode = "DataPullMode"
        case firstExecutionFrom = "FirstExecutionFrom"
        case scheduleEndTime = "ScheduleEndTime"
        case scheduleExpression = "ScheduleExpression"
        case scheduleOffset = "ScheduleOffset"
        case scheduleStartTime = "ScheduleStartTime"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullMode = self.dataPullMode {
            try encodeContainer.encode(dataPullMode.rawValue, forKey: .dataPullMode)
        }
        if let firstExecutionFrom = self.firstExecutionFrom {
            try encodeContainer.encodeTimestamp(firstExecutionFrom, format: .epochSeconds, forKey: .firstExecutionFrom)
        }
        if let scheduleEndTime = self.scheduleEndTime {
            try encodeContainer.encodeTimestamp(scheduleEndTime, format: .epochSeconds, forKey: .scheduleEndTime)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let scheduleOffset = self.scheduleOffset {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleStartTime = self.scheduleStartTime {
            try encodeContainer.encodeTimestamp(scheduleStartTime, format: .epochSeconds, forKey: .scheduleStartTime)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let dataPullModeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.DataPullMode.self, forKey: .dataPullMode)
        dataPullMode = dataPullModeDecoded
        let scheduleStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduleStartTime)
        scheduleStartTime = scheduleStartTimeDecoded
        let scheduleEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduleEndTime)
        scheduleEndTime = scheduleEndTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let firstExecutionFromDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Specifies the configuration details of a scheduled-trigger flow that you define. Currently, these settings only apply to the scheduled-trigger type.
    public struct ScheduledTriggerProperties: Swift.Equatable {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public var dataPullMode: CustomerProfilesClientTypes.DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public var firstExecutionFrom: ClientRuntime.Date?
        /// Specifies the scheduled end time for a scheduled-trigger flow.
        public var scheduleEndTime: ClientRuntime.Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public var scheduleOffset: Swift.Int?
        /// Specifies the scheduled start time for a scheduled-trigger flow.
        public var scheduleStartTime: ClientRuntime.Date?
        /// Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        public var timezone: Swift.String?

        public init(
            dataPullMode: CustomerProfilesClientTypes.DataPullMode? = nil,
            firstExecutionFrom: ClientRuntime.Date? = nil,
            scheduleEndTime: ClientRuntime.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            scheduleStartTime: ClientRuntime.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }

}

extension SearchProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalSearchKeys = "AdditionalSearchKeys"
        case keyName = "KeyName"
        case logicalOperator = "LogicalOperator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalSearchKeys = additionalSearchKeys {
            var additionalSearchKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalSearchKeys)
            for additionalsearchkey0 in additionalSearchKeys {
                try additionalSearchKeysContainer.encode(additionalsearchkey0)
            }
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let logicalOperator = self.logicalOperator {
            try encodeContainer.encode(logicalOperator.rawValue, forKey: .logicalOperator)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string1to2550 in values {
                try valuesContainer.encode(string1to2550)
            }
        }
    }
}

extension SearchProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/search"
    }
}

public struct SearchProfilesInput: Swift.Equatable {
    /// A list of AdditionalSearchKey objects that are each searchable identifiers of a profile. Each AdditionalSearchKey object contains a KeyName and a list of Values associated with that specific key (i.e., a key-value(s) pair). These additional search keys will be used in conjunction with the LogicalOperator and the required KeyName and Values parameters to search for profiles that satisfy the search criteria.
    public var additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
    /// This member is required.
    public var keyName: Swift.String?
    /// Relationship between all specified search keys that will be used to search for profiles. This includes the required KeyName and Values parameters as well as any key-value(s) pairs specified in the AdditionalSearchKeys list. This parameter influences which profiles will be returned in the response in the following manner:
    ///
    /// * AND - The response only includes profiles that match all of the search keys.
    ///
    /// * OR - The response includes profiles that match at least one of the search keys.
    ///
    ///
    /// The OR relationship is the default behavior if this parameter is not included in the request.
    public var logicalOperator: CustomerProfilesClientTypes.LogicalOperator?
    /// The maximum number of objects returned per page. The default is 20 if this parameter is not included in the request.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous SearchProfiles API call.
    public var nextToken: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]? = nil,
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        logicalOperator: CustomerProfilesClientTypes.LogicalOperator? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.additionalSearchKeys = additionalSearchKeys
        self.domainName = domainName
        self.keyName = keyName
        self.logicalOperator = logicalOperator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

struct SearchProfilesInputBody: Swift.Equatable {
    let keyName: Swift.String?
    let values: [Swift.String]?
    let additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]?
    let logicalOperator: CustomerProfilesClientTypes.LogicalOperator?
}

extension SearchProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalSearchKeys = "AdditionalSearchKeys"
        case keyName = "KeyName"
        case logicalOperator = "LogicalOperator"
        case values = "Values"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let additionalSearchKeysContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.AdditionalSearchKey?].self, forKey: .additionalSearchKeys)
        var additionalSearchKeysDecoded0:[CustomerProfilesClientTypes.AdditionalSearchKey]? = nil
        if let additionalSearchKeysContainer = additionalSearchKeysContainer {
            additionalSearchKeysDecoded0 = [CustomerProfilesClientTypes.AdditionalSearchKey]()
            for structure0 in additionalSearchKeysContainer {
                if let structure0 = structure0 {
                    additionalSearchKeysDecoded0?.append(structure0)
                }
            }
        }
        additionalSearchKeys = additionalSearchKeysDecoded0
        let logicalOperatorDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.LogicalOperator.self, forKey: .logicalOperator)
        logicalOperator = logicalOperatorDecoded
    }
}

extension SearchProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct SearchProfilesOutput: Swift.Equatable {
    /// The list of Profiles matching the search criteria.
    public var items: [CustomerProfilesClientTypes.Profile]?
    /// The pagination token from the previous SearchProfiles API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.Profile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct SearchProfilesOutputBody: Swift.Equatable {
    let items: [CustomerProfilesClientTypes.Profile]?
    let nextToken: Swift.String?
}

extension SearchProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomerProfilesClientTypes.Profile?].self, forKey: .items)
        var itemsDecoded0:[CustomerProfilesClientTypes.Profile]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomerProfilesClientTypes.Profile]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum ServiceNowConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNowConnectorOperator(rawValue: rawValue) ?? ServiceNowConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.ServiceNowSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object = "Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The properties that are applied when ServiceNow is being used as a source.
    public struct ServiceNowSourceProperties: Swift.Equatable {
        /// The object specified in the ServiceNow flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension CustomerProfilesClientTypes.SourceConnectorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let marketoDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MarketoSourceProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.S3SourceProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.SalesforceSourceProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ServiceNowSourceProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ZendeskSourceProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Specifies the information that is required to query a particular Amazon AppFlow connector. Customer Profiles supports Salesforce, Zendesk, Marketo, ServiceNow and Amazon S3.
    public struct SourceConnectorProperties: Swift.Equatable {
        /// The properties that are applied when Marketo is being used as a source.
        public var marketo: CustomerProfilesClientTypes.MarketoSourceProperties?
        /// The properties that are applied when Amazon S3 is being used as the flow source.
        public var s3: CustomerProfilesClientTypes.S3SourceProperties?
        /// The properties that are applied when Salesforce is being used as a source.
        public var salesforce: CustomerProfilesClientTypes.SalesforceSourceProperties?
        /// The properties that are applied when ServiceNow is being used as a source.
        public var serviceNow: CustomerProfilesClientTypes.ServiceNowSourceProperties?
        /// The properties that are applied when using Zendesk as a flow source.
        public var zendesk: CustomerProfilesClientTypes.ZendeskSourceProperties?

        public init(
            marketo: CustomerProfilesClientTypes.MarketoSourceProperties? = nil,
            s3: CustomerProfilesClientTypes.S3SourceProperties? = nil,
            salesforce: CustomerProfilesClientTypes.SalesforceSourceProperties? = nil,
            serviceNow: CustomerProfilesClientTypes.ServiceNowSourceProperties? = nil,
            zendesk: CustomerProfilesClientTypes.ZendeskSourceProperties? = nil
        )
        {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum SourceConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case marketo
        case s3
        case salesforce
        case servicenow
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceConnectorType] {
            return [
                .marketo,
                .s3,
                .salesforce,
                .servicenow,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .marketo: return "Marketo"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .servicenow: return "Servicenow"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceConnectorType(rawValue: rawValue) ?? SourceConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.SourceFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName = "ConnectorProfileName"
        case connectorType = "ConnectorType"
        case incrementalPullConfig = "IncrementalPullConfig"
        case sourceConnectorProperties = "SourceConnectorProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let incrementalPullConfig = self.incrementalPullConfig {
            try encodeContainer.encode(incrementalPullConfig, forKey: .incrementalPullConfig)
        }
        if let sourceConnectorProperties = self.sourceConnectorProperties {
            try encodeContainer.encode(sourceConnectorProperties, forKey: .sourceConnectorProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.SourceConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let incrementalPullConfigDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.IncrementalPullConfig.self, forKey: .incrementalPullConfig)
        incrementalPullConfig = incrementalPullConfigDecoded
        let sourceConnectorPropertiesDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.SourceConnectorProperties.self, forKey: .sourceConnectorProperties)
        sourceConnectorProperties = sourceConnectorPropertiesDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Contains information about the configuration of the source connector used in the flow.
    public struct SourceFlowConfig: Swift.Equatable {
        /// The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Marketo, and so on.
        /// This member is required.
        public var connectorType: CustomerProfilesClientTypes.SourceConnectorType?
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public var incrementalPullConfig: CustomerProfilesClientTypes.IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        /// This member is required.
        public var sourceConnectorProperties: CustomerProfilesClientTypes.SourceConnectorProperties?

        public init(
            connectorProfileName: Swift.String? = nil,
            connectorType: CustomerProfilesClientTypes.SourceConnectorType? = nil,
            incrementalPullConfig: CustomerProfilesClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: CustomerProfilesClientTypes.SourceConnectorProperties? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum StandardIdentifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case `case`
        case lookupOnly
        case newOnly
        case order
        case profile
        case secondary
        case unique
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardIdentifier] {
            return [
                .asset,
                .case,
                .lookupOnly,
                .newOnly,
                .order,
                .profile,
                .secondary,
                .unique,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .case: return "CASE"
            case .lookupOnly: return "LOOKUP_ONLY"
            case .newOnly: return "NEW_ONLY"
            case .order: return "ORDER"
            case .profile: return "PROFILE"
            case .secondary: return "SECONDARY"
            case .unique: return "UNIQUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StandardIdentifier(rawValue: rawValue) ?? StandardIdentifier.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum Statistic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case count
        case firstOccurrence
        case lastOccurrence
        case maximum
        case maxOccurrence
        case minimum
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [Statistic] {
            return [
                .average,
                .count,
                .firstOccurrence,
                .lastOccurrence,
                .maximum,
                .maxOccurrence,
                .minimum,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .firstOccurrence: return "FIRST_OCCURRENCE"
            case .lastOccurrence: return "LAST_OCCURRENCE"
            case .maximum: return "MAXIMUM"
            case .maxOccurrence: return "MAX_OCCURRENCE"
            case .minimum: return "MINIMUM"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Statistic(rawValue: rawValue) ?? Statistic.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case complete
        case failed
        case inProgress
        case notStarted
        case retry
        case split
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .cancelled,
                .complete,
                .failed,
                .inProgress,
                .notStarted,
                .retry,
                .split,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .retry: return "RETRY"
            case .split: return "SPLIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.Task: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorOperator = "ConnectorOperator"
        case destinationField = "DestinationField"
        case sourceFields = "SourceFields"
        case taskProperties = "TaskProperties"
        case taskType = "TaskType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorOperator = self.connectorOperator {
            try encodeContainer.encode(connectorOperator, forKey: .connectorOperator)
        }
        if let destinationField = self.destinationField {
            try encodeContainer.encode(destinationField, forKey: .destinationField)
        }
        if let sourceFields = sourceFields {
            var sourceFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceFields)
            for stringto20480 in sourceFields {
                try sourceFieldsContainer.encode(stringto20480)
            }
        }
        if let taskProperties = taskProperties {
            var taskPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskProperties)
            for (dictKey0, taskPropertiesMap0) in taskProperties {
                try taskPropertiesContainer.encode(taskPropertiesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskType = self.taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorOperatorDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ConnectorOperator.self, forKey: .connectorOperator)
        connectorOperator = connectorOperatorDecoded
        let destinationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationField)
        destinationField = destinationFieldDecoded
        let sourceFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceFields)
        var sourceFieldsDecoded0:[Swift.String]? = nil
        if let sourceFieldsContainer = sourceFieldsContainer {
            sourceFieldsDecoded0 = [Swift.String]()
            for string0 in sourceFieldsContainer {
                if let string0 = string0 {
                    sourceFieldsDecoded0?.append(string0)
                }
            }
        }
        sourceFields = sourceFieldsDecoded0
        let taskPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .taskProperties)
        var taskPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let taskPropertiesContainer = taskPropertiesContainer {
            taskPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, property0) in taskPropertiesContainer {
                if let property0 = property0 {
                    taskPropertiesDecoded0?[key0] = property0
                }
            }
        }
        taskProperties = taskPropertiesDecoded0
        let taskTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// A class for modeling different type of tasks. Task implementation varies based on the TaskType.
    public struct Task: Swift.Equatable {
        /// The operation to be performed on the provided source fields.
        public var connectorOperator: CustomerProfilesClientTypes.ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public var destinationField: Swift.String?
        /// The source fields to which a particular task is applied.
        /// This member is required.
        public var sourceFields: [Swift.String]?
        /// A map used to store task-related information. The service looks for particular information based on the TaskType.
        public var taskProperties: [Swift.String:Swift.String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// This member is required.
        public var taskType: CustomerProfilesClientTypes.TaskType?

        public init(
            connectorOperator: CustomerProfilesClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String:Swift.String]? = nil,
            taskType: CustomerProfilesClientTypes.TaskType? = nil
        )
        {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum TaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mask
        case merge
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mask,
                .merge,
                .truncate,
                .validate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.Threshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The threshold for the calculated attribute.
    public struct Threshold: Swift.Equatable {
        /// The operator of the threshold.
        /// This member is required.
        public var `operator`: CustomerProfilesClientTypes.Operator?
        /// The value of the threshold.
        /// This member is required.
        public var value: Swift.String?

        public init(
            `operator`: CustomerProfilesClientTypes.Operator? = nil,
            value: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You exceeded the maximum number of requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomerProfilesClientTypes.TriggerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerProperties = "TriggerProperties"
        case triggerType = "TriggerType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerProperties = self.triggerProperties {
            try encodeContainer.encode(triggerProperties, forKey: .triggerProperties)
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerPropertiesDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.TriggerProperties.self, forKey: .triggerProperties)
        triggerProperties = triggerPropertiesDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    public struct TriggerConfig: Swift.Equatable {
        /// Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        public var triggerProperties: CustomerProfilesClientTypes.TriggerProperties?
        /// Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        /// This member is required.
        public var triggerType: CustomerProfilesClientTypes.TriggerType?

        public init(
            triggerProperties: CustomerProfilesClientTypes.TriggerProperties? = nil,
            triggerType: CustomerProfilesClientTypes.TriggerType? = nil
        )
        {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }

}

extension CustomerProfilesClientTypes.TriggerProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduled = "Scheduled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduled = self.scheduled {
            try encodeContainer.encode(scheduled, forKey: .scheduled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.ScheduledTriggerProperties.self, forKey: .scheduled)
        scheduled = scheduledDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the Scheduled trigger type.
    public struct TriggerProperties: Swift.Equatable {
        /// Specifies the configuration details of a schedule-triggered flow that you define.
        public var scheduled: CustomerProfilesClientTypes.ScheduledTriggerProperties?

        public init(
            scheduled: CustomerProfilesClientTypes.ScheduledTriggerProperties? = nil
        )
        {
            self.scheduled = scheduled
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.UpdateAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address1 = "Address1"
        case address2 = "Address2"
        case address3 = "Address3"
        case address4 = "Address4"
        case city = "City"
        case country = "Country"
        case county = "County"
        case postalCode = "PostalCode"
        case province = "Province"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address1 = self.address1 {
            try encodeContainer.encode(address1, forKey: .address1)
        }
        if let address2 = self.address2 {
            try encodeContainer.encode(address2, forKey: .address2)
        }
        if let address3 = self.address3 {
            try encodeContainer.encode(address3, forKey: .address3)
        }
        if let address4 = self.address4 {
            try encodeContainer.encode(address4, forKey: .address4)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let county = self.county {
            try encodeContainer.encode(county, forKey: .county)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let province = self.province {
            try encodeContainer.encode(province, forKey: .province)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let address1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address1)
        address1 = address1Decoded
        let address2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address2)
        address2 = address2Decoded
        let address3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address3)
        address3 = address3Decoded
        let address4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address4)
        address4 = address4Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let countyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .county)
        county = countyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let provinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .province)
        province = provinceDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension CustomerProfilesClientTypes.UpdateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {
    /// Updates associated with the address properties of a customer profile.
    public struct UpdateAddress: Swift.Equatable {
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            province: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }

}

extension UpdateCalculatedAttributeDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCalculatedAttributeDefinitionInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), conditions: \"CONTENT_REDACTED\")"}
}

extension UpdateCalculatedAttributeDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditions = "Conditions"
        case description = "Description"
        case displayName = "DisplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditions = self.conditions {
            try encodeContainer.encode(conditions, forKey: .conditions)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension UpdateCalculatedAttributeDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let calculatedAttributeName = calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

public struct UpdateCalculatedAttributeDefinitionInput: Swift.Equatable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
    }
}

struct UpdateCalculatedAttributeDefinitionInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let conditions: CustomerProfilesClientTypes.Conditions?
}

extension UpdateCalculatedAttributeDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditions = "Conditions"
        case description = "Description"
        case displayName = "DisplayName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let conditionsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
    }
}

extension UpdateCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension UpdateCalculatedAttributeDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCalculatedAttributeDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeDetails = output.attributeDetails
            self.calculatedAttributeName = output.calculatedAttributeName
            self.conditions = output.conditions
            self.createdAt = output.createdAt
            self.description = output.description
            self.displayName = output.displayName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.statistic = output.statistic
            self.tags = output.tags
        } else {
            self.attributeDetails = nil
            self.calculatedAttributeName = nil
            self.conditions = nil
            self.createdAt = nil
            self.description = nil
            self.displayName = nil
            self.lastUpdatedAt = nil
            self.statistic = nil
            self.tags = nil
        }
    }
}

public struct UpdateCalculatedAttributeDefinitionOutput: Swift.Equatable {
    /// The mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.statistic = statistic
        self.tags = tags
    }
}

struct UpdateCalculatedAttributeDefinitionOutputBody: Swift.Equatable {
    let calculatedAttributeName: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let statistic: CustomerProfilesClientTypes.Statistic?
    let conditions: CustomerProfilesClientTypes.Conditions?
    let attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateCalculatedAttributeDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDetails = "AttributeDetails"
        case calculatedAttributeName = "CalculatedAttributeName"
        case conditions = "Conditions"
        case createdAt = "CreatedAt"
        case description = "Description"
        case displayName = "DisplayName"
        case lastUpdatedAt = "LastUpdatedAt"
        case statistic = "Statistic"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatedAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatedAttributeName)
        calculatedAttributeName = calculatedAttributeNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let conditionsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
        let attributeDetailsDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AttributeDetails.self, forKey: .attributeDetails)
        attributeDetails = attributeDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateCalculatedAttributeDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterQueueUrl = self.deadLetterQueueUrl {
            try encodeContainer.encode(deadLetterQueueUrl, forKey: .deadLetterQueueUrl)
        }
        if let defaultEncryptionKey = self.defaultEncryptionKey {
            try encodeContainer.encode(defaultEncryptionKey, forKey: .defaultEncryptionKey)
        }
        if let defaultExpirationDays = self.defaultExpirationDays {
            try encodeContainer.encode(defaultExpirationDays, forKey: .defaultExpirationDays)
        }
        if let matching = self.matching {
            try encodeContainer.encode(matching, forKey: .matching)
        }
        if let ruleBasedMatching = self.ruleBasedMatching {
            try encodeContainer.encode(ruleBasedMatching, forKey: .ruleBasedMatching)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

public struct UpdateDomainInput: Swift.Equatable {
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. If specified as an empty string, it will clear any existing value. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage. If specified as an empty string, it will clear any existing value.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingRequest?
    /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        matching: CustomerProfilesClientTypes.MatchingRequest? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

struct UpdateDomainInputBody: Swift.Equatable {
    let defaultExpirationDays: Swift.Int?
    let defaultEncryptionKey: Swift.String?
    let deadLetterQueueUrl: Swift.String?
    let matching: CustomerProfilesClientTypes.MatchingRequest?
    let ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchingRequest.self, forKey: .matching)
        matching = matchingDecoded
        let ruleBasedMatchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.RuleBasedMatchingRequest.self, forKey: .ruleBasedMatching)
        ruleBasedMatching = ruleBasedMatchingDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.deadLetterQueueUrl = output.deadLetterQueueUrl
            self.defaultEncryptionKey = output.defaultEncryptionKey
            self.defaultExpirationDays = output.defaultExpirationDays
            self.domainName = output.domainName
            self.lastUpdatedAt = output.lastUpdatedAt
            self.matching = output.matching
            self.ruleBasedMatching = output.ruleBasedMatching
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deadLetterQueueUrl = nil
            self.defaultEncryptionKey = nil
            self.defaultExpirationDays = nil
            self.domainName = nil
            self.lastUpdatedAt = nil
            self.matching = nil
            self.ruleBasedMatching = nil
            self.tags = nil
        }
    }
}

public struct UpdateDomainOutput: Swift.Equatable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

struct UpdateDomainOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let defaultExpirationDays: Swift.Int?
    let defaultEncryptionKey: Swift.String?
    let deadLetterQueueUrl: Swift.String?
    let matching: CustomerProfilesClientTypes.MatchingResponse?
    let ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deadLetterQueueUrl = "DeadLetterQueueUrl"
        case defaultEncryptionKey = "DefaultEncryptionKey"
        case defaultExpirationDays = "DefaultExpirationDays"
        case domainName = "DomainName"
        case lastUpdatedAt = "LastUpdatedAt"
        case matching = "Matching"
        case ruleBasedMatching = "RuleBasedMatching"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultExpirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExpirationDays)
        defaultExpirationDays = defaultExpirationDaysDecoded
        let defaultEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEncryptionKey)
        defaultEncryptionKey = defaultEncryptionKeyDecoded
        let deadLetterQueueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deadLetterQueueUrl)
        deadLetterQueueUrl = deadLetterQueueUrlDecoded
        let matchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.MatchingResponse.self, forKey: .matching)
        matching = matchingDecoded
        let ruleBasedMatchingDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.RuleBasedMatchingResponse.self, forKey: .ruleBasedMatching)
        ruleBasedMatching = ruleBasedMatchingDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileInput(domainName: \(Swift.String(describing: domainName)), profileId: \(Swift.String(describing: profileId)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case genderString = "GenderString"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case partyTypeString = "PartyTypeString"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case profileId = "ProfileId"
        case shippingAddress = "ShippingAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountNumber = self.accountNumber {
            try encodeContainer.encode(accountNumber, forKey: .accountNumber)
        }
        if let additionalInformation = self.additionalInformation {
            try encodeContainer.encode(additionalInformation, forKey: .additionalInformation)
        }
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, updateAttributes0) in attributes {
                try attributesContainer.encode(updateAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let billingAddress = self.billingAddress {
            try encodeContainer.encode(billingAddress, forKey: .billingAddress)
        }
        if let birthDate = self.birthDate {
            try encodeContainer.encode(birthDate, forKey: .birthDate)
        }
        if let businessEmailAddress = self.businessEmailAddress {
            try encodeContainer.encode(businessEmailAddress, forKey: .businessEmailAddress)
        }
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let businessPhoneNumber = self.businessPhoneNumber {
            try encodeContainer.encode(businessPhoneNumber, forKey: .businessPhoneNumber)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let gender = self.gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let genderString = self.genderString {
            try encodeContainer.encode(genderString, forKey: .genderString)
        }
        if let homePhoneNumber = self.homePhoneNumber {
            try encodeContainer.encode(homePhoneNumber, forKey: .homePhoneNumber)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let mailingAddress = self.mailingAddress {
            try encodeContainer.encode(mailingAddress, forKey: .mailingAddress)
        }
        if let middleName = self.middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
        if let mobilePhoneNumber = self.mobilePhoneNumber {
            try encodeContainer.encode(mobilePhoneNumber, forKey: .mobilePhoneNumber)
        }
        if let partyType = self.partyType {
            try encodeContainer.encode(partyType.rawValue, forKey: .partyType)
        }
        if let partyTypeString = self.partyTypeString {
            try encodeContainer.encode(partyTypeString, forKey: .partyTypeString)
        }
        if let personalEmailAddress = self.personalEmailAddress {
            try encodeContainer.encode(personalEmailAddress, forKey: .personalEmailAddress)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// A unique account number that you have given to the customer.
    public var accountNumber: Swift.String?
    /// Any additional information relevant to the customers profile.
    public var additionalInformation: Swift.String?
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public var address: CustomerProfilesClientTypes.UpdateAddress?
    /// A key value pair of attributes of a customer profile.
    public var attributes: [Swift.String:Swift.String]?
    /// The customers billing address.
    public var billingAddress: CustomerProfilesClientTypes.UpdateAddress?
    /// The customers birth date.
    public var birthDate: Swift.String?
    /// The customers business email address.
    public var businessEmailAddress: Swift.String?
    /// The name of the customers business.
    public var businessName: Swift.String?
    /// The customers business phone number.
    public var businessPhoneNumber: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customers email address, which has not been specified as a personal or business address.
    public var emailAddress: Swift.String?
    /// The customers first name.
    public var firstName: Swift.String?
    /// The gender with which the customer identifies.
    @available(*, deprecated)
    public var gender: CustomerProfilesClientTypes.Gender?
    /// An alternative to Gender which accepts any string as input.
    public var genderString: Swift.String?
    /// The customers home phone number.
    public var homePhoneNumber: Swift.String?
    /// The customers last name.
    public var lastName: Swift.String?
    /// The customers mailing address.
    public var mailingAddress: CustomerProfilesClientTypes.UpdateAddress?
    /// The customers middle name.
    public var middleName: Swift.String?
    /// The customers mobile phone number.
    public var mobilePhoneNumber: Swift.String?
    /// The type of profile used to describe the customer.
    @available(*, deprecated)
    public var partyType: CustomerProfilesClientTypes.PartyType?
    /// An alternative to PartyType which accepts any string as input.
    public var partyTypeString: Swift.String?
    /// The customers personal email address.
    public var personalEmailAddress: Swift.String?
    /// The customers phone number, which has not been specified as a mobile, home, or business number.
    public var phoneNumber: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The customers shipping address.
    public var shippingAddress: CustomerProfilesClientTypes.UpdateAddress?

    public init(
        accountNumber: Swift.String? = nil,
        additionalInformation: Swift.String? = nil,
        address: CustomerProfilesClientTypes.UpdateAddress? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        billingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil,
        birthDate: Swift.String? = nil,
        businessEmailAddress: Swift.String? = nil,
        businessName: Swift.String? = nil,
        businessPhoneNumber: Swift.String? = nil,
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        gender: CustomerProfilesClientTypes.Gender? = nil,
        genderString: Swift.String? = nil,
        homePhoneNumber: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil,
        middleName: Swift.String? = nil,
        mobilePhoneNumber: Swift.String? = nil,
        partyType: CustomerProfilesClientTypes.PartyType? = nil,
        partyTypeString: Swift.String? = nil,
        personalEmailAddress: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        profileId: Swift.String? = nil,
        shippingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.genderString = genderString
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.partyTypeString = partyTypeString
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.profileId = profileId
        self.shippingAddress = shippingAddress
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let additionalInformation: Swift.String?
    let accountNumber: Swift.String?
    let partyType: CustomerProfilesClientTypes.PartyType?
    let businessName: Swift.String?
    let firstName: Swift.String?
    let middleName: Swift.String?
    let lastName: Swift.String?
    let birthDate: Swift.String?
    let gender: CustomerProfilesClientTypes.Gender?
    let phoneNumber: Swift.String?
    let mobilePhoneNumber: Swift.String?
    let homePhoneNumber: Swift.String?
    let businessPhoneNumber: Swift.String?
    let emailAddress: Swift.String?
    let personalEmailAddress: Swift.String?
    let businessEmailAddress: Swift.String?
    let address: CustomerProfilesClientTypes.UpdateAddress?
    let shippingAddress: CustomerProfilesClientTypes.UpdateAddress?
    let mailingAddress: CustomerProfilesClientTypes.UpdateAddress?
    let billingAddress: CustomerProfilesClientTypes.UpdateAddress?
    let attributes: [Swift.String:Swift.String]?
    let partyTypeString: Swift.String?
    let genderString: Swift.String?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountNumber = "AccountNumber"
        case additionalInformation = "AdditionalInformation"
        case address = "Address"
        case attributes = "Attributes"
        case billingAddress = "BillingAddress"
        case birthDate = "BirthDate"
        case businessEmailAddress = "BusinessEmailAddress"
        case businessName = "BusinessName"
        case businessPhoneNumber = "BusinessPhoneNumber"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case gender = "Gender"
        case genderString = "GenderString"
        case homePhoneNumber = "HomePhoneNumber"
        case lastName = "LastName"
        case mailingAddress = "MailingAddress"
        case middleName = "MiddleName"
        case mobilePhoneNumber = "MobilePhoneNumber"
        case partyType = "PartyType"
        case partyTypeString = "PartyTypeString"
        case personalEmailAddress = "PersonalEmailAddress"
        case phoneNumber = "PhoneNumber"
        case profileId = "ProfileId"
        case shippingAddress = "ShippingAddress"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let additionalInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInformation)
        additionalInformation = additionalInformationDecoded
        let accountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountNumber)
        accountNumber = accountNumberDecoded
        let partyTypeDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.PartyType.self, forKey: .partyType)
        partyType = partyTypeDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let birthDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .birthDate)
        birthDate = birthDateDecoded
        let genderDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.Gender.self, forKey: .gender)
        gender = genderDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let mobilePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobilePhoneNumber)
        mobilePhoneNumber = mobilePhoneNumberDecoded
        let homePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePhoneNumber)
        homePhoneNumber = homePhoneNumberDecoded
        let businessPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessPhoneNumber)
        businessPhoneNumber = businessPhoneNumberDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let personalEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .personalEmailAddress)
        personalEmailAddress = personalEmailAddressDecoded
        let businessEmailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessEmailAddress)
        businessEmailAddress = businessEmailAddressDecoded
        let addressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.UpdateAddress.self, forKey: .address)
        address = addressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.UpdateAddress.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let mailingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.UpdateAddress.self, forKey: .mailingAddress)
        mailingAddress = mailingAddressDecoded
        let billingAddressDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.UpdateAddress.self, forKey: .billingAddress)
        billingAddress = billingAddressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0to2550) in attributesContainer {
                if let string0to2550 = string0to2550 {
                    attributesDecoded0?[key0] = string0to2550
                }
            }
        }
        attributes = attributesDecoded0
        let partyTypeStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partyTypeString)
        partyTypeString = partyTypeStringDecoded
        let genderStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .genderString)
        genderString = genderStringDecoded
    }
}

extension UpdateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileId = output.profileId
        } else {
            self.profileId = nil
        }
    }
}

public struct UpdateProfileOutput: Swift.Equatable {
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct UpdateProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
}

extension UpdateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

enum UpdateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerProfilesClientTypes.WorkflowAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appflowIntegration = "AppflowIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appflowIntegration = self.appflowIntegration {
            try encodeContainer.encode(appflowIntegration, forKey: .appflowIntegration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appflowIntegrationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes.self, forKey: .appflowIntegration)
        appflowIntegration = appflowIntegrationDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Structure to hold workflow attributes.
    public struct WorkflowAttributes: Swift.Equatable {
        /// Workflow attributes specific to APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }

}

extension CustomerProfilesClientTypes.WorkflowMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appflowIntegration = "AppflowIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appflowIntegration = self.appflowIntegration {
            try encodeContainer.encode(appflowIntegration, forKey: .appflowIntegration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appflowIntegrationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics.self, forKey: .appflowIntegration)
        appflowIntegration = appflowIntegrationDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// Generic object containing workflow execution metrics.
    public struct WorkflowMetrics: Swift.Equatable {
        /// Workflow execution metrics for APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }

}

extension CustomerProfilesClientTypes.WorkflowStepItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appflowIntegration = "AppflowIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appflowIntegration = self.appflowIntegration {
            try encodeContainer.encode(appflowIntegration, forKey: .appflowIntegration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appflowIntegrationDecoded = try containerValues.decodeIfPresent(CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep.self, forKey: .appflowIntegration)
        appflowIntegration = appflowIntegrationDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// List containing steps in workflow.
    public struct WorkflowStepItem: Swift.Equatable {
        /// Workflow step information specific to APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }

}

extension CustomerProfilesClientTypes {
    public enum WorkflowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appflowIntegration
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .appflowIntegration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appflowIntegration: return "APPFLOW_INTEGRATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowType(rawValue: rawValue) ?? WorkflowType.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes {
    public enum ZendeskConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZendeskConnectorOperator(rawValue: rawValue) ?? ZendeskConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension CustomerProfilesClientTypes.ZendeskSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object = "Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension CustomerProfilesClientTypes {
    /// The properties that are applied when using Zendesk as a flow source.
    public struct ZendeskSourceProperties: Swift.Equatable {
        /// The object specified in the Zendesk flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}
