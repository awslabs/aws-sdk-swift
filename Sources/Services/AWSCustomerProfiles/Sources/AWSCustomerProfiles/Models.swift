//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension CustomerProfilesClientTypes {

    /// A data type pair that consists of a KeyName and Values list that is used in conjunction with the [KeyName](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html#customerprofiles-SearchProfiles-request-KeyName) and [Values](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html#customerprofiles-SearchProfiles-request-Values) parameters to search for profiles using the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) API.
    public struct AdditionalSearchKey: Swift.Sendable {
        /// A searchable identifier of a customer profile.
        /// This member is required.
        public var keyName: Swift.String?
        /// A list of key values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.keyName = keyName
            self.values = values
        }
    }
}

/// The input you provided is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An internal service error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// You exceeded the maximum number of requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct AddProfileKeyInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile. The predefined keys you can use include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
    /// This member is required.
    public var keyName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        values: [Swift.String]? = nil
    ) {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

public struct AddProfileKeyOutput: Swift.Sendable {
    /// A searchable identifier of a customer profile.
    public var keyName: Swift.String?
    /// A list of key values.
    public var values: [Swift.String]?

    public init(
        keyName: Swift.String? = nil,
        values: [Swift.String]? = nil
    ) {
        self.keyName = keyName
        self.values = values
    }
}

extension CustomerProfilesClientTypes {

    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public struct Address: Swift.Sendable {
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            province: Swift.String? = nil,
            state: Swift.String? = nil
        ) {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }
}

extension CustomerProfilesClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    public enum StringDimensionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case contains
        case endsWith
        case exclusive
        case inclusive
        case sdkUnknown(Swift.String)

        public static var allCases: [StringDimensionType] {
            return [
                .beginsWith,
                .contains,
                .endsWith,
                .exclusive,
                .inclusive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .exclusive: return "EXCLUSIVE"
            case .inclusive: return "INCLUSIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object to hold the dimensions of a profile's fields to segment on.
    public struct ProfileDimension: Swift.Sendable {
        /// The action to segment on.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.StringDimensionType?
        /// The values to apply the DimensionType on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            dimensionType: CustomerProfilesClientTypes.StringDimensionType? = nil,
            values: [Swift.String]? = nil
        ) {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that segments on Customer Profile's address object.
    public struct AddressDimension: Swift.Sendable {
        /// The city belonging to the address.
        public var city: CustomerProfilesClientTypes.ProfileDimension?
        /// The country belonging to the address.
        public var country: CustomerProfilesClientTypes.ProfileDimension?
        /// The county belonging to the address.
        public var county: CustomerProfilesClientTypes.ProfileDimension?
        /// The postal code belonging to the address.
        public var postalCode: CustomerProfilesClientTypes.ProfileDimension?
        /// The province belonging to the address.
        public var province: CustomerProfilesClientTypes.ProfileDimension?
        /// The state belonging to the address.
        public var state: CustomerProfilesClientTypes.ProfileDimension?

        public init(
            city: CustomerProfilesClientTypes.ProfileDimension? = nil,
            country: CustomerProfilesClientTypes.ProfileDimension? = nil,
            county: CustomerProfilesClientTypes.ProfileDimension? = nil,
            postalCode: CustomerProfilesClientTypes.ProfileDimension? = nil,
            province: CustomerProfilesClientTypes.ProfileDimension? = nil,
            state: CustomerProfilesClientTypes.ProfileDimension? = nil
        ) {
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Batch defines the boundaries for ingestion for each step in APPFLOW_INTEGRATION workflow. APPFLOW_INTEGRATION workflow splits ingestion based on these boundaries.
    public struct Batch: Swift.Sendable {
        /// End time of batch to split ingestion.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// Start time of batch to split ingestion.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        ) {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum SourceConnectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case marketo
        case s3
        case salesforce
        case servicenow
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceConnectorType] {
            return [
                .marketo,
                .s3,
                .salesforce,
                .servicenow,
                .zendesk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .marketo: return "Marketo"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .servicenow: return "Servicenow"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the configuration used when importing incremental records from the source.
    public struct IncrementalPullConfig: Swift.Sendable {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public var datetimeTypeFieldName: Swift.String?

        public init(
            datetimeTypeFieldName: Swift.String? = nil
        ) {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when Marketo is being used as a source.
    public struct MarketoSourceProperties: Swift.Sendable {
        /// The object specified in the Marketo flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        ) {
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when Amazon S3 is being used as the flow source.
    public struct S3SourceProperties: Swift.Sendable {
        /// The Amazon S3 bucket name where the source files are stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public var bucketPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil
        ) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when Salesforce is being used as a source.
    public struct SalesforceSourceProperties: Swift.Sendable {
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public var enableDynamicFieldUpdate: Swift.Bool
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public var includeDeletedRecords: Swift.Bool
        /// The object specified in the Salesforce flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        ) {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when ServiceNow is being used as a source.
    public struct ServiceNowSourceProperties: Swift.Sendable {
        /// The object specified in the ServiceNow flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        ) {
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when using Zendesk as a flow source.
    public struct ZendeskSourceProperties: Swift.Sendable {
        /// The object specified in the Zendesk flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        ) {
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the information that is required to query a particular Amazon AppFlow connector. Customer Profiles supports Salesforce, Zendesk, Marketo, ServiceNow and Amazon S3.
    public struct SourceConnectorProperties: Swift.Sendable {
        /// The properties that are applied when Marketo is being used as a source.
        public var marketo: CustomerProfilesClientTypes.MarketoSourceProperties?
        /// The properties that are applied when Amazon S3 is being used as the flow source.
        public var s3: CustomerProfilesClientTypes.S3SourceProperties?
        /// The properties that are applied when Salesforce is being used as a source.
        public var salesforce: CustomerProfilesClientTypes.SalesforceSourceProperties?
        /// The properties that are applied when ServiceNow is being used as a source.
        public var serviceNow: CustomerProfilesClientTypes.ServiceNowSourceProperties?
        /// The properties that are applied when using Zendesk as a flow source.
        public var zendesk: CustomerProfilesClientTypes.ZendeskSourceProperties?

        public init(
            marketo: CustomerProfilesClientTypes.MarketoSourceProperties? = nil,
            s3: CustomerProfilesClientTypes.S3SourceProperties? = nil,
            salesforce: CustomerProfilesClientTypes.SalesforceSourceProperties? = nil,
            serviceNow: CustomerProfilesClientTypes.ServiceNowSourceProperties? = nil,
            zendesk: CustomerProfilesClientTypes.ZendeskSourceProperties? = nil
        ) {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Contains information about the configuration of the source connector used in the flow.
    public struct SourceFlowConfig: Swift.Sendable {
        /// The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Marketo, and so on.
        /// This member is required.
        public var connectorType: CustomerProfilesClientTypes.SourceConnectorType?
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public var incrementalPullConfig: CustomerProfilesClientTypes.IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        /// This member is required.
        public var sourceConnectorProperties: CustomerProfilesClientTypes.SourceConnectorProperties?

        public init(
            connectorProfileName: Swift.String? = nil,
            connectorType: CustomerProfilesClientTypes.SourceConnectorType? = nil,
            incrementalPullConfig: CustomerProfilesClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: CustomerProfilesClientTypes.SourceConnectorProperties? = nil
        ) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum MarketoConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum S3ConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum SalesforceConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ServiceNowConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ZendeskConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The operation to be performed on the provided source fields.
    public struct ConnectorOperator: Swift.Sendable {
        /// The operation to be performed on the provided Marketo source fields.
        public var marketo: CustomerProfilesClientTypes.MarketoConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public var s3: CustomerProfilesClientTypes.S3ConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public var salesforce: CustomerProfilesClientTypes.SalesforceConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public var serviceNow: CustomerProfilesClientTypes.ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public var zendesk: CustomerProfilesClientTypes.ZendeskConnectorOperator?

        public init(
            marketo: CustomerProfilesClientTypes.MarketoConnectorOperator? = nil,
            s3: CustomerProfilesClientTypes.S3ConnectorOperator? = nil,
            salesforce: CustomerProfilesClientTypes.SalesforceConnectorOperator? = nil,
            serviceNow: CustomerProfilesClientTypes.ServiceNowConnectorOperator? = nil,
            zendesk: CustomerProfilesClientTypes.ZendeskConnectorOperator? = nil
        ) {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum OperatorPropertiesKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum TaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mask
        case merge
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mask,
                .merge,
                .truncate,
                .validate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// A class for modeling different type of tasks. Task implementation varies based on the TaskType.
    public struct Task: Swift.Sendable {
        /// The operation to be performed on the provided source fields.
        public var connectorOperator: CustomerProfilesClientTypes.ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public var destinationField: Swift.String?
        /// The source fields to which a particular task is applied.
        /// This member is required.
        public var sourceFields: [Swift.String]?
        /// A map used to store task-related information. The service looks for particular information based on the TaskType.
        public var taskProperties: [Swift.String: Swift.String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// This member is required.
        public var taskType: CustomerProfilesClientTypes.TaskType?

        public init(
            connectorOperator: CustomerProfilesClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String: Swift.String]? = nil,
            taskType: CustomerProfilesClientTypes.TaskType? = nil
        ) {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum DataPullMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the configuration details of a scheduled-trigger flow that you define. Currently, these settings only apply to the scheduled-trigger type.
    public struct ScheduledTriggerProperties: Swift.Sendable {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public var dataPullMode: CustomerProfilesClientTypes.DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public var firstExecutionFrom: Foundation.Date?
        /// Specifies the scheduled end time for a scheduled-trigger flow.
        public var scheduleEndTime: Foundation.Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public var scheduleOffset: Swift.Int?
        /// Specifies the scheduled start time for a scheduled-trigger flow.
        public var scheduleStartTime: Foundation.Date?
        /// Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        public var timezone: Swift.String?

        public init(
            dataPullMode: CustomerProfilesClientTypes.DataPullMode? = nil,
            firstExecutionFrom: Foundation.Date? = nil,
            scheduleEndTime: Foundation.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = 0,
            scheduleStartTime: Foundation.Date? = nil,
            timezone: Swift.String? = nil
        ) {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the Scheduled trigger type.
    public struct TriggerProperties: Swift.Sendable {
        /// Specifies the configuration details of a schedule-triggered flow that you define.
        public var scheduled: CustomerProfilesClientTypes.ScheduledTriggerProperties?

        public init(
            scheduled: CustomerProfilesClientTypes.ScheduledTriggerProperties? = nil
        ) {
            self.scheduled = scheduled
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum TriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    public struct TriggerConfig: Swift.Sendable {
        /// Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        public var triggerProperties: CustomerProfilesClientTypes.TriggerProperties?
        /// Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        /// This member is required.
        public var triggerType: CustomerProfilesClientTypes.TriggerType?

        public init(
            triggerProperties: CustomerProfilesClientTypes.TriggerProperties? = nil,
            triggerType: CustomerProfilesClientTypes.TriggerType? = nil
        ) {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The configurations that control how Customer Profiles retrieves data from the source, Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of customers.
    public struct FlowDefinition: Swift.Sendable {
        /// A description of the flow you want to create.
        public var description: Swift.String?
        /// The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        /// This member is required.
        public var flowName: Swift.String?
        /// The Amazon Resource Name of the AWS Key Management Service (KMS) key you provide for encryption.
        /// This member is required.
        public var kmsArn: Swift.String?
        /// The configuration that controls how Customer Profiles retrieves data from the source.
        /// This member is required.
        public var sourceFlowConfig: CustomerProfilesClientTypes.SourceFlowConfig?
        /// A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        /// This member is required.
        public var tasks: [CustomerProfilesClientTypes.Task]?
        /// The trigger settings that determine how and when the flow runs.
        /// This member is required.
        public var triggerConfig: CustomerProfilesClientTypes.TriggerConfig?

        public init(
            description: Swift.String? = nil,
            flowName: Swift.String? = nil,
            kmsArn: Swift.String? = nil,
            sourceFlowConfig: CustomerProfilesClientTypes.SourceFlowConfig? = nil,
            tasks: [CustomerProfilesClientTypes.Task]? = nil,
            triggerConfig: CustomerProfilesClientTypes.TriggerConfig? = nil
        ) {
            self.description = description
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }
    }
}

extension CustomerProfilesClientTypes.FlowDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    /// Details for workflow of type APPFLOW_INTEGRATION.
    public struct AppflowIntegration: Swift.Sendable {
        /// Batches in workflow of type APPFLOW_INTEGRATION.
        public var batches: [CustomerProfilesClientTypes.Batch]?
        /// The configurations that control how Customer Profiles retrieves data from the source, Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of customers.
        /// This member is required.
        public var flowDefinition: CustomerProfilesClientTypes.FlowDefinition?

        public init(
            batches: [CustomerProfilesClientTypes.Batch]? = nil,
            flowDefinition: CustomerProfilesClientTypes.FlowDefinition? = nil
        ) {
            self.batches = batches
            self.flowDefinition = flowDefinition
        }
    }
}

extension CustomerProfilesClientTypes.AppflowIntegration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppflowIntegration(batches: \(Swift.String(describing: batches)), flowDefinition: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Structure holding all APPFLOW_INTEGRATION specific workflow attributes.
    public struct AppflowIntegrationWorkflowAttributes: Swift.Sendable {
        /// The name of the AppFlow connector profile used for ingestion.
        /// This member is required.
        public var connectorProfileName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
        public var roleArn: Swift.String?
        /// Specifies the source connector type, such as Salesforce, ServiceNow, and Marketo. Indicates source of ingestion.
        /// This member is required.
        public var sourceConnectorType: CustomerProfilesClientTypes.SourceConnectorType?

        public init(
            connectorProfileName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sourceConnectorType: CustomerProfilesClientTypes.SourceConnectorType? = nil
        ) {
            self.connectorProfileName = connectorProfileName
            self.roleArn = roleArn
            self.sourceConnectorType = sourceConnectorType
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Workflow specific execution metrics for APPFLOW_INTEGRATION workflow.
    public struct AppflowIntegrationWorkflowMetrics: Swift.Sendable {
        /// Number of records processed in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var recordsProcessed: Swift.Int
        /// Total steps completed in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var stepsCompleted: Swift.Int
        /// Total steps in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var totalSteps: Swift.Int

        public init(
            recordsProcessed: Swift.Int = 0,
            stepsCompleted: Swift.Int = 0,
            totalSteps: Swift.Int = 0
        ) {
            self.recordsProcessed = recordsProcessed
            self.stepsCompleted = stepsCompleted
            self.totalSteps = totalSteps
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case complete
        case failed
        case inProgress
        case notStarted
        case retry
        case split
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .cancelled,
                .complete,
                .failed,
                .inProgress,
                .notStarted,
                .retry,
                .split
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .retry: return "RETRY"
            case .split: return "SPLIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Workflow step details for APPFLOW_INTEGRATION workflow.
    public struct AppflowIntegrationWorkflowStep: Swift.Sendable {
        /// End datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var batchRecordsEndTime: Swift.String?
        /// Start datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var batchRecordsStartTime: Swift.String?
        /// Creation timestamp of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Message indicating execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var executionMessage: Swift.String?
        /// Name of the flow created during execution of workflow step. APPFLOW_INTEGRATION workflow type creates an appflow flow during workflow step execution on the customers behalf.
        /// This member is required.
        public var flowName: Swift.String?
        /// Last updated timestamp for workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// Total number of records processed during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var recordsProcessed: Swift.Int
        /// Workflow step status for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.Status?

        public init(
            batchRecordsEndTime: Swift.String? = nil,
            batchRecordsStartTime: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            executionMessage: Swift.String? = nil,
            flowName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            recordsProcessed: Swift.Int = 0,
            status: CustomerProfilesClientTypes.Status? = nil
        ) {
            self.batchRecordsEndTime = batchRecordsEndTime
            self.batchRecordsStartTime = batchRecordsStartTime
            self.createdAt = createdAt
            self.executionMessage = executionMessage
            self.flowName = flowName
            self.lastUpdatedAt = lastUpdatedAt
            self.recordsProcessed = recordsProcessed
            self.status = status
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The details of a single attribute item specified in the mathematical expression.
    public struct AttributeItem: Swift.Sendable {
        /// The name of an attribute defined in a profile object type.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Mathematical expression and a list of attribute items specified in that expression.
    public struct AttributeDetails: Swift.Sendable {
        /// A list of attribute items specified in the mathematical expression.
        /// This member is required.
        public var attributes: [CustomerProfilesClientTypes.AttributeItem]?
        /// Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \"{ObjectTypeName.AttributeName}\".
        /// This member is required.
        public var expression: Swift.String?

        public init(
            attributes: [CustomerProfilesClientTypes.AttributeItem]? = nil,
            expression: Swift.String? = nil
        ) {
            self.attributes = attributes
            self.expression = expression
        }
    }
}

extension CustomerProfilesClientTypes.AttributeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    public enum AttributeDimensionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case after
        case before
        case beginsWith
        case between
        case contains
        case endsWith
        case equal
        case exclusive
        case greaterThan
        case greaterThanOrEqual
        case inclusive
        case lessThan
        case lessThanOrEqual
        case notBetween
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeDimensionType] {
            return [
                .after,
                .before,
                .beginsWith,
                .between,
                .contains,
                .endsWith,
                .equal,
                .exclusive,
                .greaterThan,
                .greaterThanOrEqual,
                .inclusive,
                .lessThan,
                .lessThanOrEqual,
                .notBetween,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case .beginsWith: return "BEGINS_WITH"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equal: return "EQUAL"
            case .exclusive: return "EXCLUSIVE"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .inclusive: return "INCLUSIVE"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case .notBetween: return "NOT_BETWEEN"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that segments on various Customer Profile's fields.
    public struct AttributeDimension: Swift.Sendable {
        /// The action to segment with.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.AttributeDimensionType?
        /// The values to apply the DimensionType on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            dimensionType: CustomerProfilesClientTypes.AttributeDimensionType? = nil,
            values: [Swift.String]? = nil
        ) {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum FilterDimensionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case after
        case before
        case beginsWith
        case between
        case contains
        case endsWith
        case equal
        case exclusive
        case greaterThan
        case greaterThanOrEqual
        case inclusive
        case lessThan
        case lessThanOrEqual
        case notBetween
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterDimensionType] {
            return [
                .after,
                .before,
                .beginsWith,
                .between,
                .contains,
                .endsWith,
                .equal,
                .exclusive,
                .greaterThan,
                .greaterThanOrEqual,
                .inclusive,
                .lessThan,
                .lessThanOrEqual,
                .notBetween,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case .beginsWith: return "BEGINS_WITH"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equal: return "EQUAL"
            case .exclusive: return "EXCLUSIVE"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .inclusive: return "INCLUSIVE"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case .notBetween: return "NOT_BETWEEN"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that defines how to filter the incoming objects for the calculated attribute.
    public struct FilterAttributeDimension: Swift.Sendable {
        /// The action to filter with.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.FilterDimensionType?
        /// The values to apply the DimensionType on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            dimensionType: CustomerProfilesClientTypes.FilterDimensionType? = nil,
            values: [Swift.String]? = nil
        ) {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum AttributeMatchingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles. You can choose how profiles are compared across attribute types and which attribute to use for matching from each type. There are three attribute types you can configure:
    ///
    /// * Email type
    ///
    /// * You can choose from Email, BusinessEmail, and PersonalEmail
    ///
    ///
    ///
    ///
    /// * Phone number type
    ///
    /// * You can choose from Phone, HomePhone, and MobilePhone
    ///
    ///
    ///
    ///
    /// * Address type
    ///
    /// * You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress
    ///
    ///
    ///
    ///
    ///
    /// You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attribute across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
    public struct AttributeTypesSelector: Swift.Sendable {
        /// The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        public var address: [Swift.String]?
        /// Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        /// This member is required.
        public var attributeMatchingModel: CustomerProfilesClientTypes.AttributeMatchingModel?
        /// The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        public var emailAddress: [Swift.String]?
        /// The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        public var phoneNumber: [Swift.String]?

        public init(
            address: [Swift.String]? = nil,
            attributeMatchingModel: CustomerProfilesClientTypes.AttributeMatchingModel? = nil,
            emailAddress: [Swift.String]? = nil,
            phoneNumber: [Swift.String]? = nil
        ) {
            self.address = address
            self.attributeMatchingModel = attributeMatchingModel
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }
    }
}

extension CustomerProfilesClientTypes {

    /// List containing the values for the given attribute.
    public struct AttributeValueItem: Swift.Sendable {
        /// An individual value belonging to the given attribute.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        ) {
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ConflictResolvingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case recency
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictResolvingModel] {
            return [
                .recency,
                .source
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .recency: return "RECENCY"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// How the auto-merging process should resolve conflicts between different profiles.
    public struct ConflictResolution: Swift.Sendable {
        /// How the auto-merging process should resolve conflicts between different profiles.
        ///
        /// * RECENCY: Uses the data that was most recently updated.
        ///
        /// * SOURCE: Uses the data from a specific source. For example, if a company has been aquired or two departments have merged, data from the specified source is used. If two duplicate profiles are from the same source, then RECENCY is used again.
        /// This member is required.
        public var conflictResolvingModel: CustomerProfilesClientTypes.ConflictResolvingModel?
        /// The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        public var sourceName: Swift.String?

        public init(
            conflictResolvingModel: CustomerProfilesClientTypes.ConflictResolvingModel? = nil,
            sourceName: Swift.String? = nil
        ) {
            self.conflictResolvingModel = conflictResolvingModel
            self.sourceName = sourceName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The matching criteria to be used during the auto-merging process.
    public struct Consolidation: Swift.Sendable {
        /// A list of matching criteria.
        /// This member is required.
        public var matchingAttributesList: [[Swift.String]]?

        public init(
            matchingAttributesList: [[Swift.String]]? = nil
        ) {
            self.matchingAttributesList = matchingAttributesList
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration settings for how to perform the auto-merging of profiles.
    public struct AutoMerging: Swift.Sendable {
        /// How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used?
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        public var consolidation: CustomerProfilesClientTypes.Consolidation?
        /// The flag that enables the auto-merging of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        public var minAllowedConfidenceScoreForMerging: Swift.Double?

        public init(
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            consolidation: CustomerProfilesClientTypes.Consolidation? = nil,
            enabled: Swift.Bool? = nil,
            minAllowedConfidenceScoreForMerging: Swift.Double? = nil
        ) {
            self.conflictResolution = conflictResolution
            self.consolidation = consolidation
            self.enabled = enabled
            self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum RangeUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [RangeUnit] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Overrides the original range on a calculated attribute definition.
    public struct RangeOverride: Swift.Sendable {
        /// The end time of when to include objects.
        public var end: Swift.Int
        /// The start time of when to include objects.
        /// This member is required.
        public var start: Swift.Int?
        /// The unit for start and end.
        /// This member is required.
        public var unit: CustomerProfilesClientTypes.RangeUnit?

        public init(
            end: Swift.Int = 0,
            start: Swift.Int? = 366,
            unit: CustomerProfilesClientTypes.RangeUnit? = nil
        ) {
            self.end = end
            self.start = start
            self.unit = unit
        }
    }
}

extension CustomerProfilesClientTypes {

    /// An object to override the original condition block of a calculated attribute.
    public struct ConditionOverrides: Swift.Sendable {
        /// The relative time period over which data is included in the aggregation for this override.
        public var range: CustomerProfilesClientTypes.RangeOverride?

        public init(
            range: CustomerProfilesClientTypes.RangeOverride? = nil
        ) {
            self.range = range
        }
    }
}

extension CustomerProfilesClientTypes.ConditionOverrides: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct BatchGetCalculatedAttributeForProfileInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// Overrides the condition block within the original calculated attribute definition.
    public var conditionOverrides: CustomerProfilesClientTypes.ConditionOverrides?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// List of unique identifiers for customer profiles to retrieve.
    /// This member is required.
    public var profileIds: [Swift.String]?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        conditionOverrides: CustomerProfilesClientTypes.ConditionOverrides? = nil,
        domainName: Swift.String? = nil,
        profileIds: [Swift.String]? = nil
    ) {
        self.calculatedAttributeName = calculatedAttributeName
        self.conditionOverrides = conditionOverrides
        self.domainName = domainName
        self.profileIds = profileIds
    }
}

extension BatchGetCalculatedAttributeForProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetCalculatedAttributeForProfileInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), domainName: \(Swift.String(describing: domainName)), profileIds: \(Swift.String(describing: profileIds)), conditionOverrides: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// The object containing the values of a single calculated attribute value.
    public struct CalculatedAttributeValue: Swift.Sendable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// Indicates whether the calculated attribute's value is based on partial data. If the data is partial, it is set to true.
        public var isDataPartial: Swift.String?
        /// The timestamp of the newest object included in the calculated attribute calculation.
        public var lastObjectTimestamp: Foundation.Date?
        /// The profile id belonging to this calculated attribute value.
        public var profileId: Swift.String?
        /// The value of the calculated attribute.
        public var value: Swift.String?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            displayName: Swift.String? = nil,
            isDataPartial: Swift.String? = nil,
            lastObjectTimestamp: Foundation.Date? = nil,
            profileId: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.lastObjectTimestamp = lastObjectTimestamp
            self.profileId = profileId
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Error object describing why a specific profile and calculated attribute failed.
    public struct BatchGetCalculatedAttributeForProfileError: Swift.Sendable {
        /// Status code for why a specific profile and calculated attribute failed.
        /// This member is required.
        public var code: Swift.String?
        /// Message describing why a specific profile and calculated attribute failed.
        /// This member is required.
        public var message: Swift.String?
        /// The profile id that failed.
        /// This member is required.
        public var profileId: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            profileId: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
            self.profileId = profileId
        }
    }
}

public struct BatchGetCalculatedAttributeForProfileOutput: Swift.Sendable {
    /// List of calculated attribute values retrieved.
    public var calculatedAttributeValues: [CustomerProfilesClientTypes.CalculatedAttributeValue]?
    /// Overrides the condition block within the original calculated attribute definition.
    public var conditionOverrides: CustomerProfilesClientTypes.ConditionOverrides?
    /// List of errors for calculated attribute values that could not be retrieved.
    public var errors: [CustomerProfilesClientTypes.BatchGetCalculatedAttributeForProfileError]?

    public init(
        calculatedAttributeValues: [CustomerProfilesClientTypes.CalculatedAttributeValue]? = nil,
        conditionOverrides: CustomerProfilesClientTypes.ConditionOverrides? = nil,
        errors: [CustomerProfilesClientTypes.BatchGetCalculatedAttributeForProfileError]? = nil
    ) {
        self.calculatedAttributeValues = calculatedAttributeValues
        self.conditionOverrides = conditionOverrides
        self.errors = errors
    }
}

extension BatchGetCalculatedAttributeForProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetCalculatedAttributeForProfileOutput(calculatedAttributeValues: \(Swift.String(describing: calculatedAttributeValues)), errors: \(Swift.String(describing: errors)), conditionOverrides: \"CONTENT_REDACTED\")"}
}

public struct BatchGetProfileInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// List of unique identifiers for customer profiles to retrieve.
    /// This member is required.
    public var profileIds: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        profileIds: [Swift.String]? = nil
    ) {
        self.domainName = domainName
        self.profileIds = profileIds
    }
}

extension CustomerProfilesClientTypes {

    /// Error object describing why a specific profile failed.
    public struct BatchGetProfileError: Swift.Sendable {
        /// Status code for why a specific profile failed.
        /// This member is required.
        public var code: Swift.String?
        /// Message describing why a specific profile failed.
        /// This member is required.
        public var message: Swift.String?
        /// The profile id that failed.
        /// This member is required.
        public var profileId: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            profileId: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
            self.profileId = profileId
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ContactType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessEmailAddress
        case businessPhoneNumber
        case emailAddress
        case homePhoneNumber
        case mobilePhoneNumber
        case personalEmailAddress
        case phoneNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .businessEmailAddress,
                .businessPhoneNumber,
                .emailAddress,
                .homePhoneNumber,
                .mobilePhoneNumber,
                .personalEmailAddress,
                .phoneNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessEmailAddress: return "BusinessEmailAddress"
            case .businessPhoneNumber: return "BusinessPhoneNumber"
            case .emailAddress: return "EmailAddress"
            case .homePhoneNumber: return "HomePhoneNumber"
            case .mobilePhoneNumber: return "MobilePhoneNumber"
            case .personalEmailAddress: return "PersonalEmailAddress"
            case .phoneNumber: return "PhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that defines users contact preference.
    public struct ContactPreference: Swift.Sendable {
        /// The contact type used for engagement. For example: HomePhoneNumber, PersonalEmailAddress.
        public var contactType: CustomerProfilesClientTypes.ContactType?
        /// A searchable, unique identifier of a customer profile.
        public var keyName: Swift.String?
        /// The key value used to look up profile based off the keyName.
        public var keyValue: Swift.String?
        /// The unique identifier of a customer profile.
        public var profileId: Swift.String?

        public init(
            contactType: CustomerProfilesClientTypes.ContactType? = nil,
            keyName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            profileId: Swift.String? = nil
        ) {
            self.contactType = contactType
            self.keyName = keyName
            self.keyValue = keyValue
            self.profileId = profileId
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that defines users preferred methods of engagement.
    public struct EngagementPreferences: Swift.Sendable {
        /// A list of email-related contact preferences
        public var email: [CustomerProfilesClientTypes.ContactPreference]?
        /// A list of phone-related contact preferences
        public var phone: [CustomerProfilesClientTypes.ContactPreference]?

        public init(
            email: [CustomerProfilesClientTypes.ContactPreference]? = nil,
            phone: [CustomerProfilesClientTypes.ContactPreference]? = nil
        ) {
            self.email = email
            self.phone = phone
        }
    }
}

extension CustomerProfilesClientTypes.EngagementPreferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    /// A data type pair that consists of a KeyName and Values list that were used to find a profile returned in response to a [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request.
    public struct FoundByKeyValue: Swift.Sendable {
        /// A searchable identifier of a customer profile.
        public var keyName: Swift.String?
        /// A list of key values.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.keyName = keyName
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    @available(*, deprecated)
    public enum Gender: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case female
        case male
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [Gender] {
            return [
                .female,
                .male,
                .unspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .female: return "FEMALE"
            case .male: return "MALE"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    @available(*, deprecated)
    public enum PartyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case individual
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [PartyType] {
            return [
                .business,
                .individual,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "BUSINESS"
            case .individual: return "INDIVIDUAL"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ProfileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountProfile
        case profile
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileType] {
            return [
                .accountProfile,
                .profile
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountProfile: return "ACCOUNT_PROFILE"
            case .profile: return "PROFILE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The standard profile of a customer.
    public struct Profile: Swift.Sendable {
        /// An account number that you have assigned to the customer.
        public var accountNumber: Swift.String?
        /// Any additional information relevant to the customers profile.
        public var additionalInformation: Swift.String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public var address: CustomerProfilesClientTypes.Address?
        /// A key value pair of attributes of a customer profile.
        public var attributes: [Swift.String: Swift.String]?
        /// The customers billing address.
        public var billingAddress: CustomerProfilesClientTypes.Address?
        /// The customers birth date.
        public var birthDate: Swift.String?
        /// The customers business email address.
        public var businessEmailAddress: Swift.String?
        /// The name of the customers business.
        public var businessName: Swift.String?
        /// The customers home phone number.
        public var businessPhoneNumber: Swift.String?
        /// The customers email address, which has not been specified as a personal or business address.
        public var emailAddress: Swift.String?
        /// The customer or accounts engagement preferences.
        public var engagementPreferences: CustomerProfilesClientTypes.EngagementPreferences?
        /// The customers first name.
        public var firstName: Swift.String?
        /// A list of items used to find a profile returned in a [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) response. An item is a key-value(s) pair that matches an attribute in the profile. If the optional AdditionalSearchKeys parameter was included in the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request, the FoundByItems list should be interpreted based on the LogicalOperator used in the request:
        ///
        /// * AND - The profile included in the response matched all of the search keys specified in the request. The FoundByItems will include all of the key-value(s) pairs that were specified in the request (as this is a requirement of AND search logic).
        ///
        /// * OR - The profile included in the response matched at least one of the search keys specified in the request. The FoundByItems will include each of the key-value(s) pairs that the profile was found by.
        ///
        ///
        /// The OR relationship is the default behavior if the LogicalOperator parameter is not included in the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request.
        public var foundByItems: [CustomerProfilesClientTypes.FoundByKeyValue]?
        /// The gender with which the customer identifies.
        @available(*, deprecated)
        public var gender: CustomerProfilesClientTypes.Gender?
        /// An alternative to Gender which accepts any string as input.
        public var genderString: Swift.String?
        /// The customers home phone number.
        public var homePhoneNumber: Swift.String?
        /// The customers last name.
        public var lastName: Swift.String?
        /// The customers mailing address.
        public var mailingAddress: CustomerProfilesClientTypes.Address?
        /// The customers middle name.
        public var middleName: Swift.String?
        /// The customers mobile phone number.
        public var mobilePhoneNumber: Swift.String?
        /// The type of profile used to describe the customer.
        @available(*, deprecated)
        public var partyType: CustomerProfilesClientTypes.PartyType?
        /// An alternative to PartyType which accepts any string as input.
        public var partyTypeString: Swift.String?
        /// The customers personal email address.
        public var personalEmailAddress: Swift.String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public var phoneNumber: Swift.String?
        /// The unique identifier of a customer profile.
        public var profileId: Swift.String?
        /// The type of the profile.
        public var profileType: CustomerProfilesClientTypes.ProfileType?
        /// The customers shipping address.
        public var shippingAddress: CustomerProfilesClientTypes.Address?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address: CustomerProfilesClientTypes.Address? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            billingAddress: CustomerProfilesClientTypes.Address? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            engagementPreferences: CustomerProfilesClientTypes.EngagementPreferences? = nil,
            firstName: Swift.String? = nil,
            foundByItems: [CustomerProfilesClientTypes.FoundByKeyValue]? = nil,
            gender: CustomerProfilesClientTypes.Gender? = nil,
            genderString: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress: CustomerProfilesClientTypes.Address? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: CustomerProfilesClientTypes.PartyType? = nil,
            partyTypeString: Swift.String? = nil,
            personalEmailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            profileId: Swift.String? = nil,
            profileType: CustomerProfilesClientTypes.ProfileType? = nil,
            shippingAddress: CustomerProfilesClientTypes.Address? = nil
        ) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.engagementPreferences = engagementPreferences
            self.firstName = firstName
            self.foundByItems = foundByItems
            self.gender = gender
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.profileType = profileType
            self.shippingAddress = shippingAddress
        }
    }
}

extension CustomerProfilesClientTypes.Profile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Profile(foundByItems: \(Swift.String(describing: foundByItems)), profileId: \(Swift.String(describing: profileId)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", engagementPreferences: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", profileType: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

public struct BatchGetProfileOutput: Swift.Sendable {
    /// For information about the errors that are common to all actions, see [Common Errors](https://docs.aws.amazon.com/connect/latest/APIReference/CommonErrors.html).
    public var errors: [CustomerProfilesClientTypes.BatchGetProfileError]?
    /// Array of Profile Objects.
    public var profiles: [CustomerProfilesClientTypes.Profile]?

    public init(
        errors: [CustomerProfilesClientTypes.BatchGetProfileError]? = nil,
        profiles: [CustomerProfilesClientTypes.Profile]? = nil
    ) {
        self.errors = errors
        self.profiles = profiles
    }
}

extension CustomerProfilesClientTypes {

    public enum ReadinessStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadinessStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .preparing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The details of a single calculated attribute definition.
    public struct ListCalculatedAttributeDefinitionItem: Swift.Sendable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The threshold for the calculated attribute.
        public var createdAt: Foundation.Date?
        /// The threshold for the calculated attribute.
        public var description: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public var lastUpdatedAt: Foundation.Date?
        /// Status of the Calculated Attribute creation (whether all historical data has been indexed.)
        public var status: CustomerProfilesClientTypes.ReadinessStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// Whether historical data ingested before the Calculated Attribute was created should be included in calculations.
        public var useHistoricalData: Swift.Bool?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: CustomerProfilesClientTypes.ReadinessStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            useHistoricalData: Swift.Bool? = nil
        ) {
            self.calculatedAttributeName = calculatedAttributeName
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.tags = tags
            self.useHistoricalData = useHistoricalData
        }
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCalculatedAttributeDefinitionItem(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), useHistoricalData: \(Swift.String(describing: useHistoricalData)), description: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Object that segments on Customer Profile's Calculated Attributes.
    public struct CalculatedAttributeDimension: Swift.Sendable {
        /// Applies the given condition over the initial Calculated Attribute's definition.
        public var conditionOverrides: CustomerProfilesClientTypes.ConditionOverrides?
        /// The action to segment with.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.AttributeDimensionType?
        /// The values to apply the DimensionType with.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            conditionOverrides: CustomerProfilesClientTypes.ConditionOverrides? = nil,
            dimensionType: CustomerProfilesClientTypes.AttributeDimensionType? = nil,
            values: [Swift.String]? = nil
        ) {
            self.conditionOverrides = conditionOverrides
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes.CalculatedAttributeDimension: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedAttributeDimension(dimensionType: \(Swift.String(describing: dimensionType)), values: \(Swift.String(describing: values)), conditionOverrides: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// The details of a single calculated attribute for a profile.
    public struct ListCalculatedAttributeForProfileItem: Swift.Sendable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// Indicates whether the calculated attributes value is based on partial data. If data is partial, it is set to true.
        public var isDataPartial: Swift.String?
        /// The timestamp of the newest object included in the calculated attribute calculation.
        public var lastObjectTimestamp: Foundation.Date?
        /// The value of the calculated attribute.
        public var value: Swift.String?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            displayName: Swift.String? = nil,
            isDataPartial: Swift.String? = nil,
            lastObjectTimestamp: Foundation.Date? = nil,
            value: Swift.String? = nil
        ) {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.lastObjectTimestamp = lastObjectTimestamp
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ComparisonOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case after
        case before
        case beginsWith
        case between
        case contains
        case endsWith
        case equal
        case exclusive
        case greaterThan
        case greaterThanOrEqual
        case inclusive
        case lessThan
        case lessThanOrEqual
        case notBetween
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .after,
                .before,
                .beginsWith,
                .between,
                .contains,
                .endsWith,
                .equal,
                .exclusive,
                .greaterThan,
                .greaterThanOrEqual,
                .inclusive,
                .lessThan,
                .lessThanOrEqual,
                .notBetween,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case .beginsWith: return "BEGINS_WITH"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equal: return "EQUAL"
            case .exclusive: return "EXCLUSIVE"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .inclusive: return "INCLUSIVE"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case .notBetween: return "NOT_BETWEEN"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Unit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// A structure letting customers specify a relative time window over which over which data is included in the Calculated Attribute. Use positive numbers to indicate that the endpoint is in the past, and negative numbers to indicate it is in the future. ValueRange overrides Value.
    public struct ValueRange: Swift.Sendable {
        /// The end time of when to include objects. Use positive numbers to indicate that the starting point is in the past, and negative numbers to indicate it is in the future.
        /// This member is required.
        public var end: Swift.Int?
        /// The start time of when to include objects. Use positive numbers to indicate that the starting point is in the past, and negative numbers to indicate it is in the future.
        /// This member is required.
        public var start: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        ) {
            self.end = end
            self.start = start
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The relative time period over which data is included in the aggregation.
    public struct Range: Swift.Sendable {
        /// The format the timestamp field in your JSON object is specified. This value should be one of EPOCHMILLI (for Unix epoch timestamps with second/millisecond level precision) or ISO_8601 (following ISO_8601 format with second/millisecond level precision, with an optional offset of Z or in the format HH:MM or HHMM.). E.g. if your object type is MyType and source JSON is {"generatedAt": {"timestamp": "2001-07-04T12:08:56.235-0700"}}, then TimestampFormat should be "ISO_8601".
        public var timestampFormat: Swift.String?
        /// An expression specifying the field in your JSON object from which the date should be parsed. The expression should follow the structure of \"{ObjectTypeName.}\". E.g. if your object type is MyType and source JSON is {"generatedAt": {"timestamp": "1737587945945"}}, then TimestampSource should be "{MyType.generatedAt.timestamp}".
        public var timestampSource: Swift.String?
        /// The unit of time.
        public var unit: CustomerProfilesClientTypes.Unit?
        /// The amount of time of the specified unit.
        public var value: Swift.Int?
        /// A structure letting customers specify a relative time window over which over which data is included in the Calculated Attribute. Use positive numbers to indicate that the endpoint is in the past, and negative numbers to indicate it is in the future. ValueRange overrides Value.
        public var valueRange: CustomerProfilesClientTypes.ValueRange?

        public init(
            timestampFormat: Swift.String? = nil,
            timestampSource: Swift.String? = nil,
            unit: CustomerProfilesClientTypes.Unit? = .days,
            value: Swift.Int? = 0,
            valueRange: CustomerProfilesClientTypes.ValueRange? = nil
        ) {
            self.timestampFormat = timestampFormat
            self.timestampSource = timestampSource
            self.unit = unit
            self.value = value
            self.valueRange = valueRange
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case notEqualTo
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan,
                .notEqualTo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The threshold for the calculated attribute.
    public struct Threshold: Swift.Sendable {
        /// The operator of the threshold.
        /// This member is required.
        public var `operator`: CustomerProfilesClientTypes.Operator?
        /// The value of the threshold.
        /// This member is required.
        public var value: Swift.String?

        public init(
            `operator`: CustomerProfilesClientTypes.Operator? = nil,
            value: Swift.String? = nil
        ) {
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The conditions including range, object count, and threshold for the calculated attribute.
    public struct Conditions: Swift.Sendable {
        /// The number of profile objects used for the calculated attribute.
        public var objectCount: Swift.Int?
        /// The relative time period over which data is included in the aggregation.
        public var range: CustomerProfilesClientTypes.Range?
        /// The threshold for the calculated attribute.
        public var threshold: CustomerProfilesClientTypes.Threshold?

        public init(
            objectCount: Swift.Int? = nil,
            range: CustomerProfilesClientTypes.Range? = nil,
            threshold: CustomerProfilesClientTypes.Threshold? = nil
        ) {
            self.objectCount = objectCount
            self.range = range
            self.threshold = threshold
        }
    }
}

extension CustomerProfilesClientTypes.Conditions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    /// Contains the map of attribute names to attribute dimensions.
    public struct FilterDimension: Swift.Sendable {
        /// Is the attribute within the FilterDimension map
        /// This member is required.
        public var attributes: [Swift.String: CustomerProfilesClientTypes.FilterAttributeDimension]?

        public init(
            attributes: [Swift.String: CustomerProfilesClientTypes.FilterAttributeDimension]? = nil
        ) {
            self.attributes = attributes
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that holds the dimensions to filter on.
    public struct FilterGroup: Swift.Sendable {
        /// Object that holds the attributes to filter on.
        /// This member is required.
        public var dimensions: [CustomerProfilesClientTypes.FilterDimension]?
        /// The type of logical relationship between the dimensions of the Filter group.
        /// This member is required.
        public var type: CustomerProfilesClientTypes.ModelType?

        public init(
            dimensions: [CustomerProfilesClientTypes.FilterDimension]? = nil,
            type: CustomerProfilesClientTypes.ModelType? = nil
        ) {
            self.dimensions = dimensions
            self.type = type
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Include: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Include] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Defines how to filter the objects coming in for calculated attributes.
    public struct Filter: Swift.Sendable {
        /// Holds the list of Filter groups within the Filter definition.
        /// This member is required.
        public var groups: [CustomerProfilesClientTypes.FilterGroup]?
        /// Define whether to include or exclude objects for Calculated Attributed calculation that fit the filter groups criteria.
        /// This member is required.
        public var include: CustomerProfilesClientTypes.Include?

        public init(
            groups: [CustomerProfilesClientTypes.FilterGroup]? = nil,
            include: CustomerProfilesClientTypes.Include? = nil
        ) {
            self.groups = groups
            self.include = include
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Statistic: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case firstOccurrence
        case lastOccurrence
        case maximum
        case maxOccurrence
        case minimum
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [Statistic] {
            return [
                .average,
                .count,
                .firstOccurrence,
                .lastOccurrence,
                .maximum,
                .maxOccurrence,
                .minimum,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .firstOccurrence: return "FIRST_OCCURRENCE"
            case .lastOccurrence: return "LAST_OCCURRENCE"
            case .maximum: return "MAXIMUM"
            case .maxOccurrence: return "MAX_OCCURRENCE"
            case .minimum: return "MINIMUM"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    /// This member is required.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Defines how to filter incoming objects to include part of the Calculated Attribute.
    public var filter: CustomerProfilesClientTypes.Filter?
    /// The aggregation operation to perform for the calculated attribute.
    /// This member is required.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// Whether historical data ingested before the Calculated Attribute was created should be included in calculations.
    public var useHistoricalData: Swift.Bool?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        filter: CustomerProfilesClientTypes.Filter? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useHistoricalData: Swift.Bool? = nil
    ) {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
        self.filter = filter
        self.statistic = statistic
        self.tags = tags
        self.useHistoricalData = useHistoricalData
    }
}

extension CreateCalculatedAttributeDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCalculatedAttributeDefinitionInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), filter: \(Swift.String(describing: filter)), tags: \(Swift.String(describing: tags)), useHistoricalData: \(Swift.String(describing: useHistoricalData)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Information indicating if the Calculated Attribute is ready for use by confirming all historical data has been processed and reflected.
    public struct Readiness: Swift.Sendable {
        /// Any customer messaging.
        public var message: Swift.String?
        /// Approximately how far the Calculated Attribute creation is from completion.
        public var progressPercentage: Swift.Int?

        public init(
            message: Swift.String? = nil,
            progressPercentage: Swift.Int? = nil
        ) {
            self.message = message
            self.progressPercentage = progressPercentage
        }
    }
}

public struct CreateCalculatedAttributeDefinitionOutput: Swift.Sendable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The filter that was used as part of the request.
    public var filter: CustomerProfilesClientTypes.Filter?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// Information indicating if the Calculated Attribute is ready for use by confirming all historical data has been processed and reflected.
    public var readiness: CustomerProfilesClientTypes.Readiness?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// Status of the Calculated Attribute creation (whether all historical data has been indexed.)
    public var status: CustomerProfilesClientTypes.ReadinessStatus?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// Whether historical data ingested before the Calculated Attribute was created should be included in calculations.
    public var useHistoricalData: Swift.Bool?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        filter: CustomerProfilesClientTypes.Filter? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        readiness: CustomerProfilesClientTypes.Readiness? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        status: CustomerProfilesClientTypes.ReadinessStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useHistoricalData: Swift.Bool? = nil
    ) {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.filter = filter
        self.lastUpdatedAt = lastUpdatedAt
        self.readiness = readiness
        self.statistic = statistic
        self.status = status
        self.tags = tags
        self.useHistoricalData = useHistoricalData
    }
}

extension CreateCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), filter: \(Swift.String(describing: filter)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), readiness: \(Swift.String(describing: readiness)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), useHistoricalData: \(Swift.String(describing: useHistoricalData)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Configuration information about the S3 bucket where Identity Resolution Jobs write result files.
    public struct S3ExportingConfig: Swift.Sendable {
        /// The name of the S3 bucket where Identity Resolution Jobs write result files.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public var s3KeyName: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyName: Swift.String? = nil
        ) {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
    public struct ExportingConfig: Swift.Sendable {
        /// The S3 location where Identity Resolution Jobs write result files.
        public var s3Exporting: CustomerProfilesClientTypes.S3ExportingConfig?

        public init(
            s3Exporting: CustomerProfilesClientTypes.S3ExportingConfig? = nil
        ) {
            self.s3Exporting = s3Exporting
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum JobScheduleDayOfTheWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [JobScheduleDayOfTheWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The day and time when do you want to start the Identity Resolution Job every week.
    public struct JobSchedule: Swift.Sendable {
        /// The day when the Identity Resolution Job should run every week.
        /// This member is required.
        public var dayOfTheWeek: CustomerProfilesClientTypes.JobScheduleDayOfTheWeek?
        /// The time when the Identity Resolution Job should run every week.
        /// This member is required.
        public var time: Swift.String?

        public init(
            dayOfTheWeek: CustomerProfilesClientTypes.JobScheduleDayOfTheWeek? = nil,
            time: Swift.String? = nil
        ) {
            self.dayOfTheWeek = dayOfTheWeek
            self.time = time
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The flag that enables the matching process of duplicate profiles.
    public struct MatchingRequest: Swift.Sendable {
        /// Configuration information about the auto-merging process.
        public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public var jobSchedule: CustomerProfilesClientTypes.JobSchedule?

        public init(
            autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            jobSchedule: CustomerProfilesClientTypes.JobSchedule? = nil
        ) {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies how does the rule-based matching process should match profiles. You can choose from the following attributes to build the matching Rule:
    ///
    /// * AccountNumber
    ///
    /// * Address.Address
    ///
    /// * Address.City
    ///
    /// * Address.Country
    ///
    /// * Address.County
    ///
    /// * Address.PostalCode
    ///
    /// * Address.State
    ///
    /// * Address.Province
    ///
    /// * BirthDate
    ///
    /// * BusinessName
    ///
    /// * EmailAddress
    ///
    /// * FirstName
    ///
    /// * Gender
    ///
    /// * LastName
    ///
    /// * MiddleName
    ///
    /// * PhoneNumber
    ///
    /// * Any customized profile attributes that start with the Attributes
    public struct MatchingRule: Swift.Sendable {
        /// A single rule level of the MatchRules. Configures how the rule-based matching process should match profiles.
        /// This member is required.
        public var rule: [Swift.String]?

        public init(
            rule: [Swift.String]? = nil
        ) {
            self.rule = rule
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The request to enable the rule-based matching.
    public struct RuleBasedMatchingRequest: Swift.Sendable {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public var attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector?
        /// How the auto-merging process should resolve conflicts between different profiles.
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public var matchingRules: [CustomerProfilesClientTypes.MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public var maxAllowedRuleLevelForMatching: Swift.Int?
        /// [MatchingRule](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_MatchingRule.html)
        public var maxAllowedRuleLevelForMerging: Swift.Int?

        public init(
            attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector? = nil,
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            matchingRules: [CustomerProfilesClientTypes.MatchingRule]? = nil,
            maxAllowedRuleLevelForMatching: Swift.Int? = nil,
            maxAllowedRuleLevelForMerging: Swift.Int? = nil
        ) {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
        }
    }
}

public struct CreateDomainInput: Swift.Sendable {
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    /// This member is required.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingRequest?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        matching: CustomerProfilesClientTypes.MatchingRequest? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

extension CustomerProfilesClientTypes {

    /// The flag that enables the matching process of duplicate profiles.
    public struct MatchingResponse: Swift.Sendable {
        /// Configuration information about the auto-merging process.
        public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        public var enabled: Swift.Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public var jobSchedule: CustomerProfilesClientTypes.JobSchedule?

        public init(
            autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            jobSchedule: CustomerProfilesClientTypes.JobSchedule? = nil
        ) {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum RuleBasedMatchingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleBasedMatchingStatus] {
            return [
                .active,
                .inProgress,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The response of the Rule-based matching request.
    public struct RuleBasedMatchingResponse: Swift.Sendable {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public var attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector?
        /// How the auto-merging process should resolve conflicts between different profiles.
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        public var enabled: Swift.Bool?
        /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public var matchingRules: [CustomerProfilesClientTypes.MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public var maxAllowedRuleLevelForMatching: Swift.Int?
        /// [MatchingRule](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_MatchingRule.html)
        public var maxAllowedRuleLevelForMerging: Swift.Int?
        /// PENDING
        ///
        /// * The first status after configuration a rule-based matching rule. If it is an existing domain, the rule-based Identity Resolution waits one hour before creating the matching rule. If it is a new domain, the system will skip the PENDING stage.
        ///
        ///
        /// IN_PROGRESS
        ///
        /// * The system is creating the rule-based matching rule. Under this status, the system is evaluating the existing data and you can no longer change the Rule-based matching configuration.
        ///
        ///
        /// ACTIVE
        ///
        /// * The rule is ready to use. You can change the rule a day after the status is in ACTIVE.
        public var status: CustomerProfilesClientTypes.RuleBasedMatchingStatus?

        public init(
            attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector? = nil,
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            matchingRules: [CustomerProfilesClientTypes.MatchingRule]? = nil,
            maxAllowedRuleLevelForMatching: Swift.Int? = nil,
            maxAllowedRuleLevelForMerging: Swift.Int? = nil,
            status: CustomerProfilesClientTypes.RuleBasedMatchingStatus? = nil
        ) {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
            self.status = status
        }
    }
}

public struct CreateDomainOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    /// This member is required.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

extension CustomerProfilesClientTypes {

    public enum LayoutType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profileExplorer
        case sdkUnknown(Swift.String)

        public static var allCases: [LayoutType] {
            return [
                .profileExplorer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profileExplorer: return "PROFILE_EXPLORER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDomainLayoutInput: Swift.Sendable {
    /// The description of the layout
    /// This member is required.
    public var description: Swift.String?
    /// The display name of the layout
    /// This member is required.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// If set to true for a layout, this layout will be used by default to view data. If set to false, then the layout will not be used by default, but it can be used to view data by explicitly selecting it in the console.
    public var isDefault: Swift.Bool?
    /// A customizable layout that can be used to view data under a Customer Profiles domain.
    /// This member is required.
    public var layout: Swift.String?
    /// The unique name of the layout.
    /// This member is required.
    public var layoutDefinitionName: Swift.String?
    /// The type of layout that can be used to view data under a Customer Profiles domain.
    /// This member is required.
    public var layoutType: CustomerProfilesClientTypes.LayoutType?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        isDefault: Swift.Bool? = false,
        layout: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil,
        layoutType: CustomerProfilesClientTypes.LayoutType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
        self.isDefault = isDefault
        self.layout = layout
        self.layoutDefinitionName = layoutDefinitionName
        self.layoutType = layoutType
        self.tags = tags
    }
}

extension CreateDomainLayoutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainLayoutInput(displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), isDefault: \(Swift.String(describing: isDefault)), layoutDefinitionName: \(Swift.String(describing: layoutDefinitionName)), layoutType: \(Swift.String(describing: layoutType)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", layout: \"CONTENT_REDACTED\")"}
}

public struct CreateDomainLayoutOutput: Swift.Sendable {
    /// The timestamp of when the layout was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the layout
    /// This member is required.
    public var description: Swift.String?
    /// The display name of the layout
    /// This member is required.
    public var displayName: Swift.String?
    /// If set to true for a layout, this layout will be used by default to view data. If set to false, then the layout will not be used by default, but it can be used to view data by explicitly selecting it in the console.
    public var isDefault: Swift.Bool
    /// The timestamp of when the layout was most recently updated.
    public var lastUpdatedAt: Foundation.Date?
    /// A customizable layout that can be used to view data under Customer Profiles domain.
    /// This member is required.
    public var layout: Swift.String?
    /// The unique name of the layout.
    /// This member is required.
    public var layoutDefinitionName: Swift.String?
    /// The type of layout that can be used to view data under customer profiles domain.
    /// This member is required.
    public var layoutType: CustomerProfilesClientTypes.LayoutType?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The version used to create layout.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isDefault: Swift.Bool = false,
        lastUpdatedAt: Foundation.Date? = nil,
        layout: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil,
        layoutType: CustomerProfilesClientTypes.LayoutType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.layout = layout
        self.layoutDefinitionName = layoutDefinitionName
        self.layoutType = layoutType
        self.tags = tags
        self.version = version
    }
}

extension CreateDomainLayoutOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainLayoutOutput(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), isDefault: \(Swift.String(describing: isDefault)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), layoutDefinitionName: \(Swift.String(describing: layoutDefinitionName)), layoutType: \(Swift.String(describing: layoutType)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", layout: \"CONTENT_REDACTED\")"}
}

public struct CreateEventStreamInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream.
    /// This member is required.
    public var eventStreamName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
        self.tags = tags
        self.uri = uri
    }
}

public struct CreateEventStreamOutput: Swift.Sendable {
    /// A unique identifier for the event stream.
    /// This member is required.
    public var eventStreamArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        eventStreamArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.eventStreamArn = eventStreamArn
        self.tags = tags
    }
}

extension CustomerProfilesClientTypes {

    /// The criteria that a specific object attribute must meet to trigger the destination.
    public struct ObjectAttribute: Swift.Sendable {
        /// The operator used to compare an attribute against a list of values.
        /// This member is required.
        public var comparisonOperator: CustomerProfilesClientTypes.ComparisonOperator?
        /// A field defined within an object type.
        public var fieldName: Swift.String?
        /// An attribute contained within a source object.
        public var source: Swift.String?
        /// A list of attribute values used for comparison.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            comparisonOperator: CustomerProfilesClientTypes.ComparisonOperator? = nil,
            fieldName: Swift.String? = nil,
            source: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.comparisonOperator = comparisonOperator
            self.fieldName = fieldName
            self.source = source
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    /// A specific event dimension to be assessed.
    public struct EventTriggerDimension: Swift.Sendable {
        /// A list of object attributes to be evaluated.
        /// This member is required.
        public var objectAttributes: [CustomerProfilesClientTypes.ObjectAttribute]?

        public init(
            objectAttributes: [CustomerProfilesClientTypes.ObjectAttribute]? = nil
        ) {
            self.objectAttributes = objectAttributes
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum EventTriggerLogicalOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EventTriggerLogicalOperator] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the circumstances under which the event should trigger the destination.
    public struct EventTriggerCondition: Swift.Sendable {
        /// A list of dimensions to be evaluated for the event.
        /// This member is required.
        public var eventTriggerDimensions: [CustomerProfilesClientTypes.EventTriggerDimension]?
        /// The operator used to combine multiple dimensions.
        /// This member is required.
        public var logicalOperator: CustomerProfilesClientTypes.EventTriggerLogicalOperator?

        public init(
            eventTriggerDimensions: [CustomerProfilesClientTypes.EventTriggerDimension]? = nil,
            logicalOperator: CustomerProfilesClientTypes.EventTriggerLogicalOperator? = nil
        ) {
            self.eventTriggerDimensions = eventTriggerDimensions
            self.logicalOperator = logicalOperator
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum PeriodUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case hours
        case months
        case weeks
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodUnit] {
            return [
                .days,
                .hours,
                .months,
                .weeks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .hours: return "HOURS"
            case .months: return "MONTHS"
            case .weeks: return "WEEKS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Defines a limit and the time period during which it is enforced.
    public struct Period: Swift.Sendable {
        /// The maximum allowed number of destination invocations per profile.
        public var maxInvocationsPerProfile: Swift.Int?
        /// The unit of time.
        /// This member is required.
        public var unit: CustomerProfilesClientTypes.PeriodUnit?
        /// If set to true, there is no limit on the number of destination invocations per profile. The default is false.
        public var unlimited: Swift.Bool
        /// The amount of time of the specified unit.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            maxInvocationsPerProfile: Swift.Int? = nil,
            unit: CustomerProfilesClientTypes.PeriodUnit? = nil,
            unlimited: Swift.Bool = false,
            value: Swift.Int? = nil
        ) {
            self.maxInvocationsPerProfile = maxInvocationsPerProfile
            self.unit = unit
            self.unlimited = unlimited
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
    public struct EventTriggerLimits: Swift.Sendable {
        /// In milliseconds. Specifies that an event will only trigger the destination if it is processed within a certain latency period.
        public var eventExpiration: Swift.Int?
        /// A list of time periods during which the limits apply.
        public var periods: [CustomerProfilesClientTypes.Period]?

        public init(
            eventExpiration: Swift.Int? = nil,
            periods: [CustomerProfilesClientTypes.Period]? = nil
        ) {
            self.eventExpiration = eventExpiration
            self.periods = periods
        }
    }
}

public struct CreateEventTriggerInput: Swift.Sendable {
    /// The description of the event trigger.
    public var description: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of conditions that determine when an event should trigger the destination.
    /// This member is required.
    public var eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]?
    /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
    public var eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits?
    /// The unique name of the event trigger.
    /// This member is required.
    public var eventTriggerName: Swift.String?
    /// The unique name of the object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The destination is triggered only for profiles that meet the criteria of a segment definition.
    public var segmentFilter: Swift.String?
    /// An array of key-value pairs to apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]? = nil,
        eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits? = nil,
        eventTriggerName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil,
        segmentFilter: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.domainName = domainName
        self.eventTriggerConditions = eventTriggerConditions
        self.eventTriggerLimits = eventTriggerLimits
        self.eventTriggerName = eventTriggerName
        self.objectTypeName = objectTypeName
        self.segmentFilter = segmentFilter
        self.tags = tags
    }
}

extension CreateEventTriggerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventTriggerInput(domainName: \(Swift.String(describing: domainName)), eventTriggerLimits: \(Swift.String(describing: eventTriggerLimits)), eventTriggerName: \(Swift.String(describing: eventTriggerName)), objectTypeName: \(Swift.String(describing: objectTypeName)), segmentFilter: \(Swift.String(describing: segmentFilter)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", eventTriggerConditions: \"CONTENT_REDACTED\")"}
}

public struct CreateEventTriggerOutput: Swift.Sendable {
    /// The timestamp of when the event trigger was created.
    public var createdAt: Foundation.Date?
    /// The description of the event trigger.
    public var description: Swift.String?
    /// A list of conditions that determine when an event should trigger the destination.
    public var eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]?
    /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
    public var eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits?
    /// The unique name of the event trigger.
    public var eventTriggerName: Swift.String?
    /// The timestamp of when the event trigger was most recently updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The unique name of the object type.
    public var objectTypeName: Swift.String?
    /// The destination is triggered only for profiles that meet the criteria of a segment definition.
    public var segmentFilter: Swift.String?
    /// An array of key-value pairs to apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]? = nil,
        eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits? = nil,
        eventTriggerName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        segmentFilter: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.eventTriggerConditions = eventTriggerConditions
        self.eventTriggerLimits = eventTriggerLimits
        self.eventTriggerName = eventTriggerName
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.segmentFilter = segmentFilter
        self.tags = tags
    }
}

extension CreateEventTriggerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventTriggerOutput(createdAt: \(Swift.String(describing: createdAt)), eventTriggerLimits: \(Swift.String(describing: eventTriggerLimits)), eventTriggerName: \(Swift.String(describing: eventTriggerName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), objectTypeName: \(Swift.String(describing: objectTypeName)), segmentFilter: \(Swift.String(describing: segmentFilter)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", eventTriggerConditions: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Configuration data for integration workflow.
    public struct IntegrationConfig: Swift.Sendable {
        /// Configuration data for APPFLOW_INTEGRATION workflow type.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegration?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegration? = nil
        ) {
            self.appflowIntegration = appflowIntegration
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum WorkflowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appflowIntegration
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .appflowIntegration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appflowIntegration: return "APPFLOW_INTEGRATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIntegrationWorkflowInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration data for integration workflow.
    /// This member is required.
    public var integrationConfig: CustomerProfilesClientTypes.IntegrationConfig?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    /// This member is required.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        domainName: Swift.String? = nil,
        integrationConfig: CustomerProfilesClientTypes.IntegrationConfig? = nil,
        objectTypeName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    ) {
        self.domainName = domainName
        self.integrationConfig = integrationConfig
        self.objectTypeName = objectTypeName
        self.roleArn = roleArn
        self.tags = tags
        self.workflowType = workflowType
    }
}

public struct CreateIntegrationWorkflowOutput: Swift.Sendable {
    /// A message indicating create request was received.
    /// This member is required.
    public var message: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        message: Swift.String? = nil,
        workflowId: Swift.String? = nil
    ) {
        self.message = message
        self.workflowId = workflowId
    }
}

public struct CreateProfileInput: Swift.Sendable {
    /// An account number that you have assigned to the customer.
    public var accountNumber: Swift.String?
    /// Any additional information relevant to the customers profile.
    public var additionalInformation: Swift.String?
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public var address: CustomerProfilesClientTypes.Address?
    /// A key value pair of attributes of a customer profile.
    public var attributes: [Swift.String: Swift.String]?
    /// The customers billing address.
    public var billingAddress: CustomerProfilesClientTypes.Address?
    /// The customers birth date.
    public var birthDate: Swift.String?
    /// The customers business email address.
    public var businessEmailAddress: Swift.String?
    /// The name of the customers business.
    public var businessName: Swift.String?
    /// The customers business phone number.
    public var businessPhoneNumber: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customers email address, which has not been specified as a personal or business address.
    public var emailAddress: Swift.String?
    /// Object that defines the preferred methods of engagement, per channel.
    public var engagementPreferences: CustomerProfilesClientTypes.EngagementPreferences?
    /// The customers first name.
    public var firstName: Swift.String?
    /// The gender with which the customer identifies.
    @available(*, deprecated)
    public var gender: CustomerProfilesClientTypes.Gender?
    /// An alternative to Gender which accepts any string as input.
    public var genderString: Swift.String?
    /// The customers home phone number.
    public var homePhoneNumber: Swift.String?
    /// The customers last name.
    public var lastName: Swift.String?
    /// The customers mailing address.
    public var mailingAddress: CustomerProfilesClientTypes.Address?
    /// The customers middle name.
    public var middleName: Swift.String?
    /// The customers mobile phone number.
    public var mobilePhoneNumber: Swift.String?
    /// The type of profile used to describe the customer.
    @available(*, deprecated)
    public var partyType: CustomerProfilesClientTypes.PartyType?
    /// An alternative to PartyType which accepts any string as input.
    public var partyTypeString: Swift.String?
    /// The customers personal email address.
    public var personalEmailAddress: Swift.String?
    /// The customers phone number, which has not been specified as a mobile, home, or business number.
    public var phoneNumber: Swift.String?
    /// The type of the profile.
    public var profileType: CustomerProfilesClientTypes.ProfileType?
    /// The customers shipping address.
    public var shippingAddress: CustomerProfilesClientTypes.Address?

    public init(
        accountNumber: Swift.String? = nil,
        additionalInformation: Swift.String? = nil,
        address: CustomerProfilesClientTypes.Address? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        billingAddress: CustomerProfilesClientTypes.Address? = nil,
        birthDate: Swift.String? = nil,
        businessEmailAddress: Swift.String? = nil,
        businessName: Swift.String? = nil,
        businessPhoneNumber: Swift.String? = nil,
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        engagementPreferences: CustomerProfilesClientTypes.EngagementPreferences? = nil,
        firstName: Swift.String? = nil,
        gender: CustomerProfilesClientTypes.Gender? = nil,
        genderString: Swift.String? = nil,
        homePhoneNumber: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailingAddress: CustomerProfilesClientTypes.Address? = nil,
        middleName: Swift.String? = nil,
        mobilePhoneNumber: Swift.String? = nil,
        partyType: CustomerProfilesClientTypes.PartyType? = nil,
        partyTypeString: Swift.String? = nil,
        personalEmailAddress: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        profileType: CustomerProfilesClientTypes.ProfileType? = nil,
        shippingAddress: CustomerProfilesClientTypes.Address? = nil
    ) {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.engagementPreferences = engagementPreferences
        self.firstName = firstName
        self.gender = gender
        self.genderString = genderString
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.partyTypeString = partyTypeString
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.profileType = profileType
        self.shippingAddress = shippingAddress
    }
}

extension CreateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileInput(domainName: \(Swift.String(describing: domainName)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", engagementPreferences: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", profileType: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

public struct CreateProfileOutput: Swift.Sendable {
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    ) {
        self.profileId = profileId
    }
}

extension CustomerProfilesClientTypes {

    /// Object that segments on various Customer profile's fields that are larger than normal.
    public struct ExtraLengthValueProfileDimension: Swift.Sendable {
        /// The action to segment with.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.StringDimensionType?
        /// The values to apply the DimensionType on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            dimensionType: CustomerProfilesClientTypes.StringDimensionType? = nil,
            values: [Swift.String]? = nil
        ) {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum DateDimensionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case after
        case before
        case between
        case notBetween
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [DateDimensionType] {
            return [
                .after,
                .before,
                .between,
                .notBetween,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case .between: return "BETWEEN"
            case .notBetween: return "NOT_BETWEEN"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that segments on various Customer Profile's date fields.
    public struct DateDimension: Swift.Sendable {
        /// The action to segment with.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.DateDimensionType?
        /// The values to apply the DimensionType on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            dimensionType: CustomerProfilesClientTypes.DateDimensionType? = nil,
            values: [Swift.String]? = nil
        ) {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ProfileTypeDimensionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclusive
        case inclusive
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileTypeDimensionType] {
            return [
                .exclusive,
                .inclusive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclusive: return "EXCLUSIVE"
            case .inclusive: return "INCLUSIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object to hold the dimension of a profile type field to segment on.
    public struct ProfileTypeDimension: Swift.Sendable {
        /// The action to segment on.
        /// This member is required.
        public var dimensionType: CustomerProfilesClientTypes.ProfileTypeDimensionType?
        /// The values to apply the DimensionType on.
        /// This member is required.
        public var values: [CustomerProfilesClientTypes.ProfileType]?

        public init(
            dimensionType: CustomerProfilesClientTypes.ProfileTypeDimensionType? = nil,
            values: [CustomerProfilesClientTypes.ProfileType]? = nil
        ) {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes.ProfileTypeDimension: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProfileTypeDimension(dimensionType: \(Swift.String(describing: dimensionType)), values: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// The object used to segment on attributes within the customer profile.
    public struct ProfileAttributes: Swift.Sendable {
        /// A field to describe values to segment on within account number.
        public var accountNumber: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within additional information.
        public var additionalInformation: CustomerProfilesClientTypes.ExtraLengthValueProfileDimension?
        /// A field to describe values to segment on within address.
        public var address: CustomerProfilesClientTypes.AddressDimension?
        /// A field to describe values to segment on within attributes.
        public var attributes: [Swift.String: CustomerProfilesClientTypes.AttributeDimension]?
        /// A field to describe values to segment on within billing address.
        public var billingAddress: CustomerProfilesClientTypes.AddressDimension?
        /// A field to describe values to segment on within birthDate.
        public var birthDate: CustomerProfilesClientTypes.DateDimension?
        /// A field to describe values to segment on within business email address.
        public var businessEmailAddress: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within business name.
        public var businessName: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within business phone number.
        public var businessPhoneNumber: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within email address.
        public var emailAddress: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within first name.
        public var firstName: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within genderString.
        public var genderString: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within home phone number.
        public var homePhoneNumber: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within last name.
        public var lastName: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within mailing address.
        public var mailingAddress: CustomerProfilesClientTypes.AddressDimension?
        /// A field to describe values to segment on within middle name.
        public var middleName: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within mobile phone number.
        public var mobilePhoneNumber: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within partyTypeString.
        public var partyTypeString: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within personal email address.
        public var personalEmailAddress: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within phone number.
        public var phoneNumber: CustomerProfilesClientTypes.ProfileDimension?
        /// A field to describe values to segment on within profile type.
        public var profileType: CustomerProfilesClientTypes.ProfileTypeDimension?
        /// A field to describe values to segment on within shipping address.
        public var shippingAddress: CustomerProfilesClientTypes.AddressDimension?

        public init(
            accountNumber: CustomerProfilesClientTypes.ProfileDimension? = nil,
            additionalInformation: CustomerProfilesClientTypes.ExtraLengthValueProfileDimension? = nil,
            address: CustomerProfilesClientTypes.AddressDimension? = nil,
            attributes: [Swift.String: CustomerProfilesClientTypes.AttributeDimension]? = nil,
            billingAddress: CustomerProfilesClientTypes.AddressDimension? = nil,
            birthDate: CustomerProfilesClientTypes.DateDimension? = nil,
            businessEmailAddress: CustomerProfilesClientTypes.ProfileDimension? = nil,
            businessName: CustomerProfilesClientTypes.ProfileDimension? = nil,
            businessPhoneNumber: CustomerProfilesClientTypes.ProfileDimension? = nil,
            emailAddress: CustomerProfilesClientTypes.ProfileDimension? = nil,
            firstName: CustomerProfilesClientTypes.ProfileDimension? = nil,
            genderString: CustomerProfilesClientTypes.ProfileDimension? = nil,
            homePhoneNumber: CustomerProfilesClientTypes.ProfileDimension? = nil,
            lastName: CustomerProfilesClientTypes.ProfileDimension? = nil,
            mailingAddress: CustomerProfilesClientTypes.AddressDimension? = nil,
            middleName: CustomerProfilesClientTypes.ProfileDimension? = nil,
            mobilePhoneNumber: CustomerProfilesClientTypes.ProfileDimension? = nil,
            partyTypeString: CustomerProfilesClientTypes.ProfileDimension? = nil,
            personalEmailAddress: CustomerProfilesClientTypes.ProfileDimension? = nil,
            phoneNumber: CustomerProfilesClientTypes.ProfileDimension? = nil,
            profileType: CustomerProfilesClientTypes.ProfileTypeDimension? = nil,
            shippingAddress: CustomerProfilesClientTypes.AddressDimension? = nil
        ) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileType = profileType
            self.shippingAddress = shippingAddress
        }
    }
}

extension CustomerProfilesClientTypes.ProfileAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    /// Object that holds what profile and calculated attributes to segment on.
    public enum Dimension: Swift.Sendable {
        /// Object that holds the profile attributes to segment on.
        case profileattributes(CustomerProfilesClientTypes.ProfileAttributes)
        /// Object that holds the calculated attributes to segment on.
        case calculatedattributes([Swift.String: CustomerProfilesClientTypes.CalculatedAttributeDimension])
        case sdkUnknown(Swift.String)
    }
}

extension CustomerProfilesClientTypes {

    /// The source segments to build off of.
    public struct SourceSegment: Swift.Sendable {
        /// The unique name of the segment definition.
        public var segmentDefinitionName: Swift.String?

        public init(
            segmentDefinitionName: Swift.String? = nil
        ) {
            self.segmentDefinitionName = segmentDefinitionName
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum IncludeOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [IncludeOptions] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Contains dimensions that determine what to segment on.
    public struct Group: Swift.Sendable {
        /// Defines the attributes to segment on.
        public var dimensions: [CustomerProfilesClientTypes.Dimension]?
        /// Defines the starting source of data.
        public var sourceSegments: [CustomerProfilesClientTypes.SourceSegment]?
        /// Defines how to interact with the source data.
        public var sourceType: CustomerProfilesClientTypes.IncludeOptions?
        /// Defines how to interact with the profiles found in the current filtering.
        public var type: CustomerProfilesClientTypes.IncludeOptions?

        public init(
            dimensions: [CustomerProfilesClientTypes.Dimension]? = nil,
            sourceSegments: [CustomerProfilesClientTypes.SourceSegment]? = nil,
            sourceType: CustomerProfilesClientTypes.IncludeOptions? = .all,
            type: CustomerProfilesClientTypes.IncludeOptions? = .all
        ) {
            self.dimensions = dimensions
            self.sourceSegments = sourceSegments
            self.sourceType = sourceType
            self.type = type
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Contains all groups of the segment definition.
    public struct SegmentGroup: Swift.Sendable {
        /// Holds the list of groups within the segment definition.
        public var groups: [CustomerProfilesClientTypes.Group]?
        /// Defines whether to include or exclude the profiles that fit the segment criteria.
        public var include: CustomerProfilesClientTypes.IncludeOptions?

        public init(
            groups: [CustomerProfilesClientTypes.Group]? = nil,
            include: CustomerProfilesClientTypes.IncludeOptions? = .all
        ) {
            self.groups = groups
            self.include = include
        }
    }
}

extension CustomerProfilesClientTypes.SegmentGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct CreateSegmentDefinitionInput: Swift.Sendable {
    /// The description of the segment definition.
    public var description: Swift.String?
    /// The display name of the segment definition.
    /// This member is required.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the segment definition.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?
    /// Specifies the base segments and dimensions for a segment definition along with their respective relationship.
    /// This member is required.
    public var segmentGroups: CustomerProfilesClientTypes.SegmentGroup?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil,
        segmentGroups: CustomerProfilesClientTypes.SegmentGroup? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
        self.segmentDefinitionName = segmentDefinitionName
        self.segmentGroups = segmentGroups
        self.tags = tags
    }
}

extension CreateSegmentDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSegmentDefinitionInput(displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), segmentDefinitionName: \(Swift.String(describing: segmentDefinitionName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", segmentGroups: \"CONTENT_REDACTED\")"}
}

public struct CreateSegmentDefinitionOutput: Swift.Sendable {
    /// The timestamp of when the segment definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the segment definition.
    public var description: Swift.String?
    /// The display name of the segment definition.
    public var displayName: Swift.String?
    /// The arn of the segment definition.
    public var segmentDefinitionArn: Swift.String?
    /// The name of the segment definition.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        segmentDefinitionArn: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.segmentDefinitionArn = segmentDefinitionArn
        self.segmentDefinitionName = segmentDefinitionName
        self.tags = tags
    }
}

extension CreateSegmentDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSegmentDefinitionOutput(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), segmentDefinitionArn: \(Swift.String(describing: segmentDefinitionArn)), segmentDefinitionName: \(Swift.String(describing: segmentDefinitionName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Contains all groups of the segment definition.
    public struct SegmentGroupStructure: Swift.Sendable {
        /// Holds the list of groups within the segment definition.
        public var groups: [CustomerProfilesClientTypes.Group]?
        /// Define whether to include or exclude the profiles that fit the segment criteria.
        public var include: CustomerProfilesClientTypes.IncludeOptions?

        public init(
            groups: [CustomerProfilesClientTypes.Group]? = nil,
            include: CustomerProfilesClientTypes.IncludeOptions? = nil
        ) {
            self.groups = groups
            self.include = include
        }
    }
}

public struct CreateSegmentEstimateInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The segment query for calculating a segment estimate.
    /// This member is required.
    public var segmentQuery: CustomerProfilesClientTypes.SegmentGroupStructure?

    public init(
        domainName: Swift.String? = nil,
        segmentQuery: CustomerProfilesClientTypes.SegmentGroupStructure? = nil
    ) {
        self.domainName = domainName
        self.segmentQuery = segmentQuery
    }
}

public struct CreateSegmentEstimateOutput: Swift.Sendable {
    /// The unique name of the domain.
    public var domainName: Swift.String?
    /// A unique identifier for the resource. The value can be passed to GetSegmentEstimate to retrieve the result of segment estimate status.
    public var estimateId: Swift.String?
    /// The status code for the response.
    public var statusCode: Swift.Int

    public init(
        domainName: Swift.String? = nil,
        estimateId: Swift.String? = nil,
        statusCode: Swift.Int = 0
    ) {
        self.domainName = domainName
        self.estimateId = estimateId
        self.statusCode = statusCode
    }
}

extension CustomerProfilesClientTypes {

    public enum DataFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case jsonl
        case orc
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormat] {
            return [
                .csv,
                .jsonl,
                .orc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .jsonl: return "JSONL"
            case .orc: return "ORC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSegmentSnapshotInput: Swift.Sendable {
    /// The format in which the segment will be exported.
    /// This member is required.
    public var dataFormat: CustomerProfilesClientTypes.DataFormat?
    /// The destination to which the segment will be exported. This field must be provided if the request is not submitted from the Amazon Connect Admin Website.
    public var destinationUri: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the exported segment.
    public var encryptionKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that allows Customer Profiles service principal to assume the role for conducting KMS and S3 operations.
    public var roleArn: Swift.String?
    /// The name of the segment definition used in this snapshot request.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?

    public init(
        dataFormat: CustomerProfilesClientTypes.DataFormat? = nil,
        destinationUri: Swift.String? = nil,
        domainName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil
    ) {
        self.dataFormat = dataFormat
        self.destinationUri = destinationUri
        self.domainName = domainName
        self.encryptionKey = encryptionKey
        self.roleArn = roleArn
        self.segmentDefinitionName = segmentDefinitionName
    }
}

public struct CreateSegmentSnapshotOutput: Swift.Sendable {
    /// The unique identifier of the segment snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        snapshotId: Swift.String? = nil
    ) {
        self.snapshotId = snapshotId
    }
}

extension CustomerProfilesClientTypes {

    public enum FieldContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emailAddress
        case name
        case number
        case phoneNumber
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldContentType] {
            return [
                .emailAddress,
                .name,
                .number,
                .phoneNumber,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .number: return "NUMBER"
            case .phoneNumber: return "PHONE_NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Represents a field in a ProfileObjectType.
    public struct ObjectTypeField: Swift.Sendable {
        /// The content type of the field. Used for determining equality when searching.
        public var contentType: CustomerProfilesClientTypes.FieldContentType?
        /// A field of a ProfileObject. For example: _source.FirstName, where _source is a ProfileObjectType of a Zendesk user and FirstName is a field in that ObjectType.
        public var source: Swift.String?
        /// The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        public var target: Swift.String?

        public init(
            contentType: CustomerProfilesClientTypes.FieldContentType? = nil,
            source: Swift.String? = nil,
            target: Swift.String? = nil
        ) {
            self.contentType = contentType
            self.source = source
            self.target = target
        }
    }
}

public struct CreateUploadJobInput: Swift.Sendable {
    /// The expiry duration for the profiles ingested with the job. If not provided, the system default of 2 weeks is used.
    public var dataExpiry: Swift.Int?
    /// The unique name of the upload job. Could be a file name to identify the upload job.
    /// This member is required.
    public var displayName: Swift.String?
    /// The unique name of the domain. Domain should be exists for the upload job to be created.
    /// This member is required.
    public var domainName: Swift.String?
    /// The mapping between CSV Columns and Profile Object attributes. A map of the name and ObjectType field.
    /// This member is required.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// The unique key columns for de-duping the profiles used to map data to the profile.
    /// This member is required.
    public var uniqueKey: Swift.String?

    public init(
        dataExpiry: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        uniqueKey: Swift.String? = nil
    ) {
        self.dataExpiry = dataExpiry
        self.displayName = displayName
        self.domainName = domainName
        self.fields = fields
        self.uniqueKey = uniqueKey
    }
}

extension CreateUploadJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUploadJobInput(dataExpiry: \(Swift.String(describing: dataExpiry)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), uniqueKey: \(Swift.String(describing: uniqueKey)), fields: \"CONTENT_REDACTED\")"}
}

public struct CreateUploadJobOutput: Swift.Sendable {
    /// The unique identifier for the created upload job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    ) {
        self.jobId = jobId
    }
}

public struct DeleteCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    ) {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
    }
}

public struct DeleteCalculatedAttributeDefinitionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDomainInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    ) {
        self.domainName = domainName
    }
}

public struct DeleteDomainOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteDomainLayoutInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the layout.
    /// This member is required.
    public var layoutDefinitionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.layoutDefinitionName = layoutDefinitionName
    }
}

public struct DeleteDomainLayoutOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteEventStreamInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream
    /// This member is required.
    public var eventStreamName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
    }
}

public struct DeleteEventStreamOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEventTriggerInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the event trigger.
    /// This member is required.
    public var eventTriggerName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventTriggerName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.eventTriggerName = eventTriggerName
    }
}

public struct DeleteEventTriggerOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteIntegrationInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        uri: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.uri = uri
    }
}

public struct DeleteIntegrationOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteProfileInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        profileId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.profileId = profileId
    }
}

public struct DeleteProfileOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteProfileKeyInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile.
    /// This member is required.
    public var keyName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        values: [Swift.String]? = nil
    ) {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

public struct DeleteProfileKeyOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteProfileObjectInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The unique identifier of the profile object generated by the service.
    /// This member is required.
    public var profileObjectUniqueKey: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        profileObjectUniqueKey: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
        self.profileId = profileId
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

public struct DeleteProfileObjectOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteProfileObjectTypeInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

public struct DeleteProfileObjectTypeOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteSegmentDefinitionInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the segment definition.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.segmentDefinitionName = segmentDefinitionName
    }
}

public struct DeleteSegmentDefinitionOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct DeleteWorkflowInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.workflowId = workflowId
    }
}

public struct DeleteWorkflowOutput: Swift.Sendable {

    public init() { }
}

public struct DetectProfileObjectTypeInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A string that is serialized from a JSON object.
    /// This member is required.
    public var objects: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        objects: [Swift.String]? = nil
    ) {
        self.domainName = domainName
        self.objects = objects
    }
}

extension DetectProfileObjectTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectProfileObjectTypeInput(domainName: \(Swift.String(describing: domainName)), objects: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    public enum StandardIdentifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case airBooking
        case airPreference
        case airSegment
        case asset
        case `case`
        case communicationRecord
        case hotelPreference
        case hotelReservation
        case hotelStayRevenue
        case lookupOnly
        case loyalty
        case loyaltyPromotion
        case loyaltyTransaction
        case newOnly
        case order
        case profile
        case secondary
        case unique
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardIdentifier] {
            return [
                .airBooking,
                .airPreference,
                .airSegment,
                .asset,
                .case,
                .communicationRecord,
                .hotelPreference,
                .hotelReservation,
                .hotelStayRevenue,
                .lookupOnly,
                .loyalty,
                .loyaltyPromotion,
                .loyaltyTransaction,
                .newOnly,
                .order,
                .profile,
                .secondary,
                .unique
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .airBooking: return "AIR_BOOKING"
            case .airPreference: return "AIR_PREFERENCE"
            case .airSegment: return "AIR_SEGMENT"
            case .asset: return "ASSET"
            case .case: return "CASE"
            case .communicationRecord: return "COMMUNICATION_RECORD"
            case .hotelPreference: return "HOTEL_PREFERENCE"
            case .hotelReservation: return "HOTEL_RESERVATION"
            case .hotelStayRevenue: return "HOTEL_STAY_REVENUE"
            case .lookupOnly: return "LOOKUP_ONLY"
            case .loyalty: return "LOYALTY"
            case .loyaltyPromotion: return "LOYALTY_PROMOTION"
            case .loyaltyTransaction: return "LOYALTY_TRANSACTION"
            case .newOnly: return "NEW_ONLY"
            case .order: return "ORDER"
            case .profile: return "PROFILE"
            case .secondary: return "SECONDARY"
            case .unique: return "UNIQUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
    public struct ObjectTypeKey: Swift.Sendable {
        /// The reference for the key name of the fields map.
        public var fieldNames: [Swift.String]?
        /// The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE, ASSET, CASE, or ORDER means that this key can be used to tie an object to a PROFILE, ASSET, CASE, or ORDER respectively. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        public var standardIdentifiers: [CustomerProfilesClientTypes.StandardIdentifier]?

        public init(
            fieldNames: [Swift.String]? = nil,
            standardIdentifiers: [CustomerProfilesClientTypes.StandardIdentifier]? = nil
        ) {
            self.fieldNames = fieldNames
            self.standardIdentifiers = standardIdentifiers
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Contains ProfileObjectType mapping information from the model.
    public struct DetectedProfileObjectType: Swift.Sendable {
        /// A map of the name and the ObjectType field.
        public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
        /// A list of unique keys that can be used to map data to a profile.
        public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
        /// The format of sourceLastUpdatedTimestamp that was detected in fields.
        public var sourceLastUpdatedTimestampFormat: Swift.String?

        public init(
            fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
            keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
            sourceLastUpdatedTimestampFormat: Swift.String? = nil
        ) {
            self.fields = fields
            self.keys = keys
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        }
    }
}

extension CustomerProfilesClientTypes.DetectedProfileObjectType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectedProfileObjectType(sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct DetectProfileObjectTypeOutput: Swift.Sendable {
    /// Detected ProfileObjectType mappings from given objects. A maximum of one mapping is supported.
    public var detectedProfileObjectTypes: [CustomerProfilesClientTypes.DetectedProfileObjectType]?

    public init(
        detectedProfileObjectTypes: [CustomerProfilesClientTypes.DetectedProfileObjectType]? = nil
    ) {
        self.detectedProfileObjectTypes = detectedProfileObjectTypes
    }
}

public struct GetAutoMergingPreviewInput: Swift.Sendable {
    /// How the auto-merging process should resolve conflicts between different profiles.
    /// This member is required.
    public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
    /// A list of matching attributes that represent matching criteria.
    /// This member is required.
    public var consolidation: CustomerProfilesClientTypes.Consolidation?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Minimum confidence score required for profiles within a matching group to be merged during the auto-merge process.
    public var minAllowedConfidenceScoreForMerging: Swift.Double?

    public init(
        conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
        consolidation: CustomerProfilesClientTypes.Consolidation? = nil,
        domainName: Swift.String? = nil,
        minAllowedConfidenceScoreForMerging: Swift.Double? = nil
    ) {
        self.conflictResolution = conflictResolution
        self.consolidation = consolidation
        self.domainName = domainName
        self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
    }
}

public struct GetAutoMergingPreviewOutput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of match groups in the domain that have been reviewed in this preview dry run.
    public var numberOfMatchesInSample: Swift.Int
    /// The number of profiles found in this preview dry run.
    public var numberOfProfilesInSample: Swift.Int
    /// The number of profiles that would be merged if this wasn't a preview dry run.
    public var numberOfProfilesWillBeMerged: Swift.Int

    public init(
        domainName: Swift.String? = nil,
        numberOfMatchesInSample: Swift.Int = 0,
        numberOfProfilesInSample: Swift.Int = 0,
        numberOfProfilesWillBeMerged: Swift.Int = 0
    ) {
        self.domainName = domainName
        self.numberOfMatchesInSample = numberOfMatchesInSample
        self.numberOfProfilesInSample = numberOfProfilesInSample
        self.numberOfProfilesWillBeMerged = numberOfProfilesWillBeMerged
    }
}

public struct GetCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    ) {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
    }
}

public struct GetCalculatedAttributeDefinitionOutput: Swift.Sendable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The filter assigned to this calculated attribute definition.
    public var filter: CustomerProfilesClientTypes.Filter?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// Information indicating if the Calculated Attribute is ready for use by confirming all historical data has been processed and reflected.
    public var readiness: CustomerProfilesClientTypes.Readiness?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// Status of the Calculated Attribute creation (whether all historical data has been indexed).
    public var status: CustomerProfilesClientTypes.ReadinessStatus?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// Whether historical data ingested before the Calculated Attribute was created should be included in calculations.
    public var useHistoricalData: Swift.Bool?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        filter: CustomerProfilesClientTypes.Filter? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        readiness: CustomerProfilesClientTypes.Readiness? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        status: CustomerProfilesClientTypes.ReadinessStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useHistoricalData: Swift.Bool? = nil
    ) {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.filter = filter
        self.lastUpdatedAt = lastUpdatedAt
        self.readiness = readiness
        self.statistic = statistic
        self.status = status
        self.tags = tags
        self.useHistoricalData = useHistoricalData
    }
}

extension GetCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), filter: \(Swift.String(describing: filter)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), readiness: \(Swift.String(describing: readiness)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), useHistoricalData: \(Swift.String(describing: useHistoricalData)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

public struct GetCalculatedAttributeForProfileInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        profileId: Swift.String? = nil
    ) {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
        self.profileId = profileId
    }
}

public struct GetCalculatedAttributeForProfileOutput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// Indicates whether the calculated attributes value is based on partial data. If data is partial, it is set to true.
    public var isDataPartial: Swift.String?
    /// The timestamp of the newest object included in the calculated attribute calculation.
    public var lastObjectTimestamp: Foundation.Date?
    /// The value of the calculated attribute.
    public var value: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isDataPartial: Swift.String? = nil,
        lastObjectTimestamp: Foundation.Date? = nil,
        value: Swift.String? = nil
    ) {
        self.calculatedAttributeName = calculatedAttributeName
        self.displayName = displayName
        self.isDataPartial = isDataPartial
        self.lastObjectTimestamp = lastObjectTimestamp
        self.value = value
    }
}

public struct GetDomainInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    ) {
        self.domainName = domainName
    }
}

extension CustomerProfilesClientTypes {

    /// Usage-specific statistics about the domain.
    public struct DomainStats: Swift.Sendable {
        /// The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        public var meteringProfileCount: Swift.Int
        /// The total number of objects in domain.
        public var objectCount: Swift.Int
        /// The total number of profiles currently in the domain.
        public var profileCount: Swift.Int
        /// The total size, in bytes, of all objects in the domain.
        public var totalSize: Swift.Int

        public init(
            meteringProfileCount: Swift.Int = 0,
            objectCount: Swift.Int = 0,
            profileCount: Swift.Int = 0,
            totalSize: Swift.Int = 0
        ) {
            self.meteringProfileCount = meteringProfileCount
            self.objectCount = objectCount
            self.profileCount = profileCount
            self.totalSize = totalSize
        }
    }
}

public struct GetDomainOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// Usage-specific statistics about the domain.
    public var stats: CustomerProfilesClientTypes.DomainStats?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        stats: CustomerProfilesClientTypes.DomainStats? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.stats = stats
        self.tags = tags
    }
}

public struct GetDomainLayoutInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the layout.
    /// This member is required.
    public var layoutDefinitionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.layoutDefinitionName = layoutDefinitionName
    }
}

public struct GetDomainLayoutOutput: Swift.Sendable {
    /// The timestamp of when the layout was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the layout
    /// This member is required.
    public var description: Swift.String?
    /// The display name of the layout
    /// This member is required.
    public var displayName: Swift.String?
    /// If set to true for a layout, this layout will be used by default to view data. If set to false, then the layout will not be used by default, but it can be used to view data by explicitly selecting it in the console.
    public var isDefault: Swift.Bool
    /// The timestamp of when the layout was most recently updated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// A customizable layout that can be used to view data under a Customer Profiles domain.
    /// This member is required.
    public var layout: Swift.String?
    /// The unique name of the layout.
    /// This member is required.
    public var layoutDefinitionName: Swift.String?
    /// The type of layout that can be used to view data under a Customer Profiles domain.
    /// This member is required.
    public var layoutType: CustomerProfilesClientTypes.LayoutType?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The version used to create layout.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isDefault: Swift.Bool = false,
        lastUpdatedAt: Foundation.Date? = nil,
        layout: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil,
        layoutType: CustomerProfilesClientTypes.LayoutType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.layout = layout
        self.layoutDefinitionName = layoutDefinitionName
        self.layoutType = layoutType
        self.tags = tags
        self.version = version
    }
}

extension GetDomainLayoutOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainLayoutOutput(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), isDefault: \(Swift.String(describing: isDefault)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), layoutDefinitionName: \(Swift.String(describing: layoutDefinitionName)), layoutType: \(Swift.String(describing: layoutType)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", layout: \"CONTENT_REDACTED\")"}
}

public struct GetEventStreamInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream provided during create operations.
    /// This member is required.
    public var eventStreamName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
    }
}

extension CustomerProfilesClientTypes {

    public enum EventStreamDestinationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStreamDestinationStatus] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Details of the destination being used for the EventStream.
    public struct EventStreamDestinationDetails: Swift.Sendable {
        /// The human-readable string that corresponds to the error or success while enabling the streaming destination.
        public var message: Swift.String?
        /// The status of enabling the Kinesis stream as a destination for export.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.EventStreamDestinationStatus?
        /// The timestamp when the status last changed to UNHEALHY.
        public var unhealthySince: Foundation.Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            message: Swift.String? = nil,
            status: CustomerProfilesClientTypes.EventStreamDestinationStatus? = nil,
            unhealthySince: Foundation.Date? = nil,
            uri: Swift.String? = nil
        ) {
            self.message = message
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum EventStreamState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStreamState] {
            return [
                .running,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetEventStreamOutput: Swift.Sendable {
    /// The timestamp of when the export was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Details regarding the Kinesis stream.
    /// This member is required.
    public var destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A unique identifier for the event stream.
    /// This member is required.
    public var eventStreamArn: Swift.String?
    /// The operational state of destination stream for export.
    /// This member is required.
    public var state: CustomerProfilesClientTypes.EventStreamState?
    /// The timestamp when the State changed to STOPPED.
    public var stoppedSince: Foundation.Date?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails? = nil,
        domainName: Swift.String? = nil,
        eventStreamArn: Swift.String? = nil,
        state: CustomerProfilesClientTypes.EventStreamState? = nil,
        stoppedSince: Foundation.Date? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.destinationDetails = destinationDetails
        self.domainName = domainName
        self.eventStreamArn = eventStreamArn
        self.state = state
        self.stoppedSince = stoppedSince
        self.tags = tags
    }
}

public struct GetEventTriggerInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the event trigger.
    /// This member is required.
    public var eventTriggerName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventTriggerName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.eventTriggerName = eventTriggerName
    }
}

public struct GetEventTriggerOutput: Swift.Sendable {
    /// The timestamp of when the event trigger was created.
    public var createdAt: Foundation.Date?
    /// The description of the event trigger.
    public var description: Swift.String?
    /// A list of conditions that determine when an event should trigger the destination.
    public var eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]?
    /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
    public var eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits?
    /// The unique name of the event trigger.
    public var eventTriggerName: Swift.String?
    /// The timestamp of when the event trigger was most recently updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The unique name of the object type.
    public var objectTypeName: Swift.String?
    /// The destination is triggered only for profiles that meet the criteria of a segment definition.
    public var segmentFilter: Swift.String?
    /// An array of key-value pairs to apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]? = nil,
        eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits? = nil,
        eventTriggerName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        segmentFilter: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.eventTriggerConditions = eventTriggerConditions
        self.eventTriggerLimits = eventTriggerLimits
        self.eventTriggerName = eventTriggerName
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.segmentFilter = segmentFilter
        self.tags = tags
    }
}

extension GetEventTriggerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventTriggerOutput(createdAt: \(Swift.String(describing: createdAt)), eventTriggerLimits: \(Swift.String(describing: eventTriggerLimits)), eventTriggerName: \(Swift.String(describing: eventTriggerName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), objectTypeName: \(Swift.String(describing: objectTypeName)), segmentFilter: \(Swift.String(describing: segmentFilter)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", eventTriggerConditions: \"CONTENT_REDACTED\")"}
}

public struct GetIdentityResolutionJobInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the Identity Resolution Job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.jobId = jobId
    }
}

extension CustomerProfilesClientTypes {

    /// The S3 location where Identity Resolution Jobs write result files.
    public struct S3ExportingLocation: Swift.Sendable {
        /// The name of the S3 bucket name where Identity Resolution Jobs write result files.
        public var s3BucketName: Swift.String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public var s3KeyName: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyName: Swift.String? = nil
        ) {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The S3 location where Identity Resolution Jobs write result files.
    public struct ExportingLocation: Swift.Sendable {
        /// Information about the S3 location where Identity Resolution Jobs write result files.
        public var s3Exporting: CustomerProfilesClientTypes.S3ExportingLocation?

        public init(
            s3Exporting: CustomerProfilesClientTypes.S3ExportingLocation? = nil
        ) {
            self.s3Exporting = s3Exporting
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Statistics about the Identity Resolution Job.
    public struct JobStats: Swift.Sendable {
        /// The number of matches found.
        public var numberOfMatchesFound: Swift.Int
        /// The number of merges completed.
        public var numberOfMergesDone: Swift.Int
        /// The number of profiles reviewed.
        public var numberOfProfilesReviewed: Swift.Int

        public init(
            numberOfMatchesFound: Swift.Int = 0,
            numberOfMergesDone: Swift.Int = 0,
            numberOfProfilesReviewed: Swift.Int = 0
        ) {
            self.numberOfMatchesFound = numberOfMatchesFound
            self.numberOfMergesDone = numberOfMergesDone
            self.numberOfProfilesReviewed = numberOfProfilesReviewed
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum IdentityResolutionJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case findMatching
        case merging
        case partialSuccess
        case pending
        case preprocessing
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityResolutionJobStatus] {
            return [
                .completed,
                .failed,
                .findMatching,
                .merging,
                .partialSuccess,
                .pending,
                .preprocessing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .findMatching: return "FIND_MATCHING"
            case .merging: return "MERGING"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .pending: return "PENDING"
            case .preprocessing: return "PREPROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIdentityResolutionJobOutput: Swift.Sendable {
    /// Configuration settings for how to perform the auto-merging of profiles.
    public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
    /// The unique name of the domain.
    public var domainName: Swift.String?
    /// The S3 location where the Identity Resolution Job writes result files.
    public var exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
    /// The timestamp of when the Identity Resolution Job was completed.
    public var jobEndTime: Foundation.Date?
    /// The timestamp of when the Identity Resolution Job will expire.
    public var jobExpirationTime: Foundation.Date?
    /// The unique identifier of the Identity Resolution Job.
    public var jobId: Swift.String?
    /// The timestamp of when the Identity Resolution Job was started or will be started.
    public var jobStartTime: Foundation.Date?
    /// Statistics about the Identity Resolution Job.
    public var jobStats: CustomerProfilesClientTypes.JobStats?
    /// The timestamp of when the Identity Resolution Job was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The error messages that are generated when the Identity Resolution Job runs.
    public var message: Swift.String?
    /// The status of the Identity Resolution Job.
    ///
    /// * PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.
    ///
    /// * PREPROCESSING: The Identity Resolution Job is loading your data.
    ///
    /// * FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.
    ///
    /// * MERGING: The Identity Resolution Job is merging duplicate profiles.
    ///
    /// * COMPLETED: The Identity Resolution Job completed successfully.
    ///
    /// * PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.
    ///
    /// * FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
    public var status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?

    public init(
        autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
        domainName: Swift.String? = nil,
        exportingLocation: CustomerProfilesClientTypes.ExportingLocation? = nil,
        jobEndTime: Foundation.Date? = nil,
        jobExpirationTime: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        jobStartTime: Foundation.Date? = nil,
        jobStats: CustomerProfilesClientTypes.JobStats? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: CustomerProfilesClientTypes.IdentityResolutionJobStatus? = nil
    ) {
        self.autoMerging = autoMerging
        self.domainName = domainName
        self.exportingLocation = exportingLocation
        self.jobEndTime = jobEndTime
        self.jobExpirationTime = jobExpirationTime
        self.jobId = jobId
        self.jobStartTime = jobStartTime
        self.jobStats = jobStats
        self.lastUpdatedAt = lastUpdatedAt
        self.message = message
        self.status = status
    }
}

public struct GetIntegrationInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        uri: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.uri = uri
    }
}

public struct GetIntegrationOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of unique names for active event triggers associated with the integration. This list would be empty if no Event Trigger is associated with the integration.
    public var eventTriggerNames: [Swift.String]?
    /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
    public var isUnstructured: Swift.Bool?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        domainName: Swift.String? = nil,
        eventTriggerNames: [Swift.String]? = nil,
        isUnstructured: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String: Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil,
        workflowId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.domainName = domainName
        self.eventTriggerNames = eventTriggerNames
        self.isUnstructured = isUnstructured
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.roleArn = roleArn
        self.tags = tags
        self.uri = uri
        self.workflowId = workflowId
    }
}

public struct GetMatchesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// The Match group object.
    public struct MatchItem: Swift.Sendable {
        /// A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used an absolute measure of matching quality.
        public var confidenceScore: Swift.Double?
        /// The unique identifiers for this group of profiles that match.
        public var matchId: Swift.String?
        /// A list of identifiers for profiles that match.
        public var profileIds: [Swift.String]?

        public init(
            confidenceScore: Swift.Double? = nil,
            matchId: Swift.String? = nil,
            profileIds: [Swift.String]? = nil
        ) {
            self.confidenceScore = confidenceScore
            self.matchId = matchId
            self.profileIds = profileIds
        }
    }
}

public struct GetMatchesOutput: Swift.Sendable {
    /// The timestamp this version of Match Result generated.
    public var matchGenerationDate: Foundation.Date?
    /// The list of matched profiles for this instance.
    public var matches: [CustomerProfilesClientTypes.MatchItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The number of potential matches found.
    public var potentialMatches: Swift.Int?

    public init(
        matchGenerationDate: Foundation.Date? = nil,
        matches: [CustomerProfilesClientTypes.MatchItem]? = nil,
        nextToken: Swift.String? = nil,
        potentialMatches: Swift.Int? = nil
    ) {
        self.matchGenerationDate = matchGenerationDate
        self.matches = matches
        self.nextToken = nextToken
        self.potentialMatches = potentialMatches
    }
}

public struct GetProfileObjectTypeInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

public struct GetProfileObjectTypeOutput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// The timestamp of when the domain was created.
    public var createdAt: Foundation.Date?
    /// The description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The timestamp of when the domain was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The amount of provisioned profile object max count available.
    public var maxAvailableProfileObjectCount: Swift.Int?
    /// The amount of profile object max count assigned to the object type.
    public var maxProfileObjectCount: Swift.Int?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        maxAvailableProfileObjectCount: Swift.Int? = nil,
        maxProfileObjectCount: Swift.Int? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateId: Swift.String? = nil
    ) {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
        self.maxProfileObjectCount = maxProfileObjectCount
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

extension GetProfileObjectTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileObjectTypeOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), maxAvailableProfileObjectCount: \(Swift.String(describing: maxAvailableProfileObjectCount)), maxProfileObjectCount: \(Swift.String(describing: maxProfileObjectCount)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct GetProfileObjectTypeTemplateInput: Swift.Sendable {
    /// A unique identifier for the object template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        templateId: Swift.String? = nil
    ) {
        self.templateId = templateId
    }
}

public struct GetProfileObjectTypeTemplateOutput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The name of the source of the object template.
    public var sourceName: Swift.String?
    /// The source of the object template.
    public var sourceObject: Swift.String?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceObject: Swift.String? = nil,
        templateId: Swift.String? = nil
    ) {
        self.allowProfileCreation = allowProfileCreation
        self.fields = fields
        self.keys = keys
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.sourceName = sourceName
        self.sourceObject = sourceObject
        self.templateId = templateId
    }
}

extension GetProfileObjectTypeTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileObjectTypeTemplateOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), sourceName: \(Swift.String(describing: sourceName)), sourceObject: \(Swift.String(describing: sourceObject)), templateId: \(Swift.String(describing: templateId)), fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct GetSegmentDefinitionInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the segment definition.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.segmentDefinitionName = segmentDefinitionName
    }
}

public struct GetSegmentDefinitionOutput: Swift.Sendable {
    /// The timestamp of when the segment definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the segment definition.
    public var description: Swift.String?
    /// The display name of the segment definition.
    public var displayName: Swift.String?
    /// The arn of the segment definition.
    /// This member is required.
    public var segmentDefinitionArn: Swift.String?
    /// The name of the segment definition.
    public var segmentDefinitionName: Swift.String?
    /// The segment criteria associated with this definition.
    public var segmentGroups: CustomerProfilesClientTypes.SegmentGroup?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        segmentDefinitionArn: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil,
        segmentGroups: CustomerProfilesClientTypes.SegmentGroup? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.segmentDefinitionArn = segmentDefinitionArn
        self.segmentDefinitionName = segmentDefinitionName
        self.segmentGroups = segmentGroups
        self.tags = tags
    }
}

extension GetSegmentDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSegmentDefinitionOutput(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), segmentDefinitionArn: \(Swift.String(describing: segmentDefinitionArn)), segmentDefinitionName: \(Swift.String(describing: segmentDefinitionName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", segmentGroups: \"CONTENT_REDACTED\")"}
}

public struct GetSegmentEstimateInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The query Id passed by a previous CreateSegmentEstimate operation.
    /// This member is required.
    public var estimateId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        estimateId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.estimateId = estimateId
    }
}

extension CustomerProfilesClientTypes {

    public enum EstimateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EstimateStatus] {
            return [
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSegmentEstimateOutput: Swift.Sendable {
    /// The unique name of the domain.
    public var domainName: Swift.String?
    /// The estimated number of profiles contained in the segment.
    public var estimate: Swift.String?
    /// The QueryId which is the same as the value passed in QueryId.
    public var estimateId: Swift.String?
    /// The error message if there is any error.
    public var message: Swift.String?
    /// The current status of the query.
    public var status: CustomerProfilesClientTypes.EstimateStatus?
    /// The status code of the segment estimate.
    public var statusCode: Swift.Int

    public init(
        domainName: Swift.String? = nil,
        estimate: Swift.String? = nil,
        estimateId: Swift.String? = nil,
        message: Swift.String? = nil,
        status: CustomerProfilesClientTypes.EstimateStatus? = nil,
        statusCode: Swift.Int = 0
    ) {
        self.domainName = domainName
        self.estimate = estimate
        self.estimateId = estimateId
        self.message = message
        self.status = status
        self.statusCode = statusCode
    }
}

public struct GetSegmentMembershipInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The list of profile IDs to query for.
    /// This member is required.
    public var profileIds: [Swift.String]?
    /// The Id of the wanted segment. Needs to be a valid, and existing segment Id.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        profileIds: [Swift.String]? = nil,
        segmentDefinitionName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.profileIds = profileIds
        self.segmentDefinitionName = segmentDefinitionName
    }
}

extension CustomerProfilesClientTypes {

    /// Object that holds failures for membership.
    public struct ProfileQueryFailures: Swift.Sendable {
        /// A message describing the failure.
        /// This member is required.
        public var message: Swift.String?
        /// The profile id the failure belongs to.
        /// This member is required.
        public var profileId: Swift.String?
        /// The status describing the failure.
        public var status: Swift.Int?

        public init(
            message: Swift.String? = nil,
            profileId: Swift.String? = nil,
            status: Swift.Int? = nil
        ) {
            self.message = message
            self.profileId = profileId
            self.status = status
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum QueryResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absent
        case present
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryResult] {
            return [
                .absent,
                .present
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absent: return "ABSENT"
            case .present: return "PRESENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Object that holds the results for membership.
    public struct ProfileQueryResult: Swift.Sendable {
        /// The standard profile of a customer.
        public var profile: CustomerProfilesClientTypes.Profile?
        /// The profile id the result belongs to.
        /// This member is required.
        public var profileId: Swift.String?
        /// Describes whether the profile was absent or present in the segment.
        /// This member is required.
        public var queryResult: CustomerProfilesClientTypes.QueryResult?

        public init(
            profile: CustomerProfilesClientTypes.Profile? = nil,
            profileId: Swift.String? = nil,
            queryResult: CustomerProfilesClientTypes.QueryResult? = nil
        ) {
            self.profile = profile
            self.profileId = profileId
            self.queryResult = queryResult
        }
    }
}

public struct GetSegmentMembershipOutput: Swift.Sendable {
    /// An array of maps where each contains a response per profile failed for the request.
    public var failures: [CustomerProfilesClientTypes.ProfileQueryFailures]?
    /// An array of maps where each contains a response per profile requested.
    public var profiles: [CustomerProfilesClientTypes.ProfileQueryResult]?
    /// The unique name of the segment definition.
    public var segmentDefinitionName: Swift.String?

    public init(
        failures: [CustomerProfilesClientTypes.ProfileQueryFailures]? = nil,
        profiles: [CustomerProfilesClientTypes.ProfileQueryResult]? = nil,
        segmentDefinitionName: Swift.String? = nil
    ) {
        self.failures = failures
        self.profiles = profiles
        self.segmentDefinitionName = segmentDefinitionName
    }
}

public struct GetSegmentSnapshotInput: Swift.Sendable {
    /// The unique identifier of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique name of the segment definition.
    /// This member is required.
    public var segmentDefinitionName: Swift.String?
    /// The unique identifier of the segment snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        segmentDefinitionName: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.segmentDefinitionName = segmentDefinitionName
        self.snapshotId = snapshotId
    }
}

extension CustomerProfilesClientTypes {

    public enum SegmentSnapshotStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentSnapshotStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSegmentSnapshotOutput: Swift.Sendable {
    /// The format in which the segment will be exported.
    /// This member is required.
    public var dataFormat: CustomerProfilesClientTypes.DataFormat?
    /// The destination to which the segment will be exported. This field must be provided if the request is not submitted from the Amazon Connect Admin Website.
    public var destinationUri: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the exported segment.
    public var encryptionKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that allows Customer Profiles service principal to assume the role for conducting KMS and S3 operations.
    public var roleArn: Swift.String?
    /// The unique identifier of the segment snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?
    /// The status of the asynchronous job for exporting the segment snapshot.
    /// This member is required.
    public var status: CustomerProfilesClientTypes.SegmentSnapshotStatus?
    /// The status message of the asynchronous job for exporting the segment snapshot.
    public var statusMessage: Swift.String?

    public init(
        dataFormat: CustomerProfilesClientTypes.DataFormat? = nil,
        destinationUri: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        status: CustomerProfilesClientTypes.SegmentSnapshotStatus? = nil,
        statusMessage: Swift.String? = nil
    ) {
        self.dataFormat = dataFormat
        self.destinationUri = destinationUri
        self.encryptionKey = encryptionKey
        self.roleArn = roleArn
        self.snapshotId = snapshotId
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension CustomerProfilesClientTypes {

    public enum MatchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mlBasedMatching
        case ruleBasedMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchType] {
            return [
                .mlBasedMatching,
                .ruleBasedMatching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mlBasedMatching: return "ML_BASED_MATCHING"
            case .ruleBasedMatching: return "RULE_BASED_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSimilarProfilesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Specify the type of matching to get similar profiles for.
    /// This member is required.
    public var matchType: CustomerProfilesClientTypes.MatchType?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous GetSimilarProfiles API call.
    public var nextToken: Swift.String?
    /// The string indicating the search key to be used.
    /// This member is required.
    public var searchKey: Swift.String?
    /// The string based on SearchKey to be searched for similar profiles.
    /// This member is required.
    public var searchValue: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        matchType: CustomerProfilesClientTypes.MatchType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchKey: Swift.String? = nil,
        searchValue: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.matchType = matchType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchKey = searchKey
        self.searchValue = searchValue
    }
}

public struct GetSimilarProfilesOutput: Swift.Sendable {
    /// It only has value when the MatchType is ML_BASED_MATCHING.A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used as an absolute measure of matching quality.
    public var confidenceScore: Swift.Double?
    /// The string matchId that the similar profiles belong to.
    public var matchId: Swift.String?
    /// Specify the type of matching to get similar profiles for.
    public var matchType: CustomerProfilesClientTypes.MatchType?
    /// The pagination token from the previous GetSimilarProfiles API call.
    public var nextToken: Swift.String?
    /// Set of profileIds that belong to the same matching group.
    public var profileIds: [Swift.String]?
    /// The integer rule level that the profiles matched on.
    public var ruleLevel: Swift.Int?

    public init(
        confidenceScore: Swift.Double? = nil,
        matchId: Swift.String? = nil,
        matchType: CustomerProfilesClientTypes.MatchType? = nil,
        nextToken: Swift.String? = nil,
        profileIds: [Swift.String]? = nil,
        ruleLevel: Swift.Int? = nil
    ) {
        self.confidenceScore = confidenceScore
        self.matchId = matchId
        self.matchType = matchType
        self.nextToken = nextToken
        self.profileIds = profileIds
        self.ruleLevel = ruleLevel
    }
}

public struct GetUploadJobInput: Swift.Sendable {
    /// The unique name of the domain containing the upload job.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the upload job to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.jobId = jobId
    }
}

extension CustomerProfilesClientTypes {

    /// The summary of results for an upload job, including the number of updated, created, and failed records.
    public struct ResultsSummary: Swift.Sendable {
        /// The number of records that were newly created during the upload job.
        public var createdRecords: Swift.Int?
        /// The number of records that failed to be processed during the upload job.
        public var failedRecords: Swift.Int?
        /// The number of records that were updated during the upload job.
        public var updatedRecords: Swift.Int?

        public init(
            createdRecords: Swift.Int? = nil,
            failedRecords: Swift.Int? = nil,
            updatedRecords: Swift.Int? = nil
        ) {
            self.createdRecords = createdRecords
            self.failedRecords = failedRecords
            self.updatedRecords = updatedRecords
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum UploadJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case inProgress
        case partiallySucceeded
        case stopped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadJobStatus] {
            return [
                .created,
                .failed,
                .inProgress,
                .partiallySucceeded,
                .stopped,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .partiallySucceeded: return "PARTIALLY_SUCCEEDED"
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum StatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalFailure
        case validationFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusReason] {
            return [
                .internalFailure,
                .validationFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .validationFailure: return "VALIDATION_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetUploadJobOutput: Swift.Sendable {
    /// The timestamp when the upload job was completed.
    public var completedAt: Foundation.Date?
    /// The timestamp when the upload job was created.
    public var createdAt: Foundation.Date?
    /// The expiry duration for the profiles ingested with the upload job.
    public var dataExpiry: Swift.Int?
    /// The unique name of the upload job. Could be a file name to identify the upload job.
    public var displayName: Swift.String?
    /// The mapping between CSV Columns and Profile Object attributes for the upload job.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// The unique identifier of the upload job.
    public var jobId: Swift.String?
    /// The summary of results for the upload job, including the number of updated, created, and failed records.
    public var resultsSummary: CustomerProfilesClientTypes.ResultsSummary?
    /// The status describing the status for the upload job. The following are Valid Values:
    ///
    /// * CREATED: The upload job has been created, but has not started processing yet.
    ///
    /// * IN_PROGRESS: The upload job is currently in progress, ingesting and processing the profile data.
    ///
    /// * PARTIALLY_SUCCEEDED: The upload job has successfully completed the ingestion and processing of all profile data.
    ///
    /// * SUCCEEDED: The upload job has successfully completed the ingestion and processing of all profile data.
    ///
    /// * FAILED: The upload job has failed to complete.
    ///
    /// * STOPPED: The upload job has been manually stopped or terminated before completion.
    public var status: CustomerProfilesClientTypes.UploadJobStatus?
    /// The reason for the current status of the upload job. Possible reasons:
    ///
    /// * VALIDATION_FAILURE: The upload job has encountered an error or issue and was unable to complete the profile data ingestion.
    ///
    /// * INTERNAL_FAILURE: Failure caused from service side
    public var statusReason: CustomerProfilesClientTypes.StatusReason?
    /// The unique key columns used for de-duping the keys in the upload job.
    public var uniqueKey: Swift.String?

    public init(
        completedAt: Foundation.Date? = nil,
        createdAt: Foundation.Date? = nil,
        dataExpiry: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        jobId: Swift.String? = nil,
        resultsSummary: CustomerProfilesClientTypes.ResultsSummary? = nil,
        status: CustomerProfilesClientTypes.UploadJobStatus? = nil,
        statusReason: CustomerProfilesClientTypes.StatusReason? = nil,
        uniqueKey: Swift.String? = nil
    ) {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.dataExpiry = dataExpiry
        self.displayName = displayName
        self.fields = fields
        self.jobId = jobId
        self.resultsSummary = resultsSummary
        self.status = status
        self.statusReason = statusReason
        self.uniqueKey = uniqueKey
    }
}

extension GetUploadJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUploadJobOutput(completedAt: \(Swift.String(describing: completedAt)), createdAt: \(Swift.String(describing: createdAt)), dataExpiry: \(Swift.String(describing: dataExpiry)), displayName: \(Swift.String(describing: displayName)), jobId: \(Swift.String(describing: jobId)), resultsSummary: \(Swift.String(describing: resultsSummary)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), uniqueKey: \(Swift.String(describing: uniqueKey)), fields: \"CONTENT_REDACTED\")"}
}

public struct GetUploadJobPathInput: Swift.Sendable {
    /// The unique name of the domain containing the upload job.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the upload job to retrieve the upload path for. This is generated from the CreateUploadJob API.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.jobId = jobId
    }
}

public struct GetUploadJobPathOutput: Swift.Sendable {
    /// The plaintext data key used to encrypt the upload file. To persist to the pre-signed url, use the client token and MD5 client token as header. The required headers are as follows:
    ///
    /// * x-amz-server-side-encryption-customer-key: Client Token
    ///
    /// * x-amz-server-side-encryption-customer-key-MD5: MD5 Client Token
    ///
    /// * x-amz-server-side-encryption-customer-algorithm: AES256
    public var clientToken: Swift.String?
    /// The pre-signed S3 URL for uploading the CSV file associated with the upload job.
    /// This member is required.
    public var url: Swift.String?
    /// The expiry timestamp for the pre-signed URL, after which the URL will no longer be valid.
    public var validUntil: Foundation.Date?

    public init(
        clientToken: Swift.String? = nil,
        url: Swift.String? = nil,
        validUntil: Foundation.Date? = nil
    ) {
        self.clientToken = clientToken
        self.url = url
        self.validUntil = validUntil
    }
}

public struct GetWorkflowInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.workflowId = workflowId
    }
}

extension CustomerProfilesClientTypes {

    /// Structure to hold workflow attributes.
    public struct WorkflowAttributes: Swift.Sendable {
        /// Workflow attributes specific to APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes? = nil
        ) {
            self.appflowIntegration = appflowIntegration
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Generic object containing workflow execution metrics.
    public struct WorkflowMetrics: Swift.Sendable {
        /// Workflow execution metrics for APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics? = nil
        ) {
            self.appflowIntegration = appflowIntegration
        }
    }
}

public struct GetWorkflowOutput: Swift.Sendable {
    /// Attributes provided for workflow execution.
    public var attributes: CustomerProfilesClientTypes.WorkflowAttributes?
    /// Workflow error messages during execution (if any).
    public var errorDescription: Swift.String?
    /// The timestamp that represents when workflow execution last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// Workflow specific execution metrics.
    public var metrics: CustomerProfilesClientTypes.WorkflowMetrics?
    /// The timestamp that represents when workflow execution started.
    public var startDate: Foundation.Date?
    /// Status of workflow execution.
    public var status: CustomerProfilesClientTypes.Status?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        attributes: CustomerProfilesClientTypes.WorkflowAttributes? = nil,
        errorDescription: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        metrics: CustomerProfilesClientTypes.WorkflowMetrics? = nil,
        startDate: Foundation.Date? = nil,
        status: CustomerProfilesClientTypes.Status? = nil,
        workflowId: Swift.String? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    ) {
        self.attributes = attributes
        self.errorDescription = errorDescription
        self.lastUpdatedAt = lastUpdatedAt
        self.metrics = metrics
        self.startDate = startDate
        self.status = status
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

public struct GetWorkflowStepsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

extension CustomerProfilesClientTypes {

    /// List containing steps in workflow.
    public struct WorkflowStepItem: Swift.Sendable {
        /// Workflow step information specific to APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep? = nil
        ) {
            self.appflowIntegration = appflowIntegration
        }
    }
}

public struct GetWorkflowStepsOutput: Swift.Sendable {
    /// List containing workflow step details.
    public var items: [CustomerProfilesClientTypes.WorkflowStepItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        items: [CustomerProfilesClientTypes.WorkflowStepItem]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

public struct ListAccountIntegrationsInput: Swift.Sendable {
    /// Boolean to indicate if hidden integration should be returned. Defaults to False.
    public var includeHidden: Swift.Bool?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListAccountIntegrations API call.
    public var nextToken: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        includeHidden: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        uri: Swift.String? = nil
    ) {
        self.includeHidden = includeHidden
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.uri = uri
    }
}

extension CustomerProfilesClientTypes {

    /// An integration in list of integrations.
    public struct ListIntegrationItem: Swift.Sendable {
        /// The timestamp of when the domain was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// A list of unique names for active event triggers associated with the integration.
        public var eventTriggerNames: [Swift.String]?
        /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
        public var isUnstructured: Swift.Bool?
        /// The timestamp of when the domain was most recently edited.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the profile object type.
        public var objectTypeName: Swift.String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public var objectTypeNames: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
        public var roleArn: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The URI of the S3 bucket or any other type of data source.
        /// This member is required.
        public var uri: Swift.String?
        /// Unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            eventTriggerNames: [Swift.String]? = nil,
            isUnstructured: Swift.Bool? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            objectTypeName: Swift.String? = nil,
            objectTypeNames: [Swift.String: Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            uri: Swift.String? = nil,
            workflowId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.eventTriggerNames = eventTriggerNames
            self.isUnstructured = isUnstructured
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.roleArn = roleArn
            self.tags = tags
            self.uri = uri
            self.workflowId = workflowId
        }
    }
}

public struct ListAccountIntegrationsOutput: Swift.Sendable {
    /// The list of ListAccountIntegration instances.
    public var items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    /// The pagination token from the previous ListAccountIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListIntegrationItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListCalculatedAttributeDefinitionsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of calculated attribute definitions returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCalculatedAttributeDefinitionsOutput: Swift.Sendable {
    /// The list of calculated attribute definitions.
    public var items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]?
    /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension ListCalculatedAttributeDefinitionsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCalculatedAttributeDefinitionsOutput(nextToken: \(Swift.String(describing: nextToken)), items: \"CONTENT_REDACTED\")"}
}

public struct ListCalculatedAttributesForProfileInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of calculated attributes returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
    public var nextToken: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
    }
}

public struct ListCalculatedAttributesForProfileOutput: Swift.Sendable {
    /// The list of calculated attributes.
    public var items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]?
    /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListDomainLayoutsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// The layout object that contains LayoutDefinitionName, Description, DisplayName, IsDefault, LayoutType, Tags, CreatedAt, LastUpdatedAt
    public struct LayoutItem: Swift.Sendable {
        /// The timestamp of when the layout was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the layout
        /// This member is required.
        public var description: Swift.String?
        /// The display name of the layout
        /// This member is required.
        public var displayName: Swift.String?
        /// If set to true for a layout, this layout will be used by default to view data. If set to false, then layout will not be used by default but it can be used to view data by explicit selection on UI.
        public var isDefault: Swift.Bool
        /// The timestamp of when the layout was most recently updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The unique name of the layout.
        /// This member is required.
        public var layoutDefinitionName: Swift.String?
        /// The type of layout that can be used to view data under customer profiles domain.
        /// This member is required.
        public var layoutType: CustomerProfilesClientTypes.LayoutType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            lastUpdatedAt: Foundation.Date? = nil,
            layoutDefinitionName: Swift.String? = nil,
            layoutType: CustomerProfilesClientTypes.LayoutType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.layoutDefinitionName = layoutDefinitionName
            self.layoutType = layoutType
            self.tags = tags
        }
    }
}

extension CustomerProfilesClientTypes.LayoutItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayoutItem(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), isDefault: \(Swift.String(describing: isDefault)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), layoutDefinitionName: \(Swift.String(describing: layoutDefinitionName)), layoutType: \(Swift.String(describing: layoutType)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct ListDomainLayoutsOutput: Swift.Sendable {
    /// Contains summary information about an EventStream.
    public var items: [CustomerProfilesClientTypes.LayoutItem]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.LayoutItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListDomainsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListDomain API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// An object in a list that represents a domain.
    public struct ListDomainItem: Swift.Sendable {
        /// The timestamp of when the domain was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The timestamp of when the domain was most recently edited.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }
    }
}

public struct ListDomainsOutput: Swift.Sendable {
    /// The list of ListDomains instances.
    public var items: [CustomerProfilesClientTypes.ListDomainItem]?
    /// The pagination token from the previous ListDomains API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListDomainItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEventStreamsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// Summary information about the Kinesis data stream
    public struct DestinationSummary: Swift.Sendable {
        /// The status of enabling the Kinesis stream as a destination for export.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.EventStreamDestinationStatus?
        /// The timestamp when the status last changed to UNHEALHY.
        public var unhealthySince: Foundation.Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            status: CustomerProfilesClientTypes.EventStreamDestinationStatus? = nil,
            unhealthySince: Foundation.Date? = nil,
            uri: Swift.String? = nil
        ) {
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }
    }
}

extension CustomerProfilesClientTypes {

    /// An instance of EventStream in a list of EventStreams.
    public struct EventStreamSummary: Swift.Sendable {
        /// Summary information about the Kinesis data stream.
        public var destinationSummary: CustomerProfilesClientTypes.DestinationSummary?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the event stream.
        /// This member is required.
        public var eventStreamArn: Swift.String?
        /// The name of the event stream.
        /// This member is required.
        public var eventStreamName: Swift.String?
        /// The operational state of destination stream for export.
        /// This member is required.
        public var state: CustomerProfilesClientTypes.EventStreamState?
        /// The timestamp when the State changed to STOPPED.
        public var stoppedSince: Foundation.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            destinationSummary: CustomerProfilesClientTypes.DestinationSummary? = nil,
            domainName: Swift.String? = nil,
            eventStreamArn: Swift.String? = nil,
            eventStreamName: Swift.String? = nil,
            state: CustomerProfilesClientTypes.EventStreamState? = nil,
            stoppedSince: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.destinationSummary = destinationSummary
            self.domainName = domainName
            self.eventStreamArn = eventStreamArn
            self.eventStreamName = eventStreamName
            self.state = state
            self.stoppedSince = stoppedSince
            self.tags = tags
        }
    }
}

public struct ListEventStreamsOutput: Swift.Sendable {
    /// Contains summary information about an EventStream.
    public var items: [CustomerProfilesClientTypes.EventStreamSummary]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.EventStreamSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEventTriggersInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The pagination token to use with ListEventTriggers.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// The summary of the event trigger.
    public struct EventTriggerSummaryItem: Swift.Sendable {
        /// The timestamp of when the event trigger was created.
        public var createdAt: Foundation.Date?
        /// The description of the event trigger.
        public var description: Swift.String?
        /// The unique name of the event trigger.
        public var eventTriggerName: Swift.String?
        /// The timestamp of when the event trigger was most recently updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The unique name of the object type.
        public var objectTypeName: Swift.String?
        /// An array of key-value pairs to apply to this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            eventTriggerName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            objectTypeName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.eventTriggerName = eventTriggerName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
        }
    }
}

public struct ListEventTriggersOutput: Swift.Sendable {
    /// The list of Event Triggers.
    public var items: [CustomerProfilesClientTypes.EventTriggerSummaryItem]?
    /// The pagination token from the previous call to ListEventTriggers.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.EventTriggerSummaryItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension ListEventTriggersOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventTriggersOutput(nextToken: \(Swift.String(describing: nextToken)), items: \"CONTENT_REDACTED\")"}
}

public struct ListIdentityResolutionJobsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// Information about the Identity Resolution Job.
    public struct IdentityResolutionJob: Swift.Sendable {
        /// The unique name of the domain.
        public var domainName: Swift.String?
        /// The S3 location where the Identity Resolution Job writes result files.
        public var exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
        /// The timestamp of when the job was completed.
        public var jobEndTime: Foundation.Date?
        /// The unique identifier of the Identity Resolution Job.
        public var jobId: Swift.String?
        /// The timestamp of when the job was started or will be started.
        public var jobStartTime: Foundation.Date?
        /// Statistics about an Identity Resolution Job.
        public var jobStats: CustomerProfilesClientTypes.JobStats?
        /// The error messages that are generated when the Identity Resolution Job runs.
        public var message: Swift.String?
        /// The status of the Identity Resolution Job.
        ///
        /// * PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.
        ///
        /// * PREPROCESSING: The Identity Resolution Job is loading your data.
        ///
        /// * FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.
        ///
        /// * MERGING: The Identity Resolution Job is merging duplicate profiles.
        ///
        /// * COMPLETED: The Identity Resolution Job completed successfully.
        ///
        /// * PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.
        ///
        /// * FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
        public var status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?

        public init(
            domainName: Swift.String? = nil,
            exportingLocation: CustomerProfilesClientTypes.ExportingLocation? = nil,
            jobEndTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobStartTime: Foundation.Date? = nil,
            jobStats: CustomerProfilesClientTypes.JobStats? = nil,
            message: Swift.String? = nil,
            status: CustomerProfilesClientTypes.IdentityResolutionJobStatus? = nil
        ) {
            self.domainName = domainName
            self.exportingLocation = exportingLocation
            self.jobEndTime = jobEndTime
            self.jobId = jobId
            self.jobStartTime = jobStartTime
            self.jobStats = jobStats
            self.message = message
            self.status = status
        }
    }
}

public struct ListIdentityResolutionJobsOutput: Swift.Sendable {
    /// A list of Identity Resolution Jobs.
    public var identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.identityResolutionJobsList = identityResolutionJobsList
        self.nextToken = nextToken
    }
}

public struct ListIntegrationsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean to indicate if hidden integration should be returned. Defaults to False.
    public var includeHidden: Swift.Bool?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        includeHidden: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.includeHidden = includeHidden
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIntegrationsOutput: Swift.Sendable {
    /// The list of ListIntegrations instances.
    public var items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    /// The pagination token from the previous ListIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListIntegrationItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListObjectTypeAttributesInput: Swift.Sendable {
    /// The unique identifier of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call.
    public var nextToken: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectTypeName = objectTypeName
    }
}

extension CustomerProfilesClientTypes {

    /// Item that contains the attribute and when it was last updated.
    public struct ListObjectTypeAttributeItem: Swift.Sendable {
        /// Name of the attribute.
        /// This member is required.
        public var attributeName: Swift.String?
        /// When the attribute was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?

        public init(
            attributeName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil
        ) {
            self.attributeName = attributeName
            self.lastUpdatedAt = lastUpdatedAt
        }
    }
}

public struct ListObjectTypeAttributesOutput: Swift.Sendable {
    /// The items returned as part of the response.
    public var items: [CustomerProfilesClientTypes.ListObjectTypeAttributeItem]?
    /// The pagination token from the previous call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListObjectTypeAttributeItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListProfileAttributeValuesInput: Swift.Sendable {
    /// The attribute name.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The unique identifier of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    ) {
        self.attributeName = attributeName
        self.domainName = domainName
    }
}

public struct ListProfileAttributeValuesOutput: Swift.Sendable {
    /// The attribute name.
    public var attributeName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The items returned as part of the response.
    public var items: [CustomerProfilesClientTypes.AttributeValueItem]?
    /// The status code for the response.
    public var statusCode: Swift.Int

    public init(
        attributeName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        items: [CustomerProfilesClientTypes.AttributeValueItem]? = nil,
        statusCode: Swift.Int = 0
    ) {
        self.attributeName = attributeName
        self.domainName = domainName
        self.items = items
        self.statusCode = statusCode
    }
}

extension CustomerProfilesClientTypes {

    /// The filter applied to ListProfileObjects response to include profile objects with the specified index values.
    public struct ObjectFilter: Swift.Sendable {
        /// A searchable identifier of a profile object. The predefined keys you can use to search for _asset include: _assetId, _assetName, and _serialNumber. The predefined keys you can use to search for _case include: _caseId. The predefined keys you can use to search for _order include: _orderId.
        /// This member is required.
        public var keyName: Swift.String?
        /// A list of key values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.keyName = keyName
            self.values = values
        }
    }
}

public struct ListProfileObjectsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListProfileObjects.
    public var nextToken: Swift.String?
    /// Applies a filter to the response to include profile objects with the specified index values.
    public var objectFilter: CustomerProfilesClientTypes.ObjectFilter?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectFilter: CustomerProfilesClientTypes.ObjectFilter? = nil,
        objectTypeName: Swift.String? = nil,
        profileId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectFilter = objectFilter
        self.objectTypeName = objectTypeName
        self.profileId = profileId
    }
}

extension CustomerProfilesClientTypes {

    /// A ProfileObject in a list of ProfileObjects.
    public struct ListProfileObjectsItem: Swift.Sendable {
        /// A JSON representation of a ProfileObject that belongs to a profile.
        public var object: Swift.String?
        /// Specifies the kind of object being added to a profile, such as "Salesforce-Account."
        public var objectTypeName: Swift.String?
        /// The unique identifier of the ProfileObject generated by the service.
        public var profileObjectUniqueKey: Swift.String?

        public init(
            object: Swift.String? = nil,
            objectTypeName: Swift.String? = nil,
            profileObjectUniqueKey: Swift.String? = nil
        ) {
            self.object = object
            self.objectTypeName = objectTypeName
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectsItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileObjectsItem(objectTypeName: \(Swift.String(describing: objectTypeName)), profileObjectUniqueKey: \(Swift.String(describing: profileObjectUniqueKey)), object: \"CONTENT_REDACTED\")"}
}

public struct ListProfileObjectsOutput: Swift.Sendable {
    /// The list of ListProfileObject instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectsItem]?
    /// The pagination token from the previous call to ListProfileObjects.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectsItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListProfileObjectTypesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// A ProfileObjectType instance.
    public struct ListProfileObjectTypeItem: Swift.Sendable {
        /// The timestamp of when the domain was created.
        public var createdAt: Foundation.Date?
        /// Description of the profile object type.
        /// This member is required.
        public var description: Swift.String?
        /// The timestamp of when the domain was most recently edited.
        public var lastUpdatedAt: Foundation.Date?
        /// The amount of provisioned profile object max count available.
        public var maxAvailableProfileObjectCount: Swift.Int?
        /// The amount of profile object max count assigned to the object type.
        public var maxProfileObjectCount: Swift.Int?
        /// The name of the profile object type.
        /// This member is required.
        public var objectTypeName: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            maxAvailableProfileObjectCount: Swift.Int? = nil,
            maxProfileObjectCount: Swift.Int? = nil,
            objectTypeName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
            self.maxProfileObjectCount = maxProfileObjectCount
            self.objectTypeName = objectTypeName
            self.tags = tags
        }
    }
}

public struct ListProfileObjectTypesOutput: Swift.Sendable {
    /// The list of ListProfileObjectTypes instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension ListProfileObjectTypesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileObjectTypesOutput(nextToken: \(Swift.String(describing: nextToken)), items: \"CONTENT_REDACTED\")"}
}

public struct ListProfileObjectTypeTemplatesInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListObjectTypeTemplates API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// A ProfileObjectTypeTemplate in a list of ProfileObjectTypeTemplates.
    public struct ListProfileObjectTypeTemplateItem: Swift.Sendable {
        /// The name of the source of the object template.
        public var sourceName: Swift.String?
        /// The source of the object template.
        public var sourceObject: Swift.String?
        /// A unique identifier for the object template.
        public var templateId: Swift.String?

        public init(
            sourceName: Swift.String? = nil,
            sourceObject: Swift.String? = nil,
            templateId: Swift.String? = nil
        ) {
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }
    }
}

public struct ListProfileObjectTypeTemplatesOutput: Swift.Sendable {
    /// The list of ListProfileObjectType template instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]?
    /// The pagination token from the previous ListObjectTypeTemplates API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListRuleBasedMatchesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of MatchIds returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListRuleBasedMatches API call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRuleBasedMatchesOutput: Swift.Sendable {
    /// The list of MatchIds for the given domain.
    public var matchIds: [Swift.String]?
    /// The pagination token from the previous ListRuleBasedMatches API call.
    public var nextToken: Swift.String?

    public init(
        matchIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.matchIds = matchIds
        self.nextToken = nextToken
    }
}

public struct ListSegmentDefinitionsInput: Swift.Sendable {
    /// The unique identifier of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// Object holding the segment definition fields.
    public struct SegmentDefinitionItem: Swift.Sendable {
        /// When the segment definition was created.
        public var createdAt: Foundation.Date?
        /// The description of the segment definition.
        public var description: Swift.String?
        /// Display name of the segment definition.
        public var displayName: Swift.String?
        /// The arn of the segment definition.
        public var segmentDefinitionArn: Swift.String?
        /// Name of the segment definition.
        public var segmentDefinitionName: Swift.String?
        /// The tags belonging to the segment definition.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            segmentDefinitionArn: Swift.String? = nil,
            segmentDefinitionName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.segmentDefinitionArn = segmentDefinitionArn
            self.segmentDefinitionName = segmentDefinitionName
            self.tags = tags
        }
    }
}

extension CustomerProfilesClientTypes.SegmentDefinitionItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SegmentDefinitionItem(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), segmentDefinitionArn: \(Swift.String(describing: segmentDefinitionArn)), segmentDefinitionName: \(Swift.String(describing: segmentDefinitionName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct ListSegmentDefinitionsOutput: Swift.Sendable {
    /// List of segment definitions.
    public var items: [CustomerProfilesClientTypes.SegmentDefinitionItem]?
    /// The pagination token from the previous call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.SegmentDefinitionItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct ListUploadJobsInput: Swift.Sendable {
    /// The unique name of the domain to list upload jobs for.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of upload jobs to return per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// The summary information for an individual upload job.
    public struct UploadJobItem: Swift.Sendable {
        /// The timestamp when the upload job was completed.
        public var completedAt: Foundation.Date?
        /// The timestamp when the upload job was created.
        public var createdAt: Foundation.Date?
        /// The expiry duration for the profiles ingested with the upload job.
        public var dataExpiry: Swift.Int?
        /// The name of the upload job.
        public var displayName: Swift.String?
        /// The unique identifier of the upload job.
        public var jobId: Swift.String?
        /// The current status of the upload job.
        public var status: CustomerProfilesClientTypes.UploadJobStatus?
        /// The reason for the current status of the upload job.
        public var statusReason: CustomerProfilesClientTypes.StatusReason?

        public init(
            completedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            dataExpiry: Swift.Int? = nil,
            displayName: Swift.String? = nil,
            jobId: Swift.String? = nil,
            status: CustomerProfilesClientTypes.UploadJobStatus? = nil,
            statusReason: CustomerProfilesClientTypes.StatusReason? = nil
        ) {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.dataExpiry = dataExpiry
            self.displayName = displayName
            self.jobId = jobId
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListUploadJobsOutput: Swift.Sendable {
    /// The list of upload jobs for the specified domain.
    public var items: [CustomerProfilesClientTypes.UploadJobItem]?
    /// The pagination token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.UploadJobItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListWorkflowsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Retrieve workflows ended after timestamp.
    public var queryEndDate: Foundation.Date?
    /// Retrieve workflows started after timestamp.
    public var queryStartDate: Foundation.Date?
    /// Status of workflow execution.
    public var status: CustomerProfilesClientTypes.Status?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryEndDate: Foundation.Date? = nil,
        queryStartDate: Foundation.Date? = nil,
        status: CustomerProfilesClientTypes.Status? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryEndDate = queryEndDate
        self.queryStartDate = queryStartDate
        self.status = status
        self.workflowType = workflowType
    }
}

extension CustomerProfilesClientTypes {

    /// A workflow in list of workflows.
    public struct ListWorkflowsItem: Swift.Sendable {
        /// Creation timestamp for workflow.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Last updated timestamp for workflow.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// Status of workflow execution.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.Status?
        /// Description for workflow execution status.
        /// This member is required.
        public var statusDescription: Swift.String?
        /// Unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        /// This member is required.
        public var workflowType: CustomerProfilesClientTypes.WorkflowType?

        public init(
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: CustomerProfilesClientTypes.Status? = nil,
            statusDescription: Swift.String? = nil,
            workflowId: Swift.String? = nil,
            workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
        ) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusDescription = statusDescription
            self.workflowId = workflowId
            self.workflowType = workflowType
        }
    }
}

public struct ListWorkflowsOutput: Swift.Sendable {
    /// List containing workflow details.
    public var items: [CustomerProfilesClientTypes.ListWorkflowsItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListWorkflowsItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// A duplicate customer profile that is to be merged into a main profile.
    public struct FieldSourceProfileIds: Swift.Sendable {
        /// A unique identifier for the account number field to be merged.
        public var accountNumber: Swift.String?
        /// A unique identifier for the additional information field to be merged.
        public var additionalInformation: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var address: Swift.String?
        /// A unique identifier for the attributes field to be merged.
        public var attributes: [Swift.String: Swift.String]?
        /// A unique identifier for the billing type field to be merged.
        public var billingAddress: Swift.String?
        /// A unique identifier for the birthdate field to be merged.
        public var birthDate: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var businessEmailAddress: Swift.String?
        /// A unique identifier for the business name field to be merged.
        public var businessName: Swift.String?
        /// A unique identifier for the business phone number field to be merged.
        public var businessPhoneNumber: Swift.String?
        /// A unique identifier for the email address field to be merged.
        public var emailAddress: Swift.String?
        /// A unique identifier for the engagement preferences field to be merged.
        public var engagementPreferences: Swift.String?
        /// A unique identifier for the first name field to be merged.
        public var firstName: Swift.String?
        /// A unique identifier for the gender field to be merged.
        public var gender: Swift.String?
        /// A unique identifier for the home phone number field to be merged.
        public var homePhoneNumber: Swift.String?
        /// A unique identifier for the last name field to be merged.
        public var lastName: Swift.String?
        /// A unique identifier for the mailing address field to be merged.
        public var mailingAddress: Swift.String?
        /// A unique identifier for the middle name field to be merged.
        public var middleName: Swift.String?
        /// A unique identifier for the mobile phone number field to be merged.
        public var mobilePhoneNumber: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var partyType: Swift.String?
        /// A unique identifier for the personal email address field to be merged.
        public var personalEmailAddress: Swift.String?
        /// A unique identifier for the phone number field to be merged.
        public var phoneNumber: Swift.String?
        /// A unique identifier for the profile type field to be merged.
        public var profileType: Swift.String?
        /// A unique identifier for the shipping address field to be merged.
        public var shippingAddress: Swift.String?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            billingAddress: Swift.String? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            engagementPreferences: Swift.String? = nil,
            firstName: Swift.String? = nil,
            gender: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress: Swift.String? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: Swift.String? = nil,
            personalEmailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            profileType: Swift.String? = nil,
            shippingAddress: Swift.String? = nil
        ) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.engagementPreferences = engagementPreferences
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileType = profileType
            self.shippingAddress = shippingAddress
        }
    }
}

public struct MergeProfilesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The identifiers of the fields in the profile that has the information you want to apply to the merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the identifier of the EmailAddress field in Profile1.
    public var fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds?
    /// The identifier of the profile to be taken.
    /// This member is required.
    public var mainProfileId: Swift.String?
    /// The identifier of the profile to be merged into MainProfileId.
    /// This member is required.
    public var profileIdsToBeMerged: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds? = nil,
        mainProfileId: Swift.String? = nil,
        profileIdsToBeMerged: [Swift.String]? = nil
    ) {
        self.domainName = domainName
        self.fieldSourceProfileIds = fieldSourceProfileIds
        self.mainProfileId = mainProfileId
        self.profileIdsToBeMerged = profileIdsToBeMerged
    }
}

public struct MergeProfilesOutput: Swift.Sendable {
    /// A message that indicates the merge request is complete.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.message = message
    }
}

public struct PutIntegrationInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of unique names for active event triggers associated with the integration.
    public var eventTriggerNames: [Swift.String]?
    /// The configuration that controls how Customer Profiles retrieves data from the source.
    public var flowDefinition: CustomerProfilesClientTypes.FlowDefinition?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventTriggerNames: [Swift.String]? = nil,
        flowDefinition: CustomerProfilesClientTypes.FlowDefinition? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String: Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.eventTriggerNames = eventTriggerNames
        self.flowDefinition = flowDefinition
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.roleArn = roleArn
        self.tags = tags
        self.uri = uri
    }
}

extension PutIntegrationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutIntegrationInput(domainName: \(Swift.String(describing: domainName)), eventTriggerNames: \(Swift.String(describing: eventTriggerNames)), objectTypeName: \(Swift.String(describing: objectTypeName)), objectTypeNames: \(Swift.String(describing: objectTypeNames)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), uri: \(Swift.String(describing: uri)), flowDefinition: \"CONTENT_REDACTED\")"}
}

public struct PutIntegrationOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of unique names for active event triggers associated with the integration. This list would be empty if no Event Trigger is associated with the integration.
    public var eventTriggerNames: [Swift.String]?
    /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
    public var isUnstructured: Swift.Bool?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        domainName: Swift.String? = nil,
        eventTriggerNames: [Swift.String]? = nil,
        isUnstructured: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String: Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil,
        workflowId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.domainName = domainName
        self.eventTriggerNames = eventTriggerNames
        self.isUnstructured = isUnstructured
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.roleArn = roleArn
        self.tags = tags
        self.uri = uri
        self.workflowId = workflowId
    }
}

public struct PutProfileObjectInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A string that is serialized from a JSON object.
    /// This member is required.
    public var object: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        object: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.object = object
        self.objectTypeName = objectTypeName
    }
}

extension PutProfileObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectInput(domainName: \(Swift.String(describing: domainName)), objectTypeName: \(Swift.String(describing: objectTypeName)), object: \"CONTENT_REDACTED\")"}
}

public struct PutProfileObjectOutput: Swift.Sendable {
    /// The unique identifier of the profile object generated by the service.
    public var profileObjectUniqueKey: Swift.String?

    public init(
        profileObjectUniqueKey: Swift.String? = nil
    ) {
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

public struct PutProfileObjectTypeInput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool?
    /// Description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The amount of profile object max count assigned to the object type
    public var maxProfileObjectCount: Swift.Int?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the object template. For some attributes in the request, the service will use the default value from the object template when TemplateId is present. If these attributes are present in the request, the service may return a BadRequestException. These attributes include: AllowProfileCreation, SourceLastUpdatedTimestampFormat, Fields, and Keys. For example, if AllowProfileCreation is set to true when TemplateId is set, the service may return a BadRequestException.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool? = false,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        maxProfileObjectCount: Swift.Int? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateId: Swift.String? = nil
    ) {
        self.allowProfileCreation = allowProfileCreation
        self.description = description
        self.domainName = domainName
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.maxProfileObjectCount = maxProfileObjectCount
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

extension PutProfileObjectTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectTypeInput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), domainName: \(Swift.String(describing: domainName)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), maxProfileObjectCount: \(Swift.String(describing: maxProfileObjectCount)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct PutProfileObjectTypeOutput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// The timestamp of when the domain was created.
    public var createdAt: Foundation.Date?
    /// Description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The timestamp of when the domain was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The amount of provisioned profile object max count available.
    public var maxAvailableProfileObjectCount: Swift.Int?
    /// The amount of profile object max count assigned to the object type.
    public var maxProfileObjectCount: Swift.Int?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up in fields that were parsed using [SimpleDateFormat](https://docs.oracle.com/javase/10/docs/api/java/text/SimpleDateFormat.html). If you have sourceLastUpdatedTimestamp in your field, you must set up sourceLastUpdatedTimestampFormat.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        maxAvailableProfileObjectCount: Swift.Int? = nil,
        maxProfileObjectCount: Swift.Int? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateId: Swift.String? = nil
    ) {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
        self.maxProfileObjectCount = maxProfileObjectCount
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

extension PutProfileObjectTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectTypeOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), maxAvailableProfileObjectCount: \(Swift.String(describing: maxAvailableProfileObjectCount)), maxProfileObjectCount: \(Swift.String(describing: maxProfileObjectCount)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    public enum LogicalOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .or
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchProfilesInput: Swift.Sendable {
    /// A list of AdditionalSearchKey objects that are each searchable identifiers of a profile. Each AdditionalSearchKey object contains a KeyName and a list of Values associated with that specific key (i.e., a key-value(s) pair). These additional search keys will be used in conjunction with the LogicalOperator and the required KeyName and Values parameters to search for profiles that satisfy the search criteria.
    public var additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
    /// This member is required.
    public var keyName: Swift.String?
    /// Relationship between all specified search keys that will be used to search for profiles. This includes the required KeyName and Values parameters as well as any key-value(s) pairs specified in the AdditionalSearchKeys list. This parameter influences which profiles will be returned in the response in the following manner:
    ///
    /// * AND - The response only includes profiles that match all of the search keys.
    ///
    /// * OR - The response includes profiles that match at least one of the search keys.
    ///
    ///
    /// The OR relationship is the default behavior if this parameter is not included in the request.
    public var logicalOperator: CustomerProfilesClientTypes.LogicalOperator?
    /// The maximum number of objects returned per page. The default is 20 if this parameter is not included in the request.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous SearchProfiles API call.
    public var nextToken: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]? = nil,
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        logicalOperator: CustomerProfilesClientTypes.LogicalOperator? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        values: [Swift.String]? = nil
    ) {
        self.additionalSearchKeys = additionalSearchKeys
        self.domainName = domainName
        self.keyName = keyName
        self.logicalOperator = logicalOperator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

public struct SearchProfilesOutput: Swift.Sendable {
    /// The list of Profiles matching the search criteria.
    public var items: [CustomerProfilesClientTypes.Profile]?
    /// The pagination token from the previous SearchProfiles API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.Profile]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartUploadJobInput: Swift.Sendable {
    /// The unique name of the domain containing the upload job to start.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the upload job to start.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.jobId = jobId
    }
}

public struct StartUploadJobOutput: Swift.Sendable {

    public init() { }
}

public struct StopUploadJobInput: Swift.Sendable {
    /// The unique name of the domain containing the upload job to stop.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the upload job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.jobId = jobId
    }
}

public struct StopUploadJobOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil
    ) {
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
    }
}

extension UpdateCalculatedAttributeDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCalculatedAttributeDefinitionInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

public struct UpdateCalculatedAttributeDefinitionOutput: Swift.Sendable {
    /// The mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// Information indicating if the Calculated Attribute is ready for use by confirming all historical data has been processed and reflected.
    public var readiness: CustomerProfilesClientTypes.Readiness?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// Status of the Calculated Attribute creation (whether all historical data has been indexed.)
    public var status: CustomerProfilesClientTypes.ReadinessStatus?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// Whether historical data ingested before the Calculated Attribute was created should be included in calculations.
    public var useHistoricalData: Swift.Bool?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        readiness: CustomerProfilesClientTypes.Readiness? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        status: CustomerProfilesClientTypes.ReadinessStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        useHistoricalData: Swift.Bool? = nil
    ) {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.readiness = readiness
        self.statistic = statistic
        self.status = status
        self.tags = tags
        self.useHistoricalData = useHistoricalData
    }
}

extension UpdateCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), readiness: \(Swift.String(describing: readiness)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), useHistoricalData: \(Swift.String(describing: useHistoricalData)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

public struct UpdateDomainInput: Swift.Sendable {
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. If specified as an empty string, it will clear any existing value. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage. If specified as an empty string, it will clear any existing value.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingRequest?
    /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        matching: CustomerProfilesClientTypes.MatchingRequest? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

public struct UpdateDomainOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

public struct UpdateDomainLayoutInput: Swift.Sendable {
    /// The description of the layout
    public var description: Swift.String?
    /// The display name of the layout
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// If set to true for a layout, this layout will be used by default to view data. If set to false, then the layout will not be used by default, but it can be used to view data by explicitly selecting it in the console.
    public var isDefault: Swift.Bool?
    /// A customizable layout that can be used to view data under a Customer Profiles domain.
    public var layout: Swift.String?
    /// The unique name of the layout.
    /// This member is required.
    public var layoutDefinitionName: Swift.String?
    /// The type of layout that can be used to view data under a Customer Profiles domain.
    public var layoutType: CustomerProfilesClientTypes.LayoutType?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        isDefault: Swift.Bool? = false,
        layout: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil,
        layoutType: CustomerProfilesClientTypes.LayoutType? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
        self.isDefault = isDefault
        self.layout = layout
        self.layoutDefinitionName = layoutDefinitionName
        self.layoutType = layoutType
    }
}

extension UpdateDomainLayoutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainLayoutInput(displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), isDefault: \(Swift.String(describing: isDefault)), layoutDefinitionName: \(Swift.String(describing: layoutDefinitionName)), layoutType: \(Swift.String(describing: layoutType)), description: \"CONTENT_REDACTED\", layout: \"CONTENT_REDACTED\")"}
}

public struct UpdateDomainLayoutOutput: Swift.Sendable {
    /// The timestamp of when the layout was created.
    public var createdAt: Foundation.Date?
    /// The description of the layout
    public var description: Swift.String?
    /// The display name of the layout
    public var displayName: Swift.String?
    /// If set to true for a layout, this layout will be used by default to view data. If set to false, then the layout will not be used by default, but it can be used to view data by explicitly selecting it in the console.
    public var isDefault: Swift.Bool
    /// The timestamp of when the layout was most recently updated.
    public var lastUpdatedAt: Foundation.Date?
    /// A customizable layout that can be used to view data under a Customer Profiles domain.
    public var layout: Swift.String?
    /// The unique name of the layout.
    public var layoutDefinitionName: Swift.String?
    /// The type of layout that can be used to view data under a Customer Profiles domain.
    public var layoutType: CustomerProfilesClientTypes.LayoutType?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The version used to create layout.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isDefault: Swift.Bool = false,
        lastUpdatedAt: Foundation.Date? = nil,
        layout: Swift.String? = nil,
        layoutDefinitionName: Swift.String? = nil,
        layoutType: CustomerProfilesClientTypes.LayoutType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.layout = layout
        self.layoutDefinitionName = layoutDefinitionName
        self.layoutType = layoutType
        self.tags = tags
        self.version = version
    }
}

extension UpdateDomainLayoutOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainLayoutOutput(createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), isDefault: \(Swift.String(describing: isDefault)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), layoutDefinitionName: \(Swift.String(describing: layoutDefinitionName)), layoutType: \(Swift.String(describing: layoutType)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", layout: \"CONTENT_REDACTED\")"}
}

public struct UpdateEventTriggerInput: Swift.Sendable {
    /// The description of the event trigger.
    public var description: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of conditions that determine when an event should trigger the destination.
    public var eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]?
    /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
    public var eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits?
    /// The unique name of the event trigger.
    /// This member is required.
    public var eventTriggerName: Swift.String?
    /// The unique name of the object type.
    public var objectTypeName: Swift.String?
    /// The destination is triggered only for profiles that meet the criteria of a segment definition.
    public var segmentFilter: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]? = nil,
        eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits? = nil,
        eventTriggerName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil,
        segmentFilter: Swift.String? = nil
    ) {
        self.description = description
        self.domainName = domainName
        self.eventTriggerConditions = eventTriggerConditions
        self.eventTriggerLimits = eventTriggerLimits
        self.eventTriggerName = eventTriggerName
        self.objectTypeName = objectTypeName
        self.segmentFilter = segmentFilter
    }
}

extension UpdateEventTriggerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEventTriggerInput(domainName: \(Swift.String(describing: domainName)), eventTriggerLimits: \(Swift.String(describing: eventTriggerLimits)), eventTriggerName: \(Swift.String(describing: eventTriggerName)), objectTypeName: \(Swift.String(describing: objectTypeName)), segmentFilter: \(Swift.String(describing: segmentFilter)), description: \"CONTENT_REDACTED\", eventTriggerConditions: \"CONTENT_REDACTED\")"}
}

public struct UpdateEventTriggerOutput: Swift.Sendable {
    /// The timestamp of when the event trigger was created.
    public var createdAt: Foundation.Date?
    /// The description of the event trigger.
    public var description: Swift.String?
    /// A list of conditions that determine when an event should trigger the destination.
    public var eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]?
    /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
    public var eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits?
    /// The unique name of the event trigger.
    public var eventTriggerName: Swift.String?
    /// The timestamp of when the event trigger was most recently updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The unique name of the object type.
    public var objectTypeName: Swift.String?
    /// The destination is triggered only for profiles that meet the criteria of a segment definition.
    public var segmentFilter: Swift.String?
    /// An array of key-value pairs to apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        eventTriggerConditions: [CustomerProfilesClientTypes.EventTriggerCondition]? = nil,
        eventTriggerLimits: CustomerProfilesClientTypes.EventTriggerLimits? = nil,
        eventTriggerName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        segmentFilter: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.eventTriggerConditions = eventTriggerConditions
        self.eventTriggerLimits = eventTriggerLimits
        self.eventTriggerName = eventTriggerName
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.segmentFilter = segmentFilter
        self.tags = tags
    }
}

extension UpdateEventTriggerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEventTriggerOutput(createdAt: \(Swift.String(describing: createdAt)), eventTriggerLimits: \(Swift.String(describing: eventTriggerLimits)), eventTriggerName: \(Swift.String(describing: eventTriggerName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), objectTypeName: \(Swift.String(describing: objectTypeName)), segmentFilter: \(Swift.String(describing: segmentFilter)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", eventTriggerConditions: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Updates associated with the address properties of a customer profile.
    public struct UpdateAddress: Swift.Sendable {
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            province: Swift.String? = nil,
            state: Swift.String? = nil
        ) {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }
}

extension CustomerProfilesClientTypes.UpdateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct UpdateProfileInput: Swift.Sendable {
    /// An account number that you have assigned to the customer.
    public var accountNumber: Swift.String?
    /// Any additional information relevant to the customers profile.
    public var additionalInformation: Swift.String?
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public var address: CustomerProfilesClientTypes.UpdateAddress?
    /// A key value pair of attributes of a customer profile.
    public var attributes: [Swift.String: Swift.String]?
    /// The customers billing address.
    public var billingAddress: CustomerProfilesClientTypes.UpdateAddress?
    /// The customers birth date.
    public var birthDate: Swift.String?
    /// The customers business email address.
    public var businessEmailAddress: Swift.String?
    /// The name of the customers business.
    public var businessName: Swift.String?
    /// The customers business phone number.
    public var businessPhoneNumber: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customers email address, which has not been specified as a personal or business address.
    public var emailAddress: Swift.String?
    /// Object that defines users preferred methods of engagement.
    public var engagementPreferences: CustomerProfilesClientTypes.EngagementPreferences?
    /// The customers first name.
    public var firstName: Swift.String?
    /// The gender with which the customer identifies.
    @available(*, deprecated)
    public var gender: CustomerProfilesClientTypes.Gender?
    /// An alternative to Gender which accepts any string as input.
    public var genderString: Swift.String?
    /// The customers home phone number.
    public var homePhoneNumber: Swift.String?
    /// The customers last name.
    public var lastName: Swift.String?
    /// The customers mailing address.
    public var mailingAddress: CustomerProfilesClientTypes.UpdateAddress?
    /// The customers middle name.
    public var middleName: Swift.String?
    /// The customers mobile phone number.
    public var mobilePhoneNumber: Swift.String?
    /// The type of profile used to describe the customer.
    @available(*, deprecated)
    public var partyType: CustomerProfilesClientTypes.PartyType?
    /// An alternative to PartyType which accepts any string as input.
    public var partyTypeString: Swift.String?
    /// The customers personal email address.
    public var personalEmailAddress: Swift.String?
    /// The customers phone number, which has not been specified as a mobile, home, or business number.
    public var phoneNumber: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// Determines the type of the profile.
    public var profileType: CustomerProfilesClientTypes.ProfileType?
    /// The customers shipping address.
    public var shippingAddress: CustomerProfilesClientTypes.UpdateAddress?

    public init(
        accountNumber: Swift.String? = nil,
        additionalInformation: Swift.String? = nil,
        address: CustomerProfilesClientTypes.UpdateAddress? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        billingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil,
        birthDate: Swift.String? = nil,
        businessEmailAddress: Swift.String? = nil,
        businessName: Swift.String? = nil,
        businessPhoneNumber: Swift.String? = nil,
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        engagementPreferences: CustomerProfilesClientTypes.EngagementPreferences? = nil,
        firstName: Swift.String? = nil,
        gender: CustomerProfilesClientTypes.Gender? = nil,
        genderString: Swift.String? = nil,
        homePhoneNumber: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil,
        middleName: Swift.String? = nil,
        mobilePhoneNumber: Swift.String? = nil,
        partyType: CustomerProfilesClientTypes.PartyType? = nil,
        partyTypeString: Swift.String? = nil,
        personalEmailAddress: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        profileId: Swift.String? = nil,
        profileType: CustomerProfilesClientTypes.ProfileType? = nil,
        shippingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil
    ) {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.engagementPreferences = engagementPreferences
        self.firstName = firstName
        self.gender = gender
        self.genderString = genderString
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.partyTypeString = partyTypeString
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.profileId = profileId
        self.profileType = profileType
        self.shippingAddress = shippingAddress
    }
}

extension UpdateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileInput(domainName: \(Swift.String(describing: domainName)), profileId: \(Swift.String(describing: profileId)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", engagementPreferences: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", profileType: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

public struct UpdateProfileOutput: Swift.Sendable {
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    ) {
        self.profileId = profileId
    }
}

extension AddProfileKeyInput {

    static func urlPathProvider(_ value: AddProfileKeyInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/keys"
    }
}

extension BatchGetCalculatedAttributeForProfileInput {

    static func urlPathProvider(_ value: BatchGetCalculatedAttributeForProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())/batch-get-for-profiles"
    }
}

extension BatchGetProfileInput {

    static func urlPathProvider(_ value: BatchGetProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/batch-get-profiles"
    }
}

extension CreateCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: CreateCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension CreateDomainLayoutInput {

    static func urlPathProvider(_ value: CreateDomainLayoutInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let layoutDefinitionName = value.layoutDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/layouts/\(layoutDefinitionName.urlPercentEncoding())"
    }
}

extension CreateEventStreamInput {

    static func urlPathProvider(_ value: CreateEventStreamInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventStreamName = value.eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

extension CreateEventTriggerInput {

    static func urlPathProvider(_ value: CreateEventTriggerInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventTriggerName = value.eventTriggerName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-triggers/\(eventTriggerName.urlPercentEncoding())"
    }
}

extension CreateIntegrationWorkflowInput {

    static func urlPathProvider(_ value: CreateIntegrationWorkflowInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/integrations"
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles"
    }
}

extension CreateSegmentDefinitionInput {

    static func urlPathProvider(_ value: CreateSegmentDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let segmentDefinitionName = value.segmentDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segment-definitions/\(segmentDefinitionName.urlPercentEncoding())"
    }
}

extension CreateSegmentEstimateInput {

    static func urlPathProvider(_ value: CreateSegmentEstimateInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segment-estimates"
    }
}

extension CreateSegmentSnapshotInput {

    static func urlPathProvider(_ value: CreateSegmentSnapshotInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let segmentDefinitionName = value.segmentDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segments/\(segmentDefinitionName.urlPercentEncoding())/snapshots"
    }
}

extension CreateUploadJobInput {

    static func urlPathProvider(_ value: CreateUploadJobInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/upload-jobs"
    }
}

extension DeleteCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: DeleteCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteDomainLayoutInput {

    static func urlPathProvider(_ value: DeleteDomainLayoutInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let layoutDefinitionName = value.layoutDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/layouts/\(layoutDefinitionName.urlPercentEncoding())"
    }
}

extension DeleteEventStreamInput {

    static func urlPathProvider(_ value: DeleteEventStreamInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventStreamName = value.eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

extension DeleteEventTriggerInput {

    static func urlPathProvider(_ value: DeleteEventTriggerInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventTriggerName = value.eventTriggerName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-triggers/\(eventTriggerName.urlPercentEncoding())"
    }
}

extension DeleteIntegrationInput {

    static func urlPathProvider(_ value: DeleteIntegrationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations/delete"
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/delete"
    }
}

extension DeleteProfileKeyInput {

    static func urlPathProvider(_ value: DeleteProfileKeyInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/keys/delete"
    }
}

extension DeleteProfileObjectInput {

    static func urlPathProvider(_ value: DeleteProfileObjectInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects/delete"
    }
}

extension DeleteProfileObjectTypeInput {

    static func urlPathProvider(_ value: DeleteProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

extension DeleteSegmentDefinitionInput {

    static func urlPathProvider(_ value: DeleteSegmentDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let segmentDefinitionName = value.segmentDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segment-definitions/\(segmentDefinitionName.urlPercentEncoding())"
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let workflowId = value.workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())"
    }
}

extension DetectProfileObjectTypeInput {

    static func urlPathProvider(_ value: DetectProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/detect/object-types"
    }
}

extension GetAutoMergingPreviewInput {

    static func urlPathProvider(_ value: GetAutoMergingPreviewInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs/auto-merging-preview"
    }
}

extension GetCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: GetCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension GetCalculatedAttributeForProfileInput {

    static func urlPathProvider(_ value: GetCalculatedAttributeForProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let profileId = value.profileId else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile/\(profileId.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension GetDomainInput {

    static func urlPathProvider(_ value: GetDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension GetDomainLayoutInput {

    static func urlPathProvider(_ value: GetDomainLayoutInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let layoutDefinitionName = value.layoutDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/layouts/\(layoutDefinitionName.urlPercentEncoding())"
    }
}

extension GetEventStreamInput {

    static func urlPathProvider(_ value: GetEventStreamInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventStreamName = value.eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

extension GetEventTriggerInput {

    static func urlPathProvider(_ value: GetEventTriggerInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventTriggerName = value.eventTriggerName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-triggers/\(eventTriggerName.urlPercentEncoding())"
    }
}

extension GetIdentityResolutionJobInput {

    static func urlPathProvider(_ value: GetIdentityResolutionJobInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetIntegrationInput {

    static func urlPathProvider(_ value: GetIntegrationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

extension GetMatchesInput {

    static func urlPathProvider(_ value: GetMatchesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/matches"
    }
}

extension GetMatchesInput {

    static func queryItemProvider(_ value: GetMatchesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetProfileObjectTypeInput {

    static func urlPathProvider(_ value: GetProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

extension GetProfileObjectTypeTemplateInput {

    static func urlPathProvider(_ value: GetProfileObjectTypeTemplateInput) -> Swift.String? {
        guard let templateId = value.templateId else {
            return nil
        }
        return "/templates/\(templateId.urlPercentEncoding())"
    }
}

extension GetSegmentDefinitionInput {

    static func urlPathProvider(_ value: GetSegmentDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let segmentDefinitionName = value.segmentDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segment-definitions/\(segmentDefinitionName.urlPercentEncoding())"
    }
}

extension GetSegmentEstimateInput {

    static func urlPathProvider(_ value: GetSegmentEstimateInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let estimateId = value.estimateId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segment-estimates/\(estimateId.urlPercentEncoding())"
    }
}

extension GetSegmentMembershipInput {

    static func urlPathProvider(_ value: GetSegmentMembershipInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let segmentDefinitionName = value.segmentDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segments/\(segmentDefinitionName.urlPercentEncoding())/membership"
    }
}

extension GetSegmentSnapshotInput {

    static func urlPathProvider(_ value: GetSegmentSnapshotInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let segmentDefinitionName = value.segmentDefinitionName else {
            return nil
        }
        guard let snapshotId = value.snapshotId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segments/\(segmentDefinitionName.urlPercentEncoding())/snapshots/\(snapshotId.urlPercentEncoding())"
    }
}

extension GetSimilarProfilesInput {

    static func urlPathProvider(_ value: GetSimilarProfilesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/matches"
    }
}

extension GetSimilarProfilesInput {

    static func queryItemProvider(_ value: GetSimilarProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetUploadJobInput {

    static func urlPathProvider(_ value: GetUploadJobInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/upload-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetUploadJobPathInput {

    static func urlPathProvider(_ value: GetUploadJobPathInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/upload-jobs/\(jobId.urlPercentEncoding())/path"
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let workflowId = value.workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())"
    }
}

extension GetWorkflowStepsInput {

    static func urlPathProvider(_ value: GetWorkflowStepsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let workflowId = value.workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())/steps"
    }
}

extension GetWorkflowStepsInput {

    static func queryItemProvider(_ value: GetWorkflowStepsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAccountIntegrationsInput {

    static func urlPathProvider(_ value: ListAccountIntegrationsInput) -> Swift.String? {
        return "/integrations"
    }
}

extension ListAccountIntegrationsInput {

    static func queryItemProvider(_ value: ListAccountIntegrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeHidden = value.includeHidden {
            let includeHiddenQueryItem = Smithy.URIQueryItem(name: "include-hidden".urlPercentEncoding(), value: Swift.String(includeHidden).urlPercentEncoding())
            items.append(includeHiddenQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCalculatedAttributeDefinitionsInput {

    static func urlPathProvider(_ value: ListCalculatedAttributeDefinitionsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes"
    }
}

extension ListCalculatedAttributeDefinitionsInput {

    static func queryItemProvider(_ value: ListCalculatedAttributeDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCalculatedAttributesForProfileInput {

    static func urlPathProvider(_ value: ListCalculatedAttributesForProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let profileId = value.profileId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile/\(profileId.urlPercentEncoding())/calculated-attributes"
    }
}

extension ListCalculatedAttributesForProfileInput {

    static func queryItemProvider(_ value: ListCalculatedAttributesForProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainLayoutsInput {

    static func urlPathProvider(_ value: ListDomainLayoutsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/layouts"
    }
}

extension ListDomainLayoutsInput {

    static func queryItemProvider(_ value: ListDomainLayoutsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/domains"
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventStreamsInput {

    static func urlPathProvider(_ value: ListEventStreamsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams"
    }
}

extension ListEventStreamsInput {

    static func queryItemProvider(_ value: ListEventStreamsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventTriggersInput {

    static func urlPathProvider(_ value: ListEventTriggersInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-triggers"
    }
}

extension ListEventTriggersInput {

    static func queryItemProvider(_ value: ListEventTriggersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdentityResolutionJobsInput {

    static func urlPathProvider(_ value: ListIdentityResolutionJobsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs"
    }
}

extension ListIdentityResolutionJobsInput {

    static func queryItemProvider(_ value: ListIdentityResolutionJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIntegrationsInput {

    static func urlPathProvider(_ value: ListIntegrationsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

extension ListIntegrationsInput {

    static func queryItemProvider(_ value: ListIntegrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeHidden = value.includeHidden {
            let includeHiddenQueryItem = Smithy.URIQueryItem(name: "include-hidden".urlPercentEncoding(), value: Swift.String(includeHidden).urlPercentEncoding())
            items.append(includeHiddenQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListObjectTypeAttributesInput {

    static func urlPathProvider(_ value: ListObjectTypeAttributesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())/attributes"
    }
}

extension ListObjectTypeAttributesInput {

    static func queryItemProvider(_ value: ListObjectTypeAttributesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileAttributeValuesInput {

    static func urlPathProvider(_ value: ListProfileAttributeValuesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let attributeName = value.attributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile-attributes/\(attributeName.urlPercentEncoding())/values"
    }
}

extension ListProfileObjectsInput {

    static func urlPathProvider(_ value: ListProfileObjectsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects"
    }
}

extension ListProfileObjectsInput {

    static func queryItemProvider(_ value: ListProfileObjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileObjectTypesInput {

    static func urlPathProvider(_ value: ListProfileObjectTypesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types"
    }
}

extension ListProfileObjectTypesInput {

    static func queryItemProvider(_ value: ListProfileObjectTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileObjectTypeTemplatesInput {

    static func urlPathProvider(_ value: ListProfileObjectTypeTemplatesInput) -> Swift.String? {
        return "/templates"
    }
}

extension ListProfileObjectTypeTemplatesInput {

    static func queryItemProvider(_ value: ListProfileObjectTypeTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRuleBasedMatchesInput {

    static func urlPathProvider(_ value: ListRuleBasedMatchesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/ruleBasedMatches"
    }
}

extension ListRuleBasedMatchesInput {

    static func queryItemProvider(_ value: ListRuleBasedMatchesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSegmentDefinitionsInput {

    static func urlPathProvider(_ value: ListSegmentDefinitionsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/segment-definitions"
    }
}

extension ListSegmentDefinitionsInput {

    static func queryItemProvider(_ value: ListSegmentDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListUploadJobsInput {

    static func urlPathProvider(_ value: ListUploadJobsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/upload-jobs"
    }
}

extension ListUploadJobsInput {

    static func queryItemProvider(_ value: ListUploadJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows"
    }
}

extension ListWorkflowsInput {

    static func queryItemProvider(_ value: ListWorkflowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension MergeProfilesInput {

    static func urlPathProvider(_ value: MergeProfilesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects/merge"
    }
}

extension PutIntegrationInput {

    static func urlPathProvider(_ value: PutIntegrationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

extension PutProfileObjectInput {

    static func urlPathProvider(_ value: PutProfileObjectInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects"
    }
}

extension PutProfileObjectTypeInput {

    static func urlPathProvider(_ value: PutProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

extension SearchProfilesInput {

    static func urlPathProvider(_ value: SearchProfilesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/search"
    }
}

extension SearchProfilesInput {

    static func queryItemProvider(_ value: SearchProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension StartUploadJobInput {

    static func urlPathProvider(_ value: StartUploadJobInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/upload-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension StopUploadJobInput {

    static func urlPathProvider(_ value: StopUploadJobInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/upload-jobs/\(jobId.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: UpdateCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension UpdateDomainInput {

    static func urlPathProvider(_ value: UpdateDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateDomainLayoutInput {

    static func urlPathProvider(_ value: UpdateDomainLayoutInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let layoutDefinitionName = value.layoutDefinitionName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/layouts/\(layoutDefinitionName.urlPercentEncoding())"
    }
}

extension UpdateEventTriggerInput {

    static func urlPathProvider(_ value: UpdateEventTriggerInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventTriggerName = value.eventTriggerName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-triggers/\(eventTriggerName.urlPercentEncoding())"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles"
    }
}

extension AddProfileKeyInput {

    static func write(value: AddProfileKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["ProfileId"].write(value.profileId)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetCalculatedAttributeForProfileInput {

    static func write(value: BatchGetCalculatedAttributeForProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionOverrides"].write(value.conditionOverrides, with: CustomerProfilesClientTypes.ConditionOverrides.write(value:to:))
        try writer["ProfileIds"].writeList(value.profileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetProfileInput {

    static func write(value: BatchGetProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileIds"].writeList(value.profileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCalculatedAttributeDefinitionInput {

    static func write(value: CreateCalculatedAttributeDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeDetails"].write(value.attributeDetails, with: CustomerProfilesClientTypes.AttributeDetails.write(value:to:))
        try writer["Conditions"].write(value.conditions, with: CustomerProfilesClientTypes.Conditions.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["Filter"].write(value.filter, with: CustomerProfilesClientTypes.Filter.write(value:to:))
        try writer["Statistic"].write(value.statistic)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UseHistoricalData"].write(value.useHistoricalData)
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeadLetterQueueUrl"].write(value.deadLetterQueueUrl)
        try writer["DefaultEncryptionKey"].write(value.defaultEncryptionKey)
        try writer["DefaultExpirationDays"].write(value.defaultExpirationDays)
        try writer["Matching"].write(value.matching, with: CustomerProfilesClientTypes.MatchingRequest.write(value:to:))
        try writer["RuleBasedMatching"].write(value.ruleBasedMatching, with: CustomerProfilesClientTypes.RuleBasedMatchingRequest.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDomainLayoutInput {

    static func write(value: CreateDomainLayoutInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["IsDefault"].write(value.isDefault)
        try writer["Layout"].write(value.layout)
        try writer["LayoutType"].write(value.layoutType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEventStreamInput {

    static func write(value: CreateEventStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Uri"].write(value.uri)
    }
}

extension CreateEventTriggerInput {

    static func write(value: CreateEventTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["EventTriggerConditions"].writeList(value.eventTriggerConditions, memberWritingClosure: CustomerProfilesClientTypes.EventTriggerCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EventTriggerLimits"].write(value.eventTriggerLimits, with: CustomerProfilesClientTypes.EventTriggerLimits.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["SegmentFilter"].write(value.segmentFilter)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateIntegrationWorkflowInput {

    static func write(value: CreateIntegrationWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IntegrationConfig"].write(value.integrationConfig, with: CustomerProfilesClientTypes.IntegrationConfig.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WorkflowType"].write(value.workflowType)
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber)
        try writer["AdditionalInformation"].write(value.additionalInformation)
        try writer["Address"].write(value.address, with: CustomerProfilesClientTypes.Address.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress, with: CustomerProfilesClientTypes.Address.write(value:to:))
        try writer["BirthDate"].write(value.birthDate)
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress)
        try writer["BusinessName"].write(value.businessName)
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["EngagementPreferences"].write(value.engagementPreferences, with: CustomerProfilesClientTypes.EngagementPreferences.write(value:to:))
        try writer["FirstName"].write(value.firstName)
        try writer["Gender"].write(value.gender)
        try writer["GenderString"].write(value.genderString)
        try writer["HomePhoneNumber"].write(value.homePhoneNumber)
        try writer["LastName"].write(value.lastName)
        try writer["MailingAddress"].write(value.mailingAddress, with: CustomerProfilesClientTypes.Address.write(value:to:))
        try writer["MiddleName"].write(value.middleName)
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["PartyType"].write(value.partyType)
        try writer["PartyTypeString"].write(value.partyTypeString)
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["ProfileType"].write(value.profileType)
        try writer["ShippingAddress"].write(value.shippingAddress, with: CustomerProfilesClientTypes.Address.write(value:to:))
    }
}

extension CreateSegmentDefinitionInput {

    static func write(value: CreateSegmentDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["SegmentGroups"].write(value.segmentGroups, with: CustomerProfilesClientTypes.SegmentGroup.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSegmentEstimateInput {

    static func write(value: CreateSegmentEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SegmentQuery"].write(value.segmentQuery, with: CustomerProfilesClientTypes.SegmentGroupStructure.write(value:to:))
    }
}

extension CreateSegmentSnapshotInput {

    static func write(value: CreateSegmentSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataFormat"].write(value.dataFormat)
        try writer["DestinationUri"].write(value.destinationUri)
        try writer["EncryptionKey"].write(value.encryptionKey)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension CreateUploadJobInput {

    static func write(value: CreateUploadJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataExpiry"].write(value.dataExpiry)
        try writer["DisplayName"].write(value.displayName)
        try writer["Fields"].writeMap(value.fields, valueWritingClosure: CustomerProfilesClientTypes.ObjectTypeField.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UniqueKey"].write(value.uniqueKey)
    }
}

extension DeleteIntegrationInput {

    static func write(value: DeleteIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }
}

extension DeleteProfileInput {

    static func write(value: DeleteProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
    }
}

extension DeleteProfileKeyInput {

    static func write(value: DeleteProfileKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["ProfileId"].write(value.profileId)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteProfileObjectInput {

    static func write(value: DeleteProfileObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["ProfileId"].write(value.profileId)
        try writer["ProfileObjectUniqueKey"].write(value.profileObjectUniqueKey)
    }
}

extension DetectProfileObjectTypeInput {

    static func write(value: DetectProfileObjectTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Objects"].writeList(value.objects, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetAutoMergingPreviewInput {

    static func write(value: GetAutoMergingPreviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConflictResolution"].write(value.conflictResolution, with: CustomerProfilesClientTypes.ConflictResolution.write(value:to:))
        try writer["Consolidation"].write(value.consolidation, with: CustomerProfilesClientTypes.Consolidation.write(value:to:))
        try writer["MinAllowedConfidenceScoreForMerging"].write(value.minAllowedConfidenceScoreForMerging)
    }
}

extension GetIntegrationInput {

    static func write(value: GetIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }
}

extension GetSegmentMembershipInput {

    static func write(value: GetSegmentMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileIds"].writeList(value.profileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetSimilarProfilesInput {

    static func write(value: GetSimilarProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchType"].write(value.matchType)
        try writer["SearchKey"].write(value.searchKey)
        try writer["SearchValue"].write(value.searchValue)
    }
}

extension ListAccountIntegrationsInput {

    static func write(value: ListAccountIntegrationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }
}

extension ListProfileObjectsInput {

    static func write(value: ListProfileObjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectFilter"].write(value.objectFilter, with: CustomerProfilesClientTypes.ObjectFilter.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["ProfileId"].write(value.profileId)
    }
}

extension ListWorkflowsInput {

    static func write(value: ListWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryEndDate"].writeTimestamp(value.queryEndDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["QueryStartDate"].writeTimestamp(value.queryStartDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Status"].write(value.status)
        try writer["WorkflowType"].write(value.workflowType)
    }
}

extension MergeProfilesInput {

    static func write(value: MergeProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldSourceProfileIds"].write(value.fieldSourceProfileIds, with: CustomerProfilesClientTypes.FieldSourceProfileIds.write(value:to:))
        try writer["MainProfileId"].write(value.mainProfileId)
        try writer["ProfileIdsToBeMerged"].writeList(value.profileIdsToBeMerged, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutIntegrationInput {

    static func write(value: PutIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventTriggerNames"].writeList(value.eventTriggerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FlowDefinition"].write(value.flowDefinition, with: CustomerProfilesClientTypes.FlowDefinition.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["ObjectTypeNames"].writeMap(value.objectTypeNames, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Uri"].write(value.uri)
    }
}

extension PutProfileObjectInput {

    static func write(value: PutProfileObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
        try writer["ObjectTypeName"].write(value.objectTypeName)
    }
}

extension PutProfileObjectTypeInput {

    static func write(value: PutProfileObjectTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowProfileCreation"].write(value.allowProfileCreation)
        try writer["Description"].write(value.description)
        try writer["EncryptionKey"].write(value.encryptionKey)
        try writer["ExpirationDays"].write(value.expirationDays)
        try writer["Fields"].writeMap(value.fields, valueWritingClosure: CustomerProfilesClientTypes.ObjectTypeField.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Keys"].writeMap(value.keys, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: CustomerProfilesClientTypes.ObjectTypeKey.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MaxProfileObjectCount"].write(value.maxProfileObjectCount)
        try writer["SourceLastUpdatedTimestampFormat"].write(value.sourceLastUpdatedTimestampFormat)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TemplateId"].write(value.templateId)
    }
}

extension SearchProfilesInput {

    static func write(value: SearchProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalSearchKeys"].writeList(value.additionalSearchKeys, memberWritingClosure: CustomerProfilesClientTypes.AdditionalSearchKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KeyName"].write(value.keyName)
        try writer["LogicalOperator"].write(value.logicalOperator)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateCalculatedAttributeDefinitionInput {

    static func write(value: UpdateCalculatedAttributeDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Conditions"].write(value.conditions, with: CustomerProfilesClientTypes.Conditions.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
    }
}

extension UpdateDomainInput {

    static func write(value: UpdateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeadLetterQueueUrl"].write(value.deadLetterQueueUrl)
        try writer["DefaultEncryptionKey"].write(value.defaultEncryptionKey)
        try writer["DefaultExpirationDays"].write(value.defaultExpirationDays)
        try writer["Matching"].write(value.matching, with: CustomerProfilesClientTypes.MatchingRequest.write(value:to:))
        try writer["RuleBasedMatching"].write(value.ruleBasedMatching, with: CustomerProfilesClientTypes.RuleBasedMatchingRequest.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDomainLayoutInput {

    static func write(value: UpdateDomainLayoutInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["IsDefault"].write(value.isDefault)
        try writer["Layout"].write(value.layout)
        try writer["LayoutType"].write(value.layoutType)
    }
}

extension UpdateEventTriggerInput {

    static func write(value: UpdateEventTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["EventTriggerConditions"].writeList(value.eventTriggerConditions, memberWritingClosure: CustomerProfilesClientTypes.EventTriggerCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EventTriggerLimits"].write(value.eventTriggerLimits, with: CustomerProfilesClientTypes.EventTriggerLimits.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["SegmentFilter"].write(value.segmentFilter)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber)
        try writer["AdditionalInformation"].write(value.additionalInformation)
        try writer["Address"].write(value.address, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
        try writer["BirthDate"].write(value.birthDate)
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress)
        try writer["BusinessName"].write(value.businessName)
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["EngagementPreferences"].write(value.engagementPreferences, with: CustomerProfilesClientTypes.EngagementPreferences.write(value:to:))
        try writer["FirstName"].write(value.firstName)
        try writer["Gender"].write(value.gender)
        try writer["GenderString"].write(value.genderString)
        try writer["HomePhoneNumber"].write(value.homePhoneNumber)
        try writer["LastName"].write(value.lastName)
        try writer["MailingAddress"].write(value.mailingAddress, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
        try writer["MiddleName"].write(value.middleName)
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["PartyType"].write(value.partyType)
        try writer["PartyTypeString"].write(value.partyTypeString)
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["ProfileId"].write(value.profileId)
        try writer["ProfileType"].write(value.profileType)
        try writer["ShippingAddress"].write(value.shippingAddress, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
    }
}

extension AddProfileKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddProfileKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddProfileKeyOutput()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetCalculatedAttributeForProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCalculatedAttributeForProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCalculatedAttributeForProfileOutput()
        value.calculatedAttributeValues = try reader["CalculatedAttributeValues"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.CalculatedAttributeValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.conditionOverrides = try reader["ConditionOverrides"].readIfPresent(with: CustomerProfilesClientTypes.ConditionOverrides.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.BatchGetCalculatedAttributeForProfileError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetProfileOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.BatchGetProfileError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.Profile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCalculatedAttributeDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCalculatedAttributeDefinitionOutput()
        value.attributeDetails = try reader["AttributeDetails"].readIfPresent(with: CustomerProfilesClientTypes.AttributeDetails.read(from:))
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.conditions = try reader["Conditions"].readIfPresent(with: CustomerProfilesClientTypes.Conditions.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.filter = try reader["Filter"].readIfPresent(with: CustomerProfilesClientTypes.Filter.read(from:))
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readiness = try reader["Readiness"].readIfPresent(with: CustomerProfilesClientTypes.Readiness.read(from:))
        value.statistic = try reader["Statistic"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useHistoricalData = try reader["UseHistoricalData"].readIfPresent()
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deadLetterQueueUrl = try reader["DeadLetterQueueUrl"].readIfPresent()
        value.defaultEncryptionKey = try reader["DefaultEncryptionKey"].readIfPresent()
        value.defaultExpirationDays = try reader["DefaultExpirationDays"].readIfPresent() ?? 0
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.matching = try reader["Matching"].readIfPresent(with: CustomerProfilesClientTypes.MatchingResponse.read(from:))
        value.ruleBasedMatching = try reader["RuleBasedMatching"].readIfPresent(with: CustomerProfilesClientTypes.RuleBasedMatchingResponse.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateDomainLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainLayoutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainLayoutOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent() ?? ""
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.layout = try reader["Layout"].readIfPresent() ?? ""
        value.layoutDefinitionName = try reader["LayoutDefinitionName"].readIfPresent() ?? ""
        value.layoutType = try reader["LayoutType"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["Version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventStreamOutput()
        value.eventStreamArn = try reader["EventStreamArn"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateEventTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventTriggerOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.eventTriggerConditions = try reader["EventTriggerConditions"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventTriggerCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventTriggerLimits = try reader["EventTriggerLimits"].readIfPresent(with: CustomerProfilesClientTypes.EventTriggerLimits.read(from:))
        value.eventTriggerName = try reader["EventTriggerName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.segmentFilter = try reader["SegmentFilter"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateIntegrationWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationWorkflowOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateSegmentDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSegmentDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSegmentDefinitionOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.segmentDefinitionArn = try reader["SegmentDefinitionArn"].readIfPresent()
        value.segmentDefinitionName = try reader["SegmentDefinitionName"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateSegmentEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSegmentEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSegmentEstimateOutput()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.estimateId = try reader["EstimateId"].readIfPresent()
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateSegmentSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSegmentSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSegmentSnapshotOutput()
        value.snapshotId = try reader["SnapshotId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateUploadJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUploadJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUploadJobOutput()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCalculatedAttributeDefinitionOutput {
        return DeleteCalculatedAttributeDefinitionOutput()
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDomainLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainLayoutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainLayoutOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventStreamOutput {
        return DeleteEventStreamOutput()
    }
}

extension DeleteEventTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventTriggerOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIntegrationOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteProfileKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileKeyOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteProfileObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileObjectOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileObjectTypeOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteSegmentDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSegmentDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSegmentDefinitionOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowOutput {
        return DeleteWorkflowOutput()
    }
}

extension DetectProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetectProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetectProfileObjectTypeOutput()
        value.detectedProfileObjectTypes = try reader["DetectedProfileObjectTypes"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.DetectedProfileObjectType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAutoMergingPreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutoMergingPreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutoMergingPreviewOutput()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.numberOfMatchesInSample = try reader["NumberOfMatchesInSample"].readIfPresent() ?? 0
        value.numberOfProfilesInSample = try reader["NumberOfProfilesInSample"].readIfPresent() ?? 0
        value.numberOfProfilesWillBeMerged = try reader["NumberOfProfilesWillBeMerged"].readIfPresent() ?? 0
        return value
    }
}

extension GetCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCalculatedAttributeDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculatedAttributeDefinitionOutput()
        value.attributeDetails = try reader["AttributeDetails"].readIfPresent(with: CustomerProfilesClientTypes.AttributeDetails.read(from:))
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.conditions = try reader["Conditions"].readIfPresent(with: CustomerProfilesClientTypes.Conditions.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.filter = try reader["Filter"].readIfPresent(with: CustomerProfilesClientTypes.Filter.read(from:))
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readiness = try reader["Readiness"].readIfPresent(with: CustomerProfilesClientTypes.Readiness.read(from:))
        value.statistic = try reader["Statistic"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useHistoricalData = try reader["UseHistoricalData"].readIfPresent()
        return value
    }
}

extension GetCalculatedAttributeForProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCalculatedAttributeForProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculatedAttributeForProfileOutput()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.isDataPartial = try reader["IsDataPartial"].readIfPresent()
        value.lastObjectTimestamp = try reader["LastObjectTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension GetDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deadLetterQueueUrl = try reader["DeadLetterQueueUrl"].readIfPresent()
        value.defaultEncryptionKey = try reader["DefaultEncryptionKey"].readIfPresent()
        value.defaultExpirationDays = try reader["DefaultExpirationDays"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.matching = try reader["Matching"].readIfPresent(with: CustomerProfilesClientTypes.MatchingResponse.read(from:))
        value.ruleBasedMatching = try reader["RuleBasedMatching"].readIfPresent(with: CustomerProfilesClientTypes.RuleBasedMatchingResponse.read(from:))
        value.stats = try reader["Stats"].readIfPresent(with: CustomerProfilesClientTypes.DomainStats.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDomainLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainLayoutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainLayoutOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent() ?? ""
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.layout = try reader["Layout"].readIfPresent() ?? ""
        value.layoutDefinitionName = try reader["LayoutDefinitionName"].readIfPresent() ?? ""
        value.layoutType = try reader["LayoutType"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["Version"].readIfPresent() ?? ""
        return value
    }
}

extension GetEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventStreamOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationDetails = try reader["DestinationDetails"].readIfPresent(with: CustomerProfilesClientTypes.EventStreamDestinationDetails.read(from:))
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.eventStreamArn = try reader["EventStreamArn"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.stoppedSince = try reader["StoppedSince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetEventTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventTriggerOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.eventTriggerConditions = try reader["EventTriggerConditions"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventTriggerCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventTriggerLimits = try reader["EventTriggerLimits"].readIfPresent(with: CustomerProfilesClientTypes.EventTriggerLimits.read(from:))
        value.eventTriggerName = try reader["EventTriggerName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.segmentFilter = try reader["SegmentFilter"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetIdentityResolutionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdentityResolutionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdentityResolutionJobOutput()
        value.autoMerging = try reader["AutoMerging"].readIfPresent(with: CustomerProfilesClientTypes.AutoMerging.read(from:))
        value.domainName = try reader["DomainName"].readIfPresent()
        value.exportingLocation = try reader["ExportingLocation"].readIfPresent(with: CustomerProfilesClientTypes.ExportingLocation.read(from:))
        value.jobEndTime = try reader["JobEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobExpirationTime = try reader["JobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobStartTime = try reader["JobStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobStats = try reader["JobStats"].readIfPresent(with: CustomerProfilesClientTypes.JobStats.read(from:))
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.eventTriggerNames = try reader["EventTriggerNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isUnstructured = try reader["IsUnstructured"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.objectTypeNames = try reader["ObjectTypeNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        return value
    }
}

extension GetMatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMatchesOutput()
        value.matchGenerationDate = try reader["MatchGenerationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.matches = try reader["Matches"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.MatchItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.potentialMatches = try reader["PotentialMatches"].readIfPresent()
        return value
    }
}

extension GetProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileObjectTypeOutput()
        value.allowProfileCreation = try reader["AllowProfileCreation"].readIfPresent() ?? false
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.encryptionKey = try reader["EncryptionKey"].readIfPresent()
        value.expirationDays = try reader["ExpirationDays"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxAvailableProfileObjectCount = try reader["MaxAvailableProfileObjectCount"].readIfPresent()
        value.maxProfileObjectCount = try reader["MaxProfileObjectCount"].readIfPresent()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent() ?? ""
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension GetProfileObjectTypeTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileObjectTypeTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileObjectTypeTemplateOutput()
        value.allowProfileCreation = try reader["AllowProfileCreation"].readIfPresent() ?? false
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.sourceName = try reader["SourceName"].readIfPresent()
        value.sourceObject = try reader["SourceObject"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension GetSegmentDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentDefinitionOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.segmentDefinitionArn = try reader["SegmentDefinitionArn"].readIfPresent() ?? ""
        value.segmentDefinitionName = try reader["SegmentDefinitionName"].readIfPresent()
        value.segmentGroups = try reader["SegmentGroups"].readIfPresent(with: CustomerProfilesClientTypes.SegmentGroup.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSegmentEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentEstimateOutput()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.estimate = try reader["Estimate"].readIfPresent()
        value.estimateId = try reader["EstimateId"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetSegmentMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentMembershipOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ProfileQueryFailures.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ProfileQueryResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.segmentDefinitionName = try reader["SegmentDefinitionName"].readIfPresent()
        return value
    }
}

extension GetSegmentSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentSnapshotOutput()
        value.dataFormat = try reader["DataFormat"].readIfPresent() ?? .sdkUnknown("")
        value.destinationUri = try reader["DestinationUri"].readIfPresent()
        value.encryptionKey = try reader["EncryptionKey"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.snapshotId = try reader["SnapshotId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension GetSimilarProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSimilarProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSimilarProfilesOutput()
        value.confidenceScore = try reader["ConfidenceScore"].readIfPresent()
        value.matchId = try reader["MatchId"].readIfPresent()
        value.matchType = try reader["MatchType"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profileIds = try reader["ProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleLevel = try reader["RuleLevel"].readIfPresent()
        return value
    }
}

extension GetUploadJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUploadJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUploadJobOutput()
        value.completedAt = try reader["CompletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataExpiry = try reader["DataExpiry"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobId = try reader["JobId"].readIfPresent()
        value.resultsSummary = try reader["ResultsSummary"].readIfPresent(with: CustomerProfilesClientTypes.ResultsSummary.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.uniqueKey = try reader["UniqueKey"].readIfPresent()
        return value
    }
}

extension GetUploadJobPathOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUploadJobPathOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUploadJobPathOutput()
        value.clientToken = try reader["ClientToken"].readIfPresent()
        value.url = try reader["Url"].readIfPresent() ?? ""
        value.validUntil = try reader["ValidUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowOutput()
        value.attributes = try reader["Attributes"].readIfPresent(with: CustomerProfilesClientTypes.WorkflowAttributes.read(from:))
        value.errorDescription = try reader["ErrorDescription"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metrics = try reader["Metrics"].readIfPresent(with: CustomerProfilesClientTypes.WorkflowMetrics.read(from:))
        value.startDate = try reader["StartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.workflowType = try reader["WorkflowType"].readIfPresent()
        return value
    }
}

extension GetWorkflowStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowStepsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.WorkflowStepItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.workflowType = try reader["WorkflowType"].readIfPresent()
        return value
    }
}

extension ListAccountIntegrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountIntegrationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListIntegrationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCalculatedAttributeDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCalculatedAttributeDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCalculatedAttributeDefinitionsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCalculatedAttributesForProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCalculatedAttributesForProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCalculatedAttributesForProfileOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDomainLayoutsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainLayoutsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainLayoutsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.LayoutItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListDomainItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventStreamsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventStreamSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventTriggersOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventTriggerSummaryItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIdentityResolutionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentityResolutionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentityResolutionJobsOutput()
        value.identityResolutionJobsList = try reader["IdentityResolutionJobsList"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.IdentityResolutionJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIntegrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIntegrationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListIntegrationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListObjectTypeAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectTypeAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectTypeAttributesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListObjectTypeAttributeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProfileAttributeValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileAttributeValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileAttributeValuesOutput()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.AttributeValueItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListProfileObjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileObjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileObjectsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListProfileObjectsItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProfileObjectTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileObjectTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileObjectTypesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListProfileObjectTypeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProfileObjectTypeTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileObjectTypeTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileObjectTypeTemplatesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRuleBasedMatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRuleBasedMatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRuleBasedMatchesOutput()
        value.matchIds = try reader["MatchIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSegmentDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSegmentDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSegmentDefinitionsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.SegmentDefinitionItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListUploadJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUploadJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUploadJobsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.UploadJobItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListWorkflowsItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension MergeProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergeProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergeProfilesOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension PutIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutIntegrationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.eventTriggerNames = try reader["EventTriggerNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isUnstructured = try reader["IsUnstructured"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.objectTypeNames = try reader["ObjectTypeNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        return value
    }
}

extension PutProfileObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProfileObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProfileObjectOutput()
        value.profileObjectUniqueKey = try reader["ProfileObjectUniqueKey"].readIfPresent()
        return value
    }
}

extension PutProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProfileObjectTypeOutput()
        value.allowProfileCreation = try reader["AllowProfileCreation"].readIfPresent() ?? false
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.encryptionKey = try reader["EncryptionKey"].readIfPresent()
        value.expirationDays = try reader["ExpirationDays"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxAvailableProfileObjectCount = try reader["MaxAvailableProfileObjectCount"].readIfPresent()
        value.maxProfileObjectCount = try reader["MaxProfileObjectCount"].readIfPresent()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent() ?? ""
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension SearchProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchProfilesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.Profile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension StartUploadJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartUploadJobOutput {
        return StartUploadJobOutput()
    }
}

extension StopUploadJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopUploadJobOutput {
        return StopUploadJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCalculatedAttributeDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCalculatedAttributeDefinitionOutput()
        value.attributeDetails = try reader["AttributeDetails"].readIfPresent(with: CustomerProfilesClientTypes.AttributeDetails.read(from:))
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.conditions = try reader["Conditions"].readIfPresent(with: CustomerProfilesClientTypes.Conditions.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readiness = try reader["Readiness"].readIfPresent(with: CustomerProfilesClientTypes.Readiness.read(from:))
        value.statistic = try reader["Statistic"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useHistoricalData = try reader["UseHistoricalData"].readIfPresent()
        return value
    }
}

extension UpdateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deadLetterQueueUrl = try reader["DeadLetterQueueUrl"].readIfPresent()
        value.defaultEncryptionKey = try reader["DefaultEncryptionKey"].readIfPresent()
        value.defaultExpirationDays = try reader["DefaultExpirationDays"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.matching = try reader["Matching"].readIfPresent(with: CustomerProfilesClientTypes.MatchingResponse.read(from:))
        value.ruleBasedMatching = try reader["RuleBasedMatching"].readIfPresent(with: CustomerProfilesClientTypes.RuleBasedMatchingResponse.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateDomainLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainLayoutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainLayoutOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.layout = try reader["Layout"].readIfPresent()
        value.layoutDefinitionName = try reader["LayoutDefinitionName"].readIfPresent()
        value.layoutType = try reader["LayoutType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension UpdateEventTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEventTriggerOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.eventTriggerConditions = try reader["EventTriggerConditions"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventTriggerCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventTriggerLimits = try reader["EventTriggerLimits"].readIfPresent(with: CustomerProfilesClientTypes.EventTriggerLimits.read(from:))
        value.eventTriggerName = try reader["EventTriggerName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.segmentFilter = try reader["SegmentFilter"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

enum AddProfileKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetCalculatedAttributeForProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSegmentDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSegmentEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSegmentSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUploadJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSegmentDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetectProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutoMergingPreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCalculatedAttributeForProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdentityResolutionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileObjectTypeTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSimilarProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUploadJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUploadJobPathOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountIntegrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCalculatedAttributeDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCalculatedAttributesForProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainLayoutsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentityResolutionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIntegrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectTypeAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileAttributeValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileObjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileObjectTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileObjectTypeTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRuleBasedMatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSegmentDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUploadJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergeProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProfileObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartUploadJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopUploadJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomerProfilesClientTypes.BatchGetCalculatedAttributeForProfileError {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.BatchGetCalculatedAttributeForProfileError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.BatchGetCalculatedAttributeForProfileError()
        value.code = try reader["Code"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.CalculatedAttributeValue {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.CalculatedAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.CalculatedAttributeValue()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.isDataPartial = try reader["IsDataPartial"].readIfPresent()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.lastObjectTimestamp = try reader["LastObjectTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CustomerProfilesClientTypes.ConditionOverrides {

    static func write(value: CustomerProfilesClientTypes.ConditionOverrides?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Range"].write(value.range, with: CustomerProfilesClientTypes.RangeOverride.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ConditionOverrides {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ConditionOverrides()
        value.range = try reader["Range"].readIfPresent(with: CustomerProfilesClientTypes.RangeOverride.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.RangeOverride {

    static func write(value: CustomerProfilesClientTypes.RangeOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].write(value.end)
        try writer["Start"].write(value.start)
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.RangeOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.RangeOverride()
        value.start = try reader["Start"].readIfPresent() ?? 366
        value.end = try reader["End"].readIfPresent() ?? 0
        value.unit = try reader["Unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CustomerProfilesClientTypes.BatchGetProfileError {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.BatchGetProfileError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.BatchGetProfileError()
        value.code = try reader["Code"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.Profile {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Profile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Profile()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.accountNumber = try reader["AccountNumber"].readIfPresent()
        value.additionalInformation = try reader["AdditionalInformation"].readIfPresent()
        value.partyType = try reader["PartyType"].readIfPresent()
        value.businessName = try reader["BusinessName"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.middleName = try reader["MiddleName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.birthDate = try reader["BirthDate"].readIfPresent()
        value.gender = try reader["Gender"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.mobilePhoneNumber = try reader["MobilePhoneNumber"].readIfPresent()
        value.homePhoneNumber = try reader["HomePhoneNumber"].readIfPresent()
        value.businessPhoneNumber = try reader["BusinessPhoneNumber"].readIfPresent()
        value.emailAddress = try reader["EmailAddress"].readIfPresent()
        value.personalEmailAddress = try reader["PersonalEmailAddress"].readIfPresent()
        value.businessEmailAddress = try reader["BusinessEmailAddress"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.shippingAddress = try reader["ShippingAddress"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.mailingAddress = try reader["MailingAddress"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.billingAddress = try reader["BillingAddress"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.foundByItems = try reader["FoundByItems"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.FoundByKeyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.partyTypeString = try reader["PartyTypeString"].readIfPresent()
        value.genderString = try reader["GenderString"].readIfPresent()
        value.profileType = try reader["ProfileType"].readIfPresent()
        value.engagementPreferences = try reader["EngagementPreferences"].readIfPresent(with: CustomerProfilesClientTypes.EngagementPreferences.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.EngagementPreferences {

    static func write(value: CustomerProfilesClientTypes.EngagementPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].writeList(value.email, memberWritingClosure: CustomerProfilesClientTypes.ContactPreference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phone"].writeList(value.phone, memberWritingClosure: CustomerProfilesClientTypes.ContactPreference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EngagementPreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EngagementPreferences()
        value.phone = try reader["Phone"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ContactPreference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.email = try reader["Email"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ContactPreference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ContactPreference {

    static func write(value: CustomerProfilesClientTypes.ContactPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactType"].write(value.contactType)
        try writer["KeyName"].write(value.keyName)
        try writer["KeyValue"].write(value.keyValue)
        try writer["ProfileId"].write(value.profileId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ContactPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ContactPreference()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.keyValue = try reader["KeyValue"].readIfPresent()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.contactType = try reader["ContactType"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.FoundByKeyValue {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.FoundByKeyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.FoundByKeyValue()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.Address {

    static func write(value: CustomerProfilesClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address1"].write(value.address1)
        try writer["Address2"].write(value.address2)
        try writer["Address3"].write(value.address3)
        try writer["Address4"].write(value.address4)
        try writer["City"].write(value.city)
        try writer["Country"].write(value.country)
        try writer["County"].write(value.county)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Province"].write(value.province)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Address()
        value.address1 = try reader["Address1"].readIfPresent()
        value.address2 = try reader["Address2"].readIfPresent()
        value.address3 = try reader["Address3"].readIfPresent()
        value.address4 = try reader["Address4"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.county = try reader["County"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.province = try reader["Province"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeDetails {

    static func write(value: CustomerProfilesClientTypes.AttributeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: CustomerProfilesClientTypes.AttributeItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeDetails()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.AttributeItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeItem {

    static func write(value: CustomerProfilesClientTypes.AttributeItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeItem()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.Conditions {

    static func write(value: CustomerProfilesClientTypes.Conditions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectCount"].write(value.objectCount)
        try writer["Range"].write(value.range, with: CustomerProfilesClientTypes.Range.write(value:to:))
        try writer["Threshold"].write(value.threshold, with: CustomerProfilesClientTypes.Threshold.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Conditions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Conditions()
        value.range = try reader["Range"].readIfPresent(with: CustomerProfilesClientTypes.Range.read(from:))
        value.objectCount = try reader["ObjectCount"].readIfPresent()
        value.threshold = try reader["Threshold"].readIfPresent(with: CustomerProfilesClientTypes.Threshold.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.Threshold {

    static func write(value: CustomerProfilesClientTypes.Threshold?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Threshold {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Threshold()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CustomerProfilesClientTypes.Range {

    static func write(value: CustomerProfilesClientTypes.Range?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TimestampFormat"].write(value.timestampFormat)
        try writer["TimestampSource"].write(value.timestampSource)
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
        try writer["ValueRange"].write(value.valueRange, with: CustomerProfilesClientTypes.ValueRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Range {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Range()
        value.value = try reader["Value"].readIfPresent() ?? 0
        value.unit = try reader["Unit"].readIfPresent() ?? CustomerProfilesClientTypes.Unit.days
        value.valueRange = try reader["ValueRange"].readIfPresent(with: CustomerProfilesClientTypes.ValueRange.read(from:))
        value.timestampSource = try reader["TimestampSource"].readIfPresent()
        value.timestampFormat = try reader["TimestampFormat"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ValueRange {

    static func write(value: CustomerProfilesClientTypes.ValueRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].write(value.end)
        try writer["Start"].write(value.start)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ValueRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ValueRange()
        value.start = try reader["Start"].readIfPresent() ?? 0
        value.end = try reader["End"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.Filter {

    static func write(value: CustomerProfilesClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Groups"].writeList(value.groups, memberWritingClosure: CustomerProfilesClientTypes.FilterGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Include"].write(value.include)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Filter()
        value.include = try reader["Include"].readIfPresent() ?? .sdkUnknown("")
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.FilterGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.FilterGroup {

    static func write(value: CustomerProfilesClientTypes.FilterGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: CustomerProfilesClientTypes.FilterDimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.FilterGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.FilterGroup()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.FilterDimension.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.FilterDimension {

    static func write(value: CustomerProfilesClientTypes.FilterDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: CustomerProfilesClientTypes.FilterAttributeDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.FilterDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.FilterDimension()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.FilterAttributeDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension CustomerProfilesClientTypes.FilterAttributeDimension {

    static func write(value: CustomerProfilesClientTypes.FilterAttributeDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.FilterAttributeDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.FilterAttributeDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.Readiness {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Readiness {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Readiness()
        value.progressPercentage = try reader["ProgressPercentage"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.MatchingResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.MatchingResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.MatchingResponse()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.jobSchedule = try reader["JobSchedule"].readIfPresent(with: CustomerProfilesClientTypes.JobSchedule.read(from:))
        value.autoMerging = try reader["AutoMerging"].readIfPresent(with: CustomerProfilesClientTypes.AutoMerging.read(from:))
        value.exportingConfig = try reader["ExportingConfig"].readIfPresent(with: CustomerProfilesClientTypes.ExportingConfig.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.ExportingConfig {

    static func write(value: CustomerProfilesClientTypes.ExportingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Exporting"].write(value.s3Exporting, with: CustomerProfilesClientTypes.S3ExportingConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ExportingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ExportingConfig()
        value.s3Exporting = try reader["S3Exporting"].readIfPresent(with: CustomerProfilesClientTypes.S3ExportingConfig.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.S3ExportingConfig {

    static func write(value: CustomerProfilesClientTypes.S3ExportingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyName"].write(value.s3KeyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.S3ExportingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.S3ExportingConfig()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent() ?? ""
        value.s3KeyName = try reader["S3KeyName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.AutoMerging {

    static func write(value: CustomerProfilesClientTypes.AutoMerging?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConflictResolution"].write(value.conflictResolution, with: CustomerProfilesClientTypes.ConflictResolution.write(value:to:))
        try writer["Consolidation"].write(value.consolidation, with: CustomerProfilesClientTypes.Consolidation.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["MinAllowedConfidenceScoreForMerging"].write(value.minAllowedConfidenceScoreForMerging)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AutoMerging {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AutoMerging()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.consolidation = try reader["Consolidation"].readIfPresent(with: CustomerProfilesClientTypes.Consolidation.read(from:))
        value.conflictResolution = try reader["ConflictResolution"].readIfPresent(with: CustomerProfilesClientTypes.ConflictResolution.read(from:))
        value.minAllowedConfidenceScoreForMerging = try reader["MinAllowedConfidenceScoreForMerging"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ConflictResolution {

    static func write(value: CustomerProfilesClientTypes.ConflictResolution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConflictResolvingModel"].write(value.conflictResolvingModel)
        try writer["SourceName"].write(value.sourceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ConflictResolution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ConflictResolution()
        value.conflictResolvingModel = try reader["ConflictResolvingModel"].readIfPresent() ?? .sdkUnknown("")
        value.sourceName = try reader["SourceName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.Consolidation {

    static func write(value: CustomerProfilesClientTypes.Consolidation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchingAttributesList"].writeList(value.matchingAttributesList, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Consolidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Consolidation()
        value.matchingAttributesList = try reader["MatchingAttributesList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.JobSchedule {

    static func write(value: CustomerProfilesClientTypes.JobSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfTheWeek"].write(value.dayOfTheWeek)
        try writer["Time"].write(value.time)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.JobSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.JobSchedule()
        value.dayOfTheWeek = try reader["DayOfTheWeek"].readIfPresent() ?? .sdkUnknown("")
        value.time = try reader["Time"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.RuleBasedMatchingResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.RuleBasedMatchingResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.RuleBasedMatchingResponse()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.matchingRules = try reader["MatchingRules"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.MatchingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.maxAllowedRuleLevelForMerging = try reader["MaxAllowedRuleLevelForMerging"].readIfPresent()
        value.maxAllowedRuleLevelForMatching = try reader["MaxAllowedRuleLevelForMatching"].readIfPresent()
        value.attributeTypesSelector = try reader["AttributeTypesSelector"].readIfPresent(with: CustomerProfilesClientTypes.AttributeTypesSelector.read(from:))
        value.conflictResolution = try reader["ConflictResolution"].readIfPresent(with: CustomerProfilesClientTypes.ConflictResolution.read(from:))
        value.exportingConfig = try reader["ExportingConfig"].readIfPresent(with: CustomerProfilesClientTypes.ExportingConfig.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeTypesSelector {

    static func write(value: CustomerProfilesClientTypes.AttributeTypesSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].writeList(value.address, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttributeMatchingModel"].write(value.attributeMatchingModel)
        try writer["EmailAddress"].writeList(value.emailAddress, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PhoneNumber"].writeList(value.phoneNumber, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeTypesSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeTypesSelector()
        value.attributeMatchingModel = try reader["AttributeMatchingModel"].readIfPresent() ?? .sdkUnknown("")
        value.address = try reader["Address"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.phoneNumber = try reader["PhoneNumber"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.emailAddress = try reader["EmailAddress"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.MatchingRule {

    static func write(value: CustomerProfilesClientTypes.MatchingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rule"].writeList(value.rule, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.MatchingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.MatchingRule()
        value.rule = try reader["Rule"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.EventTriggerCondition {

    static func write(value: CustomerProfilesClientTypes.EventTriggerCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventTriggerDimensions"].writeList(value.eventTriggerDimensions, memberWritingClosure: CustomerProfilesClientTypes.EventTriggerDimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LogicalOperator"].write(value.logicalOperator)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventTriggerCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventTriggerCondition()
        value.eventTriggerDimensions = try reader["EventTriggerDimensions"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventTriggerDimension.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.logicalOperator = try reader["LogicalOperator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CustomerProfilesClientTypes.EventTriggerDimension {

    static func write(value: CustomerProfilesClientTypes.EventTriggerDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectAttributes"].writeList(value.objectAttributes, memberWritingClosure: CustomerProfilesClientTypes.ObjectAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventTriggerDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventTriggerDimension()
        value.objectAttributes = try reader["ObjectAttributes"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ObjectAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.ObjectAttribute {

    static func write(value: CustomerProfilesClientTypes.ObjectAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["FieldName"].write(value.fieldName)
        try writer["Source"].write(value.source)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ObjectAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ObjectAttribute()
        value.source = try reader["Source"].readIfPresent()
        value.fieldName = try reader["FieldName"].readIfPresent()
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.EventTriggerLimits {

    static func write(value: CustomerProfilesClientTypes.EventTriggerLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventExpiration"].write(value.eventExpiration)
        try writer["Periods"].writeList(value.periods, memberWritingClosure: CustomerProfilesClientTypes.Period.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventTriggerLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventTriggerLimits()
        value.eventExpiration = try reader["EventExpiration"].readIfPresent()
        value.periods = try reader["Periods"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.Period.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.Period {

    static func write(value: CustomerProfilesClientTypes.Period?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxInvocationsPerProfile"].write(value.maxInvocationsPerProfile)
        try writer["Unit"].write(value.unit)
        try writer["Unlimited"].write(value.unlimited)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Period {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Period()
        value.unit = try reader["Unit"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? 0
        value.maxInvocationsPerProfile = try reader["MaxInvocationsPerProfile"].readIfPresent()
        value.unlimited = try reader["Unlimited"].readIfPresent() ?? false
        return value
    }
}

extension CustomerProfilesClientTypes.DetectedProfileObjectType {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DetectedProfileObjectType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DetectedProfileObjectType()
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ObjectTypeKey {

    static func write(value: CustomerProfilesClientTypes.ObjectTypeKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldNames"].writeList(value.fieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StandardIdentifiers"].writeList(value.standardIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CustomerProfilesClientTypes.StandardIdentifier>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ObjectTypeKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ObjectTypeKey()
        value.standardIdentifiers = try reader["StandardIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CustomerProfilesClientTypes.StandardIdentifier>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fieldNames = try reader["FieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ObjectTypeField {

    static func write(value: CustomerProfilesClientTypes.ObjectTypeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentType"].write(value.contentType)
        try writer["Source"].write(value.source)
        try writer["Target"].write(value.target)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ObjectTypeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ObjectTypeField()
        value.source = try reader["Source"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.DomainStats {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DomainStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DomainStats()
        value.profileCount = try reader["ProfileCount"].readIfPresent() ?? 0
        value.meteringProfileCount = try reader["MeteringProfileCount"].readIfPresent() ?? 0
        value.objectCount = try reader["ObjectCount"].readIfPresent() ?? 0
        value.totalSize = try reader["TotalSize"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.EventStreamDestinationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventStreamDestinationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventStreamDestinationDetails()
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.unhealthySince = try reader["UnhealthySince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ExportingLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ExportingLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ExportingLocation()
        value.s3Exporting = try reader["S3Exporting"].readIfPresent(with: CustomerProfilesClientTypes.S3ExportingLocation.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.S3ExportingLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.S3ExportingLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.S3ExportingLocation()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyName = try reader["S3KeyName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.JobStats {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.JobStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.JobStats()
        value.numberOfProfilesReviewed = try reader["NumberOfProfilesReviewed"].readIfPresent() ?? 0
        value.numberOfMatchesFound = try reader["NumberOfMatchesFound"].readIfPresent() ?? 0
        value.numberOfMergesDone = try reader["NumberOfMergesDone"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.MatchItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.MatchItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.MatchItem()
        value.matchId = try reader["MatchId"].readIfPresent()
        value.profileIds = try reader["ProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.confidenceScore = try reader["ConfidenceScore"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.SegmentGroup {

    static func write(value: CustomerProfilesClientTypes.SegmentGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Groups"].writeList(value.groups, memberWritingClosure: CustomerProfilesClientTypes.Group.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Include"].write(value.include)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.SegmentGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.SegmentGroup()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.include = try reader["Include"].readIfPresent() ?? CustomerProfilesClientTypes.IncludeOptions.all
        return value
    }
}

extension CustomerProfilesClientTypes.Group {

    static func write(value: CustomerProfilesClientTypes.Group?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: CustomerProfilesClientTypes.Dimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceSegments"].writeList(value.sourceSegments, memberWritingClosure: CustomerProfilesClientTypes.SourceSegment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Group {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Group()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.Dimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceSegments = try reader["SourceSegments"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.SourceSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceType = try reader["SourceType"].readIfPresent() ?? CustomerProfilesClientTypes.IncludeOptions.all
        value.type = try reader["Type"].readIfPresent() ?? CustomerProfilesClientTypes.IncludeOptions.all
        return value
    }
}

extension CustomerProfilesClientTypes.SourceSegment {

    static func write(value: CustomerProfilesClientTypes.SourceSegment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SegmentDefinitionName"].write(value.segmentDefinitionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.SourceSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.SourceSegment()
        value.segmentDefinitionName = try reader["SegmentDefinitionName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.Dimension {

    static func write(value: CustomerProfilesClientTypes.Dimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .calculatedattributes(calculatedattributes):
                try writer["CalculatedAttributes"].writeMap(calculatedattributes, valueWritingClosure: CustomerProfilesClientTypes.CalculatedAttributeDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .profileattributes(profileattributes):
                try writer["ProfileAttributes"].write(profileattributes, with: CustomerProfilesClientTypes.ProfileAttributes.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Dimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ProfileAttributes":
                return .profileattributes(try reader["ProfileAttributes"].read(with: CustomerProfilesClientTypes.ProfileAttributes.read(from:)))
            case "CalculatedAttributes":
                return .calculatedattributes(try reader["CalculatedAttributes"].readMap(valueReadingClosure: CustomerProfilesClientTypes.CalculatedAttributeDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CustomerProfilesClientTypes.CalculatedAttributeDimension {

    static func write(value: CustomerProfilesClientTypes.CalculatedAttributeDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionOverrides"].write(value.conditionOverrides, with: CustomerProfilesClientTypes.ConditionOverrides.write(value:to:))
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.CalculatedAttributeDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.CalculatedAttributeDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.conditionOverrides = try reader["ConditionOverrides"].readIfPresent(with: CustomerProfilesClientTypes.ConditionOverrides.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.ProfileAttributes {

    static func write(value: CustomerProfilesClientTypes.ProfileAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["AdditionalInformation"].write(value.additionalInformation, with: CustomerProfilesClientTypes.ExtraLengthValueProfileDimension.write(value:to:))
        try writer["Address"].write(value.address, with: CustomerProfilesClientTypes.AddressDimension.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: CustomerProfilesClientTypes.AttributeDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress, with: CustomerProfilesClientTypes.AddressDimension.write(value:to:))
        try writer["BirthDate"].write(value.birthDate, with: CustomerProfilesClientTypes.DateDimension.write(value:to:))
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["BusinessName"].write(value.businessName, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["EmailAddress"].write(value.emailAddress, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["FirstName"].write(value.firstName, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["GenderString"].write(value.genderString, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["HomePhoneNumber"].write(value.homePhoneNumber, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["LastName"].write(value.lastName, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["MailingAddress"].write(value.mailingAddress, with: CustomerProfilesClientTypes.AddressDimension.write(value:to:))
        try writer["MiddleName"].write(value.middleName, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["PartyTypeString"].write(value.partyTypeString, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["PhoneNumber"].write(value.phoneNumber, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["ProfileType"].write(value.profileType, with: CustomerProfilesClientTypes.ProfileTypeDimension.write(value:to:))
        try writer["ShippingAddress"].write(value.shippingAddress, with: CustomerProfilesClientTypes.AddressDimension.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ProfileAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ProfileAttributes()
        value.accountNumber = try reader["AccountNumber"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.additionalInformation = try reader["AdditionalInformation"].readIfPresent(with: CustomerProfilesClientTypes.ExtraLengthValueProfileDimension.read(from:))
        value.firstName = try reader["FirstName"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.lastName = try reader["LastName"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.middleName = try reader["MiddleName"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.genderString = try reader["GenderString"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.partyTypeString = try reader["PartyTypeString"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.birthDate = try reader["BirthDate"].readIfPresent(with: CustomerProfilesClientTypes.DateDimension.read(from:))
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.businessName = try reader["BusinessName"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.businessPhoneNumber = try reader["BusinessPhoneNumber"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.homePhoneNumber = try reader["HomePhoneNumber"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.mobilePhoneNumber = try reader["MobilePhoneNumber"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.emailAddress = try reader["EmailAddress"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.personalEmailAddress = try reader["PersonalEmailAddress"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.businessEmailAddress = try reader["BusinessEmailAddress"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.address = try reader["Address"].readIfPresent(with: CustomerProfilesClientTypes.AddressDimension.read(from:))
        value.shippingAddress = try reader["ShippingAddress"].readIfPresent(with: CustomerProfilesClientTypes.AddressDimension.read(from:))
        value.mailingAddress = try reader["MailingAddress"].readIfPresent(with: CustomerProfilesClientTypes.AddressDimension.read(from:))
        value.billingAddress = try reader["BillingAddress"].readIfPresent(with: CustomerProfilesClientTypes.AddressDimension.read(from:))
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.AttributeDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.profileType = try reader["ProfileType"].readIfPresent(with: CustomerProfilesClientTypes.ProfileTypeDimension.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.ProfileTypeDimension {

    static func write(value: CustomerProfilesClientTypes.ProfileTypeDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CustomerProfilesClientTypes.ProfileType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ProfileTypeDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ProfileTypeDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CustomerProfilesClientTypes.ProfileType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeDimension {

    static func write(value: CustomerProfilesClientTypes.AttributeDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.AddressDimension {

    static func write(value: CustomerProfilesClientTypes.AddressDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["City"].write(value.city, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["Country"].write(value.country, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["County"].write(value.county, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["PostalCode"].write(value.postalCode, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["Province"].write(value.province, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
        try writer["State"].write(value.state, with: CustomerProfilesClientTypes.ProfileDimension.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AddressDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AddressDimension()
        value.city = try reader["City"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.country = try reader["Country"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.county = try reader["County"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.postalCode = try reader["PostalCode"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.province = try reader["Province"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        value.state = try reader["State"].readIfPresent(with: CustomerProfilesClientTypes.ProfileDimension.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.ProfileDimension {

    static func write(value: CustomerProfilesClientTypes.ProfileDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ProfileDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ProfileDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.DateDimension {

    static func write(value: CustomerProfilesClientTypes.DateDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DateDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DateDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.ExtraLengthValueProfileDimension {

    static func write(value: CustomerProfilesClientTypes.ExtraLengthValueProfileDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ExtraLengthValueProfileDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ExtraLengthValueProfileDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.ProfileQueryResult {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ProfileQueryResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ProfileQueryResult()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        value.queryResult = try reader["QueryResult"].readIfPresent() ?? .sdkUnknown("")
        value.profile = try reader["Profile"].readIfPresent(with: CustomerProfilesClientTypes.Profile.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.ProfileQueryFailures {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ProfileQueryFailures {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ProfileQueryFailures()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ResultsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ResultsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ResultsSummary()
        value.updatedRecords = try reader["UpdatedRecords"].readIfPresent()
        value.createdRecords = try reader["CreatedRecords"].readIfPresent()
        value.failedRecords = try reader["FailedRecords"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.WorkflowAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.WorkflowAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.WorkflowAttributes()
        value.appflowIntegration = try reader["AppflowIntegration"].readIfPresent(with: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes()
        value.sourceConnectorType = try reader["SourceConnectorType"].readIfPresent() ?? .sdkUnknown("")
        value.connectorProfileName = try reader["ConnectorProfileName"].readIfPresent() ?? ""
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.WorkflowMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.WorkflowMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.WorkflowMetrics()
        value.appflowIntegration = try reader["AppflowIntegration"].readIfPresent(with: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics()
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent() ?? 0
        value.stepsCompleted = try reader["StepsCompleted"].readIfPresent() ?? 0
        value.totalSteps = try reader["TotalSteps"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.WorkflowStepItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.WorkflowStepItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.WorkflowStepItem()
        value.appflowIntegration = try reader["AppflowIntegration"].readIfPresent(with: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep()
        value.flowName = try reader["FlowName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.executionMessage = try reader["ExecutionMessage"].readIfPresent() ?? ""
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent() ?? 0
        value.batchRecordsStartTime = try reader["BatchRecordsStartTime"].readIfPresent() ?? ""
        value.batchRecordsEndTime = try reader["BatchRecordsEndTime"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CustomerProfilesClientTypes.ListIntegrationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListIntegrationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListIntegrationItem()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.objectTypeNames = try reader["ObjectTypeNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.isUnstructured = try reader["IsUnstructured"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.eventTriggerNames = try reader["EventTriggerNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.useHistoricalData = try reader["UseHistoricalData"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.isDataPartial = try reader["IsDataPartial"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.lastObjectTimestamp = try reader["LastObjectTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CustomerProfilesClientTypes.LayoutItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.LayoutItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.LayoutItem()
        value.layoutDefinitionName = try reader["LayoutDefinitionName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent() ?? ""
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.layoutType = try reader["LayoutType"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CustomerProfilesClientTypes.ListDomainItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListDomainItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListDomainItem()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.EventStreamSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventStreamSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventStreamSummary()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.eventStreamName = try reader["EventStreamName"].readIfPresent() ?? ""
        value.eventStreamArn = try reader["EventStreamArn"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.stoppedSince = try reader["StoppedSince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinationSummary = try reader["DestinationSummary"].readIfPresent(with: CustomerProfilesClientTypes.DestinationSummary.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.DestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DestinationSummary()
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.unhealthySince = try reader["UnhealthySince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CustomerProfilesClientTypes.EventTriggerSummaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventTriggerSummaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventTriggerSummaryItem()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.eventTriggerName = try reader["EventTriggerName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.IdentityResolutionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.IdentityResolutionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.IdentityResolutionJob()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.jobStartTime = try reader["JobStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobEndTime = try reader["JobEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobStats = try reader["JobStats"].readIfPresent(with: CustomerProfilesClientTypes.JobStats.read(from:))
        value.exportingLocation = try reader["ExportingLocation"].readIfPresent(with: CustomerProfilesClientTypes.ExportingLocation.read(from:))
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListObjectTypeAttributeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListObjectTypeAttributeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListObjectTypeAttributeItem()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeValueItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeValueItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeValueItem()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListProfileObjectsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListProfileObjectsItem()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.profileObjectUniqueKey = try reader["ProfileObjectUniqueKey"].readIfPresent()
        value.object = try reader["Object"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectTypeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListProfileObjectTypeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListProfileObjectTypeItem()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxProfileObjectCount = try reader["MaxProfileObjectCount"].readIfPresent()
        value.maxAvailableProfileObjectCount = try reader["MaxAvailableProfileObjectCount"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.sourceName = try reader["SourceName"].readIfPresent()
        value.sourceObject = try reader["SourceObject"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.SegmentDefinitionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.SegmentDefinitionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.SegmentDefinitionItem()
        value.segmentDefinitionName = try reader["SegmentDefinitionName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.segmentDefinitionArn = try reader["SegmentDefinitionArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.UploadJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.UploadJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.UploadJobItem()
        value.jobId = try reader["JobId"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedAt = try reader["CompletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataExpiry = try reader["DataExpiry"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListWorkflowsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListWorkflowsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListWorkflowsItem()
        value.workflowType = try reader["WorkflowType"].readIfPresent() ?? .sdkUnknown("")
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusDescription = try reader["StatusDescription"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CustomerProfilesClientTypes.MatchingRequest {

    static func write(value: CustomerProfilesClientTypes.MatchingRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoMerging"].write(value.autoMerging, with: CustomerProfilesClientTypes.AutoMerging.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["ExportingConfig"].write(value.exportingConfig, with: CustomerProfilesClientTypes.ExportingConfig.write(value:to:))
        try writer["JobSchedule"].write(value.jobSchedule, with: CustomerProfilesClientTypes.JobSchedule.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.RuleBasedMatchingRequest {

    static func write(value: CustomerProfilesClientTypes.RuleBasedMatchingRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeTypesSelector"].write(value.attributeTypesSelector, with: CustomerProfilesClientTypes.AttributeTypesSelector.write(value:to:))
        try writer["ConflictResolution"].write(value.conflictResolution, with: CustomerProfilesClientTypes.ConflictResolution.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["ExportingConfig"].write(value.exportingConfig, with: CustomerProfilesClientTypes.ExportingConfig.write(value:to:))
        try writer["MatchingRules"].writeList(value.matchingRules, memberWritingClosure: CustomerProfilesClientTypes.MatchingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxAllowedRuleLevelForMatching"].write(value.maxAllowedRuleLevelForMatching)
        try writer["MaxAllowedRuleLevelForMerging"].write(value.maxAllowedRuleLevelForMerging)
    }
}

extension CustomerProfilesClientTypes.IntegrationConfig {

    static func write(value: CustomerProfilesClientTypes.IntegrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppflowIntegration"].write(value.appflowIntegration, with: CustomerProfilesClientTypes.AppflowIntegration.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.AppflowIntegration {

    static func write(value: CustomerProfilesClientTypes.AppflowIntegration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Batches"].writeList(value.batches, memberWritingClosure: CustomerProfilesClientTypes.Batch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FlowDefinition"].write(value.flowDefinition, with: CustomerProfilesClientTypes.FlowDefinition.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.Batch {

    static func write(value: CustomerProfilesClientTypes.Batch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension CustomerProfilesClientTypes.FlowDefinition {

    static func write(value: CustomerProfilesClientTypes.FlowDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FlowName"].write(value.flowName)
        try writer["KmsArn"].write(value.kmsArn)
        try writer["SourceFlowConfig"].write(value.sourceFlowConfig, with: CustomerProfilesClientTypes.SourceFlowConfig.write(value:to:))
        try writer["Tasks"].writeList(value.tasks, memberWritingClosure: CustomerProfilesClientTypes.Task.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TriggerConfig"].write(value.triggerConfig, with: CustomerProfilesClientTypes.TriggerConfig.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.TriggerConfig {

    static func write(value: CustomerProfilesClientTypes.TriggerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TriggerProperties"].write(value.triggerProperties, with: CustomerProfilesClientTypes.TriggerProperties.write(value:to:))
        try writer["TriggerType"].write(value.triggerType)
    }
}

extension CustomerProfilesClientTypes.TriggerProperties {

    static func write(value: CustomerProfilesClientTypes.TriggerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Scheduled"].write(value.scheduled, with: CustomerProfilesClientTypes.ScheduledTriggerProperties.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.ScheduledTriggerProperties {

    static func write(value: CustomerProfilesClientTypes.ScheduledTriggerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPullMode"].write(value.dataPullMode)
        try writer["FirstExecutionFrom"].writeTimestamp(value.firstExecutionFrom, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ScheduleEndTime"].writeTimestamp(value.scheduleEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["ScheduleStartTime"].writeTimestamp(value.scheduleStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Timezone"].write(value.timezone)
    }
}

extension CustomerProfilesClientTypes.Task {

    static func write(value: CustomerProfilesClientTypes.Task?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorOperator"].write(value.connectorOperator, with: CustomerProfilesClientTypes.ConnectorOperator.write(value:to:))
        try writer["DestinationField"].write(value.destinationField)
        try writer["SourceFields"].writeList(value.sourceFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskProperties"].writeMap(value.taskProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TaskType"].write(value.taskType)
    }
}

extension CustomerProfilesClientTypes.ConnectorOperator {

    static func write(value: CustomerProfilesClientTypes.ConnectorOperator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marketo"].write(value.marketo)
        try writer["S3"].write(value.s3)
        try writer["Salesforce"].write(value.salesforce)
        try writer["ServiceNow"].write(value.serviceNow)
        try writer["Zendesk"].write(value.zendesk)
    }
}

extension CustomerProfilesClientTypes.SourceFlowConfig {

    static func write(value: CustomerProfilesClientTypes.SourceFlowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorProfileName"].write(value.connectorProfileName)
        try writer["ConnectorType"].write(value.connectorType)
        try writer["IncrementalPullConfig"].write(value.incrementalPullConfig, with: CustomerProfilesClientTypes.IncrementalPullConfig.write(value:to:))
        try writer["SourceConnectorProperties"].write(value.sourceConnectorProperties, with: CustomerProfilesClientTypes.SourceConnectorProperties.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.SourceConnectorProperties {

    static func write(value: CustomerProfilesClientTypes.SourceConnectorProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marketo"].write(value.marketo, with: CustomerProfilesClientTypes.MarketoSourceProperties.write(value:to:))
        try writer["S3"].write(value.s3, with: CustomerProfilesClientTypes.S3SourceProperties.write(value:to:))
        try writer["Salesforce"].write(value.salesforce, with: CustomerProfilesClientTypes.SalesforceSourceProperties.write(value:to:))
        try writer["ServiceNow"].write(value.serviceNow, with: CustomerProfilesClientTypes.ServiceNowSourceProperties.write(value:to:))
        try writer["Zendesk"].write(value.zendesk, with: CustomerProfilesClientTypes.ZendeskSourceProperties.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.ZendeskSourceProperties {

    static func write(value: CustomerProfilesClientTypes.ZendeskSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.ServiceNowSourceProperties {

    static func write(value: CustomerProfilesClientTypes.ServiceNowSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.SalesforceSourceProperties {

    static func write(value: CustomerProfilesClientTypes.SalesforceSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableDynamicFieldUpdate"].write(value.enableDynamicFieldUpdate)
        try writer["IncludeDeletedRecords"].write(value.includeDeletedRecords)
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.S3SourceProperties {

    static func write(value: CustomerProfilesClientTypes.S3SourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["BucketPrefix"].write(value.bucketPrefix)
    }
}

extension CustomerProfilesClientTypes.MarketoSourceProperties {

    static func write(value: CustomerProfilesClientTypes.MarketoSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.IncrementalPullConfig {

    static func write(value: CustomerProfilesClientTypes.IncrementalPullConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatetimeTypeFieldName"].write(value.datetimeTypeFieldName)
    }
}

extension CustomerProfilesClientTypes.SegmentGroupStructure {

    static func write(value: CustomerProfilesClientTypes.SegmentGroupStructure?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Groups"].writeList(value.groups, memberWritingClosure: CustomerProfilesClientTypes.Group.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Include"].write(value.include)
    }
}

extension CustomerProfilesClientTypes.ObjectFilter {

    static func write(value: CustomerProfilesClientTypes.ObjectFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CustomerProfilesClientTypes.FieldSourceProfileIds {

    static func write(value: CustomerProfilesClientTypes.FieldSourceProfileIds?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber)
        try writer["AdditionalInformation"].write(value.additionalInformation)
        try writer["Address"].write(value.address)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress)
        try writer["BirthDate"].write(value.birthDate)
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress)
        try writer["BusinessName"].write(value.businessName)
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["EngagementPreferences"].write(value.engagementPreferences)
        try writer["FirstName"].write(value.firstName)
        try writer["Gender"].write(value.gender)
        try writer["HomePhoneNumber"].write(value.homePhoneNumber)
        try writer["LastName"].write(value.lastName)
        try writer["MailingAddress"].write(value.mailingAddress)
        try writer["MiddleName"].write(value.middleName)
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["PartyType"].write(value.partyType)
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["ProfileType"].write(value.profileType)
        try writer["ShippingAddress"].write(value.shippingAddress)
    }
}

extension CustomerProfilesClientTypes.AdditionalSearchKey {

    static func write(value: CustomerProfilesClientTypes.AdditionalSearchKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CustomerProfilesClientTypes.UpdateAddress {

    static func write(value: CustomerProfilesClientTypes.UpdateAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address1"].write(value.address1)
        try writer["Address2"].write(value.address2)
        try writer["Address3"].write(value.address3)
        try writer["Address4"].write(value.address4)
        try writer["City"].write(value.city)
        try writer["Country"].write(value.country)
        try writer["County"].write(value.county)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Province"].write(value.province)
        try writer["State"].write(value.state)
    }
}

public enum CustomerProfilesClientTypes {}
