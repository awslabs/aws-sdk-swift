//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CustomerProfilesClientTypes {

    /// A data type pair that consists of a KeyName and Values list that is used in conjunction with the [KeyName](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html#customerprofiles-SearchProfiles-request-KeyName) and [Values](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html#customerprofiles-SearchProfiles-request-Values) parameters to search for profiles using the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) API.
    public struct AdditionalSearchKey: Swift.Sendable {
        /// A searchable identifier of a customer profile.
        /// This member is required.
        public var keyName: Swift.String?
        /// A list of key values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.keyName = keyName
            self.values = values
        }
    }
}

/// The input you provided is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal service error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You exceeded the maximum number of requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AddProfileKeyInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile. The predefined keys you can use include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
    /// This member is required.
    public var keyName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

public struct AddProfileKeyOutput: Swift.Sendable {
    /// A searchable identifier of a customer profile.
    public var keyName: Swift.String?
    /// A list of key values.
    public var values: [Swift.String]?

    public init(
        keyName: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.keyName = keyName
        self.values = values
    }
}

extension CustomerProfilesClientTypes {

    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public struct Address: Swift.Sendable {
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            province: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }
}

extension CustomerProfilesClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    /// Batch defines the boundaries for ingestion for each step in APPFLOW_INTEGRATION workflow. APPFLOW_INTEGRATION workflow splits ingestion based on these boundaries.
    public struct Batch: Swift.Sendable {
        /// End time of batch to split ingestion.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// Start time of batch to split ingestion.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum SourceConnectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case marketo
        case s3
        case salesforce
        case servicenow
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceConnectorType] {
            return [
                .marketo,
                .s3,
                .salesforce,
                .servicenow,
                .zendesk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .marketo: return "Marketo"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .servicenow: return "Servicenow"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the configuration used when importing incremental records from the source.
    public struct IncrementalPullConfig: Swift.Sendable {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public var datetimeTypeFieldName: Swift.String?

        public init(
            datetimeTypeFieldName: Swift.String? = nil
        )
        {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when Marketo is being used as a source.
    public struct MarketoSourceProperties: Swift.Sendable {
        /// The object specified in the Marketo flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when Amazon S3 is being used as the flow source.
    public struct S3SourceProperties: Swift.Sendable {
        /// The Amazon S3 bucket name where the source files are stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public var bucketPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when Salesforce is being used as a source.
    public struct SalesforceSourceProperties: Swift.Sendable {
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public var enableDynamicFieldUpdate: Swift.Bool
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public var includeDeletedRecords: Swift.Bool
        /// The object specified in the Salesforce flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when ServiceNow is being used as a source.
    public struct ServiceNowSourceProperties: Swift.Sendable {
        /// The object specified in the ServiceNow flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The properties that are applied when using Zendesk as a flow source.
    public struct ZendeskSourceProperties: Swift.Sendable {
        /// The object specified in the Zendesk flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the information that is required to query a particular Amazon AppFlow connector. Customer Profiles supports Salesforce, Zendesk, Marketo, ServiceNow and Amazon S3.
    public struct SourceConnectorProperties: Swift.Sendable {
        /// The properties that are applied when Marketo is being used as a source.
        public var marketo: CustomerProfilesClientTypes.MarketoSourceProperties?
        /// The properties that are applied when Amazon S3 is being used as the flow source.
        public var s3: CustomerProfilesClientTypes.S3SourceProperties?
        /// The properties that are applied when Salesforce is being used as a source.
        public var salesforce: CustomerProfilesClientTypes.SalesforceSourceProperties?
        /// The properties that are applied when ServiceNow is being used as a source.
        public var serviceNow: CustomerProfilesClientTypes.ServiceNowSourceProperties?
        /// The properties that are applied when using Zendesk as a flow source.
        public var zendesk: CustomerProfilesClientTypes.ZendeskSourceProperties?

        public init(
            marketo: CustomerProfilesClientTypes.MarketoSourceProperties? = nil,
            s3: CustomerProfilesClientTypes.S3SourceProperties? = nil,
            salesforce: CustomerProfilesClientTypes.SalesforceSourceProperties? = nil,
            serviceNow: CustomerProfilesClientTypes.ServiceNowSourceProperties? = nil,
            zendesk: CustomerProfilesClientTypes.ZendeskSourceProperties? = nil
        )
        {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Contains information about the configuration of the source connector used in the flow.
    public struct SourceFlowConfig: Swift.Sendable {
        /// The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Marketo, and so on.
        /// This member is required.
        public var connectorType: CustomerProfilesClientTypes.SourceConnectorType?
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public var incrementalPullConfig: CustomerProfilesClientTypes.IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        /// This member is required.
        public var sourceConnectorProperties: CustomerProfilesClientTypes.SourceConnectorProperties?

        public init(
            connectorProfileName: Swift.String? = nil,
            connectorType: CustomerProfilesClientTypes.SourceConnectorType? = nil,
            incrementalPullConfig: CustomerProfilesClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: CustomerProfilesClientTypes.SourceConnectorProperties? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum MarketoConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum S3ConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum SalesforceConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ServiceNowConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ZendeskConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The operation to be performed on the provided source fields.
    public struct ConnectorOperator: Swift.Sendable {
        /// The operation to be performed on the provided Marketo source fields.
        public var marketo: CustomerProfilesClientTypes.MarketoConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public var s3: CustomerProfilesClientTypes.S3ConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public var salesforce: CustomerProfilesClientTypes.SalesforceConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public var serviceNow: CustomerProfilesClientTypes.ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public var zendesk: CustomerProfilesClientTypes.ZendeskConnectorOperator?

        public init(
            marketo: CustomerProfilesClientTypes.MarketoConnectorOperator? = nil,
            s3: CustomerProfilesClientTypes.S3ConnectorOperator? = nil,
            salesforce: CustomerProfilesClientTypes.SalesforceConnectorOperator? = nil,
            serviceNow: CustomerProfilesClientTypes.ServiceNowConnectorOperator? = nil,
            zendesk: CustomerProfilesClientTypes.ZendeskConnectorOperator? = nil
        )
        {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum OperatorPropertiesKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum TaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mask
        case merge
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mask,
                .merge,
                .truncate,
                .validate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// A class for modeling different type of tasks. Task implementation varies based on the TaskType.
    public struct Task: Swift.Sendable {
        /// The operation to be performed on the provided source fields.
        public var connectorOperator: CustomerProfilesClientTypes.ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public var destinationField: Swift.String?
        /// The source fields to which a particular task is applied.
        /// This member is required.
        public var sourceFields: [Swift.String]?
        /// A map used to store task-related information. The service looks for particular information based on the TaskType.
        public var taskProperties: [Swift.String: Swift.String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// This member is required.
        public var taskType: CustomerProfilesClientTypes.TaskType?

        public init(
            connectorOperator: CustomerProfilesClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String: Swift.String]? = nil,
            taskType: CustomerProfilesClientTypes.TaskType? = nil
        )
        {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum DataPullMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the configuration details of a scheduled-trigger flow that you define. Currently, these settings only apply to the scheduled-trigger type.
    public struct ScheduledTriggerProperties: Swift.Sendable {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public var dataPullMode: CustomerProfilesClientTypes.DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public var firstExecutionFrom: Foundation.Date?
        /// Specifies the scheduled end time for a scheduled-trigger flow.
        public var scheduleEndTime: Foundation.Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public var scheduleOffset: Swift.Int?
        /// Specifies the scheduled start time for a scheduled-trigger flow.
        public var scheduleStartTime: Foundation.Date?
        /// Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        public var timezone: Swift.String?

        public init(
            dataPullMode: CustomerProfilesClientTypes.DataPullMode? = nil,
            firstExecutionFrom: Foundation.Date? = nil,
            scheduleEndTime: Foundation.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = 0,
            scheduleStartTime: Foundation.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the Scheduled trigger type.
    public struct TriggerProperties: Swift.Sendable {
        /// Specifies the configuration details of a schedule-triggered flow that you define.
        public var scheduled: CustomerProfilesClientTypes.ScheduledTriggerProperties?

        public init(
            scheduled: CustomerProfilesClientTypes.ScheduledTriggerProperties? = nil
        )
        {
            self.scheduled = scheduled
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum TriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    public struct TriggerConfig: Swift.Sendable {
        /// Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        public var triggerProperties: CustomerProfilesClientTypes.TriggerProperties?
        /// Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        /// This member is required.
        public var triggerType: CustomerProfilesClientTypes.TriggerType?

        public init(
            triggerProperties: CustomerProfilesClientTypes.TriggerProperties? = nil,
            triggerType: CustomerProfilesClientTypes.TriggerType? = nil
        )
        {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The configurations that control how Customer Profiles retrieves data from the source, Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of customers.
    public struct FlowDefinition: Swift.Sendable {
        /// A description of the flow you want to create.
        public var description: Swift.String?
        /// The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        /// This member is required.
        public var flowName: Swift.String?
        /// The Amazon Resource Name of the AWS Key Management Service (KMS) key you provide for encryption.
        /// This member is required.
        public var kmsArn: Swift.String?
        /// The configuration that controls how Customer Profiles retrieves data from the source.
        /// This member is required.
        public var sourceFlowConfig: CustomerProfilesClientTypes.SourceFlowConfig?
        /// A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        /// This member is required.
        public var tasks: [CustomerProfilesClientTypes.Task]?
        /// The trigger settings that determine how and when the flow runs.
        /// This member is required.
        public var triggerConfig: CustomerProfilesClientTypes.TriggerConfig?

        public init(
            description: Swift.String? = nil,
            flowName: Swift.String? = nil,
            kmsArn: Swift.String? = nil,
            sourceFlowConfig: CustomerProfilesClientTypes.SourceFlowConfig? = nil,
            tasks: [CustomerProfilesClientTypes.Task]? = nil,
            triggerConfig: CustomerProfilesClientTypes.TriggerConfig? = nil
        )
        {
            self.description = description
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }
    }
}

extension CustomerProfilesClientTypes.FlowDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    /// Details for workflow of type APPFLOW_INTEGRATION.
    public struct AppflowIntegration: Swift.Sendable {
        /// Batches in workflow of type APPFLOW_INTEGRATION.
        public var batches: [CustomerProfilesClientTypes.Batch]?
        /// The configurations that control how Customer Profiles retrieves data from the source, Amazon AppFlow. Customer Profiles uses this information to create an AppFlow flow on behalf of customers.
        /// This member is required.
        public var flowDefinition: CustomerProfilesClientTypes.FlowDefinition?

        public init(
            batches: [CustomerProfilesClientTypes.Batch]? = nil,
            flowDefinition: CustomerProfilesClientTypes.FlowDefinition? = nil
        )
        {
            self.batches = batches
            self.flowDefinition = flowDefinition
        }
    }
}

extension CustomerProfilesClientTypes.AppflowIntegration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppflowIntegration(batches: \(Swift.String(describing: batches)), flowDefinition: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Structure holding all APPFLOW_INTEGRATION specific workflow attributes.
    public struct AppflowIntegrationWorkflowAttributes: Swift.Sendable {
        /// The name of the AppFlow connector profile used for ingestion.
        /// This member is required.
        public var connectorProfileName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
        public var roleArn: Swift.String?
        /// Specifies the source connector type, such as Salesforce, ServiceNow, and Marketo. Indicates source of ingestion.
        /// This member is required.
        public var sourceConnectorType: CustomerProfilesClientTypes.SourceConnectorType?

        public init(
            connectorProfileName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sourceConnectorType: CustomerProfilesClientTypes.SourceConnectorType? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.roleArn = roleArn
            self.sourceConnectorType = sourceConnectorType
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Workflow specific execution metrics for APPFLOW_INTEGRATION workflow.
    public struct AppflowIntegrationWorkflowMetrics: Swift.Sendable {
        /// Number of records processed in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var recordsProcessed: Swift.Int
        /// Total steps completed in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var stepsCompleted: Swift.Int
        /// Total steps in APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var totalSteps: Swift.Int

        public init(
            recordsProcessed: Swift.Int = 0,
            stepsCompleted: Swift.Int = 0,
            totalSteps: Swift.Int = 0
        )
        {
            self.recordsProcessed = recordsProcessed
            self.stepsCompleted = stepsCompleted
            self.totalSteps = totalSteps
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case complete
        case failed
        case inProgress
        case notStarted
        case retry
        case split
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .cancelled,
                .complete,
                .failed,
                .inProgress,
                .notStarted,
                .retry,
                .split
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .retry: return "RETRY"
            case .split: return "SPLIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Workflow step details for APPFLOW_INTEGRATION workflow.
    public struct AppflowIntegrationWorkflowStep: Swift.Sendable {
        /// End datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var batchRecordsEndTime: Swift.String?
        /// Start datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var batchRecordsStartTime: Swift.String?
        /// Creation timestamp of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Message indicating execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var executionMessage: Swift.String?
        /// Name of the flow created during execution of workflow step. APPFLOW_INTEGRATION workflow type creates an appflow flow during workflow step execution on the customers behalf.
        /// This member is required.
        public var flowName: Swift.String?
        /// Last updated timestamp for workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// Total number of records processed during execution of workflow step for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var recordsProcessed: Swift.Int
        /// Workflow step status for APPFLOW_INTEGRATION workflow.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.Status?

        public init(
            batchRecordsEndTime: Swift.String? = nil,
            batchRecordsStartTime: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            executionMessage: Swift.String? = nil,
            flowName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            recordsProcessed: Swift.Int = 0,
            status: CustomerProfilesClientTypes.Status? = nil
        )
        {
            self.batchRecordsEndTime = batchRecordsEndTime
            self.batchRecordsStartTime = batchRecordsStartTime
            self.createdAt = createdAt
            self.executionMessage = executionMessage
            self.flowName = flowName
            self.lastUpdatedAt = lastUpdatedAt
            self.recordsProcessed = recordsProcessed
            self.status = status
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The details of a single attribute item specified in the mathematical expression.
    public struct AttributeItem: Swift.Sendable {
        /// The name of an attribute defined in a profile object type.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Mathematical expression and a list of attribute items specified in that expression.
    public struct AttributeDetails: Swift.Sendable {
        /// A list of attribute items specified in the mathematical expression.
        /// This member is required.
        public var attributes: [CustomerProfilesClientTypes.AttributeItem]?
        /// Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \"{ObjectTypeName.AttributeName}\".
        /// This member is required.
        public var expression: Swift.String?

        public init(
            attributes: [CustomerProfilesClientTypes.AttributeItem]? = nil,
            expression: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.expression = expression
        }
    }
}

extension CustomerProfilesClientTypes.AttributeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    public enum AttributeMatchingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles. You can choose how profiles are compared across attribute types and which attribute to use for matching from each type. There are three attribute types you can configure:
    ///
    /// * Email type
    ///
    /// * You can choose from Email, BusinessEmail, and PersonalEmail
    ///
    ///
    ///
    ///
    /// * Phone number type
    ///
    /// * You can choose from Phone, HomePhone, and MobilePhone
    ///
    ///
    ///
    ///
    /// * Address type
    ///
    /// * You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress
    ///
    ///
    ///
    ///
    ///
    /// You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attribute across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
    public struct AttributeTypesSelector: Swift.Sendable {
        /// The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        public var address: [Swift.String]?
        /// Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        /// This member is required.
        public var attributeMatchingModel: CustomerProfilesClientTypes.AttributeMatchingModel?
        /// The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        public var emailAddress: [Swift.String]?
        /// The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        public var phoneNumber: [Swift.String]?

        public init(
            address: [Swift.String]? = nil,
            attributeMatchingModel: CustomerProfilesClientTypes.AttributeMatchingModel? = nil,
            emailAddress: [Swift.String]? = nil,
            phoneNumber: [Swift.String]? = nil
        )
        {
            self.address = address
            self.attributeMatchingModel = attributeMatchingModel
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum ConflictResolvingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case recency
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictResolvingModel] {
            return [
                .recency,
                .source
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .recency: return "RECENCY"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// How the auto-merging process should resolve conflicts between different profiles.
    public struct ConflictResolution: Swift.Sendable {
        /// How the auto-merging process should resolve conflicts between different profiles.
        ///
        /// * RECENCY: Uses the data that was most recently updated.
        ///
        /// * SOURCE: Uses the data from a specific source. For example, if a company has been aquired or two departments have merged, data from the specified source is used. If two duplicate profiles are from the same source, then RECENCY is used again.
        /// This member is required.
        public var conflictResolvingModel: CustomerProfilesClientTypes.ConflictResolvingModel?
        /// The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        public var sourceName: Swift.String?

        public init(
            conflictResolvingModel: CustomerProfilesClientTypes.ConflictResolvingModel? = nil,
            sourceName: Swift.String? = nil
        )
        {
            self.conflictResolvingModel = conflictResolvingModel
            self.sourceName = sourceName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The matching criteria to be used during the auto-merging process.
    public struct Consolidation: Swift.Sendable {
        /// A list of matching criteria.
        /// This member is required.
        public var matchingAttributesList: [[Swift.String]]?

        public init(
            matchingAttributesList: [[Swift.String]]? = nil
        )
        {
            self.matchingAttributesList = matchingAttributesList
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration settings for how to perform the auto-merging of profiles.
    public struct AutoMerging: Swift.Sendable {
        /// How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used?
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        public var consolidation: CustomerProfilesClientTypes.Consolidation?
        /// The flag that enables the auto-merging of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        public var minAllowedConfidenceScoreForMerging: Swift.Double?

        public init(
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            consolidation: CustomerProfilesClientTypes.Consolidation? = nil,
            enabled: Swift.Bool? = nil,
            minAllowedConfidenceScoreForMerging: Swift.Double? = nil
        )
        {
            self.conflictResolution = conflictResolution
            self.consolidation = consolidation
            self.enabled = enabled
            self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The details of a single calculated attribute definition.
    public struct ListCalculatedAttributeDefinitionItem: Swift.Sendable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The threshold for the calculated attribute.
        public var createdAt: Foundation.Date?
        /// The threshold for the calculated attribute.
        public var description: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public var lastUpdatedAt: Foundation.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.calculatedAttributeName = calculatedAttributeName
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCalculatedAttributeDefinitionItem(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// The details of a single calculated attribute for a profile.
    public struct ListCalculatedAttributeForProfileItem: Swift.Sendable {
        /// The unique name of the calculated attribute.
        public var calculatedAttributeName: Swift.String?
        /// The display name of the calculated attribute.
        public var displayName: Swift.String?
        /// Indicates whether the calculated attribute’s value is based on partial data. If data is partial, it is set to true.
        public var isDataPartial: Swift.String?
        /// The value of the calculated attribute.
        public var value: Swift.String?

        public init(
            calculatedAttributeName: Swift.String? = nil,
            displayName: Swift.String? = nil,
            isDataPartial: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Unit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The relative time period over which data is included in the aggregation.
    public struct Range: Swift.Sendable {
        /// The unit of time.
        /// This member is required.
        public var unit: CustomerProfilesClientTypes.Unit?
        /// The amount of time of the specified unit.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            unit: CustomerProfilesClientTypes.Unit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case notEqualTo
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan,
                .notEqualTo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The threshold for the calculated attribute.
    public struct Threshold: Swift.Sendable {
        /// The operator of the threshold.
        /// This member is required.
        public var `operator`: CustomerProfilesClientTypes.Operator?
        /// The value of the threshold.
        /// This member is required.
        public var value: Swift.String?

        public init(
            `operator`: CustomerProfilesClientTypes.Operator? = nil,
            value: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The conditions including range, object count, and threshold for the calculated attribute.
    public struct Conditions: Swift.Sendable {
        /// The number of profile objects used for the calculated attribute.
        public var objectCount: Swift.Int?
        /// The relative time period over which data is included in the aggregation.
        public var range: CustomerProfilesClientTypes.Range?
        /// The threshold for the calculated attribute.
        public var threshold: CustomerProfilesClientTypes.Threshold?

        public init(
            objectCount: Swift.Int? = nil,
            range: CustomerProfilesClientTypes.Range? = nil,
            threshold: CustomerProfilesClientTypes.Threshold? = nil
        )
        {
            self.objectCount = objectCount
            self.range = range
            self.threshold = threshold
        }
    }
}

extension CustomerProfilesClientTypes.Conditions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CustomerProfilesClientTypes {

    public enum Statistic: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case firstOccurrence
        case lastOccurrence
        case maximum
        case maxOccurrence
        case minimum
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [Statistic] {
            return [
                .average,
                .count,
                .firstOccurrence,
                .lastOccurrence,
                .maximum,
                .maxOccurrence,
                .minimum,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .firstOccurrence: return "FIRST_OCCURRENCE"
            case .lastOccurrence: return "LAST_OCCURRENCE"
            case .maximum: return "MAXIMUM"
            case .maxOccurrence: return "MAX_OCCURRENCE"
            case .minimum: return "MINIMUM"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    /// This member is required.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The aggregation operation to perform for the calculated attribute.
    /// This member is required.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
        self.statistic = statistic
        self.tags = tags
    }
}

extension CreateCalculatedAttributeDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCalculatedAttributeDefinitionInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

public struct CreateCalculatedAttributeDefinitionOutput: Swift.Sendable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.statistic = statistic
        self.tags = tags
    }
}

extension CreateCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    /// Configuration information about the S3 bucket where Identity Resolution Jobs write result files.
    public struct S3ExportingConfig: Swift.Sendable {
        /// The name of the S3 bucket where Identity Resolution Jobs write result files.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public var s3KeyName: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyName: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
    public struct ExportingConfig: Swift.Sendable {
        /// The S3 location where Identity Resolution Jobs write result files.
        public var s3Exporting: CustomerProfilesClientTypes.S3ExportingConfig?

        public init(
            s3Exporting: CustomerProfilesClientTypes.S3ExportingConfig? = nil
        )
        {
            self.s3Exporting = s3Exporting
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum JobScheduleDayOfTheWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [JobScheduleDayOfTheWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The day and time when do you want to start the Identity Resolution Job every week.
    public struct JobSchedule: Swift.Sendable {
        /// The day when the Identity Resolution Job should run every week.
        /// This member is required.
        public var dayOfTheWeek: CustomerProfilesClientTypes.JobScheduleDayOfTheWeek?
        /// The time when the Identity Resolution Job should run every week.
        /// This member is required.
        public var time: Swift.String?

        public init(
            dayOfTheWeek: CustomerProfilesClientTypes.JobScheduleDayOfTheWeek? = nil,
            time: Swift.String? = nil
        )
        {
            self.dayOfTheWeek = dayOfTheWeek
            self.time = time
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The flag that enables the matching process of duplicate profiles.
    public struct MatchingRequest: Swift.Sendable {
        /// Configuration information about the auto-merging process.
        public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public var jobSchedule: CustomerProfilesClientTypes.JobSchedule?

        public init(
            autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            jobSchedule: CustomerProfilesClientTypes.JobSchedule? = nil
        )
        {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Specifies how does the rule-based matching process should match profiles. You can choose from the following attributes to build the matching Rule:
    ///
    /// * AccountNumber
    ///
    /// * Address.Address
    ///
    /// * Address.City
    ///
    /// * Address.Country
    ///
    /// * Address.County
    ///
    /// * Address.PostalCode
    ///
    /// * Address.State
    ///
    /// * Address.Province
    ///
    /// * BirthDate
    ///
    /// * BusinessName
    ///
    /// * EmailAddress
    ///
    /// * FirstName
    ///
    /// * Gender
    ///
    /// * LastName
    ///
    /// * MiddleName
    ///
    /// * PhoneNumber
    ///
    /// * Any customized profile attributes that start with the Attributes
    public struct MatchingRule: Swift.Sendable {
        /// A single rule level of the MatchRules. Configures how the rule-based matching process should match profiles.
        /// This member is required.
        public var rule: [Swift.String]?

        public init(
            rule: [Swift.String]? = nil
        )
        {
            self.rule = rule
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The request to enable the rule-based matching.
    public struct RuleBasedMatchingRequest: Swift.Sendable {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public var attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector?
        /// How the auto-merging process should resolve conflicts between different profiles.
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public var matchingRules: [CustomerProfilesClientTypes.MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public var maxAllowedRuleLevelForMatching: Swift.Int?
        /// [MatchingRule](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_MatchingRule.html)
        public var maxAllowedRuleLevelForMerging: Swift.Int?

        public init(
            attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector? = nil,
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            matchingRules: [CustomerProfilesClientTypes.MatchingRule]? = nil,
            maxAllowedRuleLevelForMatching: Swift.Int? = nil,
            maxAllowedRuleLevelForMerging: Swift.Int? = nil
        )
        {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
        }
    }
}

public struct CreateDomainInput: Swift.Sendable {
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    /// This member is required.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingRequest?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        matching: CustomerProfilesClientTypes.MatchingRequest? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

extension CustomerProfilesClientTypes {

    /// The flag that enables the matching process of duplicate profiles.
    public struct MatchingResponse: Swift.Sendable {
        /// Configuration information about the auto-merging process.
        public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        public var enabled: Swift.Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public var jobSchedule: CustomerProfilesClientTypes.JobSchedule?

        public init(
            autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            jobSchedule: CustomerProfilesClientTypes.JobSchedule? = nil
        )
        {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum RuleBasedMatchingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleBasedMatchingStatus] {
            return [
                .active,
                .inProgress,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The response of the Rule-based matching request.
    public struct RuleBasedMatchingResponse: Swift.Sendable {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public var attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector?
        /// How the auto-merging process should resolve conflicts between different profiles.
        public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        public var enabled: Swift.Bool?
        /// Configuration information about the S3 bucket where Identity Resolution Jobs writes result files. You need to give Customer Profiles service principal write permission to your S3 bucket. Otherwise, you'll get an exception in the API response. For an example policy, see [Amazon Connect Customer Profiles cross-service confused deputy prevention](https://docs.aws.amazon.com/connect/latest/adminguide/cross-service-confused-deputy-prevention.html#customer-profiles-cross-service).
        public var exportingConfig: CustomerProfilesClientTypes.ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public var matchingRules: [CustomerProfilesClientTypes.MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public var maxAllowedRuleLevelForMatching: Swift.Int?
        /// [MatchingRule](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_MatchingRule.html)
        public var maxAllowedRuleLevelForMerging: Swift.Int?
        /// PENDING
        ///
        /// * The first status after configuration a rule-based matching rule. If it is an existing domain, the rule-based Identity Resolution waits one hour before creating the matching rule. If it is a new domain, the system will skip the PENDING stage.
        ///
        ///
        /// IN_PROGRESS
        ///
        /// * The system is creating the rule-based matching rule. Under this status, the system is evaluating the existing data and you can no longer change the Rule-based matching configuration.
        ///
        ///
        /// ACTIVE
        ///
        /// * The rule is ready to use. You can change the rule a day after the status is in ACTIVE.
        public var status: CustomerProfilesClientTypes.RuleBasedMatchingStatus?

        public init(
            attributeTypesSelector: CustomerProfilesClientTypes.AttributeTypesSelector? = nil,
            conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
            enabled: Swift.Bool? = nil,
            exportingConfig: CustomerProfilesClientTypes.ExportingConfig? = nil,
            matchingRules: [CustomerProfilesClientTypes.MatchingRule]? = nil,
            maxAllowedRuleLevelForMatching: Swift.Int? = nil,
            maxAllowedRuleLevelForMerging: Swift.Int? = nil,
            status: CustomerProfilesClientTypes.RuleBasedMatchingStatus? = nil
        )
        {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
            self.status = status
        }
    }
}

public struct CreateDomainOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    /// This member is required.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

public struct CreateEventStreamInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream.
    /// This member is required.
    public var eventStreamName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
        self.tags = tags
        self.uri = uri
    }
}

public struct CreateEventStreamOutput: Swift.Sendable {
    /// A unique identifier for the event stream.
    /// This member is required.
    public var eventStreamArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        eventStreamArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.eventStreamArn = eventStreamArn
        self.tags = tags
    }
}

extension CustomerProfilesClientTypes {

    /// Configuration data for integration workflow.
    public struct IntegrationConfig: Swift.Sendable {
        /// Configuration data for APPFLOW_INTEGRATION workflow type.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegration?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegration? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum WorkflowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appflowIntegration
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .appflowIntegration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appflowIntegration: return "APPFLOW_INTEGRATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIntegrationWorkflowInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration data for integration workflow.
    /// This member is required.
    public var integrationConfig: CustomerProfilesClientTypes.IntegrationConfig?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    /// This member is required.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        domainName: Swift.String? = nil,
        integrationConfig: CustomerProfilesClientTypes.IntegrationConfig? = nil,
        objectTypeName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.domainName = domainName
        self.integrationConfig = integrationConfig
        self.objectTypeName = objectTypeName
        self.roleArn = roleArn
        self.tags = tags
        self.workflowType = workflowType
    }
}

public struct CreateIntegrationWorkflowOutput: Swift.Sendable {
    /// A message indicating create request was received.
    /// This member is required.
    public var message: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        message: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.message = message
        self.workflowId = workflowId
    }
}

extension CustomerProfilesClientTypes {

    @available(*, deprecated)
    public enum Gender: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case female
        case male
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [Gender] {
            return [
                .female,
                .male,
                .unspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .female: return "FEMALE"
            case .male: return "MALE"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    @available(*, deprecated)
    public enum PartyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case individual
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [PartyType] {
            return [
                .business,
                .individual,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "BUSINESS"
            case .individual: return "INDIVIDUAL"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProfileInput: Swift.Sendable {
    /// An account number that you have given to the customer.
    public var accountNumber: Swift.String?
    /// Any additional information relevant to the customer’s profile.
    public var additionalInformation: Swift.String?
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public var address: CustomerProfilesClientTypes.Address?
    /// A key value pair of attributes of a customer profile.
    public var attributes: [Swift.String: Swift.String]?
    /// The customer’s billing address.
    public var billingAddress: CustomerProfilesClientTypes.Address?
    /// The customer’s birth date.
    public var birthDate: Swift.String?
    /// The customer’s business email address.
    public var businessEmailAddress: Swift.String?
    /// The name of the customer’s business.
    public var businessName: Swift.String?
    /// The customer’s business phone number.
    public var businessPhoneNumber: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customer’s email address, which has not been specified as a personal or business address.
    public var emailAddress: Swift.String?
    /// The customer’s first name.
    public var firstName: Swift.String?
    /// The gender with which the customer identifies.
    @available(*, deprecated)
    public var gender: CustomerProfilesClientTypes.Gender?
    /// An alternative to Gender which accepts any string as input.
    public var genderString: Swift.String?
    /// The customer’s home phone number.
    public var homePhoneNumber: Swift.String?
    /// The customer’s last name.
    public var lastName: Swift.String?
    /// The customer’s mailing address.
    public var mailingAddress: CustomerProfilesClientTypes.Address?
    /// The customer’s middle name.
    public var middleName: Swift.String?
    /// The customer’s mobile phone number.
    public var mobilePhoneNumber: Swift.String?
    /// The type of profile used to describe the customer.
    @available(*, deprecated)
    public var partyType: CustomerProfilesClientTypes.PartyType?
    /// An alternative to PartyType which accepts any string as input.
    public var partyTypeString: Swift.String?
    /// The customer’s personal email address.
    public var personalEmailAddress: Swift.String?
    /// The customer’s phone number, which has not been specified as a mobile, home, or business number.
    public var phoneNumber: Swift.String?
    /// The customer’s shipping address.
    public var shippingAddress: CustomerProfilesClientTypes.Address?

    public init(
        accountNumber: Swift.String? = nil,
        additionalInformation: Swift.String? = nil,
        address: CustomerProfilesClientTypes.Address? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        billingAddress: CustomerProfilesClientTypes.Address? = nil,
        birthDate: Swift.String? = nil,
        businessEmailAddress: Swift.String? = nil,
        businessName: Swift.String? = nil,
        businessPhoneNumber: Swift.String? = nil,
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        gender: CustomerProfilesClientTypes.Gender? = nil,
        genderString: Swift.String? = nil,
        homePhoneNumber: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailingAddress: CustomerProfilesClientTypes.Address? = nil,
        middleName: Swift.String? = nil,
        mobilePhoneNumber: Swift.String? = nil,
        partyType: CustomerProfilesClientTypes.PartyType? = nil,
        partyTypeString: Swift.String? = nil,
        personalEmailAddress: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        shippingAddress: CustomerProfilesClientTypes.Address? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.genderString = genderString
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.partyTypeString = partyTypeString
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.shippingAddress = shippingAddress
    }
}

extension CreateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileInput(domainName: \(Swift.String(describing: domainName)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

public struct CreateProfileOutput: Swift.Sendable {
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct DeleteCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
    }
}

public struct DeleteCalculatedAttributeDefinitionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDomainInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct DeleteDomainOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteEventStreamInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream
    /// This member is required.
    public var eventStreamName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
    }
}

public struct DeleteEventStreamOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIntegrationInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.uri = uri
    }
}

public struct DeleteIntegrationOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteProfileInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.profileId = profileId
    }
}

public struct DeleteProfileOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteProfileKeyInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile.
    /// This member is required.
    public var keyName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.keyName = keyName
        self.profileId = profileId
        self.values = values
    }
}

public struct DeleteProfileKeyOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteProfileObjectInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The unique identifier of the profile object generated by the service.
    /// This member is required.
    public var profileObjectUniqueKey: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil,
        profileId: Swift.String? = nil,
        profileObjectUniqueKey: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
        self.profileId = profileId
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

public struct DeleteProfileObjectOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteProfileObjectTypeInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

public struct DeleteProfileObjectTypeOutput: Swift.Sendable {
    /// A message that indicates the delete request is done.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteWorkflowInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.workflowId = workflowId
    }
}

public struct DeleteWorkflowOutput: Swift.Sendable {

    public init() { }
}

public struct DetectProfileObjectTypeInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A string that is serialized from a JSON object.
    /// This member is required.
    public var objects: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        objects: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.objects = objects
    }
}

extension DetectProfileObjectTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectProfileObjectTypeInput(domainName: \(Swift.String(describing: domainName)), objects: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    public enum FieldContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emailAddress
        case name
        case number
        case phoneNumber
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldContentType] {
            return [
                .emailAddress,
                .name,
                .number,
                .phoneNumber,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .number: return "NUMBER"
            case .phoneNumber: return "PHONE_NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Represents a field in a ProfileObjectType.
    public struct ObjectTypeField: Swift.Sendable {
        /// The content type of the field. Used for determining equality when searching.
        public var contentType: CustomerProfilesClientTypes.FieldContentType?
        /// A field of a ProfileObject. For example: _source.FirstName, where “_source” is a ProfileObjectType of a Zendesk user and “FirstName” is a field in that ObjectType.
        public var source: Swift.String?
        /// The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        public var target: Swift.String?

        public init(
            contentType: CustomerProfilesClientTypes.FieldContentType? = nil,
            source: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.source = source
            self.target = target
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum StandardIdentifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case `case`
        case lookupOnly
        case newOnly
        case order
        case profile
        case secondary
        case unique
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardIdentifier] {
            return [
                .asset,
                .case,
                .lookupOnly,
                .newOnly,
                .order,
                .profile,
                .secondary,
                .unique
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .case: return "CASE"
            case .lookupOnly: return "LOOKUP_ONLY"
            case .newOnly: return "NEW_ONLY"
            case .order: return "ORDER"
            case .profile: return "PROFILE"
            case .secondary: return "SECONDARY"
            case .unique: return "UNIQUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
    public struct ObjectTypeKey: Swift.Sendable {
        /// The reference for the key name of the fields map.
        public var fieldNames: [Swift.String]?
        /// The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE, ASSET, CASE, or ORDER means that this key can be used to tie an object to a PROFILE, ASSET, CASE, or ORDER respectively. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        public var standardIdentifiers: [CustomerProfilesClientTypes.StandardIdentifier]?

        public init(
            fieldNames: [Swift.String]? = nil,
            standardIdentifiers: [CustomerProfilesClientTypes.StandardIdentifier]? = nil
        )
        {
            self.fieldNames = fieldNames
            self.standardIdentifiers = standardIdentifiers
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Contains ProfileObjectType mapping information from the model.
    public struct DetectedProfileObjectType: Swift.Sendable {
        /// A map of the name and the ObjectType field.
        public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
        /// A list of unique keys that can be used to map data to a profile.
        public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
        /// The format of sourceLastUpdatedTimestamp that was detected in fields.
        public var sourceLastUpdatedTimestampFormat: Swift.String?

        public init(
            fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
            keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
            sourceLastUpdatedTimestampFormat: Swift.String? = nil
        )
        {
            self.fields = fields
            self.keys = keys
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        }
    }
}

extension CustomerProfilesClientTypes.DetectedProfileObjectType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectedProfileObjectType(sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct DetectProfileObjectTypeOutput: Swift.Sendable {
    /// Detected ProfileObjectType mappings from given objects. A maximum of one mapping is supported.
    public var detectedProfileObjectTypes: [CustomerProfilesClientTypes.DetectedProfileObjectType]?

    public init(
        detectedProfileObjectTypes: [CustomerProfilesClientTypes.DetectedProfileObjectType]? = nil
    )
    {
        self.detectedProfileObjectTypes = detectedProfileObjectTypes
    }
}

public struct GetAutoMergingPreviewInput: Swift.Sendable {
    /// How the auto-merging process should resolve conflicts between different profiles.
    /// This member is required.
    public var conflictResolution: CustomerProfilesClientTypes.ConflictResolution?
    /// A list of matching attributes that represent matching criteria.
    /// This member is required.
    public var consolidation: CustomerProfilesClientTypes.Consolidation?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Minimum confidence score required for profiles within a matching group to be merged during the auto-merge process.
    public var minAllowedConfidenceScoreForMerging: Swift.Double?

    public init(
        conflictResolution: CustomerProfilesClientTypes.ConflictResolution? = nil,
        consolidation: CustomerProfilesClientTypes.Consolidation? = nil,
        domainName: Swift.String? = nil,
        minAllowedConfidenceScoreForMerging: Swift.Double? = nil
    )
    {
        self.conflictResolution = conflictResolution
        self.consolidation = consolidation
        self.domainName = domainName
        self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
    }
}

public struct GetAutoMergingPreviewOutput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of match groups in the domain that have been reviewed in this preview dry run.
    public var numberOfMatchesInSample: Swift.Int
    /// The number of profiles found in this preview dry run.
    public var numberOfProfilesInSample: Swift.Int
    /// The number of profiles that would be merged if this wasn't a preview dry run.
    public var numberOfProfilesWillBeMerged: Swift.Int

    public init(
        domainName: Swift.String? = nil,
        numberOfMatchesInSample: Swift.Int = 0,
        numberOfProfilesInSample: Swift.Int = 0,
        numberOfProfilesWillBeMerged: Swift.Int = 0
    )
    {
        self.domainName = domainName
        self.numberOfMatchesInSample = numberOfMatchesInSample
        self.numberOfProfilesInSample = numberOfProfilesInSample
        self.numberOfProfilesWillBeMerged = numberOfProfilesWillBeMerged
    }
}

public struct GetCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
    }
}

public struct GetCalculatedAttributeDefinitionOutput: Swift.Sendable {
    /// Mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.statistic = statistic
        self.tags = tags
    }
}

extension GetCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

public struct GetCalculatedAttributeForProfileInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.domainName = domainName
        self.profileId = profileId
    }
}

public struct GetCalculatedAttributeForProfileOutput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// Indicates whether the calculated attribute’s value is based on partial data. If data is partial, it is set to true.
    public var isDataPartial: Swift.String?
    /// The value of the calculated attribute.
    public var value: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isDataPartial: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.displayName = displayName
        self.isDataPartial = isDataPartial
        self.value = value
    }
}

public struct GetDomainInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension CustomerProfilesClientTypes {

    /// Usage-specific statistics about the domain.
    public struct DomainStats: Swift.Sendable {
        /// The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        public var meteringProfileCount: Swift.Int
        /// The total number of objects in domain.
        public var objectCount: Swift.Int
        /// The total number of profiles currently in the domain.
        public var profileCount: Swift.Int
        /// The total size, in bytes, of all objects in the domain.
        public var totalSize: Swift.Int

        public init(
            meteringProfileCount: Swift.Int = 0,
            objectCount: Swift.Int = 0,
            profileCount: Swift.Int = 0,
            totalSize: Swift.Int = 0
        )
        {
            self.meteringProfileCount = meteringProfileCount
            self.objectCount = objectCount
            self.profileCount = profileCount
            self.totalSize = totalSize
        }
    }
}

public struct GetDomainOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// Usage-specific statistics about the domain.
    public var stats: CustomerProfilesClientTypes.DomainStats?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        stats: CustomerProfilesClientTypes.DomainStats? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.stats = stats
        self.tags = tags
    }
}

public struct GetEventStreamInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the event stream provided during create operations.
    /// This member is required.
    public var eventStreamName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        eventStreamName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.eventStreamName = eventStreamName
    }
}

extension CustomerProfilesClientTypes {

    public enum EventStreamDestinationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStreamDestinationStatus] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Details of the destination being used for the EventStream.
    public struct EventStreamDestinationDetails: Swift.Sendable {
        /// The human-readable string that corresponds to the error or success while enabling the streaming destination.
        public var message: Swift.String?
        /// The status of enabling the Kinesis stream as a destination for export.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.EventStreamDestinationStatus?
        /// The timestamp when the status last changed to UNHEALHY.
        public var unhealthySince: Foundation.Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            message: Swift.String? = nil,
            status: CustomerProfilesClientTypes.EventStreamDestinationStatus? = nil,
            unhealthySince: Foundation.Date? = nil,
            uri: Swift.String? = nil
        )
        {
            self.message = message
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum EventStreamState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStreamState] {
            return [
                .running,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetEventStreamOutput: Swift.Sendable {
    /// The timestamp of when the export was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Details regarding the Kinesis stream.
    /// This member is required.
    public var destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A unique identifier for the event stream.
    /// This member is required.
    public var eventStreamArn: Swift.String?
    /// The operational state of destination stream for export.
    /// This member is required.
    public var state: CustomerProfilesClientTypes.EventStreamState?
    /// The timestamp when the State changed to STOPPED.
    public var stoppedSince: Foundation.Date?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        destinationDetails: CustomerProfilesClientTypes.EventStreamDestinationDetails? = nil,
        domainName: Swift.String? = nil,
        eventStreamArn: Swift.String? = nil,
        state: CustomerProfilesClientTypes.EventStreamState? = nil,
        stoppedSince: Foundation.Date? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationDetails = destinationDetails
        self.domainName = domainName
        self.eventStreamArn = eventStreamArn
        self.state = state
        self.stoppedSince = stoppedSince
        self.tags = tags
    }
}

public struct GetIdentityResolutionJobInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the Identity Resolution Job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.jobId = jobId
    }
}

extension CustomerProfilesClientTypes {

    /// The S3 location where Identity Resolution Jobs write result files.
    public struct S3ExportingLocation: Swift.Sendable {
        /// The name of the S3 bucket name where Identity Resolution Jobs write result files.
        public var s3BucketName: Swift.String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public var s3KeyName: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyName: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The S3 location where Identity Resolution Jobs write result files.
    public struct ExportingLocation: Swift.Sendable {
        /// Information about the S3 location where Identity Resolution Jobs write result files.
        public var s3Exporting: CustomerProfilesClientTypes.S3ExportingLocation?

        public init(
            s3Exporting: CustomerProfilesClientTypes.S3ExportingLocation? = nil
        )
        {
            self.s3Exporting = s3Exporting
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Statistics about the Identity Resolution Job.
    public struct JobStats: Swift.Sendable {
        /// The number of matches found.
        public var numberOfMatchesFound: Swift.Int
        /// The number of merges completed.
        public var numberOfMergesDone: Swift.Int
        /// The number of profiles reviewed.
        public var numberOfProfilesReviewed: Swift.Int

        public init(
            numberOfMatchesFound: Swift.Int = 0,
            numberOfMergesDone: Swift.Int = 0,
            numberOfProfilesReviewed: Swift.Int = 0
        )
        {
            self.numberOfMatchesFound = numberOfMatchesFound
            self.numberOfMergesDone = numberOfMergesDone
            self.numberOfProfilesReviewed = numberOfProfilesReviewed
        }
    }
}

extension CustomerProfilesClientTypes {

    public enum IdentityResolutionJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case findMatching
        case merging
        case partialSuccess
        case pending
        case preprocessing
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityResolutionJobStatus] {
            return [
                .completed,
                .failed,
                .findMatching,
                .merging,
                .partialSuccess,
                .pending,
                .preprocessing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .findMatching: return "FIND_MATCHING"
            case .merging: return "MERGING"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .pending: return "PENDING"
            case .preprocessing: return "PREPROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIdentityResolutionJobOutput: Swift.Sendable {
    /// Configuration settings for how to perform the auto-merging of profiles.
    public var autoMerging: CustomerProfilesClientTypes.AutoMerging?
    /// The unique name of the domain.
    public var domainName: Swift.String?
    /// The S3 location where the Identity Resolution Job writes result files.
    public var exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
    /// The timestamp of when the Identity Resolution Job was completed.
    public var jobEndTime: Foundation.Date?
    /// The timestamp of when the Identity Resolution Job will expire.
    public var jobExpirationTime: Foundation.Date?
    /// The unique identifier of the Identity Resolution Job.
    public var jobId: Swift.String?
    /// The timestamp of when the Identity Resolution Job was started or will be started.
    public var jobStartTime: Foundation.Date?
    /// Statistics about the Identity Resolution Job.
    public var jobStats: CustomerProfilesClientTypes.JobStats?
    /// The timestamp of when the Identity Resolution Job was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The error messages that are generated when the Identity Resolution Job runs.
    public var message: Swift.String?
    /// The status of the Identity Resolution Job.
    ///
    /// * PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.
    ///
    /// * PREPROCESSING: The Identity Resolution Job is loading your data.
    ///
    /// * FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.
    ///
    /// * MERGING: The Identity Resolution Job is merging duplicate profiles.
    ///
    /// * COMPLETED: The Identity Resolution Job completed successfully.
    ///
    /// * PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.
    ///
    /// * FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
    public var status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?

    public init(
        autoMerging: CustomerProfilesClientTypes.AutoMerging? = nil,
        domainName: Swift.String? = nil,
        exportingLocation: CustomerProfilesClientTypes.ExportingLocation? = nil,
        jobEndTime: Foundation.Date? = nil,
        jobExpirationTime: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        jobStartTime: Foundation.Date? = nil,
        jobStats: CustomerProfilesClientTypes.JobStats? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: CustomerProfilesClientTypes.IdentityResolutionJobStatus? = nil
    )
    {
        self.autoMerging = autoMerging
        self.domainName = domainName
        self.exportingLocation = exportingLocation
        self.jobEndTime = jobEndTime
        self.jobExpirationTime = jobExpirationTime
        self.jobId = jobId
        self.jobStartTime = jobStartTime
        self.jobStats = jobStats
        self.lastUpdatedAt = lastUpdatedAt
        self.message = message
        self.status = status
    }
}

public struct GetIntegrationInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.uri = uri
    }
}

public struct GetIntegrationOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
    public var isUnstructured: Swift.Bool?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        domainName: Swift.String? = nil,
        isUnstructured: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String: Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.isUnstructured = isUnstructured
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.roleArn = roleArn
        self.tags = tags
        self.uri = uri
        self.workflowId = workflowId
    }
}

public struct GetMatchesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// The Match group object.
    public struct MatchItem: Swift.Sendable {
        /// A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used an absolute measure of matching quality.
        public var confidenceScore: Swift.Double?
        /// The unique identifiers for this group of profiles that match.
        public var matchId: Swift.String?
        /// A list of identifiers for profiles that match.
        public var profileIds: [Swift.String]?

        public init(
            confidenceScore: Swift.Double? = nil,
            matchId: Swift.String? = nil,
            profileIds: [Swift.String]? = nil
        )
        {
            self.confidenceScore = confidenceScore
            self.matchId = matchId
            self.profileIds = profileIds
        }
    }
}

public struct GetMatchesOutput: Swift.Sendable {
    /// The timestamp this version of Match Result generated.
    public var matchGenerationDate: Foundation.Date?
    /// The list of matched profiles for this instance.
    public var matches: [CustomerProfilesClientTypes.MatchItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The number of potential matches found.
    public var potentialMatches: Swift.Int?

    public init(
        matchGenerationDate: Foundation.Date? = nil,
        matches: [CustomerProfilesClientTypes.MatchItem]? = nil,
        nextToken: Swift.String? = nil,
        potentialMatches: Swift.Int? = nil
    )
    {
        self.matchGenerationDate = matchGenerationDate
        self.matches = matches
        self.nextToken = nextToken
        self.potentialMatches = potentialMatches
    }
}

public struct GetProfileObjectTypeInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.objectTypeName = objectTypeName
    }
}

public struct GetProfileObjectTypeOutput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// The timestamp of when the domain was created.
    public var createdAt: Foundation.Date?
    /// The description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The timestamp of when the domain was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The amount of provisioned profile object max count available.
    public var maxAvailableProfileObjectCount: Swift.Int?
    /// The amount of profile object max count assigned to the object type.
    public var maxProfileObjectCount: Swift.Int?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        maxAvailableProfileObjectCount: Swift.Int? = nil,
        maxProfileObjectCount: Swift.Int? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
        self.maxProfileObjectCount = maxProfileObjectCount
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

extension GetProfileObjectTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileObjectTypeOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), maxAvailableProfileObjectCount: \(Swift.String(describing: maxAvailableProfileObjectCount)), maxProfileObjectCount: \(Swift.String(describing: maxProfileObjectCount)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct GetProfileObjectTypeTemplateInput: Swift.Sendable {
    /// A unique identifier for the object template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        templateId: Swift.String? = nil
    )
    {
        self.templateId = templateId
    }
}

public struct GetProfileObjectTypeTemplateOutput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The name of the source of the object template.
    public var sourceName: Swift.String?
    /// The source of the object template.
    public var sourceObject: Swift.String?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceObject: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.fields = fields
        self.keys = keys
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.sourceName = sourceName
        self.sourceObject = sourceObject
        self.templateId = templateId
    }
}

extension GetProfileObjectTypeTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileObjectTypeTemplateOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), sourceName: \(Swift.String(describing: sourceName)), sourceObject: \(Swift.String(describing: sourceObject)), templateId: \(Swift.String(describing: templateId)), fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    public enum MatchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mlBasedMatching
        case ruleBasedMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchType] {
            return [
                .mlBasedMatching,
                .ruleBasedMatching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mlBasedMatching: return "ML_BASED_MATCHING"
            case .ruleBasedMatching: return "RULE_BASED_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSimilarProfilesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Specify the type of matching to get similar profiles for.
    /// This member is required.
    public var matchType: CustomerProfilesClientTypes.MatchType?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous GetSimilarProfiles API call.
    public var nextToken: Swift.String?
    /// The string indicating the search key to be used.
    /// This member is required.
    public var searchKey: Swift.String?
    /// The string based on SearchKey to be searched for similar profiles.
    /// This member is required.
    public var searchValue: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        matchType: CustomerProfilesClientTypes.MatchType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchKey: Swift.String? = nil,
        searchValue: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.matchType = matchType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchKey = searchKey
        self.searchValue = searchValue
    }
}

public struct GetSimilarProfilesOutput: Swift.Sendable {
    /// It only has value when the MatchType is ML_BASED_MATCHING.A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used as an absolute measure of matching quality.
    public var confidenceScore: Swift.Double?
    /// The string matchId that the similar profiles belong to.
    public var matchId: Swift.String?
    /// Specify the type of matching to get similar profiles for.
    public var matchType: CustomerProfilesClientTypes.MatchType?
    /// The pagination token from the previous GetSimilarProfiles API call.
    public var nextToken: Swift.String?
    /// Set of profileIds that belong to the same matching group.
    public var profileIds: [Swift.String]?
    /// The integer rule level that the profiles matched on.
    public var ruleLevel: Swift.Int?

    public init(
        confidenceScore: Swift.Double? = nil,
        matchId: Swift.String? = nil,
        matchType: CustomerProfilesClientTypes.MatchType? = nil,
        nextToken: Swift.String? = nil,
        profileIds: [Swift.String]? = nil,
        ruleLevel: Swift.Int? = nil
    )
    {
        self.confidenceScore = confidenceScore
        self.matchId = matchId
        self.matchType = matchType
        self.nextToken = nextToken
        self.profileIds = profileIds
        self.ruleLevel = ruleLevel
    }
}

public struct GetWorkflowInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.workflowId = workflowId
    }
}

extension CustomerProfilesClientTypes {

    /// Structure to hold workflow attributes.
    public struct WorkflowAttributes: Swift.Sendable {
        /// Workflow attributes specific to APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }
}

extension CustomerProfilesClientTypes {

    /// Generic object containing workflow execution metrics.
    public struct WorkflowMetrics: Swift.Sendable {
        /// Workflow execution metrics for APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }
}

public struct GetWorkflowOutput: Swift.Sendable {
    /// Attributes provided for workflow execution.
    public var attributes: CustomerProfilesClientTypes.WorkflowAttributes?
    /// Workflow error messages during execution (if any).
    public var errorDescription: Swift.String?
    /// The timestamp that represents when workflow execution last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// Workflow specific execution metrics.
    public var metrics: CustomerProfilesClientTypes.WorkflowMetrics?
    /// The timestamp that represents when workflow execution started.
    public var startDate: Foundation.Date?
    /// Status of workflow execution.
    public var status: CustomerProfilesClientTypes.Status?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        attributes: CustomerProfilesClientTypes.WorkflowAttributes? = nil,
        errorDescription: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        metrics: CustomerProfilesClientTypes.WorkflowMetrics? = nil,
        startDate: Foundation.Date? = nil,
        status: CustomerProfilesClientTypes.Status? = nil,
        workflowId: Swift.String? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.attributes = attributes
        self.errorDescription = errorDescription
        self.lastUpdatedAt = lastUpdatedAt
        self.metrics = metrics
        self.startDate = startDate
        self.status = status
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

public struct GetWorkflowStepsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

extension CustomerProfilesClientTypes {

    /// List containing steps in workflow.
    public struct WorkflowStepItem: Swift.Sendable {
        /// Workflow step information specific to APPFLOW_INTEGRATION workflow.
        public var appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep?

        public init(
            appflowIntegration: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep? = nil
        )
        {
            self.appflowIntegration = appflowIntegration
        }
    }
}

public struct GetWorkflowStepsOutput: Swift.Sendable {
    /// List containing workflow step details.
    public var items: [CustomerProfilesClientTypes.WorkflowStepItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        items: [CustomerProfilesClientTypes.WorkflowStepItem]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

public struct ListAccountIntegrationsInput: Swift.Sendable {
    /// Boolean to indicate if hidden integration should be returned. Defaults to False.
    public var includeHidden: Swift.Bool?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListAccountIntegrations API call.
    public var nextToken: Swift.String?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?

    public init(
        includeHidden: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        uri: Swift.String? = nil
    )
    {
        self.includeHidden = includeHidden
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.uri = uri
    }
}

extension CustomerProfilesClientTypes {

    /// An integration in list of integrations.
    public struct ListIntegrationItem: Swift.Sendable {
        /// The timestamp of when the domain was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
        public var isUnstructured: Swift.Bool?
        /// The timestamp of when the domain was most recently edited.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the profile object type.
        public var objectTypeName: Swift.String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public var objectTypeNames: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
        public var roleArn: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The URI of the S3 bucket or any other type of data source.
        /// This member is required.
        public var uri: Swift.String?
        /// Unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            isUnstructured: Swift.Bool? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            objectTypeName: Swift.String? = nil,
            objectTypeNames: [Swift.String: Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            uri: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.domainName = domainName
            self.isUnstructured = isUnstructured
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.roleArn = roleArn
            self.tags = tags
            self.uri = uri
            self.workflowId = workflowId
        }
    }
}

public struct ListAccountIntegrationsOutput: Swift.Sendable {
    /// The list of ListAccountIntegration instances.
    public var items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    /// The pagination token from the previous ListAccountIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListIntegrationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListCalculatedAttributeDefinitionsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of calculated attribute definitions returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCalculatedAttributeDefinitionsOutput: Swift.Sendable {
    /// The list of calculated attribute definitions.
    public var items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]?
    /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension ListCalculatedAttributeDefinitionsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCalculatedAttributeDefinitionsOutput(nextToken: \(Swift.String(describing: nextToken)), items: \"CONTENT_REDACTED\")"}
}

public struct ListCalculatedAttributesForProfileInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of calculated attributes returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
    public var nextToken: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
    }
}

public struct ListCalculatedAttributesForProfileOutput: Swift.Sendable {
    /// The list of calculated attributes.
    public var items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]?
    /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListDomainsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListDomain API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// An object in a list that represents a domain.
    public struct ListDomainItem: Swift.Sendable {
        /// The timestamp of when the domain was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The timestamp of when the domain was most recently edited.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }
    }
}

public struct ListDomainsOutput: Swift.Sendable {
    /// The list of ListDomains instances.
    public var items: [CustomerProfilesClientTypes.ListDomainItem]?
    /// The pagination token from the previous ListDomains API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListDomainItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEventStreamsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// Summary information about the Kinesis data stream
    public struct DestinationSummary: Swift.Sendable {
        /// The status of enabling the Kinesis stream as a destination for export.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.EventStreamDestinationStatus?
        /// The timestamp when the status last changed to UNHEALHY.
        public var unhealthySince: Foundation.Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            status: CustomerProfilesClientTypes.EventStreamDestinationStatus? = nil,
            unhealthySince: Foundation.Date? = nil,
            uri: Swift.String? = nil
        )
        {
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }
    }
}

extension CustomerProfilesClientTypes {

    /// An instance of EventStream in a list of EventStreams.
    public struct EventStreamSummary: Swift.Sendable {
        /// Summary information about the Kinesis data stream.
        public var destinationSummary: CustomerProfilesClientTypes.DestinationSummary?
        /// The unique name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the event stream.
        /// This member is required.
        public var eventStreamArn: Swift.String?
        /// The name of the event stream.
        /// This member is required.
        public var eventStreamName: Swift.String?
        /// The operational state of destination stream for export.
        /// This member is required.
        public var state: CustomerProfilesClientTypes.EventStreamState?
        /// The timestamp when the State changed to STOPPED.
        public var stoppedSince: Foundation.Date?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            destinationSummary: CustomerProfilesClientTypes.DestinationSummary? = nil,
            domainName: Swift.String? = nil,
            eventStreamArn: Swift.String? = nil,
            eventStreamName: Swift.String? = nil,
            state: CustomerProfilesClientTypes.EventStreamState? = nil,
            stoppedSince: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.destinationSummary = destinationSummary
            self.domainName = domainName
            self.eventStreamArn = eventStreamArn
            self.eventStreamName = eventStreamName
            self.state = state
            self.stoppedSince = stoppedSince
            self.tags = tags
        }
    }
}

public struct ListEventStreamsOutput: Swift.Sendable {
    /// Contains summary information about an EventStream.
    public var items: [CustomerProfilesClientTypes.EventStreamSummary]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.EventStreamSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListIdentityResolutionJobsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// Information about the Identity Resolution Job.
    public struct IdentityResolutionJob: Swift.Sendable {
        /// The unique name of the domain.
        public var domainName: Swift.String?
        /// The S3 location where the Identity Resolution Job writes result files.
        public var exportingLocation: CustomerProfilesClientTypes.ExportingLocation?
        /// The timestamp of when the job was completed.
        public var jobEndTime: Foundation.Date?
        /// The unique identifier of the Identity Resolution Job.
        public var jobId: Swift.String?
        /// The timestamp of when the job was started or will be started.
        public var jobStartTime: Foundation.Date?
        /// Statistics about an Identity Resolution Job.
        public var jobStats: CustomerProfilesClientTypes.JobStats?
        /// The error messages that are generated when the Identity Resolution Job runs.
        public var message: Swift.String?
        /// The status of the Identity Resolution Job.
        ///
        /// * PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.
        ///
        /// * PREPROCESSING: The Identity Resolution Job is loading your data.
        ///
        /// * FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.
        ///
        /// * MERGING: The Identity Resolution Job is merging duplicate profiles.
        ///
        /// * COMPLETED: The Identity Resolution Job completed successfully.
        ///
        /// * PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.
        ///
        /// * FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
        public var status: CustomerProfilesClientTypes.IdentityResolutionJobStatus?

        public init(
            domainName: Swift.String? = nil,
            exportingLocation: CustomerProfilesClientTypes.ExportingLocation? = nil,
            jobEndTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobStartTime: Foundation.Date? = nil,
            jobStats: CustomerProfilesClientTypes.JobStats? = nil,
            message: Swift.String? = nil,
            status: CustomerProfilesClientTypes.IdentityResolutionJobStatus? = nil
        )
        {
            self.domainName = domainName
            self.exportingLocation = exportingLocation
            self.jobEndTime = jobEndTime
            self.jobId = jobId
            self.jobStartTime = jobStartTime
            self.jobStats = jobStats
            self.message = message
            self.status = status
        }
    }
}

public struct ListIdentityResolutionJobsOutput: Swift.Sendable {
    /// A list of Identity Resolution Jobs.
    public var identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        identityResolutionJobsList: [CustomerProfilesClientTypes.IdentityResolutionJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityResolutionJobsList = identityResolutionJobsList
        self.nextToken = nextToken
    }
}

public struct ListIntegrationsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean to indicate if hidden integration should be returned. Defaults to False.
    public var includeHidden: Swift.Bool?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        includeHidden: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.includeHidden = includeHidden
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIntegrationsOutput: Swift.Sendable {
    /// The list of ListIntegrations instances.
    public var items: [CustomerProfilesClientTypes.ListIntegrationItem]?
    /// The pagination token from the previous ListIntegrations API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListIntegrationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// The filter applied to ListProfileObjects response to include profile objects with the specified index values.
    public struct ObjectFilter: Swift.Sendable {
        /// A searchable identifier of a profile object. The predefined keys you can use to search for _asset include: _assetId, _assetName, and _serialNumber. The predefined keys you can use to search for _case include: _caseId. The predefined keys you can use to search for _order include: _orderId.
        /// This member is required.
        public var keyName: Swift.String?
        /// A list of key values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.keyName = keyName
            self.values = values
        }
    }
}

public struct ListProfileObjectsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous call to ListProfileObjects.
    public var nextToken: Swift.String?
    /// Applies a filter to the response to include profile objects with the specified index values.
    public var objectFilter: CustomerProfilesClientTypes.ObjectFilter?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectFilter: CustomerProfilesClientTypes.ObjectFilter? = nil,
        objectTypeName: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectFilter = objectFilter
        self.objectTypeName = objectTypeName
        self.profileId = profileId
    }
}

extension CustomerProfilesClientTypes {

    /// A ProfileObject in a list of ProfileObjects.
    public struct ListProfileObjectsItem: Swift.Sendable {
        /// A JSON representation of a ProfileObject that belongs to a profile.
        public var object: Swift.String?
        /// Specifies the kind of object being added to a profile, such as "Salesforce-Account."
        public var objectTypeName: Swift.String?
        /// The unique identifier of the ProfileObject generated by the service.
        public var profileObjectUniqueKey: Swift.String?

        public init(
            object: Swift.String? = nil,
            objectTypeName: Swift.String? = nil,
            profileObjectUniqueKey: Swift.String? = nil
        )
        {
            self.object = object
            self.objectTypeName = objectTypeName
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectsItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileObjectsItem(objectTypeName: \(Swift.String(describing: objectTypeName)), profileObjectUniqueKey: \(Swift.String(describing: profileObjectUniqueKey)), object: \"CONTENT_REDACTED\")"}
}

public struct ListProfileObjectsOutput: Swift.Sendable {
    /// The list of ListProfileObject instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectsItem]?
    /// The pagination token from the previous call to ListProfileObjects.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectsItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListProfileObjectTypesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// A ProfileObjectType instance.
    public struct ListProfileObjectTypeItem: Swift.Sendable {
        /// The timestamp of when the domain was created.
        public var createdAt: Foundation.Date?
        /// Description of the profile object type.
        /// This member is required.
        public var description: Swift.String?
        /// The timestamp of when the domain was most recently edited.
        public var lastUpdatedAt: Foundation.Date?
        /// The amount of provisioned profile object max count available.
        public var maxAvailableProfileObjectCount: Swift.Int?
        /// The amount of profile object max count assigned to the object type.
        public var maxProfileObjectCount: Swift.Int?
        /// The name of the profile object type.
        /// This member is required.
        public var objectTypeName: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            maxAvailableProfileObjectCount: Swift.Int? = nil,
            maxProfileObjectCount: Swift.Int? = nil,
            objectTypeName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
            self.maxProfileObjectCount = maxProfileObjectCount
            self.objectTypeName = objectTypeName
            self.tags = tags
        }
    }
}

public struct ListProfileObjectTypesOutput: Swift.Sendable {
    /// The list of ListProfileObjectTypes instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectTypeItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension ListProfileObjectTypesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileObjectTypesOutput(nextToken: \(Swift.String(describing: nextToken)), items: \"CONTENT_REDACTED\")"}
}

public struct ListProfileObjectTypeTemplatesInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListObjectTypeTemplates API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// A ProfileObjectTypeTemplate in a list of ProfileObjectTypeTemplates.
    public struct ListProfileObjectTypeTemplateItem: Swift.Sendable {
        /// The name of the source of the object template.
        public var sourceName: Swift.String?
        /// The source of the object template.
        public var sourceObject: Swift.String?
        /// A unique identifier for the object template.
        public var templateId: Swift.String?

        public init(
            sourceName: Swift.String? = nil,
            sourceObject: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }
    }
}

public struct ListProfileObjectTypeTemplatesOutput: Swift.Sendable {
    /// The list of ListProfileObjectType template instances.
    public var items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]?
    /// The pagination token from the previous ListObjectTypeTemplates API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListRuleBasedMatchesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of MatchIds returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListRuleBasedMatches API call.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRuleBasedMatchesOutput: Swift.Sendable {
    /// The list of MatchIds for the given domain.
    public var matchIds: [Swift.String]?
    /// The pagination token from the previous ListRuleBasedMatches API call.
    public var nextToken: Swift.String?

    public init(
        matchIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.matchIds = matchIds
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWorkflowsInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Retrieve workflows ended after timestamp.
    public var queryEndDate: Foundation.Date?
    /// Retrieve workflows started after timestamp.
    public var queryStartDate: Foundation.Date?
    /// Status of workflow execution.
    public var status: CustomerProfilesClientTypes.Status?
    /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
    public var workflowType: CustomerProfilesClientTypes.WorkflowType?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryEndDate: Foundation.Date? = nil,
        queryStartDate: Foundation.Date? = nil,
        status: CustomerProfilesClientTypes.Status? = nil,
        workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryEndDate = queryEndDate
        self.queryStartDate = queryStartDate
        self.status = status
        self.workflowType = workflowType
    }
}

extension CustomerProfilesClientTypes {

    /// A workflow in list of workflows.
    public struct ListWorkflowsItem: Swift.Sendable {
        /// Creation timestamp for workflow.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Last updated timestamp for workflow.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// Status of workflow execution.
        /// This member is required.
        public var status: CustomerProfilesClientTypes.Status?
        /// Description for workflow execution status.
        /// This member is required.
        public var statusDescription: Swift.String?
        /// Unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        /// This member is required.
        public var workflowType: CustomerProfilesClientTypes.WorkflowType?

        public init(
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: CustomerProfilesClientTypes.Status? = nil,
            statusDescription: Swift.String? = nil,
            workflowId: Swift.String? = nil,
            workflowType: CustomerProfilesClientTypes.WorkflowType? = nil
        )
        {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusDescription = statusDescription
            self.workflowId = workflowId
            self.workflowType = workflowType
        }
    }
}

public struct ListWorkflowsOutput: Swift.Sendable {
    /// List containing workflow details.
    public var items: [CustomerProfilesClientTypes.ListWorkflowsItem]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.ListWorkflowsItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension CustomerProfilesClientTypes {

    /// A duplicate customer profile that is to be merged into a main profile.
    public struct FieldSourceProfileIds: Swift.Sendable {
        /// A unique identifier for the account number field to be merged.
        public var accountNumber: Swift.String?
        /// A unique identifier for the additional information field to be merged.
        public var additionalInformation: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var address: Swift.String?
        /// A unique identifier for the attributes field to be merged.
        public var attributes: [Swift.String: Swift.String]?
        /// A unique identifier for the billing type field to be merged.
        public var billingAddress: Swift.String?
        /// A unique identifier for the birthdate field to be merged.
        public var birthDate: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var businessEmailAddress: Swift.String?
        /// A unique identifier for the business name field to be merged.
        public var businessName: Swift.String?
        /// A unique identifier for the business phone number field to be merged.
        public var businessPhoneNumber: Swift.String?
        /// A unique identifier for the email address field to be merged.
        public var emailAddress: Swift.String?
        /// A unique identifier for the first name field to be merged.
        public var firstName: Swift.String?
        /// A unique identifier for the gender field to be merged.
        public var gender: Swift.String?
        /// A unique identifier for the home phone number field to be merged.
        public var homePhoneNumber: Swift.String?
        /// A unique identifier for the last name field to be merged.
        public var lastName: Swift.String?
        /// A unique identifier for the mailing address field to be merged.
        public var mailingAddress: Swift.String?
        /// A unique identifier for the middle name field to be merged.
        public var middleName: Swift.String?
        /// A unique identifier for the mobile phone number field to be merged.
        public var mobilePhoneNumber: Swift.String?
        /// A unique identifier for the party type field to be merged.
        public var partyType: Swift.String?
        /// A unique identifier for the personal email address field to be merged.
        public var personalEmailAddress: Swift.String?
        /// A unique identifier for the phone number field to be merged.
        public var phoneNumber: Swift.String?
        /// A unique identifier for the shipping address field to be merged.
        public var shippingAddress: Swift.String?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            billingAddress: Swift.String? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            gender: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress: Swift.String? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: Swift.String? = nil,
            personalEmailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            shippingAddress: Swift.String? = nil
        )
        {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.shippingAddress = shippingAddress
        }
    }
}

public struct MergeProfilesInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The identifiers of the fields in the profile that has the information you want to apply to the merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the identifier of the EmailAddress field in Profile1.
    public var fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds?
    /// The identifier of the profile to be taken.
    /// This member is required.
    public var mainProfileId: Swift.String?
    /// The identifier of the profile to be merged into MainProfileId.
    /// This member is required.
    public var profileIdsToBeMerged: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        fieldSourceProfileIds: CustomerProfilesClientTypes.FieldSourceProfileIds? = nil,
        mainProfileId: Swift.String? = nil,
        profileIdsToBeMerged: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.fieldSourceProfileIds = fieldSourceProfileIds
        self.mainProfileId = mainProfileId
        self.profileIdsToBeMerged = profileIdsToBeMerged
    }
}

public struct MergeProfilesOutput: Swift.Sendable {
    /// A message that indicates the merge request is complete.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct PutIntegrationInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The configuration that controls how Customer Profiles retrieves data from the source.
    public var flowDefinition: CustomerProfilesClientTypes.FlowDefinition?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    public var uri: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        flowDefinition: CustomerProfilesClientTypes.FlowDefinition? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String: Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.flowDefinition = flowDefinition
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.roleArn = roleArn
        self.tags = tags
        self.uri = uri
    }
}

extension PutIntegrationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutIntegrationInput(domainName: \(Swift.String(describing: domainName)), objectTypeName: \(Swift.String(describing: objectTypeName)), objectTypeNames: \(Swift.String(describing: objectTypeNames)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), uri: \(Swift.String(describing: uri)), flowDefinition: \"CONTENT_REDACTED\")"}
}

public struct PutIntegrationOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
    public var isUnstructured: Swift.Bool?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the profile object type.
    public var objectTypeName: Swift.String?
    /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event. It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders, ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
    public var objectTypeNames: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The URI of the S3 bucket or any other type of data source.
    /// This member is required.
    public var uri: Swift.String?
    /// Unique identifier for the workflow.
    public var workflowId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        domainName: Swift.String? = nil,
        isUnstructured: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        objectTypeName: Swift.String? = nil,
        objectTypeNames: [Swift.String: Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.domainName = domainName
        self.isUnstructured = isUnstructured
        self.lastUpdatedAt = lastUpdatedAt
        self.objectTypeName = objectTypeName
        self.objectTypeNames = objectTypeNames
        self.roleArn = roleArn
        self.tags = tags
        self.uri = uri
        self.workflowId = workflowId
    }
}

public struct PutProfileObjectInput: Swift.Sendable {
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A string that is serialized from a JSON object.
    /// This member is required.
    public var object: Swift.String?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        object: Swift.String? = nil,
        objectTypeName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.object = object
        self.objectTypeName = objectTypeName
    }
}

extension PutProfileObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectInput(domainName: \(Swift.String(describing: domainName)), objectTypeName: \(Swift.String(describing: objectTypeName)), object: \"CONTENT_REDACTED\")"}
}

public struct PutProfileObjectOutput: Swift.Sendable {
    /// The unique identifier of the profile object generated by the service.
    public var profileObjectUniqueKey: Swift.String?

    public init(
        profileObjectUniqueKey: Swift.String? = nil
    )
    {
        self.profileObjectUniqueKey = profileObjectUniqueKey
    }
}

public struct PutProfileObjectTypeInput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool?
    /// Description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The amount of profile object max count assigned to the object type
    public var maxProfileObjectCount: Swift.Int?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the object template. For some attributes in the request, the service will use the default value from the object template when TemplateId is present. If these attributes are present in the request, the service may return a BadRequestException. These attributes include: AllowProfileCreation, SourceLastUpdatedTimestampFormat, Fields, and Keys. For example, if AllowProfileCreation is set to true when TemplateId is set, the service may return a BadRequestException.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool? = false,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        maxProfileObjectCount: Swift.Int? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.description = description
        self.domainName = domainName
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.maxProfileObjectCount = maxProfileObjectCount
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

extension PutProfileObjectTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectTypeInput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), domainName: \(Swift.String(describing: domainName)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), maxProfileObjectCount: \(Swift.String(describing: maxProfileObjectCount)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

public struct PutProfileObjectTypeOutput: Swift.Sendable {
    /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
    public var allowProfileCreation: Swift.Bool
    /// The timestamp of when the domain was created.
    public var createdAt: Foundation.Date?
    /// Description of the profile object type.
    /// This member is required.
    public var description: Swift.String?
    /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
    public var encryptionKey: Swift.String?
    /// The number of days until the data in the object expires.
    public var expirationDays: Swift.Int?
    /// A map of the name and ObjectType field.
    public var fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]?
    /// A list of unique keys that can be used to map data to the profile.
    public var keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]?
    /// The timestamp of when the domain was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The amount of provisioned profile object max count available.
    public var maxAvailableProfileObjectCount: Swift.Int?
    /// The amount of profile object max count assigned to the object type.
    public var maxProfileObjectCount: Swift.Int?
    /// The name of the profile object type.
    /// This member is required.
    public var objectTypeName: Swift.String?
    /// The format of your sourceLastUpdatedTimestamp that was previously set up in fields that were parsed using [SimpleDateFormat](https://docs.oracle.com/javase/10/docs/api/java/text/SimpleDateFormat.html). If you have sourceLastUpdatedTimestamp in your field, you must set up sourceLastUpdatedTimestampFormat.
    public var sourceLastUpdatedTimestampFormat: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// A unique identifier for the object template.
    public var templateId: Swift.String?

    public init(
        allowProfileCreation: Swift.Bool = false,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        expirationDays: Swift.Int? = nil,
        fields: [Swift.String: CustomerProfilesClientTypes.ObjectTypeField]? = nil,
        keys: [Swift.String: [CustomerProfilesClientTypes.ObjectTypeKey]]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        maxAvailableProfileObjectCount: Swift.Int? = nil,
        maxProfileObjectCount: Swift.Int? = nil,
        objectTypeName: Swift.String? = nil,
        sourceLastUpdatedTimestampFormat: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.allowProfileCreation = allowProfileCreation
        self.createdAt = createdAt
        self.description = description
        self.encryptionKey = encryptionKey
        self.expirationDays = expirationDays
        self.fields = fields
        self.keys = keys
        self.lastUpdatedAt = lastUpdatedAt
        self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
        self.maxProfileObjectCount = maxProfileObjectCount
        self.objectTypeName = objectTypeName
        self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        self.tags = tags
        self.templateId = templateId
    }
}

extension PutProfileObjectTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProfileObjectTypeOutput(allowProfileCreation: \(Swift.String(describing: allowProfileCreation)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), expirationDays: \(Swift.String(describing: expirationDays)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), maxAvailableProfileObjectCount: \(Swift.String(describing: maxAvailableProfileObjectCount)), maxProfileObjectCount: \(Swift.String(describing: maxProfileObjectCount)), objectTypeName: \(Swift.String(describing: objectTypeName)), sourceLastUpdatedTimestampFormat: \(Swift.String(describing: sourceLastUpdatedTimestampFormat)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)), description: \"CONTENT_REDACTED\", fields: \"CONTENT_REDACTED\", keys: \"CONTENT_REDACTED\")"}
}

extension CustomerProfilesClientTypes {

    public enum LogicalOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .or
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchProfilesInput: Swift.Sendable {
    /// A list of AdditionalSearchKey objects that are each searchable identifiers of a profile. Each AdditionalSearchKey object contains a KeyName and a list of Values associated with that specific key (i.e., a key-value(s) pair). These additional search keys will be used in conjunction with the LogicalOperator and the required KeyName and Values parameters to search for profiles that satisfy the search criteria.
    public var additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
    /// This member is required.
    public var keyName: Swift.String?
    /// Relationship between all specified search keys that will be used to search for profiles. This includes the required KeyName and Values parameters as well as any key-value(s) pairs specified in the AdditionalSearchKeys list. This parameter influences which profiles will be returned in the response in the following manner:
    ///
    /// * AND - The response only includes profiles that match all of the search keys.
    ///
    /// * OR - The response includes profiles that match at least one of the search keys.
    ///
    ///
    /// The OR relationship is the default behavior if this parameter is not included in the request.
    public var logicalOperator: CustomerProfilesClientTypes.LogicalOperator?
    /// The maximum number of objects returned per page. The default is 20 if this parameter is not included in the request.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous SearchProfiles API call.
    public var nextToken: Swift.String?
    /// A list of key values.
    /// This member is required.
    public var values: [Swift.String]?

    public init(
        additionalSearchKeys: [CustomerProfilesClientTypes.AdditionalSearchKey]? = nil,
        domainName: Swift.String? = nil,
        keyName: Swift.String? = nil,
        logicalOperator: CustomerProfilesClientTypes.LogicalOperator? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.additionalSearchKeys = additionalSearchKeys
        self.domainName = domainName
        self.keyName = keyName
        self.logicalOperator = logicalOperator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

extension CustomerProfilesClientTypes {

    /// A data type pair that consists of a KeyName and Values list that were used to find a profile returned in response to a [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request.
    public struct FoundByKeyValue: Swift.Sendable {
        /// A searchable identifier of a customer profile.
        public var keyName: Swift.String?
        /// A list of key values.
        public var values: [Swift.String]?

        public init(
            keyName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.keyName = keyName
            self.values = values
        }
    }
}

extension CustomerProfilesClientTypes {

    /// The standard profile of a customer.
    public struct Profile: Swift.Sendable {
        /// An account number that you have given to the customer.
        public var accountNumber: Swift.String?
        /// Any additional information relevant to the customer’s profile.
        public var additionalInformation: Swift.String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public var address: CustomerProfilesClientTypes.Address?
        /// A key value pair of attributes of a customer profile.
        public var attributes: [Swift.String: Swift.String]?
        /// The customer’s billing address.
        public var billingAddress: CustomerProfilesClientTypes.Address?
        /// The customer’s birth date.
        public var birthDate: Swift.String?
        /// The customer’s business email address.
        public var businessEmailAddress: Swift.String?
        /// The name of the customer’s business.
        public var businessName: Swift.String?
        /// The customer’s home phone number.
        public var businessPhoneNumber: Swift.String?
        /// The customer’s email address, which has not been specified as a personal or business address.
        public var emailAddress: Swift.String?
        /// The customer’s first name.
        public var firstName: Swift.String?
        /// A list of items used to find a profile returned in a [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) response. An item is a key-value(s) pair that matches an attribute in the profile. If the optional AdditionalSearchKeys parameter was included in the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request, the FoundByItems list should be interpreted based on the LogicalOperator used in the request:
        ///
        /// * AND - The profile included in the response matched all of the search keys specified in the request. The FoundByItems will include all of the key-value(s) pairs that were specified in the request (as this is a requirement of AND search logic).
        ///
        /// * OR - The profile included in the response matched at least one of the search keys specified in the request. The FoundByItems will include each of the key-value(s) pairs that the profile was found by.
        ///
        ///
        /// The OR relationship is the default behavior if the LogicalOperator parameter is not included in the [SearchProfiles](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_SearchProfiles.html) request.
        public var foundByItems: [CustomerProfilesClientTypes.FoundByKeyValue]?
        /// The gender with which the customer identifies.
        @available(*, deprecated)
        public var gender: CustomerProfilesClientTypes.Gender?
        /// An alternative to Gender which accepts any string as input.
        public var genderString: Swift.String?
        /// The customer’s home phone number.
        public var homePhoneNumber: Swift.String?
        /// The customer’s last name.
        public var lastName: Swift.String?
        /// The customer’s mailing address.
        public var mailingAddress: CustomerProfilesClientTypes.Address?
        /// The customer’s middle name.
        public var middleName: Swift.String?
        /// The customer’s mobile phone number.
        public var mobilePhoneNumber: Swift.String?
        /// The type of profile used to describe the customer.
        @available(*, deprecated)
        public var partyType: CustomerProfilesClientTypes.PartyType?
        /// An alternative to PartyType which accepts any string as input.
        public var partyTypeString: Swift.String?
        /// The customer’s personal email address.
        public var personalEmailAddress: Swift.String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public var phoneNumber: Swift.String?
        /// The unique identifier of a customer profile.
        public var profileId: Swift.String?
        /// The customer’s shipping address.
        public var shippingAddress: CustomerProfilesClientTypes.Address?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address: CustomerProfilesClientTypes.Address? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            billingAddress: CustomerProfilesClientTypes.Address? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            foundByItems: [CustomerProfilesClientTypes.FoundByKeyValue]? = nil,
            gender: CustomerProfilesClientTypes.Gender? = nil,
            genderString: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress: CustomerProfilesClientTypes.Address? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: CustomerProfilesClientTypes.PartyType? = nil,
            partyTypeString: Swift.String? = nil,
            personalEmailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            profileId: Swift.String? = nil,
            shippingAddress: CustomerProfilesClientTypes.Address? = nil
        )
        {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.foundByItems = foundByItems
            self.gender = gender
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.shippingAddress = shippingAddress
        }
    }
}

extension CustomerProfilesClientTypes.Profile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Profile(foundByItems: \(Swift.String(describing: foundByItems)), profileId: \(Swift.String(describing: profileId)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

public struct SearchProfilesOutput: Swift.Sendable {
    /// The list of Profiles matching the search criteria.
    public var items: [CustomerProfilesClientTypes.Profile]?
    /// The pagination token from the previous SearchProfiles API call.
    public var nextToken: Swift.String?

    public init(
        items: [CustomerProfilesClientTypes.Profile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCalculatedAttributeDefinitionInput: Swift.Sendable {
    /// The unique name of the calculated attribute.
    /// This member is required.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.description = description
        self.displayName = displayName
        self.domainName = domainName
    }
}

extension UpdateCalculatedAttributeDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCalculatedAttributeDefinitionInput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), displayName: \(Swift.String(describing: displayName)), domainName: \(Swift.String(describing: domainName)), conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

public struct UpdateCalculatedAttributeDefinitionOutput: Swift.Sendable {
    /// The mathematical expression and a list of attribute items specified in that expression.
    public var attributeDetails: CustomerProfilesClientTypes.AttributeDetails?
    /// The unique name of the calculated attribute.
    public var calculatedAttributeName: Swift.String?
    /// The conditions including range, object count, and threshold for the calculated attribute.
    public var conditions: CustomerProfilesClientTypes.Conditions?
    /// The timestamp of when the calculated attribute definition was created.
    public var createdAt: Foundation.Date?
    /// The description of the calculated attribute.
    public var description: Swift.String?
    /// The display name of the calculated attribute.
    public var displayName: Swift.String?
    /// The timestamp of when the calculated attribute definition was most recently edited.
    public var lastUpdatedAt: Foundation.Date?
    /// The aggregation operation to perform for the calculated attribute.
    public var statistic: CustomerProfilesClientTypes.Statistic?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributeDetails: CustomerProfilesClientTypes.AttributeDetails? = nil,
        calculatedAttributeName: Swift.String? = nil,
        conditions: CustomerProfilesClientTypes.Conditions? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        statistic: CustomerProfilesClientTypes.Statistic? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributeDetails = attributeDetails
        self.calculatedAttributeName = calculatedAttributeName
        self.conditions = conditions
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.lastUpdatedAt = lastUpdatedAt
        self.statistic = statistic
        self.tags = tags
    }
}

extension UpdateCalculatedAttributeDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCalculatedAttributeDefinitionOutput(calculatedAttributeName: \(Swift.String(describing: calculatedAttributeName)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), tags: \(Swift.String(describing: tags)), attributeDetails: \"CONTENT_REDACTED\", conditions: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", statistic: \"CONTENT_REDACTED\")"}
}

public struct UpdateDomainInput: Swift.Sendable {
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. If specified as an empty string, it will clear any existing value. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage. If specified as an empty string, it will clear any existing value.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingRequest?
    /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        matching: CustomerProfilesClientTypes.MatchingRequest? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingRequest? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

public struct UpdateDomainOutput: Swift.Sendable {
    /// The timestamp of when the domain was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
    public var deadLetterQueueUrl: Swift.String?
    /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
    public var defaultEncryptionKey: Swift.String?
    /// The default number of days until the data within the domain expires.
    public var defaultExpirationDays: Swift.Int?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The timestamp of when the domain was most recently edited.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the [GetMatches](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html) API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    public var matching: CustomerProfilesClientTypes.MatchingResponse?
    /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    public var ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        deadLetterQueueUrl: Swift.String? = nil,
        defaultEncryptionKey: Swift.String? = nil,
        defaultExpirationDays: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        matching: CustomerProfilesClientTypes.MatchingResponse? = nil,
        ruleBasedMatching: CustomerProfilesClientTypes.RuleBasedMatchingResponse? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deadLetterQueueUrl = deadLetterQueueUrl
        self.defaultEncryptionKey = defaultEncryptionKey
        self.defaultExpirationDays = defaultExpirationDays
        self.domainName = domainName
        self.lastUpdatedAt = lastUpdatedAt
        self.matching = matching
        self.ruleBasedMatching = ruleBasedMatching
        self.tags = tags
    }
}

extension CustomerProfilesClientTypes {

    /// Updates associated with the address properties of a customer profile.
    public struct UpdateAddress: Swift.Sendable {
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            province: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }
    }
}

extension CustomerProfilesClientTypes.UpdateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct UpdateProfileInput: Swift.Sendable {
    /// An account number that you have given to the customer.
    public var accountNumber: Swift.String?
    /// Any additional information relevant to the customer’s profile.
    public var additionalInformation: Swift.String?
    /// A generic address associated with the customer that is not mailing, shipping, or billing.
    public var address: CustomerProfilesClientTypes.UpdateAddress?
    /// A key value pair of attributes of a customer profile.
    public var attributes: [Swift.String: Swift.String]?
    /// The customer’s billing address.
    public var billingAddress: CustomerProfilesClientTypes.UpdateAddress?
    /// The customer’s birth date.
    public var birthDate: Swift.String?
    /// The customer’s business email address.
    public var businessEmailAddress: Swift.String?
    /// The name of the customer’s business.
    public var businessName: Swift.String?
    /// The customer’s business phone number.
    public var businessPhoneNumber: Swift.String?
    /// The unique name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The customer’s email address, which has not been specified as a personal or business address.
    public var emailAddress: Swift.String?
    /// The customer’s first name.
    public var firstName: Swift.String?
    /// The gender with which the customer identifies.
    @available(*, deprecated)
    public var gender: CustomerProfilesClientTypes.Gender?
    /// An alternative to Gender which accepts any string as input.
    public var genderString: Swift.String?
    /// The customer’s home phone number.
    public var homePhoneNumber: Swift.String?
    /// The customer’s last name.
    public var lastName: Swift.String?
    /// The customer’s mailing address.
    public var mailingAddress: CustomerProfilesClientTypes.UpdateAddress?
    /// The customer’s middle name.
    public var middleName: Swift.String?
    /// The customer’s mobile phone number.
    public var mobilePhoneNumber: Swift.String?
    /// The type of profile used to describe the customer.
    @available(*, deprecated)
    public var partyType: CustomerProfilesClientTypes.PartyType?
    /// An alternative to PartyType which accepts any string as input.
    public var partyTypeString: Swift.String?
    /// The customer’s personal email address.
    public var personalEmailAddress: Swift.String?
    /// The customer’s phone number, which has not been specified as a mobile, home, or business number.
    public var phoneNumber: Swift.String?
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The customer’s shipping address.
    public var shippingAddress: CustomerProfilesClientTypes.UpdateAddress?

    public init(
        accountNumber: Swift.String? = nil,
        additionalInformation: Swift.String? = nil,
        address: CustomerProfilesClientTypes.UpdateAddress? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        billingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil,
        birthDate: Swift.String? = nil,
        businessEmailAddress: Swift.String? = nil,
        businessName: Swift.String? = nil,
        businessPhoneNumber: Swift.String? = nil,
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        gender: CustomerProfilesClientTypes.Gender? = nil,
        genderString: Swift.String? = nil,
        homePhoneNumber: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil,
        middleName: Swift.String? = nil,
        mobilePhoneNumber: Swift.String? = nil,
        partyType: CustomerProfilesClientTypes.PartyType? = nil,
        partyTypeString: Swift.String? = nil,
        personalEmailAddress: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        profileId: Swift.String? = nil,
        shippingAddress: CustomerProfilesClientTypes.UpdateAddress? = nil
    )
    {
        self.accountNumber = accountNumber
        self.additionalInformation = additionalInformation
        self.address = address
        self.attributes = attributes
        self.billingAddress = billingAddress
        self.birthDate = birthDate
        self.businessEmailAddress = businessEmailAddress
        self.businessName = businessName
        self.businessPhoneNumber = businessPhoneNumber
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.gender = gender
        self.genderString = genderString
        self.homePhoneNumber = homePhoneNumber
        self.lastName = lastName
        self.mailingAddress = mailingAddress
        self.middleName = middleName
        self.mobilePhoneNumber = mobilePhoneNumber
        self.partyType = partyType
        self.partyTypeString = partyTypeString
        self.personalEmailAddress = personalEmailAddress
        self.phoneNumber = phoneNumber
        self.profileId = profileId
        self.shippingAddress = shippingAddress
    }
}

extension UpdateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileInput(domainName: \(Swift.String(describing: domainName)), profileId: \(Swift.String(describing: profileId)), accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address: \"CONTENT_REDACTED\", attributes: \"CONTENT_REDACTED\", billingAddress: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", genderString: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", partyTypeString: \"CONTENT_REDACTED\", personalEmailAddress: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", shippingAddress: \"CONTENT_REDACTED\")"}
}

public struct UpdateProfileOutput: Swift.Sendable {
    /// The unique identifier of a customer profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

extension AddProfileKeyInput {

    static func urlPathProvider(_ value: AddProfileKeyInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/keys"
    }
}

extension CreateCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: CreateCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension CreateEventStreamInput {

    static func urlPathProvider(_ value: CreateEventStreamInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventStreamName = value.eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

extension CreateIntegrationWorkflowInput {

    static func urlPathProvider(_ value: CreateIntegrationWorkflowInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/integrations"
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles"
    }
}

extension DeleteCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: DeleteCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteEventStreamInput {

    static func urlPathProvider(_ value: DeleteEventStreamInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventStreamName = value.eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

extension DeleteIntegrationInput {

    static func urlPathProvider(_ value: DeleteIntegrationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations/delete"
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/delete"
    }
}

extension DeleteProfileKeyInput {

    static func urlPathProvider(_ value: DeleteProfileKeyInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/keys/delete"
    }
}

extension DeleteProfileObjectInput {

    static func urlPathProvider(_ value: DeleteProfileObjectInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects/delete"
    }
}

extension DeleteProfileObjectTypeInput {

    static func urlPathProvider(_ value: DeleteProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let workflowId = value.workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())"
    }
}

extension DetectProfileObjectTypeInput {

    static func urlPathProvider(_ value: DetectProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/detect/object-types"
    }
}

extension GetAutoMergingPreviewInput {

    static func urlPathProvider(_ value: GetAutoMergingPreviewInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs/auto-merging-preview"
    }
}

extension GetCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: GetCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension GetCalculatedAttributeForProfileInput {

    static func urlPathProvider(_ value: GetCalculatedAttributeForProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let profileId = value.profileId else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile/\(profileId.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension GetDomainInput {

    static func urlPathProvider(_ value: GetDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension GetEventStreamInput {

    static func urlPathProvider(_ value: GetEventStreamInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let eventStreamName = value.eventStreamName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams/\(eventStreamName.urlPercentEncoding())"
    }
}

extension GetIdentityResolutionJobInput {

    static func urlPathProvider(_ value: GetIdentityResolutionJobInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetIntegrationInput {

    static func urlPathProvider(_ value: GetIntegrationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

extension GetMatchesInput {

    static func urlPathProvider(_ value: GetMatchesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/matches"
    }
}

extension GetMatchesInput {

    static func queryItemProvider(_ value: GetMatchesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetProfileObjectTypeInput {

    static func urlPathProvider(_ value: GetProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

extension GetProfileObjectTypeTemplateInput {

    static func urlPathProvider(_ value: GetProfileObjectTypeTemplateInput) -> Swift.String? {
        guard let templateId = value.templateId else {
            return nil
        }
        return "/templates/\(templateId.urlPercentEncoding())"
    }
}

extension GetSimilarProfilesInput {

    static func urlPathProvider(_ value: GetSimilarProfilesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/matches"
    }
}

extension GetSimilarProfilesInput {

    static func queryItemProvider(_ value: GetSimilarProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let workflowId = value.workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())"
    }
}

extension GetWorkflowStepsInput {

    static func urlPathProvider(_ value: GetWorkflowStepsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let workflowId = value.workflowId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows/\(workflowId.urlPercentEncoding())/steps"
    }
}

extension GetWorkflowStepsInput {

    static func queryItemProvider(_ value: GetWorkflowStepsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAccountIntegrationsInput {

    static func urlPathProvider(_ value: ListAccountIntegrationsInput) -> Swift.String? {
        return "/integrations"
    }
}

extension ListAccountIntegrationsInput {

    static func queryItemProvider(_ value: ListAccountIntegrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeHidden = value.includeHidden {
            let includeHiddenQueryItem = Smithy.URIQueryItem(name: "include-hidden".urlPercentEncoding(), value: Swift.String(includeHidden).urlPercentEncoding())
            items.append(includeHiddenQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCalculatedAttributeDefinitionsInput {

    static func urlPathProvider(_ value: ListCalculatedAttributeDefinitionsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes"
    }
}

extension ListCalculatedAttributeDefinitionsInput {

    static func queryItemProvider(_ value: ListCalculatedAttributeDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCalculatedAttributesForProfileInput {

    static func urlPathProvider(_ value: ListCalculatedAttributesForProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let profileId = value.profileId else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profile/\(profileId.urlPercentEncoding())/calculated-attributes"
    }
}

extension ListCalculatedAttributesForProfileInput {

    static func queryItemProvider(_ value: ListCalculatedAttributesForProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/domains"
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventStreamsInput {

    static func urlPathProvider(_ value: ListEventStreamsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/event-streams"
    }
}

extension ListEventStreamsInput {

    static func queryItemProvider(_ value: ListEventStreamsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdentityResolutionJobsInput {

    static func urlPathProvider(_ value: ListIdentityResolutionJobsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/identity-resolution-jobs"
    }
}

extension ListIdentityResolutionJobsInput {

    static func queryItemProvider(_ value: ListIdentityResolutionJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIntegrationsInput {

    static func urlPathProvider(_ value: ListIntegrationsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

extension ListIntegrationsInput {

    static func queryItemProvider(_ value: ListIntegrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeHidden = value.includeHidden {
            let includeHiddenQueryItem = Smithy.URIQueryItem(name: "include-hidden".urlPercentEncoding(), value: Swift.String(includeHidden).urlPercentEncoding())
            items.append(includeHiddenQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileObjectsInput {

    static func urlPathProvider(_ value: ListProfileObjectsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects"
    }
}

extension ListProfileObjectsInput {

    static func queryItemProvider(_ value: ListProfileObjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileObjectTypesInput {

    static func urlPathProvider(_ value: ListProfileObjectTypesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types"
    }
}

extension ListProfileObjectTypesInput {

    static func queryItemProvider(_ value: ListProfileObjectTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileObjectTypeTemplatesInput {

    static func urlPathProvider(_ value: ListProfileObjectTypeTemplatesInput) -> Swift.String? {
        return "/templates"
    }
}

extension ListProfileObjectTypeTemplatesInput {

    static func queryItemProvider(_ value: ListProfileObjectTypeTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRuleBasedMatchesInput {

    static func urlPathProvider(_ value: ListRuleBasedMatchesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/ruleBasedMatches"
    }
}

extension ListRuleBasedMatchesInput {

    static func queryItemProvider(_ value: ListRuleBasedMatchesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/workflows"
    }
}

extension ListWorkflowsInput {

    static func queryItemProvider(_ value: ListWorkflowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension MergeProfilesInput {

    static func urlPathProvider(_ value: MergeProfilesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects/merge"
    }
}

extension PutIntegrationInput {

    static func urlPathProvider(_ value: PutIntegrationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/integrations"
    }
}

extension PutProfileObjectInput {

    static func urlPathProvider(_ value: PutProfileObjectInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/objects"
    }
}

extension PutProfileObjectTypeInput {

    static func urlPathProvider(_ value: PutProfileObjectTypeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let objectTypeName = value.objectTypeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/object-types/\(objectTypeName.urlPercentEncoding())"
    }
}

extension SearchProfilesInput {

    static func urlPathProvider(_ value: SearchProfilesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles/search"
    }
}

extension SearchProfilesInput {

    static func queryItemProvider(_ value: SearchProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateCalculatedAttributeDefinitionInput {

    static func urlPathProvider(_ value: UpdateCalculatedAttributeDefinitionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let calculatedAttributeName = value.calculatedAttributeName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/calculated-attributes/\(calculatedAttributeName.urlPercentEncoding())"
    }
}

extension UpdateDomainInput {

    static func urlPathProvider(_ value: UpdateDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domains/\(domainName.urlPercentEncoding())/profiles"
    }
}

extension AddProfileKeyInput {

    static func write(value: AddProfileKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["ProfileId"].write(value.profileId)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCalculatedAttributeDefinitionInput {

    static func write(value: CreateCalculatedAttributeDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeDetails"].write(value.attributeDetails, with: CustomerProfilesClientTypes.AttributeDetails.write(value:to:))
        try writer["Conditions"].write(value.conditions, with: CustomerProfilesClientTypes.Conditions.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["Statistic"].write(value.statistic)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeadLetterQueueUrl"].write(value.deadLetterQueueUrl)
        try writer["DefaultEncryptionKey"].write(value.defaultEncryptionKey)
        try writer["DefaultExpirationDays"].write(value.defaultExpirationDays)
        try writer["Matching"].write(value.matching, with: CustomerProfilesClientTypes.MatchingRequest.write(value:to:))
        try writer["RuleBasedMatching"].write(value.ruleBasedMatching, with: CustomerProfilesClientTypes.RuleBasedMatchingRequest.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEventStreamInput {

    static func write(value: CreateEventStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Uri"].write(value.uri)
    }
}

extension CreateIntegrationWorkflowInput {

    static func write(value: CreateIntegrationWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IntegrationConfig"].write(value.integrationConfig, with: CustomerProfilesClientTypes.IntegrationConfig.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WorkflowType"].write(value.workflowType)
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber)
        try writer["AdditionalInformation"].write(value.additionalInformation)
        try writer["Address"].write(value.address, with: CustomerProfilesClientTypes.Address.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress, with: CustomerProfilesClientTypes.Address.write(value:to:))
        try writer["BirthDate"].write(value.birthDate)
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress)
        try writer["BusinessName"].write(value.businessName)
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["FirstName"].write(value.firstName)
        try writer["Gender"].write(value.gender)
        try writer["GenderString"].write(value.genderString)
        try writer["HomePhoneNumber"].write(value.homePhoneNumber)
        try writer["LastName"].write(value.lastName)
        try writer["MailingAddress"].write(value.mailingAddress, with: CustomerProfilesClientTypes.Address.write(value:to:))
        try writer["MiddleName"].write(value.middleName)
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["PartyType"].write(value.partyType)
        try writer["PartyTypeString"].write(value.partyTypeString)
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["ShippingAddress"].write(value.shippingAddress, with: CustomerProfilesClientTypes.Address.write(value:to:))
    }
}

extension DeleteIntegrationInput {

    static func write(value: DeleteIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }
}

extension DeleteProfileInput {

    static func write(value: DeleteProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
    }
}

extension DeleteProfileKeyInput {

    static func write(value: DeleteProfileKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["ProfileId"].write(value.profileId)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteProfileObjectInput {

    static func write(value: DeleteProfileObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["ProfileId"].write(value.profileId)
        try writer["ProfileObjectUniqueKey"].write(value.profileObjectUniqueKey)
    }
}

extension DetectProfileObjectTypeInput {

    static func write(value: DetectProfileObjectTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Objects"].writeList(value.objects, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetAutoMergingPreviewInput {

    static func write(value: GetAutoMergingPreviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConflictResolution"].write(value.conflictResolution, with: CustomerProfilesClientTypes.ConflictResolution.write(value:to:))
        try writer["Consolidation"].write(value.consolidation, with: CustomerProfilesClientTypes.Consolidation.write(value:to:))
        try writer["MinAllowedConfidenceScoreForMerging"].write(value.minAllowedConfidenceScoreForMerging)
    }
}

extension GetIntegrationInput {

    static func write(value: GetIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }
}

extension GetSimilarProfilesInput {

    static func write(value: GetSimilarProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchType"].write(value.matchType)
        try writer["SearchKey"].write(value.searchKey)
        try writer["SearchValue"].write(value.searchValue)
    }
}

extension ListAccountIntegrationsInput {

    static func write(value: ListAccountIntegrationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }
}

extension ListProfileObjectsInput {

    static func write(value: ListProfileObjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectFilter"].write(value.objectFilter, with: CustomerProfilesClientTypes.ObjectFilter.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["ProfileId"].write(value.profileId)
    }
}

extension ListWorkflowsInput {

    static func write(value: ListWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryEndDate"].writeTimestamp(value.queryEndDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["QueryStartDate"].writeTimestamp(value.queryStartDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Status"].write(value.status)
        try writer["WorkflowType"].write(value.workflowType)
    }
}

extension MergeProfilesInput {

    static func write(value: MergeProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldSourceProfileIds"].write(value.fieldSourceProfileIds, with: CustomerProfilesClientTypes.FieldSourceProfileIds.write(value:to:))
        try writer["MainProfileId"].write(value.mainProfileId)
        try writer["ProfileIdsToBeMerged"].writeList(value.profileIdsToBeMerged, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutIntegrationInput {

    static func write(value: PutIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowDefinition"].write(value.flowDefinition, with: CustomerProfilesClientTypes.FlowDefinition.write(value:to:))
        try writer["ObjectTypeName"].write(value.objectTypeName)
        try writer["ObjectTypeNames"].writeMap(value.objectTypeNames, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Uri"].write(value.uri)
    }
}

extension PutProfileObjectInput {

    static func write(value: PutProfileObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
        try writer["ObjectTypeName"].write(value.objectTypeName)
    }
}

extension PutProfileObjectTypeInput {

    static func write(value: PutProfileObjectTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowProfileCreation"].write(value.allowProfileCreation)
        try writer["Description"].write(value.description)
        try writer["EncryptionKey"].write(value.encryptionKey)
        try writer["ExpirationDays"].write(value.expirationDays)
        try writer["Fields"].writeMap(value.fields, valueWritingClosure: CustomerProfilesClientTypes.ObjectTypeField.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Keys"].writeMap(value.keys, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: CustomerProfilesClientTypes.ObjectTypeKey.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MaxProfileObjectCount"].write(value.maxProfileObjectCount)
        try writer["SourceLastUpdatedTimestampFormat"].write(value.sourceLastUpdatedTimestampFormat)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TemplateId"].write(value.templateId)
    }
}

extension SearchProfilesInput {

    static func write(value: SearchProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalSearchKeys"].writeList(value.additionalSearchKeys, memberWritingClosure: CustomerProfilesClientTypes.AdditionalSearchKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KeyName"].write(value.keyName)
        try writer["LogicalOperator"].write(value.logicalOperator)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateCalculatedAttributeDefinitionInput {

    static func write(value: UpdateCalculatedAttributeDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Conditions"].write(value.conditions, with: CustomerProfilesClientTypes.Conditions.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
    }
}

extension UpdateDomainInput {

    static func write(value: UpdateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeadLetterQueueUrl"].write(value.deadLetterQueueUrl)
        try writer["DefaultEncryptionKey"].write(value.defaultEncryptionKey)
        try writer["DefaultExpirationDays"].write(value.defaultExpirationDays)
        try writer["Matching"].write(value.matching, with: CustomerProfilesClientTypes.MatchingRequest.write(value:to:))
        try writer["RuleBasedMatching"].write(value.ruleBasedMatching, with: CustomerProfilesClientTypes.RuleBasedMatchingRequest.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber)
        try writer["AdditionalInformation"].write(value.additionalInformation)
        try writer["Address"].write(value.address, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
        try writer["BirthDate"].write(value.birthDate)
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress)
        try writer["BusinessName"].write(value.businessName)
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["FirstName"].write(value.firstName)
        try writer["Gender"].write(value.gender)
        try writer["GenderString"].write(value.genderString)
        try writer["HomePhoneNumber"].write(value.homePhoneNumber)
        try writer["LastName"].write(value.lastName)
        try writer["MailingAddress"].write(value.mailingAddress, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
        try writer["MiddleName"].write(value.middleName)
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["PartyType"].write(value.partyType)
        try writer["PartyTypeString"].write(value.partyTypeString)
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["ProfileId"].write(value.profileId)
        try writer["ShippingAddress"].write(value.shippingAddress, with: CustomerProfilesClientTypes.UpdateAddress.write(value:to:))
    }
}

extension AddProfileKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddProfileKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddProfileKeyOutput()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCalculatedAttributeDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCalculatedAttributeDefinitionOutput()
        value.attributeDetails = try reader["AttributeDetails"].readIfPresent(with: CustomerProfilesClientTypes.AttributeDetails.read(from:))
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.conditions = try reader["Conditions"].readIfPresent(with: CustomerProfilesClientTypes.Conditions.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statistic = try reader["Statistic"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deadLetterQueueUrl = try reader["DeadLetterQueueUrl"].readIfPresent()
        value.defaultEncryptionKey = try reader["DefaultEncryptionKey"].readIfPresent()
        value.defaultExpirationDays = try reader["DefaultExpirationDays"].readIfPresent() ?? 0
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.matching = try reader["Matching"].readIfPresent(with: CustomerProfilesClientTypes.MatchingResponse.read(from:))
        value.ruleBasedMatching = try reader["RuleBasedMatching"].readIfPresent(with: CustomerProfilesClientTypes.RuleBasedMatchingResponse.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventStreamOutput()
        value.eventStreamArn = try reader["EventStreamArn"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateIntegrationWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationWorkflowOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCalculatedAttributeDefinitionOutput {
        return DeleteCalculatedAttributeDefinitionOutput()
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventStreamOutput {
        return DeleteEventStreamOutput()
    }
}

extension DeleteIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIntegrationOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteProfileKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileKeyOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteProfileObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileObjectOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileObjectTypeOutput()
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowOutput {
        return DeleteWorkflowOutput()
    }
}

extension DetectProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetectProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetectProfileObjectTypeOutput()
        value.detectedProfileObjectTypes = try reader["DetectedProfileObjectTypes"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.DetectedProfileObjectType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAutoMergingPreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutoMergingPreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutoMergingPreviewOutput()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.numberOfMatchesInSample = try reader["NumberOfMatchesInSample"].readIfPresent() ?? 0
        value.numberOfProfilesInSample = try reader["NumberOfProfilesInSample"].readIfPresent() ?? 0
        value.numberOfProfilesWillBeMerged = try reader["NumberOfProfilesWillBeMerged"].readIfPresent() ?? 0
        return value
    }
}

extension GetCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCalculatedAttributeDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculatedAttributeDefinitionOutput()
        value.attributeDetails = try reader["AttributeDetails"].readIfPresent(with: CustomerProfilesClientTypes.AttributeDetails.read(from:))
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.conditions = try reader["Conditions"].readIfPresent(with: CustomerProfilesClientTypes.Conditions.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statistic = try reader["Statistic"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetCalculatedAttributeForProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCalculatedAttributeForProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculatedAttributeForProfileOutput()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.isDataPartial = try reader["IsDataPartial"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension GetDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deadLetterQueueUrl = try reader["DeadLetterQueueUrl"].readIfPresent()
        value.defaultEncryptionKey = try reader["DefaultEncryptionKey"].readIfPresent()
        value.defaultExpirationDays = try reader["DefaultExpirationDays"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.matching = try reader["Matching"].readIfPresent(with: CustomerProfilesClientTypes.MatchingResponse.read(from:))
        value.ruleBasedMatching = try reader["RuleBasedMatching"].readIfPresent(with: CustomerProfilesClientTypes.RuleBasedMatchingResponse.read(from:))
        value.stats = try reader["Stats"].readIfPresent(with: CustomerProfilesClientTypes.DomainStats.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventStreamOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationDetails = try reader["DestinationDetails"].readIfPresent(with: CustomerProfilesClientTypes.EventStreamDestinationDetails.read(from:))
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.eventStreamArn = try reader["EventStreamArn"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.stoppedSince = try reader["StoppedSince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetIdentityResolutionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdentityResolutionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdentityResolutionJobOutput()
        value.autoMerging = try reader["AutoMerging"].readIfPresent(with: CustomerProfilesClientTypes.AutoMerging.read(from:))
        value.domainName = try reader["DomainName"].readIfPresent()
        value.exportingLocation = try reader["ExportingLocation"].readIfPresent(with: CustomerProfilesClientTypes.ExportingLocation.read(from:))
        value.jobEndTime = try reader["JobEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobExpirationTime = try reader["JobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobStartTime = try reader["JobStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobStats = try reader["JobStats"].readIfPresent(with: CustomerProfilesClientTypes.JobStats.read(from:))
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.isUnstructured = try reader["IsUnstructured"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.objectTypeNames = try reader["ObjectTypeNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        return value
    }
}

extension GetMatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMatchesOutput()
        value.matchGenerationDate = try reader["MatchGenerationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.matches = try reader["Matches"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.MatchItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.potentialMatches = try reader["PotentialMatches"].readIfPresent()
        return value
    }
}

extension GetProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileObjectTypeOutput()
        value.allowProfileCreation = try reader["AllowProfileCreation"].readIfPresent() ?? false
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.encryptionKey = try reader["EncryptionKey"].readIfPresent()
        value.expirationDays = try reader["ExpirationDays"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxAvailableProfileObjectCount = try reader["MaxAvailableProfileObjectCount"].readIfPresent()
        value.maxProfileObjectCount = try reader["MaxProfileObjectCount"].readIfPresent()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent() ?? ""
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension GetProfileObjectTypeTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileObjectTypeTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileObjectTypeTemplateOutput()
        value.allowProfileCreation = try reader["AllowProfileCreation"].readIfPresent() ?? false
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.sourceName = try reader["SourceName"].readIfPresent()
        value.sourceObject = try reader["SourceObject"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension GetSimilarProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSimilarProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSimilarProfilesOutput()
        value.confidenceScore = try reader["ConfidenceScore"].readIfPresent()
        value.matchId = try reader["MatchId"].readIfPresent()
        value.matchType = try reader["MatchType"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profileIds = try reader["ProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleLevel = try reader["RuleLevel"].readIfPresent()
        return value
    }
}

extension GetWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowOutput()
        value.attributes = try reader["Attributes"].readIfPresent(with: CustomerProfilesClientTypes.WorkflowAttributes.read(from:))
        value.errorDescription = try reader["ErrorDescription"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metrics = try reader["Metrics"].readIfPresent(with: CustomerProfilesClientTypes.WorkflowMetrics.read(from:))
        value.startDate = try reader["StartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.workflowType = try reader["WorkflowType"].readIfPresent()
        return value
    }
}

extension GetWorkflowStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowStepsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.WorkflowStepItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.workflowType = try reader["WorkflowType"].readIfPresent()
        return value
    }
}

extension ListAccountIntegrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountIntegrationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListIntegrationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCalculatedAttributeDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCalculatedAttributeDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCalculatedAttributeDefinitionsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCalculatedAttributesForProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCalculatedAttributesForProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCalculatedAttributesForProfileOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListDomainItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventStreamsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.EventStreamSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIdentityResolutionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentityResolutionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentityResolutionJobsOutput()
        value.identityResolutionJobsList = try reader["IdentityResolutionJobsList"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.IdentityResolutionJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIntegrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIntegrationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListIntegrationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProfileObjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileObjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileObjectsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListProfileObjectsItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProfileObjectTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileObjectTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileObjectTypesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListProfileObjectTypeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProfileObjectTypeTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileObjectTypeTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileObjectTypeTemplatesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRuleBasedMatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRuleBasedMatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRuleBasedMatchesOutput()
        value.matchIds = try reader["MatchIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.ListWorkflowsItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension MergeProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergeProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergeProfilesOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension PutIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutIntegrationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.isUnstructured = try reader["IsUnstructured"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.objectTypeNames = try reader["ObjectTypeNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        return value
    }
}

extension PutProfileObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProfileObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProfileObjectOutput()
        value.profileObjectUniqueKey = try reader["ProfileObjectUniqueKey"].readIfPresent()
        return value
    }
}

extension PutProfileObjectTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProfileObjectTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProfileObjectTypeOutput()
        value.allowProfileCreation = try reader["AllowProfileCreation"].readIfPresent() ?? false
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.encryptionKey = try reader["EncryptionKey"].readIfPresent()
        value.expirationDays = try reader["ExpirationDays"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxAvailableProfileObjectCount = try reader["MaxAvailableProfileObjectCount"].readIfPresent()
        value.maxProfileObjectCount = try reader["MaxProfileObjectCount"].readIfPresent()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent() ?? ""
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension SearchProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchProfilesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.Profile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCalculatedAttributeDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCalculatedAttributeDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCalculatedAttributeDefinitionOutput()
        value.attributeDetails = try reader["AttributeDetails"].readIfPresent(with: CustomerProfilesClientTypes.AttributeDetails.read(from:))
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.conditions = try reader["Conditions"].readIfPresent(with: CustomerProfilesClientTypes.Conditions.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statistic = try reader["Statistic"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deadLetterQueueUrl = try reader["DeadLetterQueueUrl"].readIfPresent()
        value.defaultEncryptionKey = try reader["DefaultEncryptionKey"].readIfPresent()
        value.defaultExpirationDays = try reader["DefaultExpirationDays"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.matching = try reader["Matching"].readIfPresent(with: CustomerProfilesClientTypes.MatchingResponse.read(from:))
        value.ruleBasedMatching = try reader["RuleBasedMatching"].readIfPresent(with: CustomerProfilesClientTypes.RuleBasedMatchingResponse.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

enum AddProfileKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetectProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutoMergingPreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCalculatedAttributeForProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdentityResolutionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileObjectTypeTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSimilarProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountIntegrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCalculatedAttributeDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCalculatedAttributesForProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentityResolutionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIntegrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileObjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileObjectTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileObjectTypeTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRuleBasedMatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergeProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProfileObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProfileObjectTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCalculatedAttributeDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeDetails {

    static func write(value: CustomerProfilesClientTypes.AttributeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: CustomerProfilesClientTypes.AttributeItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeDetails()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.AttributeItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeItem {

    static func write(value: CustomerProfilesClientTypes.AttributeItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeItem()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.Conditions {

    static func write(value: CustomerProfilesClientTypes.Conditions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectCount"].write(value.objectCount)
        try writer["Range"].write(value.range, with: CustomerProfilesClientTypes.Range.write(value:to:))
        try writer["Threshold"].write(value.threshold, with: CustomerProfilesClientTypes.Threshold.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Conditions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Conditions()
        value.range = try reader["Range"].readIfPresent(with: CustomerProfilesClientTypes.Range.read(from:))
        value.objectCount = try reader["ObjectCount"].readIfPresent()
        value.threshold = try reader["Threshold"].readIfPresent(with: CustomerProfilesClientTypes.Threshold.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.Threshold {

    static func write(value: CustomerProfilesClientTypes.Threshold?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Threshold {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Threshold()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CustomerProfilesClientTypes.Range {

    static func write(value: CustomerProfilesClientTypes.Range?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Range {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Range()
        value.value = try reader["Value"].readIfPresent() ?? 0
        value.unit = try reader["Unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CustomerProfilesClientTypes.MatchingResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.MatchingResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.MatchingResponse()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.jobSchedule = try reader["JobSchedule"].readIfPresent(with: CustomerProfilesClientTypes.JobSchedule.read(from:))
        value.autoMerging = try reader["AutoMerging"].readIfPresent(with: CustomerProfilesClientTypes.AutoMerging.read(from:))
        value.exportingConfig = try reader["ExportingConfig"].readIfPresent(with: CustomerProfilesClientTypes.ExportingConfig.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.ExportingConfig {

    static func write(value: CustomerProfilesClientTypes.ExportingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Exporting"].write(value.s3Exporting, with: CustomerProfilesClientTypes.S3ExportingConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ExportingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ExportingConfig()
        value.s3Exporting = try reader["S3Exporting"].readIfPresent(with: CustomerProfilesClientTypes.S3ExportingConfig.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.S3ExportingConfig {

    static func write(value: CustomerProfilesClientTypes.S3ExportingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyName"].write(value.s3KeyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.S3ExportingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.S3ExportingConfig()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent() ?? ""
        value.s3KeyName = try reader["S3KeyName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.AutoMerging {

    static func write(value: CustomerProfilesClientTypes.AutoMerging?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConflictResolution"].write(value.conflictResolution, with: CustomerProfilesClientTypes.ConflictResolution.write(value:to:))
        try writer["Consolidation"].write(value.consolidation, with: CustomerProfilesClientTypes.Consolidation.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["MinAllowedConfidenceScoreForMerging"].write(value.minAllowedConfidenceScoreForMerging)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AutoMerging {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AutoMerging()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.consolidation = try reader["Consolidation"].readIfPresent(with: CustomerProfilesClientTypes.Consolidation.read(from:))
        value.conflictResolution = try reader["ConflictResolution"].readIfPresent(with: CustomerProfilesClientTypes.ConflictResolution.read(from:))
        value.minAllowedConfidenceScoreForMerging = try reader["MinAllowedConfidenceScoreForMerging"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ConflictResolution {

    static func write(value: CustomerProfilesClientTypes.ConflictResolution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConflictResolvingModel"].write(value.conflictResolvingModel)
        try writer["SourceName"].write(value.sourceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ConflictResolution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ConflictResolution()
        value.conflictResolvingModel = try reader["ConflictResolvingModel"].readIfPresent() ?? .sdkUnknown("")
        value.sourceName = try reader["SourceName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.Consolidation {

    static func write(value: CustomerProfilesClientTypes.Consolidation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchingAttributesList"].writeList(value.matchingAttributesList, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Consolidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Consolidation()
        value.matchingAttributesList = try reader["MatchingAttributesList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.JobSchedule {

    static func write(value: CustomerProfilesClientTypes.JobSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfTheWeek"].write(value.dayOfTheWeek)
        try writer["Time"].write(value.time)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.JobSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.JobSchedule()
        value.dayOfTheWeek = try reader["DayOfTheWeek"].readIfPresent() ?? .sdkUnknown("")
        value.time = try reader["Time"].readIfPresent() ?? ""
        return value
    }
}

extension CustomerProfilesClientTypes.RuleBasedMatchingResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.RuleBasedMatchingResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.RuleBasedMatchingResponse()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.matchingRules = try reader["MatchingRules"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.MatchingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.maxAllowedRuleLevelForMerging = try reader["MaxAllowedRuleLevelForMerging"].readIfPresent()
        value.maxAllowedRuleLevelForMatching = try reader["MaxAllowedRuleLevelForMatching"].readIfPresent()
        value.attributeTypesSelector = try reader["AttributeTypesSelector"].readIfPresent(with: CustomerProfilesClientTypes.AttributeTypesSelector.read(from:))
        value.conflictResolution = try reader["ConflictResolution"].readIfPresent(with: CustomerProfilesClientTypes.ConflictResolution.read(from:))
        value.exportingConfig = try reader["ExportingConfig"].readIfPresent(with: CustomerProfilesClientTypes.ExportingConfig.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AttributeTypesSelector {

    static func write(value: CustomerProfilesClientTypes.AttributeTypesSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].writeList(value.address, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttributeMatchingModel"].write(value.attributeMatchingModel)
        try writer["EmailAddress"].writeList(value.emailAddress, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PhoneNumber"].writeList(value.phoneNumber, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AttributeTypesSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AttributeTypesSelector()
        value.attributeMatchingModel = try reader["AttributeMatchingModel"].readIfPresent() ?? .sdkUnknown("")
        value.address = try reader["Address"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.phoneNumber = try reader["PhoneNumber"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.emailAddress = try reader["EmailAddress"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.MatchingRule {

    static func write(value: CustomerProfilesClientTypes.MatchingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rule"].writeList(value.rule, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.MatchingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.MatchingRule()
        value.rule = try reader["Rule"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CustomerProfilesClientTypes.DetectedProfileObjectType {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DetectedProfileObjectType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DetectedProfileObjectType()
        value.sourceLastUpdatedTimestampFormat = try reader["SourceLastUpdatedTimestampFormat"].readIfPresent()
        value.fields = try reader["Fields"].readMapIfPresent(valueReadingClosure: CustomerProfilesClientTypes.ObjectTypeField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.keys = try reader["Keys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: CustomerProfilesClientTypes.ObjectTypeKey.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ObjectTypeKey {

    static func write(value: CustomerProfilesClientTypes.ObjectTypeKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldNames"].writeList(value.fieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StandardIdentifiers"].writeList(value.standardIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CustomerProfilesClientTypes.StandardIdentifier>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ObjectTypeKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ObjectTypeKey()
        value.standardIdentifiers = try reader["StandardIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CustomerProfilesClientTypes.StandardIdentifier>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fieldNames = try reader["FieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ObjectTypeField {

    static func write(value: CustomerProfilesClientTypes.ObjectTypeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentType"].write(value.contentType)
        try writer["Source"].write(value.source)
        try writer["Target"].write(value.target)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ObjectTypeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ObjectTypeField()
        value.source = try reader["Source"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.DomainStats {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DomainStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DomainStats()
        value.profileCount = try reader["ProfileCount"].readIfPresent() ?? 0
        value.meteringProfileCount = try reader["MeteringProfileCount"].readIfPresent() ?? 0
        value.objectCount = try reader["ObjectCount"].readIfPresent() ?? 0
        value.totalSize = try reader["TotalSize"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.EventStreamDestinationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventStreamDestinationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventStreamDestinationDetails()
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.unhealthySince = try reader["UnhealthySince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ExportingLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ExportingLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ExportingLocation()
        value.s3Exporting = try reader["S3Exporting"].readIfPresent(with: CustomerProfilesClientTypes.S3ExportingLocation.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.S3ExportingLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.S3ExportingLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.S3ExportingLocation()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyName = try reader["S3KeyName"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.JobStats {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.JobStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.JobStats()
        value.numberOfProfilesReviewed = try reader["NumberOfProfilesReviewed"].readIfPresent() ?? 0
        value.numberOfMatchesFound = try reader["NumberOfMatchesFound"].readIfPresent() ?? 0
        value.numberOfMergesDone = try reader["NumberOfMergesDone"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.MatchItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.MatchItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.MatchItem()
        value.matchId = try reader["MatchId"].readIfPresent()
        value.profileIds = try reader["ProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.confidenceScore = try reader["ConfidenceScore"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.WorkflowAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.WorkflowAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.WorkflowAttributes()
        value.appflowIntegration = try reader["AppflowIntegration"].readIfPresent(with: CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AppflowIntegrationWorkflowAttributes()
        value.sourceConnectorType = try reader["SourceConnectorType"].readIfPresent() ?? .sdkUnknown("")
        value.connectorProfileName = try reader["ConnectorProfileName"].readIfPresent() ?? ""
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.WorkflowMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.WorkflowMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.WorkflowMetrics()
        value.appflowIntegration = try reader["AppflowIntegration"].readIfPresent(with: CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AppflowIntegrationWorkflowMetrics()
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent() ?? 0
        value.stepsCompleted = try reader["StepsCompleted"].readIfPresent() ?? 0
        value.totalSteps = try reader["TotalSteps"].readIfPresent() ?? 0
        return value
    }
}

extension CustomerProfilesClientTypes.WorkflowStepItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.WorkflowStepItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.WorkflowStepItem()
        value.appflowIntegration = try reader["AppflowIntegration"].readIfPresent(with: CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep.read(from:))
        return value
    }
}

extension CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.AppflowIntegrationWorkflowStep()
        value.flowName = try reader["FlowName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.executionMessage = try reader["ExecutionMessage"].readIfPresent() ?? ""
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent() ?? 0
        value.batchRecordsStartTime = try reader["BatchRecordsStartTime"].readIfPresent() ?? ""
        value.batchRecordsEndTime = try reader["BatchRecordsEndTime"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CustomerProfilesClientTypes.ListIntegrationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListIntegrationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListIntegrationItem()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.objectTypeNames = try reader["ObjectTypeNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workflowId = try reader["WorkflowId"].readIfPresent()
        value.isUnstructured = try reader["IsUnstructured"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListCalculatedAttributeDefinitionItem()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListCalculatedAttributeForProfileItem()
        value.calculatedAttributeName = try reader["CalculatedAttributeName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.isDataPartial = try reader["IsDataPartial"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListDomainItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListDomainItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListDomainItem()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.EventStreamSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.EventStreamSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.EventStreamSummary()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.eventStreamName = try reader["EventStreamName"].readIfPresent() ?? ""
        value.eventStreamArn = try reader["EventStreamArn"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.stoppedSince = try reader["StoppedSince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinationSummary = try reader["DestinationSummary"].readIfPresent(with: CustomerProfilesClientTypes.DestinationSummary.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.DestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.DestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.DestinationSummary()
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.unhealthySince = try reader["UnhealthySince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CustomerProfilesClientTypes.IdentityResolutionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.IdentityResolutionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.IdentityResolutionJob()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.jobStartTime = try reader["JobStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobEndTime = try reader["JobEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobStats = try reader["JobStats"].readIfPresent(with: CustomerProfilesClientTypes.JobStats.read(from:))
        value.exportingLocation = try reader["ExportingLocation"].readIfPresent(with: CustomerProfilesClientTypes.ExportingLocation.read(from:))
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListProfileObjectsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListProfileObjectsItem()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent()
        value.profileObjectUniqueKey = try reader["ProfileObjectUniqueKey"].readIfPresent()
        value.object = try reader["Object"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectTypeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListProfileObjectTypeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListProfileObjectTypeItem()
        value.objectTypeName = try reader["ObjectTypeName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxProfileObjectCount = try reader["MaxProfileObjectCount"].readIfPresent()
        value.maxAvailableProfileObjectCount = try reader["MaxAvailableProfileObjectCount"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListProfileObjectTypeTemplateItem()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.sourceName = try reader["SourceName"].readIfPresent()
        value.sourceObject = try reader["SourceObject"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.ListWorkflowsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.ListWorkflowsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.ListWorkflowsItem()
        value.workflowType = try reader["WorkflowType"].readIfPresent() ?? .sdkUnknown("")
        value.workflowId = try reader["WorkflowId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusDescription = try reader["StatusDescription"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CustomerProfilesClientTypes.Profile {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Profile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Profile()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.accountNumber = try reader["AccountNumber"].readIfPresent()
        value.additionalInformation = try reader["AdditionalInformation"].readIfPresent()
        value.partyType = try reader["PartyType"].readIfPresent()
        value.businessName = try reader["BusinessName"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.middleName = try reader["MiddleName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.birthDate = try reader["BirthDate"].readIfPresent()
        value.gender = try reader["Gender"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.mobilePhoneNumber = try reader["MobilePhoneNumber"].readIfPresent()
        value.homePhoneNumber = try reader["HomePhoneNumber"].readIfPresent()
        value.businessPhoneNumber = try reader["BusinessPhoneNumber"].readIfPresent()
        value.emailAddress = try reader["EmailAddress"].readIfPresent()
        value.personalEmailAddress = try reader["PersonalEmailAddress"].readIfPresent()
        value.businessEmailAddress = try reader["BusinessEmailAddress"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.shippingAddress = try reader["ShippingAddress"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.mailingAddress = try reader["MailingAddress"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.billingAddress = try reader["BillingAddress"].readIfPresent(with: CustomerProfilesClientTypes.Address.read(from:))
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.foundByItems = try reader["FoundByItems"].readListIfPresent(memberReadingClosure: CustomerProfilesClientTypes.FoundByKeyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.partyTypeString = try reader["PartyTypeString"].readIfPresent()
        value.genderString = try reader["GenderString"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.FoundByKeyValue {

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.FoundByKeyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.FoundByKeyValue()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CustomerProfilesClientTypes.Address {

    static func write(value: CustomerProfilesClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address1"].write(value.address1)
        try writer["Address2"].write(value.address2)
        try writer["Address3"].write(value.address3)
        try writer["Address4"].write(value.address4)
        try writer["City"].write(value.city)
        try writer["Country"].write(value.country)
        try writer["County"].write(value.county)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Province"].write(value.province)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CustomerProfilesClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CustomerProfilesClientTypes.Address()
        value.address1 = try reader["Address1"].readIfPresent()
        value.address2 = try reader["Address2"].readIfPresent()
        value.address3 = try reader["Address3"].readIfPresent()
        value.address4 = try reader["Address4"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.county = try reader["County"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.province = try reader["Province"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        return value
    }
}

extension CustomerProfilesClientTypes.MatchingRequest {

    static func write(value: CustomerProfilesClientTypes.MatchingRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoMerging"].write(value.autoMerging, with: CustomerProfilesClientTypes.AutoMerging.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["ExportingConfig"].write(value.exportingConfig, with: CustomerProfilesClientTypes.ExportingConfig.write(value:to:))
        try writer["JobSchedule"].write(value.jobSchedule, with: CustomerProfilesClientTypes.JobSchedule.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.RuleBasedMatchingRequest {

    static func write(value: CustomerProfilesClientTypes.RuleBasedMatchingRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeTypesSelector"].write(value.attributeTypesSelector, with: CustomerProfilesClientTypes.AttributeTypesSelector.write(value:to:))
        try writer["ConflictResolution"].write(value.conflictResolution, with: CustomerProfilesClientTypes.ConflictResolution.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["ExportingConfig"].write(value.exportingConfig, with: CustomerProfilesClientTypes.ExportingConfig.write(value:to:))
        try writer["MatchingRules"].writeList(value.matchingRules, memberWritingClosure: CustomerProfilesClientTypes.MatchingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxAllowedRuleLevelForMatching"].write(value.maxAllowedRuleLevelForMatching)
        try writer["MaxAllowedRuleLevelForMerging"].write(value.maxAllowedRuleLevelForMerging)
    }
}

extension CustomerProfilesClientTypes.IntegrationConfig {

    static func write(value: CustomerProfilesClientTypes.IntegrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppflowIntegration"].write(value.appflowIntegration, with: CustomerProfilesClientTypes.AppflowIntegration.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.AppflowIntegration {

    static func write(value: CustomerProfilesClientTypes.AppflowIntegration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Batches"].writeList(value.batches, memberWritingClosure: CustomerProfilesClientTypes.Batch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FlowDefinition"].write(value.flowDefinition, with: CustomerProfilesClientTypes.FlowDefinition.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.Batch {

    static func write(value: CustomerProfilesClientTypes.Batch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension CustomerProfilesClientTypes.FlowDefinition {

    static func write(value: CustomerProfilesClientTypes.FlowDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FlowName"].write(value.flowName)
        try writer["KmsArn"].write(value.kmsArn)
        try writer["SourceFlowConfig"].write(value.sourceFlowConfig, with: CustomerProfilesClientTypes.SourceFlowConfig.write(value:to:))
        try writer["Tasks"].writeList(value.tasks, memberWritingClosure: CustomerProfilesClientTypes.Task.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TriggerConfig"].write(value.triggerConfig, with: CustomerProfilesClientTypes.TriggerConfig.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.TriggerConfig {

    static func write(value: CustomerProfilesClientTypes.TriggerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TriggerProperties"].write(value.triggerProperties, with: CustomerProfilesClientTypes.TriggerProperties.write(value:to:))
        try writer["TriggerType"].write(value.triggerType)
    }
}

extension CustomerProfilesClientTypes.TriggerProperties {

    static func write(value: CustomerProfilesClientTypes.TriggerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Scheduled"].write(value.scheduled, with: CustomerProfilesClientTypes.ScheduledTriggerProperties.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.ScheduledTriggerProperties {

    static func write(value: CustomerProfilesClientTypes.ScheduledTriggerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPullMode"].write(value.dataPullMode)
        try writer["FirstExecutionFrom"].writeTimestamp(value.firstExecutionFrom, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ScheduleEndTime"].writeTimestamp(value.scheduleEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["ScheduleStartTime"].writeTimestamp(value.scheduleStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Timezone"].write(value.timezone)
    }
}

extension CustomerProfilesClientTypes.Task {

    static func write(value: CustomerProfilesClientTypes.Task?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorOperator"].write(value.connectorOperator, with: CustomerProfilesClientTypes.ConnectorOperator.write(value:to:))
        try writer["DestinationField"].write(value.destinationField)
        try writer["SourceFields"].writeList(value.sourceFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskProperties"].writeMap(value.taskProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TaskType"].write(value.taskType)
    }
}

extension CustomerProfilesClientTypes.ConnectorOperator {

    static func write(value: CustomerProfilesClientTypes.ConnectorOperator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marketo"].write(value.marketo)
        try writer["S3"].write(value.s3)
        try writer["Salesforce"].write(value.salesforce)
        try writer["ServiceNow"].write(value.serviceNow)
        try writer["Zendesk"].write(value.zendesk)
    }
}

extension CustomerProfilesClientTypes.SourceFlowConfig {

    static func write(value: CustomerProfilesClientTypes.SourceFlowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorProfileName"].write(value.connectorProfileName)
        try writer["ConnectorType"].write(value.connectorType)
        try writer["IncrementalPullConfig"].write(value.incrementalPullConfig, with: CustomerProfilesClientTypes.IncrementalPullConfig.write(value:to:))
        try writer["SourceConnectorProperties"].write(value.sourceConnectorProperties, with: CustomerProfilesClientTypes.SourceConnectorProperties.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.SourceConnectorProperties {

    static func write(value: CustomerProfilesClientTypes.SourceConnectorProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marketo"].write(value.marketo, with: CustomerProfilesClientTypes.MarketoSourceProperties.write(value:to:))
        try writer["S3"].write(value.s3, with: CustomerProfilesClientTypes.S3SourceProperties.write(value:to:))
        try writer["Salesforce"].write(value.salesforce, with: CustomerProfilesClientTypes.SalesforceSourceProperties.write(value:to:))
        try writer["ServiceNow"].write(value.serviceNow, with: CustomerProfilesClientTypes.ServiceNowSourceProperties.write(value:to:))
        try writer["Zendesk"].write(value.zendesk, with: CustomerProfilesClientTypes.ZendeskSourceProperties.write(value:to:))
    }
}

extension CustomerProfilesClientTypes.ZendeskSourceProperties {

    static func write(value: CustomerProfilesClientTypes.ZendeskSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.ServiceNowSourceProperties {

    static func write(value: CustomerProfilesClientTypes.ServiceNowSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.SalesforceSourceProperties {

    static func write(value: CustomerProfilesClientTypes.SalesforceSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableDynamicFieldUpdate"].write(value.enableDynamicFieldUpdate)
        try writer["IncludeDeletedRecords"].write(value.includeDeletedRecords)
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.S3SourceProperties {

    static func write(value: CustomerProfilesClientTypes.S3SourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["BucketPrefix"].write(value.bucketPrefix)
    }
}

extension CustomerProfilesClientTypes.MarketoSourceProperties {

    static func write(value: CustomerProfilesClientTypes.MarketoSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Object"].write(value.object)
    }
}

extension CustomerProfilesClientTypes.IncrementalPullConfig {

    static func write(value: CustomerProfilesClientTypes.IncrementalPullConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatetimeTypeFieldName"].write(value.datetimeTypeFieldName)
    }
}

extension CustomerProfilesClientTypes.ObjectFilter {

    static func write(value: CustomerProfilesClientTypes.ObjectFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CustomerProfilesClientTypes.FieldSourceProfileIds {

    static func write(value: CustomerProfilesClientTypes.FieldSourceProfileIds?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountNumber"].write(value.accountNumber)
        try writer["AdditionalInformation"].write(value.additionalInformation)
        try writer["Address"].write(value.address)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["BillingAddress"].write(value.billingAddress)
        try writer["BirthDate"].write(value.birthDate)
        try writer["BusinessEmailAddress"].write(value.businessEmailAddress)
        try writer["BusinessName"].write(value.businessName)
        try writer["BusinessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["FirstName"].write(value.firstName)
        try writer["Gender"].write(value.gender)
        try writer["HomePhoneNumber"].write(value.homePhoneNumber)
        try writer["LastName"].write(value.lastName)
        try writer["MailingAddress"].write(value.mailingAddress)
        try writer["MiddleName"].write(value.middleName)
        try writer["MobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["PartyType"].write(value.partyType)
        try writer["PersonalEmailAddress"].write(value.personalEmailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["ShippingAddress"].write(value.shippingAddress)
    }
}

extension CustomerProfilesClientTypes.AdditionalSearchKey {

    static func write(value: CustomerProfilesClientTypes.AdditionalSearchKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyName"].write(value.keyName)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CustomerProfilesClientTypes.UpdateAddress {

    static func write(value: CustomerProfilesClientTypes.UpdateAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address1"].write(value.address1)
        try writer["Address2"].write(value.address2)
        try writer["Address3"].write(value.address3)
        try writer["Address4"].write(value.address4)
        try writer["City"].write(value.city)
        try writer["Country"].write(value.country)
        try writer["County"].write(value.county)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Province"].write(value.province)
        try writer["State"].write(value.state)
    }
}

public enum CustomerProfilesClientTypes {}
