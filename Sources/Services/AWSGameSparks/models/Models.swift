// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists, or another operation is in progress.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about a WebSocket connection.
    public struct Connection: Swift.Equatable {
        /// The date and time when the connection was created.
        public var created: ClientRuntime.Date?
        /// The identifier used to indicate a specific WebSocket connection.
        public var id: Swift.String?

        public init(
            created: ClientRuntime.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.created = created
            self.id = id
        }
    }

}

extension CreateGameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case gameName = "GameName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gameName = self.gameName {
            try encodeContainer.encode(gameName, forKey: .gameName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/game"
    }
}

public struct CreateGameInput: Swift.Equatable {
    /// A client-defined token. With an active client token in the request, this action is idempotent.
    public var clientToken: Swift.String?
    /// The description of the game.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of tags to apply to the game.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.gameName = gameName
        self.tags = tags
    }
}

struct CreateGameInputBody: Swift.Equatable {
    let gameName: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case gameName = "GameName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameName)
        gameName = gameNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGameOutputBody = try responseDecoder.decode(responseBody: data)
            self.game = output.game
        } else {
            self.game = nil
        }
    }
}

public struct CreateGameOutput: Swift.Equatable {
    /// Details about the game that was created.
    public var game: GameSparksClientTypes.GameDetails?

    public init(
        game: GameSparksClientTypes.GameDetails? = nil
    )
    {
        self.game = game
    }
}

struct CreateGameOutputBody: Swift.Equatable {
    let game: GameSparksClientTypes.GameDetails?
}

extension CreateGameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case game = "Game"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameDetails.self, forKey: .game)
        game = gameDecoded
    }
}

enum CreateGameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot"
    }
}

public struct CreateSnapshotInput: Swift.Equatable {
    /// The description of the snapshot.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?

    public init(
        description: Swift.String? = nil,
        gameName: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateSnapshotOutput: Swift.Equatable {
    /// Properties that provide details of the created snapshot.
    public var snapshot: GameSparksClientTypes.SnapshotDetails?

    public init(
        snapshot: GameSparksClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateSnapshotOutputBody: Swift.Equatable {
    let snapshot: GameSparksClientTypes.SnapshotDetails?
}

extension CreateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.SnapshotDetails.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum CreateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case role = "Role"
        case stageName = "StageName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage"
    }
}

public struct CreateStageInput: Swift.Equatable {
    /// A client-defined token. With an active client token in the request, this action is idempotent.
    public var clientToken: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The Amazon Resource Name (ARN) of the role to run the game with. This role can be a game-defined role or the default role that GameSparks created.
    /// This member is required.
    public var role: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?
    /// The list of tags to apply to the stage.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        role: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.gameName = gameName
        self.role = role
        self.stageName = stageName
        self.tags = tags
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let stageName: Swift.String?
    let role: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case role = "Role"
        case stageName = "StageName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct CreateStageOutput: Swift.Equatable {
    /// Properties that describe the stage.
    public var stage: GameSparksClientTypes.StageDetails?

    public init(
        stage: GameSparksClientTypes.StageDetails? = nil
    )
    {
        self.stage = stage
    }
}

struct CreateStageOutputBody: Swift.Equatable {
    let stage: GameSparksClientTypes.StageDetails?
}

extension CreateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage = "Stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDetails.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum CreateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())"
    }
}

public struct DeleteGameInput: Swift.Equatable {
    /// The name of the game to delete.
    /// This member is required.
    public var gameName: Swift.String?

    public init(
        gameName: Swift.String? = nil
    )
    {
        self.gameName = gameName
    }
}

struct DeleteGameInputBody: Swift.Equatable {
}

extension DeleteGameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGameOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())"
    }
}

public struct DeleteStageInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The name of the stage to delete.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Swift.Equatable {
}

extension DeleteStageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GameSparksClientTypes {
    public enum DeploymentAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploy
        case undeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentAction] {
            return [
                .deploy,
                .undeploy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploy: return "DEPLOY"
            case .undeploy: return "UNDEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentAction(rawValue: rawValue) ?? DeploymentAction.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.DeploymentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resultCode = "ResultCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resultCode = self.resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultCodeDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes {
    /// The result of the deployment.
    public struct DeploymentResult: Swift.Equatable {
        /// Details about the deployment result.
        public var message: Swift.String?
        /// The type of deployment result.
        public var resultCode: GameSparksClientTypes.ResultCode?

        public init(
            message: Swift.String? = nil,
            resultCode: GameSparksClientTypes.ResultCode? = nil
        )
        {
            self.message = message
            self.resultCode = resultCode
        }
    }

}

extension GameSparksClientTypes {
    public enum DeploymentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentState] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentState(rawValue: rawValue) ?? DeploymentState.sdkUnknown(rawValue)
        }
    }
}

extension DisconnectPlayerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let playerId = playerId else {
            return nil
        }
        return "/runtime/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/player/\(playerId.urlPercentEncoding())/disconnect"
    }
}

public struct DisconnectPlayerInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The unique identifier representing a player.
    /// This member is required.
    public var playerId: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        playerId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.playerId = playerId
        self.stageName = stageName
    }
}

struct DisconnectPlayerInputBody: Swift.Equatable {
}

extension DisconnectPlayerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisconnectPlayerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisconnectPlayerOutputBody = try responseDecoder.decode(responseBody: data)
            self.disconnectFailures = output.disconnectFailures
            self.disconnectSuccesses = output.disconnectSuccesses
        } else {
            self.disconnectFailures = nil
            self.disconnectSuccesses = nil
        }
    }
}

public struct DisconnectPlayerOutput: Swift.Equatable {
    /// The list of the connection ids that could not be disconnected.
    public var disconnectFailures: [Swift.String]?
    /// The list of the connection ids that were disconnected.
    public var disconnectSuccesses: [Swift.String]?

    public init(
        disconnectFailures: [Swift.String]? = nil,
        disconnectSuccesses: [Swift.String]? = nil
    )
    {
        self.disconnectFailures = disconnectFailures
        self.disconnectSuccesses = disconnectSuccesses
    }
}

struct DisconnectPlayerOutputBody: Swift.Equatable {
    let disconnectSuccesses: [Swift.String]?
    let disconnectFailures: [Swift.String]?
}

extension DisconnectPlayerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disconnectFailures = "DisconnectFailures"
        case disconnectSuccesses = "DisconnectSuccesses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disconnectSuccessesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disconnectSuccesses)
        var disconnectSuccessesDecoded0:[Swift.String]? = nil
        if let disconnectSuccessesContainer = disconnectSuccessesContainer {
            disconnectSuccessesDecoded0 = [Swift.String]()
            for string0 in disconnectSuccessesContainer {
                if let string0 = string0 {
                    disconnectSuccessesDecoded0?.append(string0)
                }
            }
        }
        disconnectSuccesses = disconnectSuccessesDecoded0
        let disconnectFailuresContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disconnectFailures)
        var disconnectFailuresDecoded0:[Swift.String]? = nil
        if let disconnectFailuresContainer = disconnectFailuresContainer {
            disconnectFailuresDecoded0 = [Swift.String]()
            for string0 in disconnectFailuresContainer {
                if let string0 = string0 {
                    disconnectFailuresDecoded0?.append(string0)
                }
            }
        }
        disconnectFailures = disconnectFailuresDecoded0
    }
}

enum DisconnectPlayerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExportSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/export"
    }
}

public struct ExportSnapshotInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the snapshot to export.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.snapshotId = snapshotId
    }
}

struct ExportSnapshotInputBody: Swift.Equatable {
}

extension ExportSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.s3Url = output.s3Url
        } else {
            self.s3Url = nil
        }
    }
}

public struct ExportSnapshotOutput: Swift.Equatable {
    /// The presigned URL for the snapshot data. This URL will be available for 10 minutes, and can be used to download the snapshot content. If the URL expires, a new one can be requested using the same operation.
    public var s3Url: Swift.String?

    public init(
        s3Url: Swift.String? = nil
    )
    {
        self.s3Url = s3Url
    }
}

struct ExportSnapshotOutputBody: Swift.Equatable {
    let s3Url: Swift.String?
}

extension ExportSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Url = "S3Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
    }
}

enum ExportSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GameSparksClientTypes.ExtensionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about the extension.
    public struct ExtensionDetails: Swift.Equatable {
        /// The description of the extension.
        public var description: Swift.String?
        /// The name of the extension.
        public var name: Swift.String?
        /// The namespace (qualifier) of the extension.
        public var namespace: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.namespace = namespace
        }
    }

}

extension GameSparksClientTypes.ExtensionVersionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case namespace = "Namespace"
        case schema = "Schema"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about the extension version.
    public struct ExtensionVersionDetails: Swift.Equatable {
        /// The name of the extension.
        public var name: Swift.String?
        /// The namespace (qualifier) of the extension.
        public var namespace: Swift.String?
        /// The model that defines the interface for this extension version.
        public var schema: Swift.String?
        /// The version of the extension.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            schema: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.namespace = namespace
            self.schema = schema
            self.version = version
        }
    }

}

extension GameSparksClientTypes.GameConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case lastUpdated = "LastUpdated"
        case sections = "Sections"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let sections = sections {
            var sectionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sections)
            for (dictKey0, sections0) in sections {
                try sectionsContainer.encode(sections0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionsContainer = try containerValues.decodeIfPresent([Swift.String: GameSparksClientTypes.Section?].self, forKey: .sections)
        var sectionsDecoded0: [Swift.String:GameSparksClientTypes.Section]? = nil
        if let sectionsContainer = sectionsContainer {
            sectionsDecoded0 = [Swift.String:GameSparksClientTypes.Section]()
            for (key0, section0) in sectionsContainer {
                if let section0 = section0 {
                    sectionsDecoded0?[key0] = section0
                }
            }
        }
        sections = sectionsDecoded0
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about the game configuration. The game configuration is organized into named sections, where the schema of each section is defined by an extension. The schema for these sections can be retrieved using the GetExtensionVersion operation.
    public struct GameConfigurationDetails: Swift.Equatable {
        /// The date when the game was created.
        public var created: ClientRuntime.Date?
        /// The date when the game was last modified.
        public var lastUpdated: ClientRuntime.Date?
        /// Configuration data, organized by section name.
        public var sections: [Swift.String:GameSparksClientTypes.Section]?

        public init(
            created: ClientRuntime.Date? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            sections: [Swift.String:GameSparksClientTypes.Section]? = nil
        )
        {
            self.created = created
            self.lastUpdated = lastUpdated
            self.sections = sections
        }
    }

}

extension GameSparksClientTypes.GameDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case created = "Created"
        case description = "Description"
        case enableTerminationProtection = "EnableTerminationProtection"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enableTerminationProtection != false {
            try encodeContainer.encode(enableTerminationProtection, forKey: .enableTerminationProtection)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameState.self, forKey: .state)
        state = stateDecoded
        let enableTerminationProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableTerminationProtection) ?? false
        enableTerminationProtection = enableTerminationProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    /// Details about a game.
    public struct GameDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this game.
        public var arn: Swift.String?
        /// The date when the game was created.
        public var created: ClientRuntime.Date?
        /// The description of the game.
        public var description: Swift.String?
        /// Determines if the game can be deleted.
        public var enableTerminationProtection: Swift.Bool
        /// The date when the game was last modified.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the game.
        public var name: Swift.String?
        /// The state of the game.
        public var state: GameSparksClientTypes.GameState?
        /// The tags associated with the game.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            enableTerminationProtection: Swift.Bool = false,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: GameSparksClientTypes.GameState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdated = lastUpdated
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension GameSparksClientTypes {
    public enum GameState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [GameState] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GameState(rawValue: rawValue) ?? GameState.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.GameSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a game.
    public struct GameSummary: Swift.Equatable {
        /// The description of the game.
        public var description: Swift.String?
        /// The name of the game.
        public var name: Swift.String?
        /// The state of the game.
        public var state: GameSparksClientTypes.GameState?
        /// The tags associated with the game.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            state: GameSparksClientTypes.GameState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension GameSparksClientTypes.GeneratedCodeJobDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expirationTime = "ExpirationTime"
        case generatedCodeJobId = "GeneratedCodeJobId"
        case s3Url = "S3Url"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .dateTime, forKey: .expirationTime)
        }
        if let generatedCodeJobId = self.generatedCodeJobId {
            try encodeContainer.encode(generatedCodeJobId, forKey: .generatedCodeJobId)
        }
        if let s3Url = self.s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GeneratedCodeJobState.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let generatedCodeJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedCodeJobId)
        generatedCodeJobId = generatedCodeJobIdDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about a generated code job.
    public struct GeneratedCodeJobDetails: Swift.Equatable {
        /// The description of the generated code job.
        public var description: Swift.String?
        /// The expiration date and time for the download URL. The download URL us guaranteed to be available until at least this time.
        public var expirationTime: ClientRuntime.Date?
        /// The identifier for the generated code job.
        public var generatedCodeJobId: Swift.String?
        /// A presigned URL that can be used to download the generated code.
        public var s3Url: Swift.String?
        /// The status of the generated code job
        public var status: GameSparksClientTypes.GeneratedCodeJobState?

        public init(
            description: Swift.String? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            generatedCodeJobId: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            status: GameSparksClientTypes.GeneratedCodeJobState? = nil
        )
        {
            self.description = description
            self.expirationTime = expirationTime
            self.generatedCodeJobId = generatedCodeJobId
            self.s3Url = s3Url
            self.status = status
        }
    }

}

extension GameSparksClientTypes {
    public enum GeneratedCodeJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [GeneratedCodeJobState] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeneratedCodeJobState(rawValue: rawValue) ?? GeneratedCodeJobState.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.Generator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameSdkVersion = "GameSdkVersion"
        case language = "Language"
        case targetPlatform = "TargetPlatform"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gameSdkVersion = self.gameSdkVersion {
            try encodeContainer.encode(gameSdkVersion, forKey: .gameSdkVersion)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let targetPlatform = self.targetPlatform {
            try encodeContainer.encode(targetPlatform, forKey: .targetPlatform)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetPlatformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetPlatform)
        targetPlatform = targetPlatformDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let gameSdkVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameSdkVersion)
        gameSdkVersion = gameSdkVersionDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that specify the code generator for a generated code job.
    public struct Generator: Swift.Equatable {
        /// The target version of the GameSparks Game SDK.
        public var gameSdkVersion: Swift.String?
        /// The programming language for the generated code. Not all languages are supported for each platform. For cases where multiple languages are supported, this parameter specifies the language to be used. If this value is omitted, the default language for the target platform will be used.
        public var language: Swift.String?
        /// The platform that will be used to run the generated code.
        public var targetPlatform: Swift.String?

        public init(
            gameSdkVersion: Swift.String? = nil,
            language: Swift.String? = nil,
            targetPlatform: Swift.String? = nil
        )
        {
            self.gameSdkVersion = gameSdkVersion
            self.language = language
            self.targetPlatform = targetPlatform
        }
    }

}

extension GetExtensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let namespace = namespace else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/extension/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

public struct GetExtensionInput: Swift.Equatable {
    /// The name of the extension.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace (qualifier) of the extension.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.name = name
        self.namespace = namespace
    }
}

struct GetExtensionInputBody: Swift.Equatable {
}

extension GetExtensionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExtensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.`extension` = output.`extension`
        } else {
            self.`extension` = nil
        }
    }
}

public struct GetExtensionOutput: Swift.Equatable {
    /// Details about the extension.
    public var `extension`: GameSparksClientTypes.ExtensionDetails?

    public init(
        `extension`: GameSparksClientTypes.ExtensionDetails? = nil
    )
    {
        self.`extension` = `extension`
    }
}

struct GetExtensionOutputBody: Swift.Equatable {
    let `extension`: GameSparksClientTypes.ExtensionDetails?
}

extension GetExtensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `extension` = "Extension"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ExtensionDetails.self, forKey: .extension)
        `extension` = extensionDecoded
    }
}

enum GetExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExtensionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let namespace = namespace else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        guard let extensionVersion = extensionVersion else {
            return nil
        }
        return "/extension/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/version/\(extensionVersion.urlPercentEncoding())"
    }
}

public struct GetExtensionVersionInput: Swift.Equatable {
    /// The version of the extension.
    /// This member is required.
    public var extensionVersion: Swift.String?
    /// The name of the extension.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace (qualifier) of the extension.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        extensionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.extensionVersion = extensionVersion
        self.name = name
        self.namespace = namespace
    }
}

struct GetExtensionVersionInputBody: Swift.Equatable {
}

extension GetExtensionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExtensionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExtensionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.extensionVersion = output.extensionVersion
        } else {
            self.extensionVersion = nil
        }
    }
}

public struct GetExtensionVersionOutput: Swift.Equatable {
    /// The version of the extension.
    public var extensionVersion: GameSparksClientTypes.ExtensionVersionDetails?

    public init(
        extensionVersion: GameSparksClientTypes.ExtensionVersionDetails? = nil
    )
    {
        self.extensionVersion = extensionVersion
    }
}

struct GetExtensionVersionOutputBody: Swift.Equatable {
    let extensionVersion: GameSparksClientTypes.ExtensionVersionDetails?
}

extension GetExtensionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionVersion = "ExtensionVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionVersionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ExtensionVersionDetails.self, forKey: .extensionVersion)
        extensionVersion = extensionVersionDecoded
    }
}

enum GetExtensionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGameConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sections = sections {
                sections.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "Sections".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetGameConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/configuration"
    }
}

public struct GetGameConfigurationInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of sections to return.
    public var sections: [Swift.String]?

    public init(
        gameName: Swift.String? = nil,
        sections: [Swift.String]? = nil
    )
    {
        self.gameName = gameName
        self.sections = sections
    }
}

struct GetGameConfigurationInputBody: Swift.Equatable {
}

extension GetGameConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGameConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGameConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.gameConfiguration = output.gameConfiguration
        } else {
            self.gameConfiguration = nil
        }
    }
}

public struct GetGameConfigurationOutput: Swift.Equatable {
    /// Details about the game configuration.
    public var gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?

    public init(
        gameConfiguration: GameSparksClientTypes.GameConfigurationDetails? = nil
    )
    {
        self.gameConfiguration = gameConfiguration
    }
}

struct GetGameConfigurationOutputBody: Swift.Equatable {
    let gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?
}

extension GetGameConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameConfiguration = "GameConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameConfigurationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameConfigurationDetails.self, forKey: .gameConfiguration)
        gameConfiguration = gameConfigurationDecoded
    }
}

enum GetGameConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())"
    }
}

public struct GetGameInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?

    public init(
        gameName: Swift.String? = nil
    )
    {
        self.gameName = gameName
    }
}

struct GetGameInputBody: Swift.Equatable {
}

extension GetGameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGameOutputBody = try responseDecoder.decode(responseBody: data)
            self.game = output.game
        } else {
            self.game = nil
        }
    }
}

public struct GetGameOutput: Swift.Equatable {
    /// The details of the game.
    public var game: GameSparksClientTypes.GameDetails?

    public init(
        game: GameSparksClientTypes.GameDetails? = nil
    )
    {
        self.game = game
    }
}

struct GetGameOutputBody: Swift.Equatable {
    let game: GameSparksClientTypes.GameDetails?
}

extension GetGameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case game = "Game"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameDetails.self, forKey: .game)
        game = gameDecoded
    }
}

enum GetGameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGeneratedCodeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/generated-sdk-code-job/\(jobId.urlPercentEncoding())"
    }
}

public struct GetGeneratedCodeJobInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the code generation job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The identifier of the snapshot for the code generation job.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.jobId = jobId
        self.snapshotId = snapshotId
    }
}

struct GetGeneratedCodeJobInputBody: Swift.Equatable {
}

extension GetGeneratedCodeJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGeneratedCodeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGeneratedCodeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.generatedCodeJob = output.generatedCodeJob
        } else {
            self.generatedCodeJob = nil
        }
    }
}

public struct GetGeneratedCodeJobOutput: Swift.Equatable {
    /// Details about the generated code job.
    public var generatedCodeJob: GameSparksClientTypes.GeneratedCodeJobDetails?

    public init(
        generatedCodeJob: GameSparksClientTypes.GeneratedCodeJobDetails? = nil
    )
    {
        self.generatedCodeJob = generatedCodeJob
    }
}

struct GetGeneratedCodeJobOutputBody: Swift.Equatable {
    let generatedCodeJob: GameSparksClientTypes.GeneratedCodeJobDetails?
}

extension GetGeneratedCodeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedCodeJob = "GeneratedCodeJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedCodeJobDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GeneratedCodeJobDetails.self, forKey: .generatedCodeJob)
        generatedCodeJob = generatedCodeJobDecoded
    }
}

enum GetGeneratedCodeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPlayerConnectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let playerId = playerId else {
            return nil
        }
        return "/runtime/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/player/\(playerId.urlPercentEncoding())/connection"
    }
}

public struct GetPlayerConnectionStatusInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The unique identifier representing a player.
    /// This member is required.
    public var playerId: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        playerId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.playerId = playerId
        self.stageName = stageName
    }
}

struct GetPlayerConnectionStatusInputBody: Swift.Equatable {
}

extension GetPlayerConnectionStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPlayerConnectionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPlayerConnectionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct GetPlayerConnectionStatusOutput: Swift.Equatable {
    /// The list of connection ids, one for each connection in use by the player.
    public var connections: [GameSparksClientTypes.Connection]?

    public init(
        connections: [GameSparksClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct GetPlayerConnectionStatusOutputBody: Swift.Equatable {
    let connections: [GameSparksClientTypes.Connection]?
}

extension GetPlayerConnectionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[GameSparksClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [GameSparksClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

enum GetPlayerConnectionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSnapshotInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sections = sections {
                sections.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "Sections".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())"
    }
}

public struct GetSnapshotInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of game configuration sections to be described.
    public var sections: [Swift.String]?
    /// The identifier of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        sections: [Swift.String]? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.sections = sections
        self.snapshotId = snapshotId
    }
}

struct GetSnapshotInputBody: Swift.Equatable {
}

extension GetSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct GetSnapshotOutput: Swift.Equatable {
    /// Properties that provide details of the snapshot.
    public var snapshot: GameSparksClientTypes.SnapshotDetails?

    public init(
        snapshot: GameSparksClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct GetSnapshotOutputBody: Swift.Equatable {
    let snapshot: GameSparksClientTypes.SnapshotDetails?
}

extension GetSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.SnapshotDetails.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum GetSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageDeploymentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deploymentId = deploymentId {
                let deploymentIdQueryItem = ClientRuntime.URLQueryItem(name: "DeploymentId".urlPercentEncoding(), value: Swift.String(deploymentId).urlPercentEncoding())
                items.append(deploymentIdQueryItem)
            }
            return items
        }
    }
}

extension GetStageDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/deployment"
    }
}

public struct GetStageDeploymentInput: Swift.Equatable {
    /// The identifier of the stage deployment. StartStageDeployment returns the identifier that you use here.
    public var deploymentId: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        gameName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.gameName = gameName
        self.stageName = stageName
    }
}

struct GetStageDeploymentInputBody: Swift.Equatable {
}

extension GetStageDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStageDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.stageDeployment = output.stageDeployment
        } else {
            self.stageDeployment = nil
        }
    }
}

public struct GetStageDeploymentOutput: Swift.Equatable {
    /// Properties that provide details of the stage deployment.
    public var stageDeployment: GameSparksClientTypes.StageDeploymentDetails?

    public init(
        stageDeployment: GameSparksClientTypes.StageDeploymentDetails? = nil
    )
    {
        self.stageDeployment = stageDeployment
    }
}

struct GetStageDeploymentOutputBody: Swift.Equatable {
    let stageDeployment: GameSparksClientTypes.StageDeploymentDetails?
}

extension GetStageDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stageDeployment = "StageDeployment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDeploymentDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDeploymentDetails.self, forKey: .stageDeployment)
        stageDeployment = stageDeploymentDecoded
    }
}

enum GetStageDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())"
    }
}

public struct GetStageInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.stageName = stageName
    }
}

struct GetStageInputBody: Swift.Equatable {
}

extension GetStageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct GetStageOutput: Swift.Equatable {
    /// Properties that provide details of the stage.
    public var stage: GameSparksClientTypes.StageDetails?

    public init(
        stage: GameSparksClientTypes.StageDetails? = nil
    )
    {
        self.stage = stage
    }
}

struct GetStageOutputBody: Swift.Equatable {
    let stage: GameSparksClientTypes.StageDetails?
}

extension GetStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage = "Stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDetails.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum GetStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportGameConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importSource = "ImportSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importSource = self.importSource {
            try encodeContainer.encode(importSource, forKey: .importSource)
        }
    }
}

extension ImportGameConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/configuration"
    }
}

public struct ImportGameConfigurationInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The source used to import configuration sections.
    /// This member is required.
    public var importSource: GameSparksClientTypes.ImportGameConfigurationSource?

    public init(
        gameName: Swift.String? = nil,
        importSource: GameSparksClientTypes.ImportGameConfigurationSource? = nil
    )
    {
        self.gameName = gameName
        self.importSource = importSource
    }
}

struct ImportGameConfigurationInputBody: Swift.Equatable {
    let importSource: GameSparksClientTypes.ImportGameConfigurationSource?
}

extension ImportGameConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importSource = "ImportSource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importSourceDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ImportGameConfigurationSource.self, forKey: .importSource)
        importSource = importSourceDecoded
    }
}

extension ImportGameConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportGameConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.gameConfiguration = output.gameConfiguration
        } else {
            self.gameConfiguration = nil
        }
    }
}

public struct ImportGameConfigurationOutput: Swift.Equatable {
    /// Details about the game configuration.
    public var gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?

    public init(
        gameConfiguration: GameSparksClientTypes.GameConfigurationDetails? = nil
    )
    {
        self.gameConfiguration = gameConfiguration
    }
}

struct ImportGameConfigurationOutputBody: Swift.Equatable {
    let gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?
}

extension ImportGameConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameConfiguration = "GameConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameConfigurationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameConfigurationDetails.self, forKey: .gameConfiguration)
        gameConfiguration = gameConfigurationDecoded
    }
}

enum ImportGameConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GameSparksClientTypes.ImportGameConfigurationSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file = "File"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension GameSparksClientTypes {
    /// The source used to import configuration sections.
    public struct ImportGameConfigurationSource: Swift.Equatable {
        /// The JSON string containing the configuration sections.
        /// This member is required.
        public var file: ClientRuntime.Data?

        public init(
            file: ClientRuntime.Data? = nil
        )
        {
            self.file = file
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an internal error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListExtensionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListExtensionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let namespace = namespace else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/extension/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/version"
    }
}

public struct ListExtensionVersionsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The name of the extension.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace (qualifier) of the extension.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListExtensionVersionsInputBody: Swift.Equatable {
}

extension ListExtensionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExtensionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExtensionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.extensionVersions = output.extensionVersions
            self.nextToken = output.nextToken
        } else {
            self.extensionVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensionVersionsOutput: Swift.Equatable {
    /// The list of extension versions.
    public var extensionVersions: [GameSparksClientTypes.ExtensionVersionDetails]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init(
        extensionVersions: [GameSparksClientTypes.ExtensionVersionDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.extensionVersions = extensionVersions
        self.nextToken = nextToken
    }
}

struct ListExtensionVersionsOutputBody: Swift.Equatable {
    let extensionVersions: [GameSparksClientTypes.ExtensionVersionDetails]?
    let nextToken: Swift.String?
}

extension ListExtensionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionVersions = "ExtensionVersions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionVersionsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.ExtensionVersionDetails?].self, forKey: .extensionVersions)
        var extensionVersionsDecoded0:[GameSparksClientTypes.ExtensionVersionDetails]? = nil
        if let extensionVersionsContainer = extensionVersionsContainer {
            extensionVersionsDecoded0 = [GameSparksClientTypes.ExtensionVersionDetails]()
            for structure0 in extensionVersionsContainer {
                if let structure0 = structure0 {
                    extensionVersionsDecoded0?.append(structure0)
                }
            }
        }
        extensionVersions = extensionVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExtensionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExtensionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListExtensionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/extension"
    }
}

public struct ListExtensionsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExtensionsInputBody: Swift.Equatable {
}

extension ListExtensionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExtensionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExtensionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.extensions = output.extensions
            self.nextToken = output.nextToken
        } else {
            self.extensions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensionsOutput: Swift.Equatable {
    /// The list of extensions.
    public var extensions: [GameSparksClientTypes.ExtensionDetails]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init(
        extensions: [GameSparksClientTypes.ExtensionDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.extensions = extensions
        self.nextToken = nextToken
    }
}

struct ListExtensionsOutputBody: Swift.Equatable {
    let extensions: [GameSparksClientTypes.ExtensionDetails]?
    let nextToken: Swift.String?
}

extension ListExtensionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensions = "Extensions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.ExtensionDetails?].self, forKey: .extensions)
        var extensionsDecoded0:[GameSparksClientTypes.ExtensionDetails]? = nil
        if let extensionsContainer = extensionsContainer {
            extensionsDecoded0 = [GameSparksClientTypes.ExtensionDetails]()
            for structure0 in extensionsContainer {
                if let structure0 = structure0 {
                    extensionsDecoded0?.append(structure0)
                }
            }
        }
        extensions = extensionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExtensionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/game"
    }
}

public struct ListGamesInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGamesInputBody: Swift.Equatable {
}

extension ListGamesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGamesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGamesOutputBody = try responseDecoder.decode(responseBody: data)
            self.games = output.games
            self.nextToken = output.nextToken
        } else {
            self.games = nil
            self.nextToken = nil
        }
    }
}

public struct ListGamesOutput: Swift.Equatable {
    /// The list of games.
    public var games: [GameSparksClientTypes.GameSummary]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init(
        games: [GameSparksClientTypes.GameSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.games = games
        self.nextToken = nextToken
    }
}

struct ListGamesOutputBody: Swift.Equatable {
    let games: [GameSparksClientTypes.GameSummary]?
    let nextToken: Swift.String?
}

extension ListGamesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case games = "Games"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gamesContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.GameSummary?].self, forKey: .games)
        var gamesDecoded0:[GameSparksClientTypes.GameSummary]? = nil
        if let gamesContainer = gamesContainer {
            gamesDecoded0 = [GameSparksClientTypes.GameSummary]()
            for structure0 in gamesContainer {
                if let structure0 = structure0 {
                    gamesDecoded0?.append(structure0)
                }
            }
        }
        games = gamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGamesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGeneratedCodeJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGeneratedCodeJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/generated-sdk-code-jobs"
    }
}

public struct ListGeneratedCodeJobsInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?
    /// The identifier of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.snapshotId = snapshotId
    }
}

struct ListGeneratedCodeJobsInputBody: Swift.Equatable {
}

extension ListGeneratedCodeJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGeneratedCodeJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGeneratedCodeJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.generatedCodeJobs = output.generatedCodeJobs
            self.nextToken = output.nextToken
        } else {
            self.generatedCodeJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeneratedCodeJobsOutput: Swift.Equatable {
    /// The list of generated code jobs.
    public var generatedCodeJobs: [GameSparksClientTypes.GeneratedCodeJobDetails]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init(
        generatedCodeJobs: [GameSparksClientTypes.GeneratedCodeJobDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.generatedCodeJobs = generatedCodeJobs
        self.nextToken = nextToken
    }
}

struct ListGeneratedCodeJobsOutputBody: Swift.Equatable {
    let generatedCodeJobs: [GameSparksClientTypes.GeneratedCodeJobDetails]?
    let nextToken: Swift.String?
}

extension ListGeneratedCodeJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedCodeJobs = "GeneratedCodeJobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedCodeJobsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.GeneratedCodeJobDetails?].self, forKey: .generatedCodeJobs)
        var generatedCodeJobsDecoded0:[GameSparksClientTypes.GeneratedCodeJobDetails]? = nil
        if let generatedCodeJobsContainer = generatedCodeJobsContainer {
            generatedCodeJobsDecoded0 = [GameSparksClientTypes.GeneratedCodeJobDetails]()
            for structure0 in generatedCodeJobsContainer {
                if let structure0 = structure0 {
                    generatedCodeJobsDecoded0?.append(structure0)
                }
            }
        }
        generatedCodeJobs = generatedCodeJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGeneratedCodeJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSnapshotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot"
    }
}

public struct ListSnapshotsInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSnapshotsInputBody: Swift.Equatable {
}

extension ListSnapshotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

public struct ListSnapshotsOutput: Swift.Equatable {
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?
    /// A list of snapshot summaries. You can use the returned snapshot IDs in the UpdateSnapshot and GetSnapshot operations.
    public var snapshots: [GameSparksClientTypes.SnapshotSummary]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [GameSparksClientTypes.SnapshotSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct ListSnapshotsOutputBody: Swift.Equatable {
    let snapshots: [GameSparksClientTypes.SnapshotSummary]?
    let nextToken: Swift.String?
}

extension ListSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case snapshots = "Snapshots"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.SnapshotSummary?].self, forKey: .snapshots)
        var snapshotsDecoded0:[GameSparksClientTypes.SnapshotSummary]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [GameSparksClientTypes.SnapshotSummary]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStageDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListStageDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/deployments"
    }
}

public struct ListStageDeploymentsInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stageName = stageName
    }
}

struct ListStageDeploymentsInputBody: Swift.Equatable {
}

extension ListStageDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStageDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStageDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stageDeployments = output.stageDeployments
        } else {
            self.nextToken = nil
            self.stageDeployments = nil
        }
    }
}

public struct ListStageDeploymentsOutput: Swift.Equatable {
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?
    /// A list of stage deployment summaries. You can use the deployment IDs in the UpdateStageDeployment and GetStageDeployment actions.
    public var stageDeployments: [GameSparksClientTypes.StageDeploymentSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stageDeployments: [GameSparksClientTypes.StageDeploymentSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stageDeployments = stageDeployments
    }
}

struct ListStageDeploymentsOutputBody: Swift.Equatable {
    let stageDeployments: [GameSparksClientTypes.StageDeploymentSummary]?
    let nextToken: Swift.String?
}

extension ListStageDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stageDeployments = "StageDeployments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDeploymentsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.StageDeploymentSummary?].self, forKey: .stageDeployments)
        var stageDeploymentsDecoded0:[GameSparksClientTypes.StageDeploymentSummary]? = nil
        if let stageDeploymentsContainer = stageDeploymentsContainer {
            stageDeploymentsDecoded0 = [GameSparksClientTypes.StageDeploymentSummary]()
            for structure0 in stageDeploymentsContainer {
                if let structure0 = structure0 {
                    stageDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        stageDeployments = stageDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStageDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage"
    }
}

public struct ListStagesInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStagesInputBody: Swift.Equatable {
}

extension ListStagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stages = output.stages
        } else {
            self.nextToken = nil
            self.stages = nil
        }
    }
}

public struct ListStagesOutput: Swift.Equatable {
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?
    /// A list of stage summaries. You can use the stage names in the UpdateStage and GetStage actions.
    public var stages: [GameSparksClientTypes.StageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stages: [GameSparksClientTypes.StageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stages = stages
    }
}

struct ListStagesOutputBody: Swift.Equatable {
    let stages: [GameSparksClientTypes.StageSummary]?
    let nextToken: Swift.String?
}

extension ListStagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stages = "Stages"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.StageSummary?].self, forKey: .stages)
        var stagesDecoded0:[GameSparksClientTypes.StageSummary]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [GameSparksClientTypes.StageSummary]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the GameSparks resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GameSparksClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .add,
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes {
    public enum ResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidRoleFailure
        case success
        case unspecifiedFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultCode] {
            return [
                .invalidRoleFailure,
                .success,
                .unspecifiedFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidRoleFailure: return "INVALID_ROLE_FAILURE"
            case .success: return "SUCCESS"
            case .unspecifiedFailure: return "UNSPECIFIED_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResultCode(rawValue: rawValue) ?? ResultCode.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.Section: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension GameSparksClientTypes {
    /// The configuration section.
    public struct Section: Swift.Equatable {
        /// The content of a configuration section.
        public var attributes: ClientRuntime.Document?
        /// The name of the section.
        public var name: Swift.String?
        /// The size, in bytes, of the section contents.
        public var size: Swift.Int

        public init(
            attributes: ClientRuntime.Document? = nil,
            name: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.attributes = attributes
            self.name = name
            self.size = size
        }
    }

}

extension GameSparksClientTypes.SectionModification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
        case path = "Path"
        case section = "Section"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let section = self.section {
            try encodeContainer.encode(section, forKey: .section)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .section)
        section = sectionDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let operationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension GameSparksClientTypes {
    /// A single modification to the configuration section.
    public struct SectionModification: Swift.Equatable {
        /// The operation to be performed on a configuration section. Content can be added, deleted, or replaced within a section.
        /// This member is required.
        public var operation: GameSparksClientTypes.Operation?
        /// The path within the section content to be modified.
        /// This member is required.
        public var path: Swift.String?
        /// The name of the section to be modified.
        /// This member is required.
        public var section: Swift.String?
        /// For add and replace operations, this is the value that will be used. This field should be omitted for delete operations.
        public var value: ClientRuntime.Document?

        public init(
            operation: GameSparksClientTypes.Operation? = nil,
            path: Swift.String? = nil,
            section: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.operation = operation
            self.path = path
            self.section = section
            self.value = value
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would result in exceeding service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes.SnapshotDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case sections = "Sections"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let sections = sections {
            var sectionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sections)
            for (dictKey0, sections0) in sections {
                try sectionsContainer.encode(sections0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sectionsContainer = try containerValues.decodeIfPresent([Swift.String: GameSparksClientTypes.Section?].self, forKey: .sections)
        var sectionsDecoded0: [Swift.String:GameSparksClientTypes.Section]? = nil
        if let sectionsContainer = sectionsContainer {
            sectionsDecoded0 = [Swift.String:GameSparksClientTypes.Section]()
            for (key0, section0) in sectionsContainer {
                if let section0 = section0 {
                    sectionsDecoded0?[key0] = section0
                }
            }
        }
        sections = sectionsDecoded0
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that provide details of a snapshot.
    public struct SnapshotDetails: Swift.Equatable {
        /// The timestamp of when the snapshot was created.
        public var created: ClientRuntime.Date?
        /// The description of the snapshot.
        public var description: Swift.String?
        /// The identifier of the snapshot.
        public var id: Swift.String?
        /// The timestamp of when the snapshot was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The sections in the snapshot.
        public var sections: [Swift.String:GameSparksClientTypes.Section]?

        public init(
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            sections: [Swift.String:GameSparksClientTypes.Section]? = nil
        )
        {
            self.created = created
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.sections = sections
        }
    }

}

extension GameSparksClientTypes.SnapshotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case id = "Id"
        case lastUpdated = "LastUpdated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a snapshot.
    public struct SnapshotSummary: Swift.Equatable {
        /// The timestamp of when the snapshot was created.
        public var created: ClientRuntime.Date?
        /// The description of the snapshot.
        public var description: Swift.String?
        /// The identifier of the snapshot.
        public var id: Swift.String?
        /// Then timestamp of when the snapshot was last updated.
        public var lastUpdated: ClientRuntime.Date?

        public init(
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil
        )
        {
            self.created = created
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
        }
    }

}

extension GameSparksClientTypes.StageDeploymentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case deploymentAction = "DeploymentAction"
        case deploymentId = "DeploymentId"
        case deploymentResult = "DeploymentResult"
        case deploymentState = "DeploymentState"
        case lastUpdated = "LastUpdated"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let deploymentAction = self.deploymentAction {
            try encodeContainer.encode(deploymentAction.rawValue, forKey: .deploymentAction)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentResult = self.deploymentResult {
            try encodeContainer.encode(deploymentResult, forKey: .deploymentResult)
        }
        if let deploymentState = self.deploymentState {
            try encodeContainer.encode(deploymentState.rawValue, forKey: .deploymentState)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let deploymentActionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentAction.self, forKey: .deploymentAction)
        deploymentAction = deploymentActionDecoded
        let deploymentStateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentState.self, forKey: .deploymentState)
        deploymentState = deploymentStateDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let deploymentResultDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentResult.self, forKey: .deploymentResult)
        deploymentResult = deploymentResultDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that provide details of a stage deployment.
    public struct StageDeploymentDetails: Swift.Equatable {
        /// The timestamp of when the stage deployment was created.
        public var created: ClientRuntime.Date?
        /// The type of action of the stage deployment.
        public var deploymentAction: GameSparksClientTypes.DeploymentAction?
        /// The identifier of the deployment.
        public var deploymentId: Swift.String?
        /// The result of the deployment.
        public var deploymentResult: GameSparksClientTypes.DeploymentResult?
        /// The state of the deployment.
        public var deploymentState: GameSparksClientTypes.DeploymentState?
        /// The timestamp of when the deployment was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The identifier of the snapshot associated with the stage deployment.
        public var snapshotId: Swift.String?

        public init(
            created: ClientRuntime.Date? = nil,
            deploymentAction: GameSparksClientTypes.DeploymentAction? = nil,
            deploymentId: Swift.String? = nil,
            deploymentResult: GameSparksClientTypes.DeploymentResult? = nil,
            deploymentState: GameSparksClientTypes.DeploymentState? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            snapshotId: Swift.String? = nil
        )
        {
            self.created = created
            self.deploymentAction = deploymentAction
            self.deploymentId = deploymentId
            self.deploymentResult = deploymentResult
            self.deploymentState = deploymentState
            self.lastUpdated = lastUpdated
            self.snapshotId = snapshotId
        }
    }

}

extension GameSparksClientTypes.StageDeploymentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentAction = "DeploymentAction"
        case deploymentId = "DeploymentId"
        case deploymentResult = "DeploymentResult"
        case deploymentState = "DeploymentState"
        case lastUpdated = "LastUpdated"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentAction = self.deploymentAction {
            try encodeContainer.encode(deploymentAction.rawValue, forKey: .deploymentAction)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentResult = self.deploymentResult {
            try encodeContainer.encode(deploymentResult, forKey: .deploymentResult)
        }
        if let deploymentState = self.deploymentState {
            try encodeContainer.encode(deploymentState.rawValue, forKey: .deploymentState)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let deploymentActionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentAction.self, forKey: .deploymentAction)
        deploymentAction = deploymentActionDecoded
        let deploymentStateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentState.self, forKey: .deploymentState)
        deploymentState = deploymentStateDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let deploymentResultDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentResult.self, forKey: .deploymentResult)
        deploymentResult = deploymentResultDecoded
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a stage deployment.
    public struct StageDeploymentSummary: Swift.Equatable {
        /// The type of action of the deployment.
        public var deploymentAction: GameSparksClientTypes.DeploymentAction?
        /// The identifier of the deployment.
        public var deploymentId: Swift.String?
        /// The result of the deployment.
        public var deploymentResult: GameSparksClientTypes.DeploymentResult?
        /// The state of the deployment.
        public var deploymentState: GameSparksClientTypes.DeploymentState?
        /// The timestamp of when the deployment was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The identifier of the snapshot associated with the stage deployment.
        public var snapshotId: Swift.String?

        public init(
            deploymentAction: GameSparksClientTypes.DeploymentAction? = nil,
            deploymentId: Swift.String? = nil,
            deploymentResult: GameSparksClientTypes.DeploymentResult? = nil,
            deploymentState: GameSparksClientTypes.DeploymentState? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            snapshotId: Swift.String? = nil
        )
        {
            self.deploymentAction = deploymentAction
            self.deploymentId = deploymentId
            self.deploymentResult = deploymentResult
            self.deploymentState = deploymentState
            self.lastUpdated = lastUpdated
            self.snapshotId = snapshotId
        }
    }

}

extension GameSparksClientTypes.StageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case created = "Created"
        case description = "Description"
        case gameKey = "GameKey"
        case lastUpdated = "LastUpdated"
        case logGroup = "LogGroup"
        case name = "Name"
        case role = "Role"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gameKey = self.gameKey {
            try encodeContainer.encode(gameKey, forKey: .gameKey)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let gameKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameKey)
        gameKey = gameKeyDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that provide details of a stage.
    public struct StageDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the stage.
        public var arn: Swift.String?
        /// The timestamp of when the stage was created.
        public var created: ClientRuntime.Date?
        /// The description of the stage.
        public var description: Swift.String?
        /// The game key associated with the stage. The game key is a unique identifier that the game client uses to connect to the GameSparks backend.
        public var gameKey: Swift.String?
        /// The timestamp of when the stage was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon CloudWatch log group for game runtimes deployed to the stage.
        public var logGroup: Swift.String?
        /// The name of the stage.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role used to run the game runtimes deployed to the stage.
        public var role: Swift.String?
        /// The state of the stage.
        public var state: GameSparksClientTypes.StageState?
        /// The tags associated with the stage.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            gameKey: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            logGroup: Swift.String? = nil,
            name: Swift.String? = nil,
            role: Swift.String? = nil,
            state: GameSparksClientTypes.StageState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.gameKey = gameKey
            self.lastUpdated = lastUpdated
            self.logGroup = logGroup
            self.name = name
            self.role = role
            self.state = state
            self.tags = tags
        }
    }

}

extension GameSparksClientTypes {
    public enum StageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [StageState] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StageState(rawValue: rawValue) ?? StageState.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.StageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gameKey = "GameKey"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gameKey = self.gameKey {
            try encodeContainer.encode(gameKey, forKey: .gameKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let gameKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameKey)
        gameKey = gameKeyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a stage.
    public struct StageSummary: Swift.Equatable {
        /// The description of the stage.
        public var description: Swift.String?
        /// The game key associated with the stage. The game key is a unique identifier that the game client uses to connect to the GameSparks backend.
        public var gameKey: Swift.String?
        /// The name of the stage.
        public var name: Swift.String?
        /// The state of the stage.
        public var state: GameSparksClientTypes.StageState?
        /// The tags associated with the stage.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            gameKey: Swift.String? = nil,
            name: Swift.String? = nil,
            state: GameSparksClientTypes.StageState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.gameKey = gameKey
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension StartGeneratedCodeJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generator = "Generator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generator = self.generator {
            try encodeContainer.encode(generator, forKey: .generator)
        }
    }
}

extension StartGeneratedCodeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/generated-sdk-code-job"
    }
}

public struct StartGeneratedCodeJobInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// Properties of the generator to use for the job.
    /// This member is required.
    public var generator: GameSparksClientTypes.Generator?
    /// The identifier of the snapshot for which to generate code.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        gameName: Swift.String? = nil,
        generator: GameSparksClientTypes.Generator? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.generator = generator
        self.snapshotId = snapshotId
    }
}

struct StartGeneratedCodeJobInputBody: Swift.Equatable {
    let generator: GameSparksClientTypes.Generator?
}

extension StartGeneratedCodeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generator = "Generator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatorDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.Generator.self, forKey: .generator)
        generator = generatorDecoded
    }
}

extension StartGeneratedCodeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartGeneratedCodeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.generatedCodeJobId = output.generatedCodeJobId
        } else {
            self.generatedCodeJobId = nil
        }
    }
}

public struct StartGeneratedCodeJobOutput: Swift.Equatable {
    /// The identifier of the code generation job. You can use this identifier in the GetGeneratedCodeJob operation.
    public var generatedCodeJobId: Swift.String?

    public init(
        generatedCodeJobId: Swift.String? = nil
    )
    {
        self.generatedCodeJobId = generatedCodeJobId
    }
}

struct StartGeneratedCodeJobOutputBody: Swift.Equatable {
    let generatedCodeJobId: Swift.String?
}

extension StartGeneratedCodeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedCodeJobId = "GeneratedCodeJobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedCodeJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedCodeJobId)
        generatedCodeJobId = generatedCodeJobIdDecoded
    }
}

enum StartGeneratedCodeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartStageDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

extension StartStageDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/deployment"
    }
}

public struct StartStageDeploymentInput: Swift.Equatable {
    /// A client-defined token. With an active client token in the request, this action is idempotent.
    public var clientToken: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the snapshot to deploy.
    /// This member is required.
    public var snapshotId: Swift.String?
    /// The name of the stage to deploy the snapshot onto.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        gameName: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.gameName = gameName
        self.snapshotId = snapshotId
        self.stageName = stageName
    }
}

struct StartStageDeploymentInputBody: Swift.Equatable {
    let snapshotId: Swift.String?
    let clientToken: Swift.String?
}

extension StartStageDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case snapshotId = "SnapshotId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartStageDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartStageDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.stageDeployment = output.stageDeployment
        } else {
            self.stageDeployment = nil
        }
    }
}

public struct StartStageDeploymentOutput: Swift.Equatable {
    /// Properties that describe the stage deployment.
    public var stageDeployment: GameSparksClientTypes.StageDeploymentDetails?

    public init(
        stageDeployment: GameSparksClientTypes.StageDeploymentDetails? = nil
    )
    {
        self.stageDeployment = stageDeployment
    }
}

struct StartStageDeploymentOutputBody: Swift.Equatable {
    let stageDeployment: GameSparksClientTypes.StageDeploymentDetails?
}

extension StartStageDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stageDeployment = "StageDeployment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDeploymentDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDeploymentDetails.self, forKey: .stageDeployment)
        stageDeployment = stageDeploymentDecoded
    }
}

enum StartStageDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to add the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGameConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifications = "Modifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modifications = modifications {
            var modificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modifications)
            for sectionmodification0 in modifications {
                try modificationsContainer.encode(sectionmodification0)
            }
        }
    }
}

extension UpdateGameConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/configuration"
    }
}

public struct UpdateGameConfigurationInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of modifications to make.
    /// This member is required.
    public var modifications: [GameSparksClientTypes.SectionModification]?

    public init(
        gameName: Swift.String? = nil,
        modifications: [GameSparksClientTypes.SectionModification]? = nil
    )
    {
        self.gameName = gameName
        self.modifications = modifications
    }
}

struct UpdateGameConfigurationInputBody: Swift.Equatable {
    let modifications: [GameSparksClientTypes.SectionModification]?
}

extension UpdateGameConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifications = "Modifications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modificationsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.SectionModification?].self, forKey: .modifications)
        var modificationsDecoded0:[GameSparksClientTypes.SectionModification]? = nil
        if let modificationsContainer = modificationsContainer {
            modificationsDecoded0 = [GameSparksClientTypes.SectionModification]()
            for structure0 in modificationsContainer {
                if let structure0 = structure0 {
                    modificationsDecoded0?.append(structure0)
                }
            }
        }
        modifications = modificationsDecoded0
    }
}

extension UpdateGameConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGameConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.gameConfiguration = output.gameConfiguration
        } else {
            self.gameConfiguration = nil
        }
    }
}

public struct UpdateGameConfigurationOutput: Swift.Equatable {
    /// Details about the game configuration.
    public var gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?

    public init(
        gameConfiguration: GameSparksClientTypes.GameConfigurationDetails? = nil
    )
    {
        self.gameConfiguration = gameConfiguration
    }
}

struct UpdateGameConfigurationOutputBody: Swift.Equatable {
    let gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?
}

extension UpdateGameConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameConfiguration = "GameConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameConfigurationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameConfigurationDetails.self, forKey: .gameConfiguration)
        gameConfiguration = gameConfigurationDecoded
    }
}

enum UpdateGameConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())"
    }
}

public struct UpdateGameInput: Swift.Equatable {
    /// The description of the game.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?

    public init(
        description: Swift.String? = nil,
        gameName: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
    }
}

struct UpdateGameInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateGameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGameOutputBody = try responseDecoder.decode(responseBody: data)
            self.game = output.game
        } else {
            self.game = nil
        }
    }
}

public struct UpdateGameOutput: Swift.Equatable {
    /// The details of the game.
    public var game: GameSparksClientTypes.GameDetails?

    public init(
        game: GameSparksClientTypes.GameDetails? = nil
    )
    {
        self.game = game
    }
}

struct UpdateGameOutputBody: Swift.Equatable {
    let game: GameSparksClientTypes.GameDetails?
}

extension UpdateGameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case game = "Game"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameDetails.self, forKey: .game)
        game = gameDecoded
    }
}

enum UpdateGameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())"
    }
}

public struct UpdateSnapshotInput: Swift.Equatable {
    /// The description of the snapshot.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
        self.snapshotId = snapshotId
    }
}

struct UpdateSnapshotInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct UpdateSnapshotOutput: Swift.Equatable {
    /// Properties that provide details of the updated snapshot.
    public var snapshot: GameSparksClientTypes.SnapshotDetails?

    public init(
        snapshot: GameSparksClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct UpdateSnapshotOutputBody: Swift.Equatable {
    let snapshot: GameSparksClientTypes.SnapshotDetails?
}

extension UpdateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.SnapshotDetails.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum UpdateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())"
    }
}

public struct UpdateStageInput: Swift.Equatable {
    /// The description of the stage.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The Amazon Resource Name (ARN) of the role to use for the game snapshots deployed to this stage.
    public var role: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        role: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
        self.role = role
        self.stageName = stageName
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let role: Swift.String?
    let description: Swift.String?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct UpdateStageOutput: Swift.Equatable {
    /// Properties that provide details of the updated stage.
    public var stage: GameSparksClientTypes.StageDetails?

    public init(
        stage: GameSparksClientTypes.StageDetails? = nil
    )
    {
        self.stage = stage
    }
}

struct UpdateStageOutputBody: Swift.Equatable {
    let stage: GameSparksClientTypes.StageDetails?
}

extension UpdateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage = "Stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDetails.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum UpdateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the parameters in the request is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
