// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists, or another operation is in progress.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about a WebSocket connection.
    public struct Connection: Swift.Equatable {
        /// The date and time when the connection was created.
        public var created: ClientRuntime.Date?
        /// The identifier used to indicate a specific WebSocket connection.
        public var id: Swift.String?

        public init (
            created: ClientRuntime.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.created = created
            self.id = id
        }
    }

}

extension CreateGameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case gameName = "GameName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gameName = self.gameName {
            try encodeContainer.encode(gameName, forKey: .gameName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/game"
    }
}

public struct CreateGameInput: Swift.Equatable {
    /// A client-defined token. With an active client token in the request, this action is idempotent.
    public var clientToken: Swift.String?
    /// The description of the game.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of tags to apply to the game.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.gameName = gameName
        self.tags = tags
    }
}

struct CreateGameInputBody: Swift.Equatable {
    let gameName: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case gameName = "GameName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameName)
        gameName = gameNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.game = output.game
        } else {
            self.game = nil
        }
    }
}

public struct CreateGameOutputResponse: Swift.Equatable {
    /// Details about the game that was created.
    public var game: GameSparksClientTypes.GameDetails?

    public init (
        game: GameSparksClientTypes.GameDetails? = nil
    )
    {
        self.game = game
    }
}

struct CreateGameOutputResponseBody: Swift.Equatable {
    let game: GameSparksClientTypes.GameDetails?
}

extension CreateGameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case game = "Game"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameDetails.self, forKey: .game)
        game = gameDecoded
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot"
    }
}

public struct CreateSnapshotInput: Swift.Equatable {
    /// The description of the snapshot.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?

    public init (
        description: Swift.String? = nil,
        gameName: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateSnapshotOutputResponse: Swift.Equatable {
    /// Properties that provide details of the created snapshot.
    public var snapshot: GameSparksClientTypes.SnapshotDetails?

    public init (
        snapshot: GameSparksClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateSnapshotOutputResponseBody: Swift.Equatable {
    let snapshot: GameSparksClientTypes.SnapshotDetails?
}

extension CreateSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.SnapshotDetails.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case role = "Role"
        case stageName = "StageName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage"
    }
}

public struct CreateStageInput: Swift.Equatable {
    /// A client-defined token. With an active client token in the request, this action is idempotent.
    public var clientToken: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The Amazon Resource Name (ARN) of the role to run the game with. This role can be a game-defined role or the default role that GameSparks created.
    /// This member is required.
    public var role: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?
    /// The list of tags to apply to the stage.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        role: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.gameName = gameName
        self.role = role
        self.stageName = stageName
        self.tags = tags
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let stageName: Swift.String?
    let role: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case role = "Role"
        case stageName = "StageName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateStageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct CreateStageOutputResponse: Swift.Equatable {
    /// Properties that describe the stage.
    public var stage: GameSparksClientTypes.StageDetails?

    public init (
        stage: GameSparksClientTypes.StageDetails? = nil
    )
    {
        self.stage = stage
    }
}

struct CreateStageOutputResponseBody: Swift.Equatable {
    let stage: GameSparksClientTypes.StageDetails?
}

extension CreateStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage = "Stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDetails.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DeleteGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())"
    }
}

public struct DeleteGameInput: Swift.Equatable {
    /// The name of the game to delete.
    /// This member is required.
    public var gameName: Swift.String?

    public init (
        gameName: Swift.String? = nil
    )
    {
        self.gameName = gameName
    }
}

struct DeleteGameInputBody: Swift.Equatable {
}

extension DeleteGameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGameOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())"
    }
}

public struct DeleteStageInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The name of the stage to delete.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Swift.Equatable {
}

extension DeleteStageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteStageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStageOutputResponse: Swift.Equatable {

    public init () { }
}

extension GameSparksClientTypes {
    public enum DeploymentAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploy
        case undeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentAction] {
            return [
                .deploy,
                .undeploy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploy: return "DEPLOY"
            case .undeploy: return "UNDEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentAction(rawValue: rawValue) ?? DeploymentAction.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.DeploymentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resultCode = "ResultCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resultCode = self.resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultCodeDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes {
    /// The result of the deployment.
    public struct DeploymentResult: Swift.Equatable {
        /// Details about the deployment result.
        public var message: Swift.String?
        /// The type of deployment result.
        public var resultCode: GameSparksClientTypes.ResultCode?

        public init (
            message: Swift.String? = nil,
            resultCode: GameSparksClientTypes.ResultCode? = nil
        )
        {
            self.message = message
            self.resultCode = resultCode
        }
    }

}

extension GameSparksClientTypes {
    public enum DeploymentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentState] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentState(rawValue: rawValue) ?? DeploymentState.sdkUnknown(rawValue)
        }
    }
}

extension DisconnectPlayerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let playerId = playerId else {
            return nil
        }
        return "/runtime/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/player/\(playerId.urlPercentEncoding())/disconnect"
    }
}

public struct DisconnectPlayerInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The unique identifier representing a player.
    /// This member is required.
    public var playerId: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        playerId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.playerId = playerId
        self.stageName = stageName
    }
}

struct DisconnectPlayerInputBody: Swift.Equatable {
}

extension DisconnectPlayerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisconnectPlayerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectPlayerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisconnectPlayerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectPlayerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisconnectPlayerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disconnectFailures = output.disconnectFailures
            self.disconnectSuccesses = output.disconnectSuccesses
        } else {
            self.disconnectFailures = nil
            self.disconnectSuccesses = nil
        }
    }
}

public struct DisconnectPlayerOutputResponse: Swift.Equatable {
    /// The list of the connection ids that could not be disconnected.
    public var disconnectFailures: [Swift.String]?
    /// The list of the connection ids that were disconnected.
    public var disconnectSuccesses: [Swift.String]?

    public init (
        disconnectFailures: [Swift.String]? = nil,
        disconnectSuccesses: [Swift.String]? = nil
    )
    {
        self.disconnectFailures = disconnectFailures
        self.disconnectSuccesses = disconnectSuccesses
    }
}

struct DisconnectPlayerOutputResponseBody: Swift.Equatable {
    let disconnectSuccesses: [Swift.String]?
    let disconnectFailures: [Swift.String]?
}

extension DisconnectPlayerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disconnectFailures = "DisconnectFailures"
        case disconnectSuccesses = "DisconnectSuccesses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disconnectSuccessesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disconnectSuccesses)
        var disconnectSuccessesDecoded0:[Swift.String]? = nil
        if let disconnectSuccessesContainer = disconnectSuccessesContainer {
            disconnectSuccessesDecoded0 = [Swift.String]()
            for string0 in disconnectSuccessesContainer {
                if let string0 = string0 {
                    disconnectSuccessesDecoded0?.append(string0)
                }
            }
        }
        disconnectSuccesses = disconnectSuccessesDecoded0
        let disconnectFailuresContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disconnectFailures)
        var disconnectFailuresDecoded0:[Swift.String]? = nil
        if let disconnectFailuresContainer = disconnectFailuresContainer {
            disconnectFailuresDecoded0 = [Swift.String]()
            for string0 in disconnectFailuresContainer {
                if let string0 = string0 {
                    disconnectFailuresDecoded0?.append(string0)
                }
            }
        }
        disconnectFailures = disconnectFailuresDecoded0
    }
}

extension ExportSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/export"
    }
}

public struct ExportSnapshotInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the snapshot to export.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.snapshotId = snapshotId
    }
}

struct ExportSnapshotInputBody: Swift.Equatable {
}

extension ExportSnapshotInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.s3Url = output.s3Url
        } else {
            self.s3Url = nil
        }
    }
}

public struct ExportSnapshotOutputResponse: Swift.Equatable {
    /// The presigned URL for the snapshot data. This URL will be available for 10 minutes, and can be used to download the snapshot content. If the URL expires, a new one can be requested using the same operation.
    public var s3Url: Swift.String?

    public init (
        s3Url: Swift.String? = nil
    )
    {
        self.s3Url = s3Url
    }
}

struct ExportSnapshotOutputResponseBody: Swift.Equatable {
    let s3Url: Swift.String?
}

extension ExportSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Url = "S3Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
    }
}

extension GameSparksClientTypes.ExtensionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about the extension.
    public struct ExtensionDetails: Swift.Equatable {
        /// The description of the extension.
        public var description: Swift.String?
        /// The name of the extension.
        public var name: Swift.String?
        /// The namespace (qualifier) of the extension.
        public var namespace: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.namespace = namespace
        }
    }

}

extension GameSparksClientTypes.ExtensionVersionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case namespace = "Namespace"
        case schema = "Schema"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about the extension version.
    public struct ExtensionVersionDetails: Swift.Equatable {
        /// The name of the extension.
        public var name: Swift.String?
        /// The namespace (qualifier) of the extension.
        public var namespace: Swift.String?
        /// The model that defines the interface for this extension version.
        public var schema: Swift.String?
        /// The version of the extension.
        public var version: Swift.String?

        public init (
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            schema: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.namespace = namespace
            self.schema = schema
            self.version = version
        }
    }

}

extension GameSparksClientTypes.GameConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case lastUpdated = "LastUpdated"
        case sections = "Sections"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let sections = sections {
            var sectionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sections)
            for (dictKey0, sections0) in sections {
                try sectionsContainer.encode(sections0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionsContainer = try containerValues.decodeIfPresent([Swift.String: GameSparksClientTypes.Section?].self, forKey: .sections)
        var sectionsDecoded0: [Swift.String:GameSparksClientTypes.Section]? = nil
        if let sectionsContainer = sectionsContainer {
            sectionsDecoded0 = [Swift.String:GameSparksClientTypes.Section]()
            for (key0, section0) in sectionsContainer {
                if let section0 = section0 {
                    sectionsDecoded0?[key0] = section0
                }
            }
        }
        sections = sectionsDecoded0
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about the game configuration. The game configuration is organized into named sections, where the schema of each section is defined by an extension. The schema for these sections can be retrieved using the GetExtensionVersion operation.
    public struct GameConfigurationDetails: Swift.Equatable {
        /// The date when the game was created.
        public var created: ClientRuntime.Date?
        /// The date when the game was last modified.
        public var lastUpdated: ClientRuntime.Date?
        /// Configuration data, organized by section name.
        public var sections: [Swift.String:GameSparksClientTypes.Section]?

        public init (
            created: ClientRuntime.Date? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            sections: [Swift.String:GameSparksClientTypes.Section]? = nil
        )
        {
            self.created = created
            self.lastUpdated = lastUpdated
            self.sections = sections
        }
    }

}

extension GameSparksClientTypes.GameDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case created = "Created"
        case description = "Description"
        case enableTerminationProtection = "EnableTerminationProtection"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enableTerminationProtection != false {
            try encodeContainer.encode(enableTerminationProtection, forKey: .enableTerminationProtection)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameState.self, forKey: .state)
        state = stateDecoded
        let enableTerminationProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableTerminationProtection) ?? false
        enableTerminationProtection = enableTerminationProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    /// Details about a game.
    public struct GameDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this game.
        public var arn: Swift.String?
        /// The date when the game was created.
        public var created: ClientRuntime.Date?
        /// The description of the game.
        public var description: Swift.String?
        /// Determines if the game can be deleted.
        public var enableTerminationProtection: Swift.Bool
        /// The date when the game was last modified.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the game.
        public var name: Swift.String?
        /// The state of the game.
        public var state: GameSparksClientTypes.GameState?
        /// The tags associated with the game.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            enableTerminationProtection: Swift.Bool = false,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: GameSparksClientTypes.GameState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdated = lastUpdated
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension GameSparksClientTypes {
    public enum GameState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [GameState] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GameState(rawValue: rawValue) ?? GameState.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.GameSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a game.
    public struct GameSummary: Swift.Equatable {
        /// The description of the game.
        public var description: Swift.String?
        /// The name of the game.
        public var name: Swift.String?
        /// The state of the game.
        public var state: GameSparksClientTypes.GameState?
        /// The tags associated with the game.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            state: GameSparksClientTypes.GameState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension GameSparksClientTypes.GeneratedCodeJobDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expirationTime = "ExpirationTime"
        case generatedCodeJobId = "GeneratedCodeJobId"
        case s3Url = "S3Url"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .dateTime, forKey: .expirationTime)
        }
        if let generatedCodeJobId = self.generatedCodeJobId {
            try encodeContainer.encode(generatedCodeJobId, forKey: .generatedCodeJobId)
        }
        if let s3Url = self.s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GeneratedCodeJobState.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let generatedCodeJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedCodeJobId)
        generatedCodeJobId = generatedCodeJobIdDecoded
    }
}

extension GameSparksClientTypes {
    /// Details about a generated code job.
    public struct GeneratedCodeJobDetails: Swift.Equatable {
        /// The description of the generated code job.
        public var description: Swift.String?
        /// The expiration date and time for the download URL. The download URL us guaranteed to be available until at least this time.
        public var expirationTime: ClientRuntime.Date?
        /// The identifier for the generated code job.
        public var generatedCodeJobId: Swift.String?
        /// A presigned URL that can be used to download the generated code.
        public var s3Url: Swift.String?
        /// The status of the generated code job
        public var status: GameSparksClientTypes.GeneratedCodeJobState?

        public init (
            description: Swift.String? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            generatedCodeJobId: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            status: GameSparksClientTypes.GeneratedCodeJobState? = nil
        )
        {
            self.description = description
            self.expirationTime = expirationTime
            self.generatedCodeJobId = generatedCodeJobId
            self.s3Url = s3Url
            self.status = status
        }
    }

}

extension GameSparksClientTypes {
    public enum GeneratedCodeJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [GeneratedCodeJobState] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeneratedCodeJobState(rawValue: rawValue) ?? GeneratedCodeJobState.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.Generator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameSdkVersion = "GameSdkVersion"
        case language = "Language"
        case targetPlatform = "TargetPlatform"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gameSdkVersion = self.gameSdkVersion {
            try encodeContainer.encode(gameSdkVersion, forKey: .gameSdkVersion)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let targetPlatform = self.targetPlatform {
            try encodeContainer.encode(targetPlatform, forKey: .targetPlatform)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetPlatformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetPlatform)
        targetPlatform = targetPlatformDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let gameSdkVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameSdkVersion)
        gameSdkVersion = gameSdkVersionDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that specify the code generator for a generated code job.
    public struct Generator: Swift.Equatable {
        /// The target version of the GameSparks Game SDK.
        public var gameSdkVersion: Swift.String?
        /// The programming language for the generated code. Not all languages are supported for each platform. For cases where multiple languages are supported, this parameter specifies the language to be used. If this value is omitted, the default language for the target platform will be used.
        public var language: Swift.String?
        /// The platform that will be used to run the generated code.
        public var targetPlatform: Swift.String?

        public init (
            gameSdkVersion: Swift.String? = nil,
            language: Swift.String? = nil,
            targetPlatform: Swift.String? = nil
        )
        {
            self.gameSdkVersion = gameSdkVersion
            self.language = language
            self.targetPlatform = targetPlatform
        }
    }

}

extension GetExtensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let namespace = namespace else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/extension/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

public struct GetExtensionInput: Swift.Equatable {
    /// The name of the extension.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace (qualifier) of the extension.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.name = name
        self.namespace = namespace
    }
}

struct GetExtensionInputBody: Swift.Equatable {
}

extension GetExtensionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExtensionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExtensionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetExtensionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExtensionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetExtensionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`extension` = output.`extension`
        } else {
            self.`extension` = nil
        }
    }
}

public struct GetExtensionOutputResponse: Swift.Equatable {
    /// Details about the extension.
    public var `extension`: GameSparksClientTypes.ExtensionDetails?

    public init (
        `extension`: GameSparksClientTypes.ExtensionDetails? = nil
    )
    {
        self.`extension` = `extension`
    }
}

struct GetExtensionOutputResponseBody: Swift.Equatable {
    let `extension`: GameSparksClientTypes.ExtensionDetails?
}

extension GetExtensionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `extension` = "Extension"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ExtensionDetails.self, forKey: .extension)
        `extension` = extensionDecoded
    }
}

extension GetExtensionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let namespace = namespace else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        guard let extensionVersion = extensionVersion else {
            return nil
        }
        return "/extension/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/version/\(extensionVersion.urlPercentEncoding())"
    }
}

public struct GetExtensionVersionInput: Swift.Equatable {
    /// The version of the extension.
    /// This member is required.
    public var extensionVersion: Swift.String?
    /// The name of the extension.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace (qualifier) of the extension.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        extensionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.extensionVersion = extensionVersion
        self.name = name
        self.namespace = namespace
    }
}

struct GetExtensionVersionInputBody: Swift.Equatable {
}

extension GetExtensionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExtensionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExtensionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetExtensionVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExtensionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetExtensionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.extensionVersion = output.extensionVersion
        } else {
            self.extensionVersion = nil
        }
    }
}

public struct GetExtensionVersionOutputResponse: Swift.Equatable {
    /// The version of the extension.
    public var extensionVersion: GameSparksClientTypes.ExtensionVersionDetails?

    public init (
        extensionVersion: GameSparksClientTypes.ExtensionVersionDetails? = nil
    )
    {
        self.extensionVersion = extensionVersion
    }
}

struct GetExtensionVersionOutputResponseBody: Swift.Equatable {
    let extensionVersion: GameSparksClientTypes.ExtensionVersionDetails?
}

extension GetExtensionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionVersion = "ExtensionVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionVersionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ExtensionVersionDetails.self, forKey: .extensionVersion)
        extensionVersion = extensionVersionDecoded
    }
}

extension GetGameConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sections = sections {
                sections.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "Sections".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetGameConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/configuration"
    }
}

public struct GetGameConfigurationInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of sections to return.
    public var sections: [Swift.String]?

    public init (
        gameName: Swift.String? = nil,
        sections: [Swift.String]? = nil
    )
    {
        self.gameName = gameName
        self.sections = sections
    }
}

struct GetGameConfigurationInputBody: Swift.Equatable {
}

extension GetGameConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGameConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGameConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGameConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGameConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGameConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gameConfiguration = output.gameConfiguration
        } else {
            self.gameConfiguration = nil
        }
    }
}

public struct GetGameConfigurationOutputResponse: Swift.Equatable {
    /// Details about the game configuration.
    public var gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?

    public init (
        gameConfiguration: GameSparksClientTypes.GameConfigurationDetails? = nil
    )
    {
        self.gameConfiguration = gameConfiguration
    }
}

struct GetGameConfigurationOutputResponseBody: Swift.Equatable {
    let gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?
}

extension GetGameConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameConfiguration = "GameConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameConfigurationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameConfigurationDetails.self, forKey: .gameConfiguration)
        gameConfiguration = gameConfigurationDecoded
    }
}

extension GetGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())"
    }
}

public struct GetGameInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?

    public init (
        gameName: Swift.String? = nil
    )
    {
        self.gameName = gameName
    }
}

struct GetGameInputBody: Swift.Equatable {
}

extension GetGameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.game = output.game
        } else {
            self.game = nil
        }
    }
}

public struct GetGameOutputResponse: Swift.Equatable {
    /// The details of the game.
    public var game: GameSparksClientTypes.GameDetails?

    public init (
        game: GameSparksClientTypes.GameDetails? = nil
    )
    {
        self.game = game
    }
}

struct GetGameOutputResponseBody: Swift.Equatable {
    let game: GameSparksClientTypes.GameDetails?
}

extension GetGameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case game = "Game"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameDetails.self, forKey: .game)
        game = gameDecoded
    }
}

extension GetGeneratedCodeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/generated-sdk-code-job/\(jobId.urlPercentEncoding())"
    }
}

public struct GetGeneratedCodeJobInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the code generation job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The identifier of the snapshot for the code generation job.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.jobId = jobId
        self.snapshotId = snapshotId
    }
}

struct GetGeneratedCodeJobInputBody: Swift.Equatable {
}

extension GetGeneratedCodeJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGeneratedCodeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeneratedCodeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGeneratedCodeJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeneratedCodeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGeneratedCodeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.generatedCodeJob = output.generatedCodeJob
        } else {
            self.generatedCodeJob = nil
        }
    }
}

public struct GetGeneratedCodeJobOutputResponse: Swift.Equatable {
    /// Details about the generated code job.
    public var generatedCodeJob: GameSparksClientTypes.GeneratedCodeJobDetails?

    public init (
        generatedCodeJob: GameSparksClientTypes.GeneratedCodeJobDetails? = nil
    )
    {
        self.generatedCodeJob = generatedCodeJob
    }
}

struct GetGeneratedCodeJobOutputResponseBody: Swift.Equatable {
    let generatedCodeJob: GameSparksClientTypes.GeneratedCodeJobDetails?
}

extension GetGeneratedCodeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedCodeJob = "GeneratedCodeJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedCodeJobDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GeneratedCodeJobDetails.self, forKey: .generatedCodeJob)
        generatedCodeJob = generatedCodeJobDecoded
    }
}

extension GetPlayerConnectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let playerId = playerId else {
            return nil
        }
        return "/runtime/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/player/\(playerId.urlPercentEncoding())/connection"
    }
}

public struct GetPlayerConnectionStatusInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The unique identifier representing a player.
    /// This member is required.
    public var playerId: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        playerId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.playerId = playerId
        self.stageName = stageName
    }
}

struct GetPlayerConnectionStatusInputBody: Swift.Equatable {
}

extension GetPlayerConnectionStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPlayerConnectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlayerConnectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPlayerConnectionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlayerConnectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPlayerConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
        } else {
            self.connections = nil
        }
    }
}

public struct GetPlayerConnectionStatusOutputResponse: Swift.Equatable {
    /// The list of connection ids, one for each connection in use by the player.
    public var connections: [GameSparksClientTypes.Connection]?

    public init (
        connections: [GameSparksClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

struct GetPlayerConnectionStatusOutputResponseBody: Swift.Equatable {
    let connections: [GameSparksClientTypes.Connection]?
}

extension GetPlayerConnectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[GameSparksClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [GameSparksClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension GetSnapshotInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sections = sections {
                sections.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "Sections".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())"
    }
}

public struct GetSnapshotInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of game configuration sections to be described.
    public var sections: [Swift.String]?
    /// The identifier of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        sections: [Swift.String]? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.sections = sections
        self.snapshotId = snapshotId
    }
}

struct GetSnapshotInputBody: Swift.Equatable {
}

extension GetSnapshotInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct GetSnapshotOutputResponse: Swift.Equatable {
    /// Properties that provide details of the snapshot.
    public var snapshot: GameSparksClientTypes.SnapshotDetails?

    public init (
        snapshot: GameSparksClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct GetSnapshotOutputResponseBody: Swift.Equatable {
    let snapshot: GameSparksClientTypes.SnapshotDetails?
}

extension GetSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.SnapshotDetails.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension GetStageDeploymentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deploymentId = deploymentId {
                let deploymentIdQueryItem = ClientRuntime.URLQueryItem(name: "DeploymentId".urlPercentEncoding(), value: Swift.String(deploymentId).urlPercentEncoding())
                items.append(deploymentIdQueryItem)
            }
            return items
        }
    }
}

extension GetStageDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/deployment"
    }
}

public struct GetStageDeploymentInput: Swift.Equatable {
    /// The identifier of the stage deployment. StartStageDeployment returns the identifier that you use here.
    public var deploymentId: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        gameName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.gameName = gameName
        self.stageName = stageName
    }
}

struct GetStageDeploymentInputBody: Swift.Equatable {
}

extension GetStageDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStageDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStageDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetStageDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStageDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetStageDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stageDeployment = output.stageDeployment
        } else {
            self.stageDeployment = nil
        }
    }
}

public struct GetStageDeploymentOutputResponse: Swift.Equatable {
    /// Properties that provide details of the stage deployment.
    public var stageDeployment: GameSparksClientTypes.StageDeploymentDetails?

    public init (
        stageDeployment: GameSparksClientTypes.StageDeploymentDetails? = nil
    )
    {
        self.stageDeployment = stageDeployment
    }
}

struct GetStageDeploymentOutputResponseBody: Swift.Equatable {
    let stageDeployment: GameSparksClientTypes.StageDeploymentDetails?
}

extension GetStageDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stageDeployment = "StageDeployment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDeploymentDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDeploymentDetails.self, forKey: .stageDeployment)
        stageDeployment = stageDeploymentDecoded
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())"
    }
}

public struct GetStageInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.stageName = stageName
    }
}

struct GetStageInputBody: Swift.Equatable {
}

extension GetStageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetStageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct GetStageOutputResponse: Swift.Equatable {
    /// Properties that provide details of the stage.
    public var stage: GameSparksClientTypes.StageDetails?

    public init (
        stage: GameSparksClientTypes.StageDetails? = nil
    )
    {
        self.stage = stage
    }
}

struct GetStageOutputResponseBody: Swift.Equatable {
    let stage: GameSparksClientTypes.StageDetails?
}

extension GetStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage = "Stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDetails.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension ImportGameConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importSource = "ImportSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importSource = self.importSource {
            try encodeContainer.encode(importSource, forKey: .importSource)
        }
    }
}

extension ImportGameConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/configuration"
    }
}

public struct ImportGameConfigurationInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The source used to import configuration sections.
    /// This member is required.
    public var importSource: GameSparksClientTypes.ImportGameConfigurationSource?

    public init (
        gameName: Swift.String? = nil,
        importSource: GameSparksClientTypes.ImportGameConfigurationSource? = nil
    )
    {
        self.gameName = gameName
        self.importSource = importSource
    }
}

struct ImportGameConfigurationInputBody: Swift.Equatable {
    let importSource: GameSparksClientTypes.ImportGameConfigurationSource?
}

extension ImportGameConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importSource = "ImportSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importSourceDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.ImportGameConfigurationSource.self, forKey: .importSource)
        importSource = importSourceDecoded
    }
}

extension ImportGameConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportGameConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportGameConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportGameConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportGameConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gameConfiguration = output.gameConfiguration
        } else {
            self.gameConfiguration = nil
        }
    }
}

public struct ImportGameConfigurationOutputResponse: Swift.Equatable {
    /// Details about the game configuration.
    public var gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?

    public init (
        gameConfiguration: GameSparksClientTypes.GameConfigurationDetails? = nil
    )
    {
        self.gameConfiguration = gameConfiguration
    }
}

struct ImportGameConfigurationOutputResponseBody: Swift.Equatable {
    let gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?
}

extension ImportGameConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameConfiguration = "GameConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameConfigurationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameConfigurationDetails.self, forKey: .gameConfiguration)
        gameConfiguration = gameConfigurationDecoded
    }
}

extension GameSparksClientTypes.ImportGameConfigurationSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file = "File"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
    }
}

extension GameSparksClientTypes {
    /// The source used to import configuration sections.
    public struct ImportGameConfigurationSource: Swift.Equatable {
        /// The JSON string containing the configuration sections.
        /// This member is required.
        public var file: ClientRuntime.Data?

        public init (
            file: ClientRuntime.Data? = nil
        )
        {
            self.file = file
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an internal error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListExtensionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListExtensionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let namespace = namespace else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/extension/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/version"
    }
}

public struct ListExtensionVersionsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The name of the extension.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace (qualifier) of the extension.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListExtensionVersionsInputBody: Swift.Equatable {
}

extension ListExtensionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExtensionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExtensionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExtensionVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExtensionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExtensionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.extensionVersions = output.extensionVersions
            self.nextToken = output.nextToken
        } else {
            self.extensionVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensionVersionsOutputResponse: Swift.Equatable {
    /// The list of extension versions.
    public var extensionVersions: [GameSparksClientTypes.ExtensionVersionDetails]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init (
        extensionVersions: [GameSparksClientTypes.ExtensionVersionDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.extensionVersions = extensionVersions
        self.nextToken = nextToken
    }
}

struct ListExtensionVersionsOutputResponseBody: Swift.Equatable {
    let extensionVersions: [GameSparksClientTypes.ExtensionVersionDetails]?
    let nextToken: Swift.String?
}

extension ListExtensionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionVersions = "ExtensionVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionVersionsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.ExtensionVersionDetails?].self, forKey: .extensionVersions)
        var extensionVersionsDecoded0:[GameSparksClientTypes.ExtensionVersionDetails]? = nil
        if let extensionVersionsContainer = extensionVersionsContainer {
            extensionVersionsDecoded0 = [GameSparksClientTypes.ExtensionVersionDetails]()
            for structure0 in extensionVersionsContainer {
                if let structure0 = structure0 {
                    extensionVersionsDecoded0?.append(structure0)
                }
            }
        }
        extensionVersions = extensionVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExtensionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListExtensionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/extension"
    }
}

public struct ListExtensionsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExtensionsInputBody: Swift.Equatable {
}

extension ListExtensionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExtensionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExtensionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExtensionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExtensionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExtensionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.extensions = output.extensions
            self.nextToken = output.nextToken
        } else {
            self.extensions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensionsOutputResponse: Swift.Equatable {
    /// The list of extensions.
    public var extensions: [GameSparksClientTypes.ExtensionDetails]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init (
        extensions: [GameSparksClientTypes.ExtensionDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.extensions = extensions
        self.nextToken = nextToken
    }
}

struct ListExtensionsOutputResponseBody: Swift.Equatable {
    let extensions: [GameSparksClientTypes.ExtensionDetails]?
    let nextToken: Swift.String?
}

extension ListExtensionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensions = "Extensions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.ExtensionDetails?].self, forKey: .extensions)
        var extensionsDecoded0:[GameSparksClientTypes.ExtensionDetails]? = nil
        if let extensionsContainer = extensionsContainer {
            extensionsDecoded0 = [GameSparksClientTypes.ExtensionDetails]()
            for structure0 in extensionsContainer {
                if let structure0 = structure0 {
                    extensionsDecoded0?.append(structure0)
                }
            }
        }
        extensions = extensionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/game"
    }
}

public struct ListGamesInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGamesInputBody: Swift.Equatable {
}

extension ListGamesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGamesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.games = output.games
            self.nextToken = output.nextToken
        } else {
            self.games = nil
            self.nextToken = nil
        }
    }
}

public struct ListGamesOutputResponse: Swift.Equatable {
    /// The list of games.
    public var games: [GameSparksClientTypes.GameSummary]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init (
        games: [GameSparksClientTypes.GameSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.games = games
        self.nextToken = nextToken
    }
}

struct ListGamesOutputResponseBody: Swift.Equatable {
    let games: [GameSparksClientTypes.GameSummary]?
    let nextToken: Swift.String?
}

extension ListGamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case games = "Games"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gamesContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.GameSummary?].self, forKey: .games)
        var gamesDecoded0:[GameSparksClientTypes.GameSummary]? = nil
        if let gamesContainer = gamesContainer {
            gamesDecoded0 = [GameSparksClientTypes.GameSummary]()
            for structure0 in gamesContainer {
                if let structure0 = structure0 {
                    gamesDecoded0?.append(structure0)
                }
            }
        }
        games = gamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGeneratedCodeJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGeneratedCodeJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/generated-sdk-code-jobs"
    }
}

public struct ListGeneratedCodeJobsInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?
    /// The identifier of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.snapshotId = snapshotId
    }
}

struct ListGeneratedCodeJobsInputBody: Swift.Equatable {
}

extension ListGeneratedCodeJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGeneratedCodeJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGeneratedCodeJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGeneratedCodeJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGeneratedCodeJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGeneratedCodeJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.generatedCodeJobs = output.generatedCodeJobs
            self.nextToken = output.nextToken
        } else {
            self.generatedCodeJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeneratedCodeJobsOutputResponse: Swift.Equatable {
    /// The list of generated code jobs.
    public var generatedCodeJobs: [GameSparksClientTypes.GeneratedCodeJobDetails]?
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?

    public init (
        generatedCodeJobs: [GameSparksClientTypes.GeneratedCodeJobDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.generatedCodeJobs = generatedCodeJobs
        self.nextToken = nextToken
    }
}

struct ListGeneratedCodeJobsOutputResponseBody: Swift.Equatable {
    let generatedCodeJobs: [GameSparksClientTypes.GeneratedCodeJobDetails]?
    let nextToken: Swift.String?
}

extension ListGeneratedCodeJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedCodeJobs = "GeneratedCodeJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedCodeJobsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.GeneratedCodeJobDetails?].self, forKey: .generatedCodeJobs)
        var generatedCodeJobsDecoded0:[GameSparksClientTypes.GeneratedCodeJobDetails]? = nil
        if let generatedCodeJobsContainer = generatedCodeJobsContainer {
            generatedCodeJobsDecoded0 = [GameSparksClientTypes.GeneratedCodeJobDetails]()
            for structure0 in generatedCodeJobsContainer {
                if let structure0 = structure0 {
                    generatedCodeJobsDecoded0?.append(structure0)
                }
            }
        }
        generatedCodeJobs = generatedCodeJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSnapshotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot"
    }
}

public struct ListSnapshotsInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSnapshotsInputBody: Swift.Equatable {
}

extension ListSnapshotsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

public struct ListSnapshotsOutputResponse: Swift.Equatable {
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?
    /// A list of snapshot summaries. You can use the returned snapshot IDs in the UpdateSnapshot and GetSnapshot operations.
    public var snapshots: [GameSparksClientTypes.SnapshotSummary]?

    public init (
        nextToken: Swift.String? = nil,
        snapshots: [GameSparksClientTypes.SnapshotSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct ListSnapshotsOutputResponseBody: Swift.Equatable {
    let snapshots: [GameSparksClientTypes.SnapshotSummary]?
    let nextToken: Swift.String?
}

extension ListSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case snapshots = "Snapshots"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.SnapshotSummary?].self, forKey: .snapshots)
        var snapshotsDecoded0:[GameSparksClientTypes.SnapshotSummary]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [GameSparksClientTypes.SnapshotSummary]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStageDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListStageDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/deployments"
    }
}

public struct ListStageDeploymentsInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stageName = stageName
    }
}

struct ListStageDeploymentsInputBody: Swift.Equatable {
}

extension ListStageDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStageDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStageDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStageDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStageDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStageDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stageDeployments = output.stageDeployments
        } else {
            self.nextToken = nil
            self.stageDeployments = nil
        }
    }
}

public struct ListStageDeploymentsOutputResponse: Swift.Equatable {
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?
    /// A list of stage deployment summaries. You can use the deployment IDs in the UpdateStageDeployment and GetStageDeployment actions.
    public var stageDeployments: [GameSparksClientTypes.StageDeploymentSummary]?

    public init (
        nextToken: Swift.String? = nil,
        stageDeployments: [GameSparksClientTypes.StageDeploymentSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stageDeployments = stageDeployments
    }
}

struct ListStageDeploymentsOutputResponseBody: Swift.Equatable {
    let stageDeployments: [GameSparksClientTypes.StageDeploymentSummary]?
    let nextToken: Swift.String?
}

extension ListStageDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stageDeployments = "StageDeployments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDeploymentsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.StageDeploymentSummary?].self, forKey: .stageDeployments)
        var stageDeploymentsDecoded0:[GameSparksClientTypes.StageDeploymentSummary]? = nil
        if let stageDeploymentsContainer = stageDeploymentsContainer {
            stageDeploymentsDecoded0 = [GameSparksClientTypes.StageDeploymentSummary]()
            for structure0 in stageDeploymentsContainer {
                if let structure0 = structure0 {
                    stageDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        stageDeployments = stageDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage"
    }
}

public struct ListStagesInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
    public var nextToken: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStagesInputBody: Swift.Equatable {
}

extension ListStagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stages = output.stages
        } else {
            self.nextToken = nil
            self.stages = nil
        }
    }
}

public struct ListStagesOutputResponse: Swift.Equatable {
    /// The token that indicates the start of the next sequential page of results. Use this value when making the next call to this operation to continue where the last one finished.
    public var nextToken: Swift.String?
    /// A list of stage summaries. You can use the stage names in the UpdateStage and GetStage actions.
    public var stages: [GameSparksClientTypes.StageSummary]?

    public init (
        nextToken: Swift.String? = nil,
        stages: [GameSparksClientTypes.StageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stages = stages
    }
}

struct ListStagesOutputResponseBody: Swift.Equatable {
    let stages: [GameSparksClientTypes.StageSummary]?
    let nextToken: Swift.String?
}

extension ListStagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stages = "Stages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.StageSummary?].self, forKey: .stages)
        var stagesDecoded0:[GameSparksClientTypes.StageSummary]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [GameSparksClientTypes.StageSummary]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the GameSparks resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .add,
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes {
    public enum ResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidRoleFailure
        case success
        case unspecifiedFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultCode] {
            return [
                .invalidRoleFailure,
                .success,
                .unspecifiedFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidRoleFailure: return "INVALID_ROLE_FAILURE"
            case .success: return "SUCCESS"
            case .unspecifiedFailure: return "UNSPECIFIED_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResultCode(rawValue: rawValue) ?? ResultCode.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.Section: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension GameSparksClientTypes {
    /// The configuration section.
    public struct Section: Swift.Equatable {
        /// The content of a configuration section.
        public var attributes: ClientRuntime.Document?
        /// The name of the section.
        public var name: Swift.String?
        /// The size, in bytes, of the section contents.
        public var size: Swift.Int

        public init (
            attributes: ClientRuntime.Document? = nil,
            name: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.attributes = attributes
            self.name = name
            self.size = size
        }
    }

}

extension GameSparksClientTypes.SectionModification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
        case path = "Path"
        case section = "Section"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let section = self.section {
            try encodeContainer.encode(section, forKey: .section)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .section)
        section = sectionDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let operationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension GameSparksClientTypes {
    /// A single modification to the configuration section.
    public struct SectionModification: Swift.Equatable {
        /// The operation to be performed on a configuration section. Content can be added, deleted, or replaced within a section.
        /// This member is required.
        public var operation: GameSparksClientTypes.Operation?
        /// The path within the section content to be modified.
        /// This member is required.
        public var path: Swift.String?
        /// The name of the section to be modified.
        /// This member is required.
        public var section: Swift.String?
        /// For add and replace operations, this is the value that will be used. This field should be omitted for delete operations.
        public var value: ClientRuntime.Document?

        public init (
            operation: GameSparksClientTypes.Operation? = nil,
            path: Swift.String? = nil,
            section: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.operation = operation
            self.path = path
            self.section = section
            self.value = value
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in exceeding service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GameSparksClientTypes.SnapshotDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case sections = "Sections"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let sections = sections {
            var sectionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sections)
            for (dictKey0, sections0) in sections {
                try sectionsContainer.encode(sections0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sectionsContainer = try containerValues.decodeIfPresent([Swift.String: GameSparksClientTypes.Section?].self, forKey: .sections)
        var sectionsDecoded0: [Swift.String:GameSparksClientTypes.Section]? = nil
        if let sectionsContainer = sectionsContainer {
            sectionsDecoded0 = [Swift.String:GameSparksClientTypes.Section]()
            for (key0, section0) in sectionsContainer {
                if let section0 = section0 {
                    sectionsDecoded0?[key0] = section0
                }
            }
        }
        sections = sectionsDecoded0
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that provide details of a snapshot.
    public struct SnapshotDetails: Swift.Equatable {
        /// The timestamp of when the snapshot was created.
        public var created: ClientRuntime.Date?
        /// The description of the snapshot.
        public var description: Swift.String?
        /// The identifier of the snapshot.
        public var id: Swift.String?
        /// The timestamp of when the snapshot was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The sections in the snapshot.
        public var sections: [Swift.String:GameSparksClientTypes.Section]?

        public init (
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            sections: [Swift.String:GameSparksClientTypes.Section]? = nil
        )
        {
            self.created = created
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.sections = sections
        }
    }

}

extension GameSparksClientTypes.SnapshotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case id = "Id"
        case lastUpdated = "LastUpdated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a snapshot.
    public struct SnapshotSummary: Swift.Equatable {
        /// The timestamp of when the snapshot was created.
        public var created: ClientRuntime.Date?
        /// The description of the snapshot.
        public var description: Swift.String?
        /// The identifier of the snapshot.
        public var id: Swift.String?
        /// Then timestamp of when the snapshot was last updated.
        public var lastUpdated: ClientRuntime.Date?

        public init (
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil
        )
        {
            self.created = created
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
        }
    }

}

extension GameSparksClientTypes.StageDeploymentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case deploymentAction = "DeploymentAction"
        case deploymentId = "DeploymentId"
        case deploymentResult = "DeploymentResult"
        case deploymentState = "DeploymentState"
        case lastUpdated = "LastUpdated"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let deploymentAction = self.deploymentAction {
            try encodeContainer.encode(deploymentAction.rawValue, forKey: .deploymentAction)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentResult = self.deploymentResult {
            try encodeContainer.encode(deploymentResult, forKey: .deploymentResult)
        }
        if let deploymentState = self.deploymentState {
            try encodeContainer.encode(deploymentState.rawValue, forKey: .deploymentState)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let deploymentActionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentAction.self, forKey: .deploymentAction)
        deploymentAction = deploymentActionDecoded
        let deploymentStateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentState.self, forKey: .deploymentState)
        deploymentState = deploymentStateDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let deploymentResultDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentResult.self, forKey: .deploymentResult)
        deploymentResult = deploymentResultDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that provide details of a stage deployment.
    public struct StageDeploymentDetails: Swift.Equatable {
        /// The timestamp of when the stage deployment was created.
        public var created: ClientRuntime.Date?
        /// The type of action of the stage deployment.
        public var deploymentAction: GameSparksClientTypes.DeploymentAction?
        /// The identifier of the deployment.
        public var deploymentId: Swift.String?
        /// The result of the deployment.
        public var deploymentResult: GameSparksClientTypes.DeploymentResult?
        /// The state of the deployment.
        public var deploymentState: GameSparksClientTypes.DeploymentState?
        /// The timestamp of when the deployment was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The identifier of the snapshot associated with the stage deployment.
        public var snapshotId: Swift.String?

        public init (
            created: ClientRuntime.Date? = nil,
            deploymentAction: GameSparksClientTypes.DeploymentAction? = nil,
            deploymentId: Swift.String? = nil,
            deploymentResult: GameSparksClientTypes.DeploymentResult? = nil,
            deploymentState: GameSparksClientTypes.DeploymentState? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            snapshotId: Swift.String? = nil
        )
        {
            self.created = created
            self.deploymentAction = deploymentAction
            self.deploymentId = deploymentId
            self.deploymentResult = deploymentResult
            self.deploymentState = deploymentState
            self.lastUpdated = lastUpdated
            self.snapshotId = snapshotId
        }
    }

}

extension GameSparksClientTypes.StageDeploymentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentAction = "DeploymentAction"
        case deploymentId = "DeploymentId"
        case deploymentResult = "DeploymentResult"
        case deploymentState = "DeploymentState"
        case lastUpdated = "LastUpdated"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentAction = self.deploymentAction {
            try encodeContainer.encode(deploymentAction.rawValue, forKey: .deploymentAction)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentResult = self.deploymentResult {
            try encodeContainer.encode(deploymentResult, forKey: .deploymentResult)
        }
        if let deploymentState = self.deploymentState {
            try encodeContainer.encode(deploymentState.rawValue, forKey: .deploymentState)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let deploymentActionDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentAction.self, forKey: .deploymentAction)
        deploymentAction = deploymentActionDecoded
        let deploymentStateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentState.self, forKey: .deploymentState)
        deploymentState = deploymentStateDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let deploymentResultDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.DeploymentResult.self, forKey: .deploymentResult)
        deploymentResult = deploymentResultDecoded
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a stage deployment.
    public struct StageDeploymentSummary: Swift.Equatable {
        /// The type of action of the deployment.
        public var deploymentAction: GameSparksClientTypes.DeploymentAction?
        /// The identifier of the deployment.
        public var deploymentId: Swift.String?
        /// The result of the deployment.
        public var deploymentResult: GameSparksClientTypes.DeploymentResult?
        /// The state of the deployment.
        public var deploymentState: GameSparksClientTypes.DeploymentState?
        /// The timestamp of when the deployment was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The identifier of the snapshot associated with the stage deployment.
        public var snapshotId: Swift.String?

        public init (
            deploymentAction: GameSparksClientTypes.DeploymentAction? = nil,
            deploymentId: Swift.String? = nil,
            deploymentResult: GameSparksClientTypes.DeploymentResult? = nil,
            deploymentState: GameSparksClientTypes.DeploymentState? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            snapshotId: Swift.String? = nil
        )
        {
            self.deploymentAction = deploymentAction
            self.deploymentId = deploymentId
            self.deploymentResult = deploymentResult
            self.deploymentState = deploymentState
            self.lastUpdated = lastUpdated
            self.snapshotId = snapshotId
        }
    }

}

extension GameSparksClientTypes.StageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case created = "Created"
        case description = "Description"
        case gameKey = "GameKey"
        case lastUpdated = "LastUpdated"
        case logGroup = "LogGroup"
        case name = "Name"
        case role = "Role"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gameKey = self.gameKey {
            try encodeContainer.encode(gameKey, forKey: .gameKey)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .dateTime, forKey: .lastUpdated)
        }
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let gameKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameKey)
        gameKey = gameKeyDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension GameSparksClientTypes {
    /// Properties that provide details of a stage.
    public struct StageDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the stage.
        public var arn: Swift.String?
        /// The timestamp of when the stage was created.
        public var created: ClientRuntime.Date?
        /// The description of the stage.
        public var description: Swift.String?
        /// The game key associated with the stage. The game key is a unique identifier that the game client uses to connect to the GameSparks backend.
        public var gameKey: Swift.String?
        /// The timestamp of when the stage was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon CloudWatch log group for game runtimes deployed to the stage.
        public var logGroup: Swift.String?
        /// The name of the stage.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role used to run the game runtimes deployed to the stage.
        public var role: Swift.String?
        /// The state of the stage.
        public var state: GameSparksClientTypes.StageState?
        /// The tags associated with the stage.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            gameKey: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            logGroup: Swift.String? = nil,
            name: Swift.String? = nil,
            role: Swift.String? = nil,
            state: GameSparksClientTypes.StageState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.gameKey = gameKey
            self.lastUpdated = lastUpdated
            self.logGroup = logGroup
            self.name = name
            self.role = role
            self.state = state
            self.tags = tags
        }
    }

}

extension GameSparksClientTypes {
    public enum StageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [StageState] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StageState(rawValue: rawValue) ?? StageState.sdkUnknown(rawValue)
        }
    }
}

extension GameSparksClientTypes.StageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gameKey = "GameKey"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gameKey = self.gameKey {
            try encodeContainer.encode(gameKey, forKey: .gameKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let gameKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gameKey)
        gameKey = gameKeyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GameSparksClientTypes {
    /// The summary of the properties of a stage.
    public struct StageSummary: Swift.Equatable {
        /// The description of the stage.
        public var description: Swift.String?
        /// The game key associated with the stage. The game key is a unique identifier that the game client uses to connect to the GameSparks backend.
        public var gameKey: Swift.String?
        /// The name of the stage.
        public var name: Swift.String?
        /// The state of the stage.
        public var state: GameSparksClientTypes.StageState?
        /// The tags associated with the stage.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            gameKey: Swift.String? = nil,
            name: Swift.String? = nil,
            state: GameSparksClientTypes.StageState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.gameKey = gameKey
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension StartGeneratedCodeJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generator = "Generator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generator = self.generator {
            try encodeContainer.encode(generator, forKey: .generator)
        }
    }
}

extension StartGeneratedCodeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())/generated-sdk-code-job"
    }
}

public struct StartGeneratedCodeJobInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// Properties of the generator to use for the job.
    /// This member is required.
    public var generator: GameSparksClientTypes.Generator?
    /// The identifier of the snapshot for which to generate code.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        gameName: Swift.String? = nil,
        generator: GameSparksClientTypes.Generator? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.gameName = gameName
        self.generator = generator
        self.snapshotId = snapshotId
    }
}

struct StartGeneratedCodeJobInputBody: Swift.Equatable {
    let generator: GameSparksClientTypes.Generator?
}

extension StartGeneratedCodeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generator = "Generator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatorDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.Generator.self, forKey: .generator)
        generator = generatorDecoded
    }
}

extension StartGeneratedCodeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartGeneratedCodeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartGeneratedCodeJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartGeneratedCodeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartGeneratedCodeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.generatedCodeJobId = output.generatedCodeJobId
        } else {
            self.generatedCodeJobId = nil
        }
    }
}

public struct StartGeneratedCodeJobOutputResponse: Swift.Equatable {
    /// The identifier of the code generation job. You can use this identifier in the GetGeneratedCodeJob operation.
    public var generatedCodeJobId: Swift.String?

    public init (
        generatedCodeJobId: Swift.String? = nil
    )
    {
        self.generatedCodeJobId = generatedCodeJobId
    }
}

struct StartGeneratedCodeJobOutputResponseBody: Swift.Equatable {
    let generatedCodeJobId: Swift.String?
}

extension StartGeneratedCodeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedCodeJobId = "GeneratedCodeJobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedCodeJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedCodeJobId)
        generatedCodeJobId = generatedCodeJobIdDecoded
    }
}

extension StartStageDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

extension StartStageDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())/deployment"
    }
}

public struct StartStageDeploymentInput: Swift.Equatable {
    /// A client-defined token. With an active client token in the request, this action is idempotent.
    public var clientToken: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the snapshot to deploy.
    /// This member is required.
    public var snapshotId: Swift.String?
    /// The name of the stage to deploy the snapshot onto.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        gameName: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.gameName = gameName
        self.snapshotId = snapshotId
        self.stageName = stageName
    }
}

struct StartStageDeploymentInputBody: Swift.Equatable {
    let snapshotId: Swift.String?
    let clientToken: Swift.String?
}

extension StartStageDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartStageDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStageDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartStageDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStageDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartStageDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stageDeployment = output.stageDeployment
        } else {
            self.stageDeployment = nil
        }
    }
}

public struct StartStageDeploymentOutputResponse: Swift.Equatable {
    /// Properties that describe the stage deployment.
    public var stageDeployment: GameSparksClientTypes.StageDeploymentDetails?

    public init (
        stageDeployment: GameSparksClientTypes.StageDeploymentDetails? = nil
    )
    {
        self.stageDeployment = stageDeployment
    }
}

struct StartStageDeploymentOutputResponseBody: Swift.Equatable {
    let stageDeployment: GameSparksClientTypes.StageDeploymentDetails?
}

extension StartStageDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stageDeployment = "StageDeployment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDeploymentDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDeploymentDetails.self, forKey: .stageDeployment)
        stageDeployment = stageDeploymentDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to add the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateGameConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifications = "Modifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modifications = modifications {
            var modificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modifications)
            for sectionmodification0 in modifications {
                try modificationsContainer.encode(sectionmodification0)
            }
        }
    }
}

extension UpdateGameConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/configuration"
    }
}

public struct UpdateGameConfigurationInput: Swift.Equatable {
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The list of modifications to make.
    /// This member is required.
    public var modifications: [GameSparksClientTypes.SectionModification]?

    public init (
        gameName: Swift.String? = nil,
        modifications: [GameSparksClientTypes.SectionModification]? = nil
    )
    {
        self.gameName = gameName
        self.modifications = modifications
    }
}

struct UpdateGameConfigurationInputBody: Swift.Equatable {
    let modifications: [GameSparksClientTypes.SectionModification]?
}

extension UpdateGameConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modifications = "Modifications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modificationsContainer = try containerValues.decodeIfPresent([GameSparksClientTypes.SectionModification?].self, forKey: .modifications)
        var modificationsDecoded0:[GameSparksClientTypes.SectionModification]? = nil
        if let modificationsContainer = modificationsContainer {
            modificationsDecoded0 = [GameSparksClientTypes.SectionModification]()
            for structure0 in modificationsContainer {
                if let structure0 = structure0 {
                    modificationsDecoded0?.append(structure0)
                }
            }
        }
        modifications = modificationsDecoded0
    }
}

extension UpdateGameConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGameConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGameConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGameConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGameConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gameConfiguration = output.gameConfiguration
        } else {
            self.gameConfiguration = nil
        }
    }
}

public struct UpdateGameConfigurationOutputResponse: Swift.Equatable {
    /// Details about the game configuration.
    public var gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?

    public init (
        gameConfiguration: GameSparksClientTypes.GameConfigurationDetails? = nil
    )
    {
        self.gameConfiguration = gameConfiguration
    }
}

struct UpdateGameConfigurationOutputResponseBody: Swift.Equatable {
    let gameConfiguration: GameSparksClientTypes.GameConfigurationDetails?
}

extension UpdateGameConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gameConfiguration = "GameConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameConfigurationDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameConfigurationDetails.self, forKey: .gameConfiguration)
        gameConfiguration = gameConfigurationDecoded
    }
}

extension UpdateGameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateGameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())"
    }
}

public struct UpdateGameInput: Swift.Equatable {
    /// The description of the game.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?

    public init (
        description: Swift.String? = nil,
        gameName: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
    }
}

struct UpdateGameInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateGameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGameOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.game = output.game
        } else {
            self.game = nil
        }
    }
}

public struct UpdateGameOutputResponse: Swift.Equatable {
    /// The details of the game.
    public var game: GameSparksClientTypes.GameDetails?

    public init (
        game: GameSparksClientTypes.GameDetails? = nil
    )
    {
        self.game = game
    }
}

struct UpdateGameOutputResponseBody: Swift.Equatable {
    let game: GameSparksClientTypes.GameDetails?
}

extension UpdateGameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case game = "Game"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gameDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.GameDetails.self, forKey: .game)
        game = gameDecoded
    }
}

extension UpdateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/snapshot/\(snapshotId.urlPercentEncoding())"
    }
}

public struct UpdateSnapshotInput: Swift.Equatable {
    /// The description of the snapshot.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The identifier of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
        self.snapshotId = snapshotId
    }
}

struct UpdateSnapshotInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct UpdateSnapshotOutputResponse: Swift.Equatable {
    /// Properties that provide details of the updated snapshot.
    public var snapshot: GameSparksClientTypes.SnapshotDetails?

    public init (
        snapshot: GameSparksClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct UpdateSnapshotOutputResponseBody: Swift.Equatable {
    let snapshot: GameSparksClientTypes.SnapshotDetails?
}

extension UpdateSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.SnapshotDetails.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gameName = gameName else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/game/\(gameName.urlPercentEncoding())/stage/\(stageName.urlPercentEncoding())"
    }
}

public struct UpdateStageInput: Swift.Equatable {
    /// The description of the stage.
    public var description: Swift.String?
    /// The name of the game.
    /// This member is required.
    public var gameName: Swift.String?
    /// The Amazon Resource Name (ARN) of the role to use for the game snapshots deployed to this stage.
    public var role: Swift.String?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        description: Swift.String? = nil,
        gameName: Swift.String? = nil,
        role: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.description = description
        self.gameName = gameName
        self.role = role
        self.stageName = stageName
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let role: Swift.String?
    let description: Swift.String?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateStageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct UpdateStageOutputResponse: Swift.Equatable {
    /// Properties that provide details of the updated stage.
    public var stage: GameSparksClientTypes.StageDetails?

    public init (
        stage: GameSparksClientTypes.StageDetails? = nil
    )
    {
        self.stage = stage
    }
}

struct UpdateStageOutputResponseBody: Swift.Equatable {
    let stage: GameSparksClientTypes.StageDetails?
}

extension UpdateStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage = "Stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(GameSparksClientTypes.StageDetails.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the parameters in the request is invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
