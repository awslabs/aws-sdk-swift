// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ApiGatewayEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiGatewayEndpointType] {
            return [
                .private,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiGatewayEndpointType(rawValue: rawValue) ?? ApiGatewayEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayId = "ApiGatewayId"
        case endpointType = "EndpointType"
        case nlbArn = "NlbArn"
        case nlbName = "NlbName"
        case proxyUrl = "ProxyUrl"
        case stageName = "StageName"
        case vpcLinkId = "VpcLinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayId = self.apiGatewayId {
            try encodeContainer.encode(apiGatewayId, forKey: .apiGatewayId)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let nlbArn = self.nlbArn {
            try encodeContainer.encode(nlbArn, forKey: .nlbArn)
        }
        if let nlbName = self.nlbName {
            try encodeContainer.encode(nlbName, forKey: .nlbName)
        }
        if let proxyUrl = self.proxyUrl {
            try encodeContainer.encode(proxyUrl, forKey: .proxyUrl)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let vpcLinkId = self.vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyUrl)
        proxyUrl = proxyUrlDecoded
        let apiGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiGatewayId)
        apiGatewayId = apiGatewayIdDecoded
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let nlbArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbArn)
        nlbArn = nlbArnDecoded
        let nlbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbName)
        nlbName = nlbNameDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A wrapper object holding the Amazon API Gateway proxy configuration.
    public struct ApiGatewayProxyConfig: Swift.Equatable {
        /// The resource ID of the API Gateway for the proxy.
        public var apiGatewayId: Swift.String?
        /// The type of API Gateway endpoint created.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType?
        /// The Amazon Resource Name (ARN) of the Network Load Balancer configured by the API Gateway proxy.
        public var nlbArn: Swift.String?
        /// The name of the Network Load Balancer that is configured by the API Gateway proxy.
        public var nlbName: Swift.String?
        /// The endpoint URL of the API Gateway proxy.
        public var proxyUrl: Swift.String?
        /// The name of the API Gateway stage. The name defaults to prod.
        public var stageName: Swift.String?
        /// The VpcLink ID of the API Gateway proxy.
        public var vpcLinkId: Swift.String?

        public init(
            apiGatewayId: Swift.String? = nil,
            endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType? = nil,
            nlbArn: Swift.String? = nil,
            nlbName: Swift.String? = nil,
            proxyUrl: Swift.String? = nil,
            stageName: Swift.String? = nil,
            vpcLinkId: Swift.String? = nil
        )
        {
            self.apiGatewayId = apiGatewayId
            self.endpointType = endpointType
            self.nlbArn = nlbArn
            self.nlbName = nlbName
            self.proxyUrl = proxyUrl
            self.stageName = stageName
            self.vpcLinkId = vpcLinkId
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case stageName = "StageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A wrapper object holding the Amazon API Gateway endpoint input.
    public struct ApiGatewayProxyInput: Swift.Equatable {
        /// The type of endpoint to use for the API Gateway proxy. If no value is specified in the request, the value is set to REGIONAL by default. If the value is set to PRIVATE in the request, this creates a private API endpoint that is isolated from the public internet. The private endpoint can only be accessed by using Amazon Virtual Private Cloud (Amazon VPC) interface endpoints for the Amazon API Gateway that has been granted access. For more information about creating a private connection with Refactor Spaces and interface endpoint (Amazon Web Services PrivateLink) availability, see [Access Refactor Spaces using an interface endpoint (Amazon Web Services PrivateLink)](https://docs.aws.amazon.com/migrationhub-refactor-spaces/latest/userguide/vpc-interface-endpoints.html).
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType?
        /// The name of the API Gateway stage. The name defaults to prod.
        public var stageName: Swift.String?

        public init(
            endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType? = nil,
            stageName: Swift.String? = nil
        )
        {
            self.endpointType = endpointType
            self.stageName = stageName
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayId = "ApiGatewayId"
        case endpointType = "EndpointType"
        case nlbArn = "NlbArn"
        case nlbName = "NlbName"
        case proxyUrl = "ProxyUrl"
        case stageName = "StageName"
        case vpcLinkId = "VpcLinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayId = self.apiGatewayId {
            try encodeContainer.encode(apiGatewayId, forKey: .apiGatewayId)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let nlbArn = self.nlbArn {
            try encodeContainer.encode(nlbArn, forKey: .nlbArn)
        }
        if let nlbName = self.nlbName {
            try encodeContainer.encode(nlbName, forKey: .nlbName)
        }
        if let proxyUrl = self.proxyUrl {
            try encodeContainer.encode(proxyUrl, forKey: .proxyUrl)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let vpcLinkId = self.vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyUrl)
        proxyUrl = proxyUrlDecoded
        let apiGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiGatewayId)
        apiGatewayId = apiGatewayIdDecoded
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let nlbArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbArn)
        nlbArn = nlbArnDecoded
        let nlbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbName)
        nlbName = nlbNameDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A wrapper object holding the Amazon API Gateway proxy summary.
    public struct ApiGatewayProxySummary: Swift.Equatable {
        /// The resource ID of the API Gateway for the proxy.
        public var apiGatewayId: Swift.String?
        /// The type of API Gateway endpoint created.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType?
        /// The Amazon Resource Name (ARN) of the Network Load Balancer configured by the API Gateway proxy.
        public var nlbArn: Swift.String?
        /// The name of the Network Load Balancer that is configured by the API Gateway proxy.
        public var nlbName: Swift.String?
        /// The endpoint URL of the API Gateway proxy.
        public var proxyUrl: Swift.String?
        /// The name of the API Gateway stage. The name defaults to prod.
        public var stageName: Swift.String?
        /// The VpcLink ID of the API Gateway proxy.
        public var vpcLinkId: Swift.String?

        public init(
            apiGatewayId: Swift.String? = nil,
            endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType? = nil,
            nlbArn: Swift.String? = nil,
            nlbName: Swift.String? = nil,
            proxyUrl: Swift.String? = nil,
            stageName: Swift.String? = nil,
            vpcLinkId: Swift.String? = nil
        )
        {
            self.apiGatewayId = apiGatewayId
            self.endpointType = endpointType
            self.nlbArn = nlbArn
            self.nlbName = nlbName
            self.proxyUrl = proxyUrl
            self.stageName = stageName
            self.vpcLinkId = vpcLinkId
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ApplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationState(rawValue: rawValue) ?? ApplicationState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case proxyType = "ProxyType"
        case state = "State"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayProxy = self.apiGatewayProxy {
            try encodeContainer.encode(apiGatewayProxy, forKey: .apiGatewayProxy)
        }
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdByAccountId = self.createdByAccountId {
            try encodeContainer.encode(createdByAccountId, forKey: .createdByAccountId)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let proxyType = self.proxyType {
            try encodeContainer.encode(proxyType.rawValue, forKey: .proxyType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes.ApplicationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationSummary(apiGatewayProxy: \(Swift.String(describing: apiGatewayProxy)), applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), proxyType: \(Swift.String(describing: proxyType)), state: \(Swift.String(describing: state)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The list of ApplicationSummary objects.
    public struct ApplicationSummary: Swift.Equatable {
        /// The endpoint URL of the Amazon API Gateway proxy.
        public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary?
        /// The unique identifier of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the application.
        public var arn: Swift.String?
        /// The Amazon Web Services account ID of the application creator.
        public var createdByAccountId: Swift.String?
        /// A timestamp that indicates when the application is created.
        public var createdTime: ClientRuntime.Date?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the application resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// A timestamp that indicates when the application was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the application.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the application owner (which is always the same as the environment owner account ID).
        public var ownerAccountId: Swift.String?
        /// The proxy type of the proxy created within the application.
        public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
        /// The current state of the application.
        public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
        /// The tags assigned to the application.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the virtual private cloud (VPC).
        public var vpcId: Swift.String?

        public init(
            apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary? = nil,
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdByAccountId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
            state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.apiGatewayProxy = apiGatewayProxy
            self.applicationId = applicationId
            self.arn = arn
            self.createdByAccountId = createdByAccountId
            self.createdTime = createdTime
            self.environmentId = environmentId
            self.error = error
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.proxyType = proxyType
            self.state = state
            self.tags = tags
            self.vpcId = vpcId
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(apiGatewayProxy: \(Swift.String(describing: apiGatewayProxy)), clientToken: \(Swift.String(describing: clientToken)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), name: \(Swift.String(describing: name)), proxyType: \(Swift.String(describing: proxyType)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case clientToken = "ClientToken"
        case name = "Name"
        case proxyType = "ProxyType"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayProxy = self.apiGatewayProxy {
            try encodeContainer.encode(apiGatewayProxy, forKey: .apiGatewayProxy)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let proxyType = self.proxyType {
            try encodeContainer.encode(proxyType.rawValue, forKey: .proxyType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// A wrapper object holding the API Gateway endpoint type and stage name for the proxy.
    public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The name to use for the application.
    /// This member is required.
    public var name: Swift.String?
    /// The proxy type of the proxy created within the application.
    /// This member is required.
    public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    /// The tags to assign to the application. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the virtual private cloud (VPC).
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput? = nil,
        clientToken: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.apiGatewayProxy = apiGatewayProxy
        self.clientToken = clientToken
        self.environmentIdentifier = environmentIdentifier
        self.name = name
        self.proxyType = proxyType
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let vpcId: Swift.String?
    let proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    let apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case clientToken = "ClientToken"
        case name = "Name"
        case proxyType = "ProxyType"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutput(apiGatewayProxy: \(Swift.String(describing: apiGatewayProxy)), applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), environmentId: \(Swift.String(describing: environmentId)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), proxyType: \(Swift.String(describing: proxyType)), state: \(Swift.String(describing: state)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayProxy = output.apiGatewayProxy
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.proxyType = output.proxyType
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.apiGatewayProxy = nil
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.proxyType = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// A wrapper object holding the API Gateway endpoint type and stage name for the proxy.
    public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    /// The unique identifier of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is arn:aws:refactor-spaces:region:account-id:resource-type/resource-id . For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of application creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the application is created.
    public var createdTime: ClientRuntime.Date?
    /// The ID of the environment in which the application is created.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the application was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the application owner (which is always the same as the environment owner account ID).
    public var ownerAccountId: Swift.String?
    /// The proxy type of the proxy created within the application.
    public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    /// The current state of the application.
    public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    /// The tags assigned to the application. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the Amazon VPC.
    public var vpcId: Swift.String?

    public init(
        apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput? = nil,
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.apiGatewayProxy = apiGatewayProxy
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.proxyType = proxyType
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let vpcId: Swift.String?
    let proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    let apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    let state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case proxyType = "ProxyType"
        case state = "State"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), networkFabricType: \(Swift.String(describing: networkFabricType)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkFabricType = self.networkFabricType {
            try encodeContainer.encode(networkFabricType.rawValue, forKey: .networkFabricType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The network fabric type of the environment.
    /// This member is required.
    public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    /// The tags to assign to the environment. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.networkFabricType = networkFabricType
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutput(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), networkFabricType: \(Swift.String(describing: networkFabricType)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), state: \(Swift.String(describing: state)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.networkFabricType = output.networkFabricType
            self.ownerAccountId = output.ownerAccountId
            self.state = output.state
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.networkFabricType = nil
            self.ownerAccountId = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the environment.
    public var arn: Swift.String?
    /// A timestamp that indicates when the environment is created.
    public var createdTime: ClientRuntime.Date?
    /// A description of the environment.
    public var description: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the environment.
    public var name: Swift.String?
    /// The network fabric type of the environment.
    public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    /// The Amazon Web Services account ID of environment owner.
    public var ownerAccountId: Swift.String?
    /// The current state of the environment.
    public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    /// The tags assigned to the created environment. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
        ownerAccountId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.networkFabricType = networkFabricType
        self.ownerAccountId = ownerAccountId
        self.state = state
        self.tags = tags
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    let ownerAccountId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRouteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRouteInput(applicationIdentifier: \(Swift.String(describing: applicationIdentifier)), clientToken: \(Swift.String(describing: clientToken)), defaultRoute: \(Swift.String(describing: defaultRoute)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), routeType: \(Swift.String(describing: routeType)), serviceIdentifier: \(Swift.String(describing: serviceIdentifier)), uriPathRoute: \(Swift.String(describing: uriPathRoute)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case defaultRoute = "DefaultRoute"
        case routeType = "RouteType"
        case serviceIdentifier = "ServiceIdentifier"
        case tags = "Tags"
        case uriPathRoute = "UriPathRoute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultRoute = self.defaultRoute {
            try encodeContainer.encode(defaultRoute, forKey: .defaultRoute)
        }
        if let routeType = self.routeType {
            try encodeContainer.encode(routeType.rawValue, forKey: .routeType)
        }
        if let serviceIdentifier = self.serviceIdentifier {
            try encodeContainer.encode(serviceIdentifier, forKey: .serviceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uriPathRoute = self.uriPathRoute {
            try encodeContainer.encode(uriPathRoute, forKey: .uriPathRoute)
        }
    }
}

extension CreateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes"
    }
}

public struct CreateRouteInput: Swift.Equatable {
    /// The ID of the application within which the route is being created.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Configuration for the default route type.
    public var defaultRoute: MigrationHubRefactorSpacesClientTypes.DefaultRouteInput?
    /// The ID of the environment in which the route is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The route type of the route. DEFAULT indicates that all traffic that does not match another route is forwarded to the default route. Applications must have a default route before any other routes can be created. URI_PATH indicates a route that is based on a URI path.
    /// This member is required.
    public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    /// The ID of the service in which the route is created. Traffic that matches this route is forwarded to this service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags to assign to the route. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URI path route type.
    public var uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?

    public init(
        applicationIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        defaultRoute: MigrationHubRefactorSpacesClientTypes.DefaultRouteInput? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.clientToken = clientToken
        self.defaultRoute = defaultRoute
        self.environmentIdentifier = environmentIdentifier
        self.routeType = routeType
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
        self.uriPathRoute = uriPathRoute
    }
}

struct CreateRouteInputBody: Swift.Equatable {
    let serviceIdentifier: Swift.String?
    let routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    let defaultRoute: MigrationHubRefactorSpacesClientTypes.DefaultRouteInput?
    let uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case defaultRoute = "DefaultRoute"
        case routeType = "RouteType"
        case serviceIdentifier = "ServiceIdentifier"
        case tags = "Tags"
        case uriPathRoute = "UriPathRoute"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceIdentifier)
        serviceIdentifier = serviceIdentifierDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let defaultRouteDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.DefaultRouteInput.self, forKey: .defaultRoute)
        defaultRoute = defaultRouteDecoded
        let uriPathRouteDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UriPathRouteInput.self, forKey: .uriPathRoute)
        uriPathRoute = uriPathRouteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRouteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRouteOutput(applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), routeId: \(Swift.String(describing: routeId)), routeType: \(Swift.String(describing: routeType)), serviceId: \(Swift.String(describing: serviceId)), state: \(Swift.String(describing: state)), uriPathRoute: \(Swift.String(describing: uriPathRoute)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.lastUpdatedTime = output.lastUpdatedTime
            self.ownerAccountId = output.ownerAccountId
            self.routeId = output.routeId
            self.routeType = output.routeType
            self.serviceId = output.serviceId
            self.state = output.state
            self.tags = output.tags
            self.uriPathRoute = output.uriPathRoute
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.lastUpdatedTime = nil
            self.ownerAccountId = nil
            self.routeId = nil
            self.routeType = nil
            self.serviceId = nil
            self.state = nil
            self.tags = nil
            self.uriPathRoute = nil
        }
    }
}

public struct CreateRouteOutput: Swift.Equatable {
    /// The ID of the application in which the route is created.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route. The format for this ARN is arn:aws:refactor-spaces:region:account-id:resource-type/resource-id . For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the route creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the route is created.
    public var createdTime: ClientRuntime.Date?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The Amazon Web Services account ID of the route owner.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the route.
    public var routeId: Swift.String?
    /// The route type of the route.
    public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    /// The ID of service in which the route is created. Traffic that matches this route is forwarded to this service.
    public var serviceId: Swift.String?
    /// The current state of the route. Activation state only allows ACTIVE or INACTIVE as user inputs. FAILED is a route state that is system generated.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?
    /// The tags assigned to the created route. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// Configuration for the URI path route type.
    public var uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        ownerAccountId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.ownerAccountId = ownerAccountId
        self.routeId = routeId
        self.routeType = routeType
        self.serviceId = serviceId
        self.state = state
        self.tags = tags
        self.uriPathRoute = uriPathRoute
    }
}

struct CreateRouteOutputBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case ownerAccountId = "OwnerAccountId"
        case routeId = "RouteId"
        case routeType = "RouteType"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case uriPathRoute = "UriPathRoute"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let uriPathRouteDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UriPathRouteInput.self, forKey: .uriPathRoute)
        uriPathRoute = uriPathRouteDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum CreateRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(applicationIdentifier: \(Swift.String(describing: applicationIdentifier)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), endpointType: \(Swift.String(describing: endpointType)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), lambdaEndpoint: \(Swift.String(describing: lambdaEndpoint)), name: \(Swift.String(describing: name)), urlEndpoint: \(Swift.String(describing: urlEndpoint)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endpointType = "EndpointType"
        case lambdaEndpoint = "LambdaEndpoint"
        case name = "Name"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let lambdaEndpoint = self.lambdaEndpoint {
            try encodeContainer.encode(lambdaEndpoint, forKey: .lambdaEndpoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let urlEndpoint = self.urlEndpoint {
            try encodeContainer.encode(urlEndpoint, forKey: .urlEndpoint)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// The ID of the application which the service is created.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the service.
    public var description: Swift.String?
    /// The type of endpoint to use for the service. The type can be a URL in a VPC or an Lambda function.
    /// This member is required.
    public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    /// The ID of the environment in which the service is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The configuration for the Lambda endpoint type.
    public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    /// The name of the service.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to assign to the service. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URL endpoint type. When creating a route to a service, Refactor Spaces automatically resolves the address in the UrlEndpointInput object URL when the Domain Name System (DNS) time-to-live (TTL) expires, or every 60 seconds for TTLs less than 60 seconds.
    public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
        environmentIdentifier: Swift.String? = nil,
        lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.clientToken = clientToken
        self.description = description
        self.endpointType = endpointType
        self.environmentIdentifier = environmentIdentifier
        self.lambdaEndpoint = lambdaEndpoint
        self.name = name
        self.tags = tags
        self.urlEndpoint = urlEndpoint
        self.vpcId = vpcId
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let vpcId: Swift.String?
    let endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    let urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    let lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endpointType = "EndpointType"
        case lambdaEndpoint = "LambdaEndpoint"
        case name = "Name"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointInput.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateServiceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceOutput(applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), endpointType: \(Swift.String(describing: endpointType)), environmentId: \(Swift.String(describing: environmentId)), lambdaEndpoint: \(Swift.String(describing: lambdaEndpoint)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), serviceId: \(Swift.String(describing: serviceId)), state: \(Swift.String(describing: state)), urlEndpoint: \(Swift.String(describing: urlEndpoint)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.description = output.description
            self.endpointType = output.endpointType
            self.environmentId = output.environmentId
            self.lambdaEndpoint = output.lambdaEndpoint
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.serviceId = output.serviceId
            self.state = output.state
            self.tags = output.tags
            self.urlEndpoint = output.urlEndpoint
            self.vpcId = output.vpcId
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.description = nil
            self.endpointType = nil
            self.environmentId = nil
            self.lambdaEndpoint = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.serviceId = nil
            self.state = nil
            self.tags = nil
            self.urlEndpoint = nil
            self.vpcId = nil
        }
    }
}

public struct CreateServiceOutput: Swift.Equatable {
    /// The ID of the application that the created service belongs to.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the service creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the service is created.
    public var createdTime: ClientRuntime.Date?
    /// The description of the created service.
    public var description: Swift.String?
    /// The endpoint type of the service.
    public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// The configuration for the Lambda endpoint type.
    public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    /// A timestamp that indicates when the service was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the service owner.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The current state of the service.
    public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    /// The tags assigned to the created service. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URL endpoint type.
    public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
        environmentId: Swift.String? = nil,
        lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.description = description
        self.endpointType = endpointType
        self.environmentId = environmentId
        self.lambdaEndpoint = lambdaEndpoint
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.serviceId = serviceId
        self.state = state
        self.tags = tags
        self.urlEndpoint = urlEndpoint
        self.vpcId = vpcId
    }
}

struct CreateServiceOutputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let applicationId: Swift.String?
    let vpcId: Swift.String?
    let endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    let urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    let lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    let state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case description = "Description"
        case endpointType = "EndpointType"
        case environmentId = "EnvironmentId"
        case lambdaEndpoint = "LambdaEndpoint"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointInput.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum CreateServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.DefaultRouteInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationState = "ActivationState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationState = self.activationState {
            try encodeContainer.encode(activationState.rawValue, forKey: .activationState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationStateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteActivationState.self, forKey: .activationState)
        activationState = activationStateDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the default route type.
    public struct DefaultRouteInput: Swift.Equatable {
        /// If set to ACTIVE, traffic is forwarded to this routes service after the route is created.
        public var activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState?

        public init(
            activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState? = nil
        )
        {
            self.activationState = activationState
        }
    }

}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the application.
    public var arn: Swift.String?
    /// The unique identifier of the applications environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The current state of the application.
    public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.state = state
    }
}

struct DeleteApplicationOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init(
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the environment.
    public var arn: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the environment.
    public var name: Swift.String?
    /// The current state of the environment.
    public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?

    public init(
        arn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil
    )
    {
        self.arn = arn
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.state = state
    }
}

struct DeleteEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let environmentId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/resourcepolicy/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resource associated with the policy.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let routeIdentifier = routeIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes/\(routeIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteRouteInput: Swift.Equatable {
    /// The ID of the application to delete the route from.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment to delete the route from.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the route to delete.
    /// This member is required.
    public var routeIdentifier: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.routeIdentifier = routeIdentifier
    }
}

struct DeleteRouteInputBody: Swift.Equatable {
}

extension DeleteRouteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.lastUpdatedTime = output.lastUpdatedTime
            self.routeId = output.routeId
            self.serviceId = output.serviceId
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.lastUpdatedTime = nil
            self.routeId = nil
            self.serviceId = nil
            self.state = nil
        }
    }
}

public struct DeleteRouteOutput: Swift.Equatable {
    /// The ID of the application that the route belongs to.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route.
    public var arn: Swift.String?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The ID of the route to delete.
    public var routeId: Swift.String?
    /// The ID of the service that the route belongs to.
    public var serviceId: Swift.String?
    /// The current state of the route.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        routeId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.lastUpdatedTime = lastUpdatedTime
        self.routeId = routeId
        self.serviceId = serviceId
        self.state = state
    }
}

struct DeleteRouteOutputBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case lastUpdatedTime = "LastUpdatedTime"
        case routeId = "RouteId"
        case serviceId = "ServiceId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum DeleteRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// Deletes a Refactor Spaces service. The RefactorSpacesSecurityGroup security group must be removed from all Amazon Web Services resources in the virtual private cloud (VPC) prior to deleting a service with a URL endpoint in a VPC.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment that the service is in.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the service to delete.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
}

extension DeleteServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.serviceId = output.serviceId
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.serviceId = nil
            self.state = nil
        }
    }
}

public struct DeleteServiceOutput: Swift.Equatable {
    /// The ID of the application that the service is in.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the service was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The current state of the service.
    public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.serviceId = serviceId
        self.state = state
    }
}

struct DeleteServiceOutputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let environmentId: Swift.String?
    let applicationId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case serviceId = "ServiceId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum DeleteServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum EnvironmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentState(rawValue: rawValue) ?? EnvironmentState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.EnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
        case transitGatewayId = "TransitGatewayId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkFabricType = self.networkFabricType {
            try encodeContainer.encode(networkFabricType.rawValue, forKey: .networkFabricType)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transitGatewayId = self.transitGatewayId {
            try encodeContainer.encode(transitGatewayId, forKey: .transitGatewayId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let transitGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayId)
        transitGatewayId = transitGatewayIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), networkFabricType: \(Swift.String(describing: networkFabricType)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), state: \(Swift.String(describing: state)), transitGatewayId: \(Swift.String(describing: transitGatewayId)), tags: \"CONTENT_REDACTED\")"}
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary information for environments as a response to ListEnvironments.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        public var arn: Swift.String?
        /// A timestamp that indicates when the environment is created.
        public var createdTime: ClientRuntime.Date?
        /// A description of the environment.
        public var description: Swift.String?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the environment resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// A timestamp that indicates when the environment was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the environment.
        public var name: Swift.String?
        /// The network fabric type of the environment.
        public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
        /// The Amazon Web Services account ID of the environment owner.
        public var ownerAccountId: Swift.String?
        /// The current state of the environment.
        public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
        /// The tags assigned to the environment.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the Transit Gateway set up by the environment.
        public var transitGatewayId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
            ownerAccountId: Swift.String? = nil,
            state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            transitGatewayId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.environmentId = environmentId
            self.error = error
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.networkFabricType = networkFabricType
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
            self.transitGatewayId = transitGatewayId
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.EnvironmentVpc: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case cidrBlocks = "CidrBlocks"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case vpcId = "VpcId"
        case vpcName = "VpcName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let cidrBlocks = cidrBlocks {
            var cidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrBlocks)
            for cidrblock0 in cidrBlocks {
                try cidrBlocksContainer.encode(cidrblock0)
            }
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcName = self.vpcName {
            try encodeContainer.encode(vpcName, forKey: .vpcName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let cidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrBlocks)
        var cidrBlocksDecoded0:[Swift.String]? = nil
        if let cidrBlocksContainer = cidrBlocksContainer {
            cidrBlocksDecoded0 = [Swift.String]()
            for string0 in cidrBlocksContainer {
                if let string0 = string0 {
                    cidrBlocksDecoded0?.append(string0)
                }
            }
        }
        cidrBlocks = cidrBlocksDecoded0
        let vpcNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcName)
        vpcName = vpcNameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// Provides summary information for the EnvironmentVpc resource as a response to ListEnvironmentVpc.
    public struct EnvironmentVpc: Swift.Equatable {
        /// The Amazon Web Services account ID of the virtual private cloud (VPC) owner.
        public var accountId: Swift.String?
        /// The list of Amazon Virtual Private Cloud (Amazon VPC) CIDR blocks.
        public var cidrBlocks: [Swift.String]?
        /// A timestamp that indicates when the VPC is first added to the environment.
        public var createdTime: ClientRuntime.Date?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// A timestamp that indicates when the VPC was last updated by the environment.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The ID of the VPC.
        public var vpcId: Swift.String?
        /// The name of the VPC at the time it is added to the environment.
        public var vpcName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            cidrBlocks: [Swift.String]? = nil,
            createdTime: ClientRuntime.Date? = nil,
            environmentId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            vpcId: Swift.String? = nil,
            vpcName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.cidrBlocks = cidrBlocks
            self.createdTime = createdTime
            self.environmentId = environmentId
            self.lastUpdatedTime = lastUpdatedTime
            self.vpcId = vpcId
            self.vpcName = vpcName
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidResourceState
        case notAuthorized
        case requestLimitExceeded
        case resourceCreationFailure
        case resourceDeletionFailure
        case resourceInUse
        case resourceLimitExceeded
        case resourceNotFound
        case resourceRetrievalFailure
        case resourceUpdateFailure
        case serviceEndpointHealthCheckFailure
        case stateTransitionFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .invalidResourceState,
                .notAuthorized,
                .requestLimitExceeded,
                .resourceCreationFailure,
                .resourceDeletionFailure,
                .resourceInUse,
                .resourceLimitExceeded,
                .resourceNotFound,
                .resourceRetrievalFailure,
                .resourceUpdateFailure,
                .serviceEndpointHealthCheckFailure,
                .stateTransitionFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidResourceState: return "INVALID_RESOURCE_STATE"
            case .notAuthorized: return "NOT_AUTHORIZED"
            case .requestLimitExceeded: return "REQUEST_LIMIT_EXCEEDED"
            case .resourceCreationFailure: return "RESOURCE_CREATION_FAILURE"
            case .resourceDeletionFailure: return "RESOURCE_DELETION_FAILURE"
            case .resourceInUse: return "RESOURCE_IN_USE"
            case .resourceLimitExceeded: return "RESOURCE_LIMIT_EXCEEDED"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .resourceRetrievalFailure: return "RESOURCE_RETRIEVAL_FAILURE"
            case .resourceUpdateFailure: return "RESOURCE_UPDATE_FAILURE"
            case .serviceEndpointHealthCheckFailure: return "SERVICE_ENDPOINT_HEALTH_CHECK_FAILURE"
            case .stateTransitionFailure: return "STATE_TRANSITION_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ErrorResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case application
        case environment
        case iamRole
        case lambda
        case loadBalancerListener
        case nlb
        case resourceShare
        case route
        case routeTable
        case securityGroup
        case service
        case subnet
        case targetGroup
        case transitGateway
        case transitGatewayAttachment
        case vpc
        case vpcEndpointServiceConfiguration
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorResourceType] {
            return [
                .apiGateway,
                .application,
                .environment,
                .iamRole,
                .lambda,
                .loadBalancerListener,
                .nlb,
                .resourceShare,
                .route,
                .routeTable,
                .securityGroup,
                .service,
                .subnet,
                .targetGroup,
                .transitGateway,
                .transitGatewayAttachment,
                .vpc,
                .vpcEndpointServiceConfiguration,
                .vpcLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .application: return "APPLICATION"
            case .environment: return "ENVIRONMENT"
            case .iamRole: return "IAM_ROLE"
            case .lambda: return "LAMBDA"
            case .loadBalancerListener: return "LOAD_BALANCER_LISTENER"
            case .nlb: return "NLB"
            case .resourceShare: return "RESOURCE_SHARE"
            case .route: return "ROUTE"
            case .routeTable: return "ROUTE_TABLE"
            case .securityGroup: return "SECURITY_GROUP"
            case .service: return "SERVICE"
            case .subnet: return "SUBNET"
            case .targetGroup: return "TARGET_GROUP"
            case .transitGateway: return "TRANSIT_GATEWAY"
            case .transitGatewayAttachment: return "TRANSIT_GATEWAY_ATTACHMENT"
            case .vpc: return "VPC"
            case .vpcEndpointServiceConfiguration: return "VPC_ENDPOINT_SERVICE_CONFIGURATION"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorResourceType(rawValue: rawValue) ?? ErrorResourceType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ErrorResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case additionalDetails = "AdditionalDetails"
        case code = "Code"
        case message = "Message"
        case resourceIdentifier = "ResourceIdentifier"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let additionalDetails = additionalDetails {
            var additionalDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalDetails)
            for (dictKey0, additionalDetails0) in additionalDetails {
                try additionalDetailsContainer.encode(additionalDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let additionalDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalDetails)
        var additionalDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalDetailsContainer = additionalDetailsContainer {
            additionalDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, additionaldetailsvalue0) in additionalDetailsContainer {
                if let additionaldetailsvalue0 = additionaldetailsvalue0 {
                    additionalDetailsDecoded0?[key0] = additionaldetailsvalue0
                }
            }
        }
        additionalDetails = additionalDetailsDecoded0
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// Error associated with a resource returned for a Get or List resource response.
    public struct ErrorResponse: Swift.Equatable {
        /// The Amazon Web Services account ID of the resource owner.
        public var accountId: Swift.String?
        /// Additional details about the error.
        public var additionalDetails: [Swift.String:Swift.String]?
        /// The error code associated with the error.
        public var code: MigrationHubRefactorSpacesClientTypes.ErrorCode?
        /// The message associated with the error.
        public var message: Swift.String?
        /// The ID of the resource.
        public var resourceIdentifier: Swift.String?
        /// The type of resource.
        public var resourceType: MigrationHubRefactorSpacesClientTypes.ErrorResourceType?

        public init(
            accountId: Swift.String? = nil,
            additionalDetails: [Swift.String:Swift.String]? = nil,
            code: MigrationHubRefactorSpacesClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceType: MigrationHubRefactorSpacesClientTypes.ErrorResourceType? = nil
        )
        {
            self.accountId = accountId
            self.additionalDetails = additionalDetails
            self.code = code
            self.message = message
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }

}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationOutput(apiGatewayProxy: \(Swift.String(describing: apiGatewayProxy)), applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), proxyType: \(Swift.String(describing: proxyType)), state: \(Swift.String(describing: state)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayProxy = output.apiGatewayProxy
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.environmentId = output.environmentId
            self.error = output.error
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.proxyType = output.proxyType
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.apiGatewayProxy = nil
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.environmentId = nil
            self.error = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.proxyType = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The endpoint URL of the API Gateway proxy.
    public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig?
    /// The unique identifier of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the application.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the application creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the application is created.
    public var createdTime: ClientRuntime.Date?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the application resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// A timestamp that indicates when the application was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the application owner (which is always the same as the environment owner account ID).
    public var ownerAccountId: Swift.String?
    /// The proxy type of the proxy created within the application.
    public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    /// The current state of the application.
    public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    /// The tags assigned to the application. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the virtual private cloud (VPC).
    public var vpcId: Swift.String?

    public init(
        apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig? = nil,
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.apiGatewayProxy = apiGatewayProxy
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.environmentId = environmentId
        self.error = error
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.proxyType = proxyType
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let vpcId: Swift.String?
    let proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    let apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig?
    let state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case proxyType = "ProxyType"
        case state = "State"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init(
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutput(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), networkFabricType: \(Swift.String(describing: networkFabricType)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), state: \(Swift.String(describing: state)), transitGatewayId: \(Swift.String(describing: transitGatewayId)), tags: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.environmentId = output.environmentId
            self.error = output.error
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.networkFabricType = output.networkFabricType
            self.ownerAccountId = output.ownerAccountId
            self.state = output.state
            self.tags = output.tags
            self.transitGatewayId = output.transitGatewayId
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.environmentId = nil
            self.error = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.networkFabricType = nil
            self.ownerAccountId = nil
            self.state = nil
            self.tags = nil
            self.transitGatewayId = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the environment.
    public var arn: Swift.String?
    /// A timestamp that indicates when the environment is created.
    public var createdTime: ClientRuntime.Date?
    /// The description of the environment.
    public var description: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the environment resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the environment.
    public var name: Swift.String?
    /// The network fabric type of the environment.
    public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    /// The Amazon Web Services account ID of the environment owner.
    public var ownerAccountId: Swift.String?
    /// The current state of the environment.
    public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    /// The tags to assign to the environment. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the Transit Gateway set up by the environment, if applicable.
    public var transitGatewayId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
        ownerAccountId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transitGatewayId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.environmentId = environmentId
        self.error = error
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.networkFabricType = networkFabricType
        self.ownerAccountId = ownerAccountId
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    let ownerAccountId: Swift.String?
    let transitGatewayId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
        case transitGatewayId = "TransitGatewayId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let transitGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayId)
        transitGatewayId = transitGatewayIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/resourcepolicy/\(identifier.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource associated with the policy.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutput: Swift.Equatable {
    /// A JSON-formatted string for an Amazon Web Services resource-based policy.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let routeIdentifier = routeIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes/\(routeIdentifier.urlPercentEncoding())"
    }
}

public struct GetRouteInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the route.
    /// This member is required.
    public var routeIdentifier: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.routeIdentifier = routeIdentifier
    }
}

struct GetRouteInputBody: Swift.Equatable {
}

extension GetRouteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRouteOutput(appendSourcePath: \(Swift.String(describing: appendSourcePath)), applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), includeChildPaths: \(Swift.String(describing: includeChildPaths)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), methods: \(Swift.String(describing: methods)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), pathResourceToId: \(Swift.String(describing: pathResourceToId)), routeId: \(Swift.String(describing: routeId)), routeType: \(Swift.String(describing: routeType)), serviceId: \(Swift.String(describing: serviceId)), sourcePath: \(Swift.String(describing: sourcePath)), state: \(Swift.String(describing: state)), tags: \"CONTENT_REDACTED\")"}
}

extension GetRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.appendSourcePath = output.appendSourcePath
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.environmentId = output.environmentId
            self.error = output.error
            self.includeChildPaths = output.includeChildPaths
            self.lastUpdatedTime = output.lastUpdatedTime
            self.methods = output.methods
            self.ownerAccountId = output.ownerAccountId
            self.pathResourceToId = output.pathResourceToId
            self.routeId = output.routeId
            self.routeType = output.routeType
            self.serviceId = output.serviceId
            self.sourcePath = output.sourcePath
            self.state = output.state
            self.tags = output.tags
        } else {
            self.appendSourcePath = nil
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.environmentId = nil
            self.error = nil
            self.includeChildPaths = nil
            self.lastUpdatedTime = nil
            self.methods = nil
            self.ownerAccountId = nil
            self.pathResourceToId = nil
            self.routeId = nil
            self.routeType = nil
            self.serviceId = nil
            self.sourcePath = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct GetRouteOutput: Swift.Equatable {
    /// If set to true, this option appends the source path to the service URL endpoint.
    public var appendSourcePath: Swift.Bool?
    /// The ID of the application that the route belongs to.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the route creator.
    public var createdByAccountId: Swift.String?
    /// The timestamp of when the route is created.
    public var createdTime: ClientRuntime.Date?
    /// Unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the route resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// Indicates whether to match all subpaths of the given source path. If this value is false, requests must match the source path exactly before they are forwarded to this route's service.
    public var includeChildPaths: Swift.Bool?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// A list of HTTP methods to match. An empty list matches all values. If a method is present, only HTTP requests using that method are forwarded to this routes service.
    public var methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
    /// The Amazon Web Services account ID of the route owner.
    public var ownerAccountId: Swift.String?
    /// A mapping of Amazon API Gateway path resources to resource IDs.
    public var pathResourceToId: [Swift.String:Swift.String]?
    /// The unique identifier of the route. DEFAULT: All traffic that does not match another route is forwarded to the default route. Applications must have a default route before any other routes can be created. URI_PATH: A route that is based on a URI path.
    public var routeId: Swift.String?
    /// The type of route.
    public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// This is the path that Refactor Spaces uses to match traffic. Paths must start with / and are relative to the base of the application. To use path parameters in the source path, add a variable in curly braces. For example, the resource path {user} represents a path parameter called 'user'.
    public var sourcePath: Swift.String?
    /// The current state of the route.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?
    /// The tags assigned to the route. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        appendSourcePath: Swift.Bool? = nil,
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        includeChildPaths: Swift.Bool? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil,
        ownerAccountId: Swift.String? = nil,
        pathResourceToId: [Swift.String:Swift.String]? = nil,
        routeId: Swift.String? = nil,
        routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
        serviceId: Swift.String? = nil,
        sourcePath: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.appendSourcePath = appendSourcePath
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.environmentId = environmentId
        self.error = error
        self.includeChildPaths = includeChildPaths
        self.lastUpdatedTime = lastUpdatedTime
        self.methods = methods
        self.ownerAccountId = ownerAccountId
        self.pathResourceToId = pathResourceToId
        self.routeId = routeId
        self.routeType = routeType
        self.serviceId = serviceId
        self.sourcePath = sourcePath
        self.state = state
        self.tags = tags
    }
}

struct GetRouteOutputBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let sourcePath: Swift.String?
    let methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
    let includeChildPaths: Swift.Bool?
    let pathResourceToId: [Swift.String:Swift.String]?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
    let appendSourcePath: Swift.Bool?
}

extension GetRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appendSourcePath = "AppendSourcePath"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case includeChildPaths = "IncludeChildPaths"
        case lastUpdatedTime = "LastUpdatedTime"
        case methods = "Methods"
        case ownerAccountId = "OwnerAccountId"
        case pathResourceToId = "PathResourceToId"
        case routeId = "RouteId"
        case routeType = "RouteType"
        case serviceId = "ServiceId"
        case sourcePath = "SourcePath"
        case state = "State"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let methodsContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.HttpMethod?].self, forKey: .methods)
        var methodsDecoded0:[MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil
        if let methodsContainer = methodsContainer {
            methodsDecoded0 = [MigrationHubRefactorSpacesClientTypes.HttpMethod]()
            for string0 in methodsContainer {
                if let string0 = string0 {
                    methodsDecoded0?.append(string0)
                }
            }
        }
        methods = methodsDecoded0
        let includeChildPathsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeChildPaths)
        includeChildPaths = includeChildPathsDecoded
        let pathResourceToIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pathResourceToId)
        var pathResourceToIdDecoded0: [Swift.String:Swift.String]? = nil
        if let pathResourceToIdContainer = pathResourceToIdContainer {
            pathResourceToIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, pathresourcetoidvalue0) in pathResourceToIdContainer {
                if let pathresourcetoidvalue0 = pathresourcetoidvalue0 {
                    pathResourceToIdDecoded0?[key0] = pathresourcetoidvalue0
                }
            }
        }
        pathResourceToId = pathResourceToIdDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let appendSourcePathDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .appendSourcePath)
        appendSourcePath = appendSourcePathDecoded
    }
}

enum GetRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetServiceInputBody: Swift.Equatable {
}

extension GetServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceOutput(applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), endpointType: \(Swift.String(describing: endpointType)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), lambdaEndpoint: \(Swift.String(describing: lambdaEndpoint)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), serviceId: \(Swift.String(describing: serviceId)), state: \(Swift.String(describing: state)), urlEndpoint: \(Swift.String(describing: urlEndpoint)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension GetServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.description = output.description
            self.endpointType = output.endpointType
            self.environmentId = output.environmentId
            self.error = output.error
            self.lambdaEndpoint = output.lambdaEndpoint
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.serviceId = output.serviceId
            self.state = output.state
            self.tags = output.tags
            self.urlEndpoint = output.urlEndpoint
            self.vpcId = output.vpcId
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.description = nil
            self.endpointType = nil
            self.environmentId = nil
            self.error = nil
            self.lambdaEndpoint = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.serviceId = nil
            self.state = nil
            self.tags = nil
            self.urlEndpoint = nil
            self.vpcId = nil
        }
    }
}

public struct GetServiceOutput: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the service creator.
    public var createdByAccountId: Swift.String?
    /// The timestamp of when the service is created.
    public var createdTime: ClientRuntime.Date?
    /// The description of the service.
    public var description: Swift.String?
    /// The endpoint type of the service.
    public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the service resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// The configuration for the Lambda endpoint type. The Arn is the Amazon Resource Name (ARN) of the Lambda function associated with this service.
    public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig?
    /// A timestamp that indicates when the service was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the service owner.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The current state of the service.
    public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    /// The tags assigned to the service. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URL endpoint type. The Url isthe URL of the endpoint type. The HealthUrl is the health check URL of the endpoint type.
    public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig?
    /// The ID of the virtual private cloud (VPC).
    public var vpcId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.description = description
        self.endpointType = endpointType
        self.environmentId = environmentId
        self.error = error
        self.lambdaEndpoint = lambdaEndpoint
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.serviceId = serviceId
        self.state = state
        self.tags = tags
        self.urlEndpoint = urlEndpoint
        self.vpcId = vpcId
    }
}

struct GetServiceOutputBody: Swift.Equatable {
    let serviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let applicationId: Swift.String?
    let vpcId: Swift.String?
    let endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    let urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig?
    let lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig?
    let state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case description = "Description"
        case endpointType = "EndpointType"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lambdaEndpoint = "LambdaEndpoint"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum GetServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum HttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpMethod] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpMethod(rawValue: rawValue) ?? HttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourcePolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourcePolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource policy is not valid.
public struct InvalidResourcePolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourcePolicyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourcePolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourcePolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the Lambda endpoint type.
    public struct LambdaEndpointConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda endpoint.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The input for the Lambda endpoint type.
    public struct LambdaEndpointInput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda function or alias.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary for the Lambda endpoint type.
    public struct LambdaEndpointSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda endpoint.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationSummaryList = output.applicationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.applicationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// The list of ApplicationSummary objects.
    public var applicationSummaryList: [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationSummaryList: [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationSummaryList = applicationSummaryList
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applicationSummaryList: [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSummaryList = "ApplicationSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.ApplicationSummary?].self, forKey: .applicationSummaryList)
        var applicationSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.ApplicationSummary]? = nil
        if let applicationSummaryListContainer = applicationSummaryListContainer {
            applicationSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]()
            for structure0 in applicationSummaryListContainer {
                if let structure0 = structure0 {
                    applicationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaryList = applicationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentVpcsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentVpcsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/vpcs"
    }
}

public struct ListEnvironmentVpcsInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentVpcsInputBody: Swift.Equatable {
}

extension ListEnvironmentVpcsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentVpcsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentVpcsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentVpcList = output.environmentVpcList
            self.nextToken = output.nextToken
        } else {
            self.environmentVpcList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentVpcsOutput: Swift.Equatable {
    /// The list of EnvironmentVpc objects.
    public var environmentVpcList: [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        environmentVpcList: [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentVpcList = environmentVpcList
        self.nextToken = nextToken
    }
}

struct ListEnvironmentVpcsOutputBody: Swift.Equatable {
    let environmentVpcList: [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]?
    let nextToken: Swift.String?
}

extension ListEnvironmentVpcsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVpcList = "EnvironmentVpcList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentVpcListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.EnvironmentVpc?].self, forKey: .environmentVpcList)
        var environmentVpcListDecoded0:[MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]? = nil
        if let environmentVpcListContainer = environmentVpcListContainer {
            environmentVpcListDecoded0 = [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]()
            for structure0 in environmentVpcListContainer {
                if let structure0 = structure0 {
                    environmentVpcListDecoded0?.append(structure0)
                }
            }
        }
        environmentVpcList = environmentVpcListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentVpcsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentSummaryList = output.environmentSummaryList
            self.nextToken = output.nextToken
        } else {
            self.environmentSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// The list of EnvironmentSummary objects.
    public var environmentSummaryList: [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        environmentSummaryList: [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentSummaryList = environmentSummaryList
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let environmentSummaryList: [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentSummaryList = "EnvironmentSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.EnvironmentSummary?].self, forKey: .environmentSummaryList)
        var environmentSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]? = nil
        if let environmentSummaryListContainer = environmentSummaryListContainer {
            environmentSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]()
            for structure0 in environmentSummaryListContainer {
                if let structure0 = structure0 {
                    environmentSummaryListDecoded0?.append(structure0)
                }
            }
        }
        environmentSummaryList = environmentSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoutesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes"
    }
}

public struct ListRoutesInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutesInputBody: Swift.Equatable {
}

extension ListRoutesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoutesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routeSummaryList = output.routeSummaryList
        } else {
            self.nextToken = nil
            self.routeSummaryList = nil
        }
    }
}

public struct ListRoutesOutput: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of RouteSummary objects.
    public var routeSummaryList: [MigrationHubRefactorSpacesClientTypes.RouteSummary]?

    public init(
        nextToken: Swift.String? = nil,
        routeSummaryList: [MigrationHubRefactorSpacesClientTypes.RouteSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routeSummaryList = routeSummaryList
    }
}

struct ListRoutesOutputBody: Swift.Equatable {
    let routeSummaryList: [MigrationHubRefactorSpacesClientTypes.RouteSummary]?
    let nextToken: Swift.String?
}

extension ListRoutesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routeSummaryList = "RouteSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.RouteSummary?].self, forKey: .routeSummaryList)
        var routeSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.RouteSummary]? = nil
        if let routeSummaryListContainer = routeSummaryListContainer {
            routeSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.RouteSummary]()
            for structure0 in routeSummaryListContainer {
                if let structure0 = structure0 {
                    routeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routeSummaryList = routeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
}

extension ListServicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceSummaryList = output.serviceSummaryList
        } else {
            self.nextToken = nil
            self.serviceSummaryList = nil
        }
    }
}

public struct ListServicesOutput: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of ServiceSummary objects.
    public var serviceSummaryList: [MigrationHubRefactorSpacesClientTypes.ServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        serviceSummaryList: [MigrationHubRefactorSpacesClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

struct ListServicesOutputBody: Swift.Equatable {
    let serviceSummaryList: [MigrationHubRefactorSpacesClientTypes.ServiceSummary]?
    let nextToken: Swift.String?
}

extension ListServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceSummaryList = "ServiceSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.ServiceSummary?].self, forKey: .serviceSummaryList)
        var serviceSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.ServiceSummary]? = nil
        if let serviceSummaryListContainer = serviceSummaryListContainer {
            serviceSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.ServiceSummary]()
            for structure0 in serviceSummaryListContainer {
                if let structure0 = structure0 {
                    serviceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        serviceSummaryList = serviceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum NetworkFabricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case transitGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFabricType] {
            return [
                .none,
                .transitGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .transitGateway: return "TRANSIT_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkFabricType(rawValue: rawValue) ?? NetworkFabricType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ProxyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxyType] {
            return [
                .apiGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxyType(rawValue: rawValue) ?? ProxyType.sdkUnknown(rawValue)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resourcepolicy"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// A JSON-formatted string for an Amazon Web Services resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource to which the policy is being attached.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourcePolicyException": return try await InvalidResourcePolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum RouteActivationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteActivationState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteActivationState(rawValue: rawValue) ?? RouteActivationState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum RouteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case inactive
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .inactive,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteState(rawValue: rawValue) ?? RouteState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.RouteSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appendSourcePath = "AppendSourcePath"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case includeChildPaths = "IncludeChildPaths"
        case lastUpdatedTime = "LastUpdatedTime"
        case methods = "Methods"
        case ownerAccountId = "OwnerAccountId"
        case pathResourceToId = "PathResourceToId"
        case routeId = "RouteId"
        case routeType = "RouteType"
        case serviceId = "ServiceId"
        case sourcePath = "SourcePath"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appendSourcePath = self.appendSourcePath {
            try encodeContainer.encode(appendSourcePath, forKey: .appendSourcePath)
        }
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdByAccountId = self.createdByAccountId {
            try encodeContainer.encode(createdByAccountId, forKey: .createdByAccountId)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let includeChildPaths = self.includeChildPaths {
            try encodeContainer.encode(includeChildPaths, forKey: .includeChildPaths)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let methods = methods {
            var methodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .methods)
            for httpmethod0 in methods {
                try methodsContainer.encode(httpmethod0.rawValue)
            }
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let pathResourceToId = pathResourceToId {
            var pathResourceToIdContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .pathResourceToId)
            for (dictKey0, pathResourceToId0) in pathResourceToId {
                try pathResourceToIdContainer.encode(pathResourceToId0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeId = self.routeId {
            try encodeContainer.encode(routeId, forKey: .routeId)
        }
        if let routeType = self.routeType {
            try encodeContainer.encode(routeType.rawValue, forKey: .routeType)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let methodsContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.HttpMethod?].self, forKey: .methods)
        var methodsDecoded0:[MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil
        if let methodsContainer = methodsContainer {
            methodsDecoded0 = [MigrationHubRefactorSpacesClientTypes.HttpMethod]()
            for string0 in methodsContainer {
                if let string0 = string0 {
                    methodsDecoded0?.append(string0)
                }
            }
        }
        methods = methodsDecoded0
        let includeChildPathsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeChildPaths)
        includeChildPaths = includeChildPathsDecoded
        let pathResourceToIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pathResourceToId)
        var pathResourceToIdDecoded0: [Swift.String:Swift.String]? = nil
        if let pathResourceToIdContainer = pathResourceToIdContainer {
            pathResourceToIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, pathresourcetoidvalue0) in pathResourceToIdContainer {
                if let pathresourcetoidvalue0 = pathresourcetoidvalue0 {
                    pathResourceToIdDecoded0?[key0] = pathresourcetoidvalue0
                }
            }
        }
        pathResourceToId = pathResourceToIdDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let appendSourcePathDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .appendSourcePath)
        appendSourcePath = appendSourcePathDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes.RouteSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteSummary(appendSourcePath: \(Swift.String(describing: appendSourcePath)), applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), includeChildPaths: \(Swift.String(describing: includeChildPaths)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), methods: \(Swift.String(describing: methods)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), pathResourceToId: \(Swift.String(describing: pathResourceToId)), routeId: \(Swift.String(describing: routeId)), routeType: \(Swift.String(describing: routeType)), serviceId: \(Swift.String(describing: serviceId)), sourcePath: \(Swift.String(describing: sourcePath)), state: \(Swift.String(describing: state)), tags: \"CONTENT_REDACTED\")"}
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary information for the routes as a response to ListRoutes.
    public struct RouteSummary: Swift.Equatable {
        /// If set to true, this option appends the source path to the service URL endpoint.
        public var appendSourcePath: Swift.Bool?
        /// The unique identifier of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the route.
        public var arn: Swift.String?
        /// The Amazon Web Services account ID of the route creator.
        public var createdByAccountId: Swift.String?
        /// A timestamp that indicates when the route is created.
        public var createdTime: ClientRuntime.Date?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the route resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// Indicates whether to match all subpaths of the given source path. If this value is false, requests must match the source path exactly before they are forwarded to this route's service.
        public var includeChildPaths: Swift.Bool?
        /// A timestamp that indicates when the route was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A list of HTTP methods to match. An empty list matches all values. If a method is present, only HTTP requests using that method are forwarded to this routes service.
        public var methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
        /// The Amazon Web Services account ID of the route owner.
        public var ownerAccountId: Swift.String?
        /// A mapping of Amazon API Gateway path resources to resource IDs.
        public var pathResourceToId: [Swift.String:Swift.String]?
        /// The unique identifier of the route.
        public var routeId: Swift.String?
        /// The route type of the route.
        public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
        /// The unique identifier of the service.
        public var serviceId: Swift.String?
        /// This is the path that Refactor Spaces uses to match traffic. Paths must start with / and are relative to the base of the application. To use path parameters in the source path, add a variable in curly braces. For example, the resource path {user} represents a path parameter called 'user'.
        public var sourcePath: Swift.String?
        /// The current state of the route.
        public var state: MigrationHubRefactorSpacesClientTypes.RouteState?
        /// The tags assigned to the route.
        public var tags: [Swift.String:Swift.String]?

        public init(
            appendSourcePath: Swift.Bool? = nil,
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdByAccountId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            includeChildPaths: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil,
            ownerAccountId: Swift.String? = nil,
            pathResourceToId: [Swift.String:Swift.String]? = nil,
            routeId: Swift.String? = nil,
            routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
            serviceId: Swift.String? = nil,
            sourcePath: Swift.String? = nil,
            state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appendSourcePath = appendSourcePath
            self.applicationId = applicationId
            self.arn = arn
            self.createdByAccountId = createdByAccountId
            self.createdTime = createdTime
            self.environmentId = environmentId
            self.error = error
            self.includeChildPaths = includeChildPaths
            self.lastUpdatedTime = lastUpdatedTime
            self.methods = methods
            self.ownerAccountId = ownerAccountId
            self.pathResourceToId = pathResourceToId
            self.routeId = routeId
            self.routeType = routeType
            self.serviceId = serviceId
            self.sourcePath = sourcePath
            self.state = state
            self.tags = tags
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes {
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case uriPath
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .default,
                .uriPath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .uriPath: return "URI_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ServiceEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambda
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceEndpointType] {
            return [
                .lambda,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceEndpointType(rawValue: rawValue) ?? ServiceEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quota requirement to identify originating quota. Reached throttling quota exception.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service quota requirement to identify originating service. Reached throttling quota exception service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ServiceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceState(rawValue: rawValue) ?? ServiceState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case description = "Description"
        case endpointType = "EndpointType"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lambdaEndpoint = "LambdaEndpoint"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdByAccountId = self.createdByAccountId {
            try encodeContainer.encode(createdByAccountId, forKey: .createdByAccountId)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lambdaEndpoint = self.lambdaEndpoint {
            try encodeContainer.encode(lambdaEndpoint, forKey: .lambdaEndpoint)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let urlEndpoint = self.urlEndpoint {
            try encodeContainer.encode(urlEndpoint, forKey: .urlEndpoint)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(applicationId: \(Swift.String(describing: applicationId)), arn: \(Swift.String(describing: arn)), createdByAccountId: \(Swift.String(describing: createdByAccountId)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), endpointType: \(Swift.String(describing: endpointType)), environmentId: \(Swift.String(describing: environmentId)), error: \(Swift.String(describing: error)), lambdaEndpoint: \(Swift.String(describing: lambdaEndpoint)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), serviceId: \(Swift.String(describing: serviceId)), state: \(Swift.String(describing: state)), urlEndpoint: \(Swift.String(describing: urlEndpoint)), vpcId: \(Swift.String(describing: vpcId)), tags: \"CONTENT_REDACTED\")"}
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A summary for the service as a response to ListServices.
    public struct ServiceSummary: Swift.Equatable {
        /// The unique identifier of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The Amazon Web Services account ID of the service creator.
        public var createdByAccountId: Swift.String?
        /// A timestamp that indicates when the service is created.
        public var createdTime: ClientRuntime.Date?
        /// A description of the service.
        public var description: Swift.String?
        /// The endpoint type of the service.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the service resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// A summary of the configuration for the Lambda endpoint type.
        public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary?
        /// A timestamp that indicates when the service was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the service owner.
        public var ownerAccountId: Swift.String?
        /// The unique identifier of the service.
        public var serviceId: Swift.String?
        /// The current state of the service.
        public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?
        /// The tags assigned to the service.
        public var tags: [Swift.String:Swift.String]?
        /// The summary of the configuration for the URL endpoint type.
        public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary?
        /// The ID of the virtual private cloud (VPC).
        public var vpcId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdByAccountId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.createdByAccountId = createdByAccountId
            self.createdTime = createdTime
            self.description = description
            self.endpointType = endpointType
            self.environmentId = environmentId
            self.error = error
            self.lambdaEndpoint = lambdaEndpoint
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.serviceId = serviceId
            self.state = state
            self.tags = tags
            self.urlEndpoint = urlEndpoint
            self.vpcId = vpcId
        }
    }

}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied because the request was throttled.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quota requirement to identify originating quota. Reached throttling quota exception.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// Service quota requirement to identify originating service. Reached throttling quota exception service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationState = "ActivationState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationState = self.activationState {
            try encodeContainer.encode(activationState.rawValue, forKey: .activationState)
        }
    }
}

extension UpdateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let routeIdentifier = routeIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes/\(routeIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateRouteInput: Swift.Equatable {
    /// If set to ACTIVE, traffic is forwarded to this routes service after the route is updated.
    /// This member is required.
    public var activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState?
    /// The ID of the application within which the route is being updated.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment in which the route is being updated.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The unique identifier of the route to update.
    /// This member is required.
    public var routeIdentifier: Swift.String?

    public init(
        activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState? = nil,
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeIdentifier: Swift.String? = nil
    )
    {
        self.activationState = activationState
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.routeIdentifier = routeIdentifier
    }
}

struct UpdateRouteInputBody: Swift.Equatable {
    let activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState?
}

extension UpdateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationState = "ActivationState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationStateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteActivationState.self, forKey: .activationState)
        activationState = activationStateDecoded
    }
}

extension UpdateRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.lastUpdatedTime = output.lastUpdatedTime
            self.routeId = output.routeId
            self.serviceId = output.serviceId
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.lastUpdatedTime = nil
            self.routeId = nil
            self.serviceId = nil
            self.state = nil
        }
    }
}

public struct UpdateRouteOutput: Swift.Equatable {
    /// The ID of the application in which the route is being updated.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route. The format for this ARN is arn:aws:refactor-spaces:region:account-id:resource-type/resource-id . For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The unique identifier of the route.
    public var routeId: Swift.String?
    /// The ID of service in which the route was created. Traffic that matches this route is forwarded to this service.
    public var serviceId: Swift.String?
    /// The current state of the route.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        routeId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.lastUpdatedTime = lastUpdatedTime
        self.routeId = routeId
        self.serviceId = serviceId
        self.state = state
    }
}

struct UpdateRouteOutputBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension UpdateRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case lastUpdatedTime = "LastUpdatedTime"
        case routeId = "RouteId"
        case serviceId = "ServiceId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum UpdateRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.UriPathRouteInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationState = "ActivationState"
        case appendSourcePath = "AppendSourcePath"
        case includeChildPaths = "IncludeChildPaths"
        case methods = "Methods"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationState = self.activationState {
            try encodeContainer.encode(activationState.rawValue, forKey: .activationState)
        }
        if let appendSourcePath = self.appendSourcePath {
            try encodeContainer.encode(appendSourcePath, forKey: .appendSourcePath)
        }
        if let includeChildPaths = self.includeChildPaths {
            try encodeContainer.encode(includeChildPaths, forKey: .includeChildPaths)
        }
        if let methods = methods {
            var methodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .methods)
            for httpmethod0 in methods {
                try methodsContainer.encode(httpmethod0.rawValue)
            }
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let activationStateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteActivationState.self, forKey: .activationState)
        activationState = activationStateDecoded
        let methodsContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.HttpMethod?].self, forKey: .methods)
        var methodsDecoded0:[MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil
        if let methodsContainer = methodsContainer {
            methodsDecoded0 = [MigrationHubRefactorSpacesClientTypes.HttpMethod]()
            for string0 in methodsContainer {
                if let string0 = string0 {
                    methodsDecoded0?.append(string0)
                }
            }
        }
        methods = methodsDecoded0
        let includeChildPathsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeChildPaths)
        includeChildPaths = includeChildPathsDecoded
        let appendSourcePathDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .appendSourcePath)
        appendSourcePath = appendSourcePathDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the URI path route type.
    public struct UriPathRouteInput: Swift.Equatable {
        /// If set to ACTIVE, traffic is forwarded to this routes service after the route is created.
        /// This member is required.
        public var activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState?
        /// If set to true, this option appends the source path to the service URL endpoint.
        public var appendSourcePath: Swift.Bool?
        /// Indicates whether to match all subpaths of the given source path. If this value is false, requests must match the source path exactly before they are forwarded to this route's service.
        public var includeChildPaths: Swift.Bool?
        /// A list of HTTP methods to match. An empty list matches all values. If a method is present, only HTTP requests using that method are forwarded to this routes service.
        public var methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
        /// This is the path that Refactor Spaces uses to match traffic. Paths must start with / and are relative to the base of the application. To use path parameters in the source path, add a variable in curly braces. For example, the resource path {user} represents a path parameter called 'user'.
        /// This member is required.
        public var sourcePath: Swift.String?

        public init(
            activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState? = nil,
            appendSourcePath: Swift.Bool? = nil,
            includeChildPaths: Swift.Bool? = nil,
            methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.activationState = activationState
            self.appendSourcePath = appendSourcePath
            self.includeChildPaths = includeChildPaths
            self.methods = methods
            self.sourcePath = sourcePath
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthUrl = "HealthUrl"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthUrl = self.healthUrl {
            try encodeContainer.encode(healthUrl, forKey: .healthUrl)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let healthUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthUrl)
        healthUrl = healthUrlDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the URL endpoint type.
    public struct UrlEndpointConfig: Swift.Equatable {
        /// The health check URL of the URL endpoint type.
        public var healthUrl: Swift.String?
        /// The HTTP URL endpoint.
        public var url: Swift.String?

        public init(
            healthUrl: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.healthUrl = healthUrl
            self.url = url
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.UrlEndpointInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthUrl = "HealthUrl"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthUrl = self.healthUrl {
            try encodeContainer.encode(healthUrl, forKey: .healthUrl)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let healthUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthUrl)
        healthUrl = healthUrlDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the URL endpoint type.
    public struct UrlEndpointInput: Swift.Equatable {
        /// The health check URL of the URL endpoint type. If the URL is a public endpoint, the HealthUrl must also be a public endpoint. If the URL is a private endpoint inside a virtual private cloud (VPC), the health URL must also be a private endpoint, and the host must be the same as the URL.
        public var healthUrl: Swift.String?
        /// The URL to route traffic to. The URL must be an [rfc3986-formatted URL](https://datatracker.ietf.org/doc/html/rfc3986). If the host is a domain name, the name must be resolvable over the public internet. If the scheme is https, the top level domain of the host must be listed in the [IANA root zone database](https://www.iana.org/domains/root/db).
        /// This member is required.
        public var url: Swift.String?

        public init(
            healthUrl: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.healthUrl = healthUrl
            self.url = url
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthUrl = "HealthUrl"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthUrl = self.healthUrl {
            try encodeContainer.encode(healthUrl, forKey: .healthUrl)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let healthUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthUrl)
        healthUrl = healthUrlDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary of the configuration for the URL endpoint type.
    public struct UrlEndpointSummary: Swift.Equatable {
        /// The health check URL of the URL endpoint type. If the URL is a public endpoint, the HealthUrl must also be a public endpoint. If the URL is a private endpoint inside a virtual private cloud (VPC), the health URL must also be a private endpoint, and the host must be the same as the URL.
        public var healthUrl: Swift.String?
        /// The URL to route traffic to. The URL must be an [rfc3986-formatted URL](https://datatracker.ietf.org/doc/html/rfc3986). If the host is a domain name, the name must be resolvable over the public internet. If the scheme is https, the top level domain of the host must be listed in the [IANA root zone database](https://www.iana.org/domains/root/db).
        public var url: Swift.String?

        public init(
            healthUrl: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.healthUrl = healthUrl
            self.url = url
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
