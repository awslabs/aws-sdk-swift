//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct DeleteLanguageModelOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMedicalScribeJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMedicalTranscriptionJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMedicalVocabularyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTranscriptionJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteVocabularyFilterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteVocabularyOutput: Swift.Sendable {

    public init() { }
}

extension TranscribeClientTypes {

    /// A time range, in milliseconds, between two points in your media file. You can use StartTime and EndTime to search a custom segment. For example, setting StartTime to 10000 and EndTime to 50000 only searches for your specified criteria in the audio contained between the 10,000 millisecond mark and the 50,000 millisecond mark of your media file. You must use StartTime and EndTime as a set; that is, if you include one, you must include both. You can use also First to search from the start of the audio until the time that you specify, or Last to search from the time that you specify until the end of the audio. For example, setting First to 50000 only searches for your specified criteria in the audio contained between the start of the media file to the 50,000 millisecond mark. You can use First and Last independently of each other. If you prefer to use percentage instead of milliseconds, see .
    public struct AbsoluteTimeRange: Swift.Sendable {
        /// The time, in milliseconds, when Amazon Transcribe stops searching for the specified criteria in your audio. If you include EndTime in your request, you must also include StartTime.
        public var endTime: Swift.Int?
        /// The time, in milliseconds, from the start of your media file until the specified value. Amazon Transcribe searches for your specified criteria in this time segment.
        public var first: Swift.Int?
        /// The time, in milliseconds, from the specified value until the end of your media file. Amazon Transcribe searches for your specified criteria in this time segment.
        public var last: Swift.Int?
        /// The time, in milliseconds, when Amazon Transcribe starts searching for the specified criteria in your audio. If you include StartTime in your request, you must also include EndTime.
        public var startTime: Swift.Int?

        public init(
            endTime: Swift.Int? = nil,
            first: Swift.Int? = nil,
            last: Swift.Int? = nil,
            startTime: Swift.Int? = nil
        )
        {
            self.endTime = endTime
            self.first = first
            self.last = last
            self.startTime = startTime
        }
    }
}

/// Your request didn't pass one or more validation tests. This can occur when the entity you're trying to delete doesn't exist or if it's in a non-terminal state (such as IN PROGRESS). See the exception message field for more information.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TranscribeClientTypes {

    public enum BaseModelName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case narrowBand
        case wideBand
        case sdkUnknown(Swift.String)

        public static var allCases: [BaseModelName] {
            return [
                .narrowBand,
                .wideBand
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .narrowBand: return "NarrowBand"
            case .wideBand: return "WideBand"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum CallAnalyticsFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case generativeSummarization
        case sdkUnknown(Swift.String)

        public static var allCases: [CallAnalyticsFeature] {
            return [
                .generativeSummarization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .generativeSummarization: return "GENERATIVE_SUMMARIZATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum CallAnalyticsSkippedReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failedSafetyGuidelines
        case insufficientConversationContent
        case sdkUnknown(Swift.String)

        public static var allCases: [CallAnalyticsSkippedReasonCode] {
            return [
                .failedSafetyGuidelines,
                .insufficientConversationContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failedSafetyGuidelines: return "FAILED_SAFETY_GUIDELINES"
            case .insufficientConversationContent: return "INSUFFICIENT_CONVERSATION_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Represents a skipped analytics feature during the analysis of a call analytics job. The Feature field indicates the type of analytics feature that was skipped. The Message field contains additional information or a message explaining why the analytics feature was skipped. The ReasonCode field provides a code indicating the reason why the analytics feature was skipped.
    public struct CallAnalyticsSkippedFeature: Swift.Sendable {
        /// Indicates the type of analytics feature that was skipped during the analysis of a call analytics job.
        public var feature: TranscribeClientTypes.CallAnalyticsFeature?
        /// Contains additional information or a message explaining why a specific analytics feature was skipped during the analysis of a call analytics job.
        public var message: Swift.String?
        /// Provides a code indicating the reason why a specific analytics feature was skipped during the analysis of a call analytics job.
        public var reasonCode: TranscribeClientTypes.CallAnalyticsSkippedReasonCode?

        public init(
            feature: TranscribeClientTypes.CallAnalyticsFeature? = nil,
            message: Swift.String? = nil,
            reasonCode: TranscribeClientTypes.CallAnalyticsSkippedReasonCode? = nil
        )
        {
            self.feature = feature
            self.message = message
            self.reasonCode = reasonCode
        }
    }
}

extension TranscribeClientTypes {

    /// Contains details about a call analytics job, including information about skipped analytics features.
    public struct CallAnalyticsJobDetails: Swift.Sendable {
        /// Contains information about any skipped analytics features during the analysis of a call analytics job. This array lists all the analytics features that were skipped, along with their corresponding reason code and message.
        public var skipped: [TranscribeClientTypes.CallAnalyticsSkippedFeature]?

        public init(
            skipped: [TranscribeClientTypes.CallAnalyticsSkippedFeature]? = nil
        )
        {
            self.skipped = skipped
        }
    }
}

extension TranscribeClientTypes {

    public enum CallAnalyticsJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case queued
        case sdkUnknown(Swift.String)

        public static var allCases: [CallAnalyticsJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .queued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum ParticipantRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Makes it possible to specify which speaker is on which channel. For example, if your agent is the first participant to speak, you would set ChannelId to 0 (to indicate the first channel) and ParticipantRole to AGENT (to indicate that it's the agent speaking).
    public struct ChannelDefinition: Swift.Sendable {
        /// Specify the audio channel you want to define.
        public var channelId: Swift.Int
        /// Specify the speaker you want to define. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?

        public init(
            channelId: Swift.Int = 0,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil
        )
        {
            self.channelId = channelId
            self.participantRole = participantRole
        }
    }
}

extension TranscribeClientTypes {

    public enum LanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abGe
        case afZa
        case arAe
        case arSa
        case astEs
        case azAz
        case baRu
        case beBy
        case bgBg
        case bnIn
        case bsBa
        case caEs
        case ckbIq
        case ckbIr
        case csCz
        case cyWl
        case daDk
        case deCh
        case deDe
        case elGr
        case enAb
        case enAu
        case enGb
        case enIe
        case enIn
        case enNz
        case enUs
        case enWl
        case enZa
        case esEs
        case esUs
        case etEt
        case euEs
        case faIr
        case fiFi
        case frCa
        case frFr
        case glEs
        case guIn
        case haNg
        case heIl
        case hiIn
        case hrHr
        case huHu
        case hyAm
        case idId
        case isIs
        case itIt
        case jaJp
        case kabDz
        case kaGe
        case kkKz
        case knIn
        case koKr
        case kyKg
        case lgIn
        case ltLt
        case lvLv
        case mhrRu
        case miNz
        case mkMk
        case mlIn
        case mnMn
        case mrIn
        case msMy
        case mtMt
        case nlNl
        case noNo
        case orIn
        case paIn
        case plPl
        case psAf
        case ptBr
        case ptPt
        case roRo
        case ruRu
        case rwRw
        case siLk
        case skSk
        case slSi
        case soSo
        case srRs
        case suId
        case svSe
        case swBi
        case swKe
        case swRw
        case swTz
        case swUg
        case taIn
        case teIn
        case thTh
        case tlPh
        case trTr
        case ttRu
        case ugCn
        case ukUa
        case uzUz
        case viVn
        case woSn
        case zhCn
        case zhTw
        case zuZa
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .abGe,
                .afZa,
                .arAe,
                .arSa,
                .astEs,
                .azAz,
                .baRu,
                .beBy,
                .bgBg,
                .bnIn,
                .bsBa,
                .caEs,
                .ckbIq,
                .ckbIr,
                .csCz,
                .cyWl,
                .daDk,
                .deCh,
                .deDe,
                .elGr,
                .enAb,
                .enAu,
                .enGb,
                .enIe,
                .enIn,
                .enNz,
                .enUs,
                .enWl,
                .enZa,
                .esEs,
                .esUs,
                .etEt,
                .euEs,
                .faIr,
                .fiFi,
                .frCa,
                .frFr,
                .glEs,
                .guIn,
                .haNg,
                .heIl,
                .hiIn,
                .hrHr,
                .huHu,
                .hyAm,
                .idId,
                .isIs,
                .itIt,
                .jaJp,
                .kabDz,
                .kaGe,
                .kkKz,
                .knIn,
                .koKr,
                .kyKg,
                .lgIn,
                .ltLt,
                .lvLv,
                .mhrRu,
                .miNz,
                .mkMk,
                .mlIn,
                .mnMn,
                .mrIn,
                .msMy,
                .mtMt,
                .nlNl,
                .noNo,
                .orIn,
                .paIn,
                .plPl,
                .psAf,
                .ptBr,
                .ptPt,
                .roRo,
                .ruRu,
                .rwRw,
                .siLk,
                .skSk,
                .slSi,
                .soSo,
                .srRs,
                .suId,
                .svSe,
                .swBi,
                .swKe,
                .swRw,
                .swTz,
                .swUg,
                .taIn,
                .teIn,
                .thTh,
                .tlPh,
                .trTr,
                .ttRu,
                .ugCn,
                .ukUa,
                .uzUz,
                .viVn,
                .woSn,
                .zhCn,
                .zhTw,
                .zuZa
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abGe: return "ab-GE"
            case .afZa: return "af-ZA"
            case .arAe: return "ar-AE"
            case .arSa: return "ar-SA"
            case .astEs: return "ast-ES"
            case .azAz: return "az-AZ"
            case .baRu: return "ba-RU"
            case .beBy: return "be-BY"
            case .bgBg: return "bg-BG"
            case .bnIn: return "bn-IN"
            case .bsBa: return "bs-BA"
            case .caEs: return "ca-ES"
            case .ckbIq: return "ckb-IQ"
            case .ckbIr: return "ckb-IR"
            case .csCz: return "cs-CZ"
            case .cyWl: return "cy-WL"
            case .daDk: return "da-DK"
            case .deCh: return "de-CH"
            case .deDe: return "de-DE"
            case .elGr: return "el-GR"
            case .enAb: return "en-AB"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enIe: return "en-IE"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enWl: return "en-WL"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esUs: return "es-US"
            case .etEt: return "et-ET"
            case .euEs: return "eu-ES"
            case .faIr: return "fa-IR"
            case .fiFi: return "fi-FI"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .glEs: return "gl-ES"
            case .guIn: return "gu-IN"
            case .haNg: return "ha-NG"
            case .heIl: return "he-IL"
            case .hiIn: return "hi-IN"
            case .hrHr: return "hr-HR"
            case .huHu: return "hu-HU"
            case .hyAm: return "hy-AM"
            case .idId: return "id-ID"
            case .isIs: return "is-IS"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .kabDz: return "kab-DZ"
            case .kaGe: return "ka-GE"
            case .kkKz: return "kk-KZ"
            case .knIn: return "kn-IN"
            case .koKr: return "ko-KR"
            case .kyKg: return "ky-KG"
            case .lgIn: return "lg-IN"
            case .ltLt: return "lt-LT"
            case .lvLv: return "lv-LV"
            case .mhrRu: return "mhr-RU"
            case .miNz: return "mi-NZ"
            case .mkMk: return "mk-MK"
            case .mlIn: return "ml-IN"
            case .mnMn: return "mn-MN"
            case .mrIn: return "mr-IN"
            case .msMy: return "ms-MY"
            case .mtMt: return "mt-MT"
            case .nlNl: return "nl-NL"
            case .noNo: return "no-NO"
            case .orIn: return "or-IN"
            case .paIn: return "pa-IN"
            case .plPl: return "pl-PL"
            case .psAf: return "ps-AF"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .roRo: return "ro-RO"
            case .ruRu: return "ru-RU"
            case .rwRw: return "rw-RW"
            case .siLk: return "si-LK"
            case .skSk: return "sk-SK"
            case .slSi: return "sl-SI"
            case .soSo: return "so-SO"
            case .srRs: return "sr-RS"
            case .suId: return "su-ID"
            case .svSe: return "sv-SE"
            case .swBi: return "sw-BI"
            case .swKe: return "sw-KE"
            case .swRw: return "sw-RW"
            case .swTz: return "sw-TZ"
            case .swUg: return "sw-UG"
            case .taIn: return "ta-IN"
            case .teIn: return "te-IN"
            case .thTh: return "th-TH"
            case .tlPh: return "tl-PH"
            case .trTr: return "tr-TR"
            case .ttRu: return "tt-RU"
            case .ugCn: return "ug-CN"
            case .ukUa: return "uk-UA"
            case .uzUz: return "uz-UZ"
            case .viVn: return "vi-VN"
            case .woSn: return "wo-SN"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case .zuZa: return "zu-ZA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the MediaFormat parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
    public struct Media: Swift.Sendable {
        /// The Amazon S3 location of the media file you want to transcribe. For example:
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/my-media-file.flac
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/media-files/my-media-file.flac
        ///
        ///
        /// Note that the Amazon S3 bucket that contains your input media must be located in the same Amazon Web Services Region where you're making your transcription request.
        public var mediaFileUri: Swift.String?
        /// The Amazon S3 location of the media file you want to redact. For example:
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/my-media-file.flac
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/media-files/my-media-file.flac
        ///
        ///
        /// Note that the Amazon S3 bucket that contains your input media must be located in the same Amazon Web Services Region where you're making your transcription request. RedactedMediaFileUri produces a redacted audio file in addition to a redacted transcript. It is only supported for Call Analytics (StartCallAnalyticsJob) transcription requests.
        public var redactedMediaFileUri: Swift.String?

        public init(
            mediaFileUri: Swift.String? = nil,
            redactedMediaFileUri: Swift.String? = nil
        )
        {
            self.mediaFileUri = mediaFileUri
            self.redactedMediaFileUri = redactedMediaFileUri
        }
    }
}

extension TranscribeClientTypes {

    public enum MediaFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amr
        case flac
        case m4a
        case mp3
        case mp4
        case ogg
        case wav
        case webm
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaFormat] {
            return [
                .amr,
                .flac,
                .m4a,
                .mp3,
                .mp4,
                .ogg,
                .wav,
                .webm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amr: return "amr"
            case .flac: return "flac"
            case .m4a: return "m4a"
            case .mp3: return "mp3"
            case .mp4: return "mp4"
            case .ogg: return "ogg"
            case .wav: return "wav"
            case .webm: return "webm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum PiiEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case all
        case bankAccountNumber
        case bankRouting
        case creditDebitCvv
        case creditDebitExpiry
        case creditDebitNumber
        case email
        case name
        case phone
        case pin
        case ssn
        case sdkUnknown(Swift.String)

        public static var allCases: [PiiEntityType] {
            return [
                .address,
                .all,
                .bankAccountNumber,
                .bankRouting,
                .creditDebitCvv,
                .creditDebitExpiry,
                .creditDebitNumber,
                .email,
                .name,
                .phone,
                .pin,
                .ssn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .all: return "ALL"
            case .bankAccountNumber: return "BANK_ACCOUNT_NUMBER"
            case .bankRouting: return "BANK_ROUTING"
            case .creditDebitCvv: return "CREDIT_DEBIT_CVV"
            case .creditDebitExpiry: return "CREDIT_DEBIT_EXPIRY"
            case .creditDebitNumber: return "CREDIT_DEBIT_NUMBER"
            case .email: return "EMAIL"
            case .name: return "NAME"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .ssn: return "SSN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum RedactionOutput: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case redacted
        case redactedAndUnredacted
        case sdkUnknown(Swift.String)

        public static var allCases: [RedactionOutput] {
            return [
                .redacted,
                .redactedAndUnredacted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .redacted: return "redacted"
            case .redactedAndUnredacted: return "redacted_and_unredacted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum RedactionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [RedactionType] {
            return [
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Makes it possible to redact or flag specified personally identifiable information (PII) in your transcript. If you use ContentRedaction, you must also include the sub-parameters: RedactionOutput and RedactionType. You can optionally include PiiEntityTypes to choose which types of PII you want to redact.
    public struct ContentRedaction: Swift.Sendable {
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL. If you do not include PiiEntityTypes in your request, all PII is redacted.
        public var piiEntityTypes: [TranscribeClientTypes.PiiEntityType]?
        /// Specify if you want only a redacted transcript, or if you want a redacted and an unredacted transcript. When you choose redacted Amazon Transcribe creates only a redacted transcript. When you choose redacted_and_unredacted Amazon Transcribe creates a redacted and an unredacted transcript (as two separate files).
        /// This member is required.
        public var redactionOutput: TranscribeClientTypes.RedactionOutput?
        /// Specify the category of information you want to redact; PII (personally identifiable information) is the only valid value. You can use PiiEntityTypes to choose which types of PII you want to redact. If you do not include PiiEntityTypes in your request, all PII is redacted.
        /// This member is required.
        public var redactionType: TranscribeClientTypes.RedactionType?

        public init(
            piiEntityTypes: [TranscribeClientTypes.PiiEntityType]? = nil,
            redactionOutput: TranscribeClientTypes.RedactionOutput? = nil,
            redactionType: TranscribeClientTypes.RedactionType? = nil
        )
        {
            self.piiEntityTypes = piiEntityTypes
            self.redactionOutput = redactionOutput
            self.redactionType = redactionType
        }
    }
}

extension TranscribeClientTypes {

    /// If using automatic language identification in your request and you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). Note that multi-language identification (IdentifyMultipleLanguages) doesn't support custom language models. LanguageIdSettings supports two to five language codes. Each language code you include can have an associated custom language model, custom vocabulary, and custom vocabulary filter. The language codes that you specify must match the languages of the associated custom language models, custom vocabularies, and custom vocabulary filters. It's recommended that you include LanguageOptions when using LanguageIdSettings to ensure that the correct language dialect is identified. For example, if you specify a custom vocabulary that is in en-US but Amazon Transcribe determines that the language spoken in your media is en-AU, your custom vocabulary is not applied to your transcription. If you include LanguageOptions and include en-US as the only English language dialect, your custom vocabulary is applied to your transcription. If you want to include a custom language model with your request but do not want to use automatic language identification, use instead the  parameter with the LanguageModelName sub-parameter. If you want to include a custom vocabulary or a custom vocabulary filter (or both) with your request but do not want to use automatic language identification, use instead the  parameter with the VocabularyName or VocabularyFilterName (or both) sub-parameter.
    public struct LanguageIdSettings: Swift.Sendable {
        /// The name of the custom language model you want to use when processing your transcription job. Note that custom language model names are case sensitive. The language of the specified custom language model must match the language code that you specify in your transcription request. If the languages do not match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.
        public var languageModelName: Swift.String?
        /// The name of the custom vocabulary filter you want to use when processing your transcription job. Custom vocabulary filter names are case sensitive. The language of the specified custom vocabulary filter must match the language code that you specify in your transcription request. If the languages do not match, the custom vocabulary filter isn't applied. There are no errors or warnings associated with a language mismatch. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to use when processing your transcription job. Custom vocabulary names are case sensitive. The language of the specified custom vocabulary must match the language code that you specify in your transcription request. If the languages do not match, the custom vocabulary isn't applied. There are no errors or warnings associated with a language mismatch.
        public var vocabularyName: Swift.String?

        public init(
            languageModelName: Swift.String? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.languageModelName = languageModelName
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }
}

extension TranscribeClientTypes {

    /// Contains GenerateAbstractiveSummary, which is a required parameter if you want to enable Generative call summarization in your Call Analytics request.
    public struct Summarization: Swift.Sendable {
        /// Enables Generative call summarization in your Call Analytics request Generative call summarization provides a summary of the transcript including important components discussed in the conversation. For more information, see [Enabling generative call summarization](https://docs.aws.amazon.com/transcribe/latest/dg/tca-enable-summarization.html).
        /// This member is required.
        public var generateAbstractiveSummary: Swift.Bool?

        public init(
            generateAbstractiveSummary: Swift.Bool? = nil
        )
        {
            self.generateAbstractiveSummary = generateAbstractiveSummary
        }
    }
}

extension TranscribeClientTypes {

    public enum VocabularyFilterMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Provides additional optional settings for your request, including content redaction, automatic language identification; allows you to apply custom language models, custom vocabulary filters, and custom vocabularies.
    public struct CallAnalyticsJobSettings: Swift.Sendable {
        /// Makes it possible to redact or flag specified personally identifiable information (PII) in your transcript. If you use ContentRedaction, you must also include the sub-parameters: RedactionOutput and RedactionType. You can optionally include PiiEntityTypes to choose which types of PII you want to redact.
        public var contentRedaction: TranscribeClientTypes.ContentRedaction?
        /// If using automatic language identification in your request and you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). LanguageIdSettings supports two to five language codes. Each language code you include can have an associated custom language model, custom vocabulary, and custom vocabulary filter. The language codes that you specify must match the languages of the associated custom language models, custom vocabularies, and custom vocabulary filters. It's recommended that you include LanguageOptions when using LanguageIdSettings to ensure that the correct language dialect is identified. For example, if you specify a custom vocabulary that is in en-US but Amazon Transcribe determines that the language spoken in your media is en-AU, your custom vocabulary is not applied to your transcription. If you include LanguageOptions and include en-US as the only English language dialect, your custom vocabulary is applied to your transcription. If you want to include a custom language model, custom vocabulary, or custom vocabulary filter with your request but do not want to use automatic language identification, use instead the  parameter with the LanguageModelName, VocabularyName, or VocabularyFilterName sub-parameters. For a list of languages supported with Call Analytics, refer to [Supported languages and language-specific features](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html).
        public var languageIdSettings: [Swift.String: TranscribeClientTypes.LanguageIdSettings]?
        /// The name of the custom language model you want to use when processing your Call Analytics job. Note that custom language model names are case sensitive. The language of the specified custom language model must match the language code that you specify in your transcription request. If the languages do not match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.
        public var languageModelName: Swift.String?
        /// You can specify two or more language codes that represent the languages you think may be present in your media. Including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. Including language options can improve the accuracy of language identification. For a list of languages supported with Call Analytics, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. To transcribe speech in Modern Standard Arabic (ar-SA), your media file must be encoded at a sample rate of 16,000 Hz or higher.
        public var languageOptions: [TranscribeClientTypes.LanguageCode]?
        /// Contains GenerateAbstractiveSummary, which is a required parameter if you want to enable Generative call summarization in your Call Analytics request.
        public var summarization: TranscribeClientTypes.Summarization?
        /// Specify how you want your custom vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter you want to include in your Call Analytics transcription request. Custom vocabulary filter names are case sensitive. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to include in your Call Analytics transcription request. Custom vocabulary names are case sensitive.
        public var vocabularyName: Swift.String?

        public init(
            contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
            languageIdSettings: [Swift.String: TranscribeClientTypes.LanguageIdSettings]? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: [TranscribeClientTypes.LanguageCode]? = nil,
            summarization: TranscribeClientTypes.Summarization? = nil,
            vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentRedaction = contentRedaction
            self.languageIdSettings = languageIdSettings
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.summarization = summarization
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }
}

extension TranscribeClientTypes {

    /// Provides you with the Amazon S3 URI you can use to access your transcript.
    public struct Transcript: Swift.Sendable {
        /// The Amazon S3 location of your redacted transcript. You can use this URI to access or download your transcript. If you included OutputBucketName in your transcription job request, this is the URI of that bucket. If you also included OutputKey in your request, your output is located in the path you specified in your request. If you didn't include OutputBucketName in your transcription job request, your transcript is stored in a service-managed bucket, and RedactedTranscriptFileUri provides you with a temporary URI you can use for secure access to your transcript. Temporary URIs for service-managed Amazon S3 buckets are only valid for 15 minutes. If you get an AccesDenied error, you can get a new temporary URI by running a GetTranscriptionJob or ListTranscriptionJob request.
        public var redactedTranscriptFileUri: Swift.String?
        /// The Amazon S3 location of your transcript. You can use this URI to access or download your transcript. If you included OutputBucketName in your transcription job request, this is the URI of that bucket. If you also included OutputKey in your request, your output is located in the path you specified in your request. If you didn't include OutputBucketName in your transcription job request, your transcript is stored in a service-managed bucket, and TranscriptFileUri provides you with a temporary URI you can use for secure access to your transcript. Temporary URIs for service-managed Amazon S3 buckets are only valid for 15 minutes. If you get an AccesDenied error, you can get a new temporary URI by running a GetTranscriptionJob or ListTranscriptionJob request.
        public var transcriptFileUri: Swift.String?

        public init(
            redactedTranscriptFileUri: Swift.String? = nil,
            transcriptFileUri: Swift.String? = nil
        )
        {
            self.redactedTranscriptFileUri = redactedTranscriptFileUri
            self.transcriptFileUri = transcriptFileUri
        }
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a Call Analytics job. To view the job's status, refer to CallAnalyticsJobStatus. If the status is COMPLETED, the job is finished. You can find your completed transcript at the URI specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed. If you enabled personally identifiable information (PII) redaction, the redacted transcript appears at the location specified in RedactedTranscriptFileUri. If you chose to redact the audio in your media file, you can find your redacted media file at the location specified in the RedactedMediaFileUri field of your response.
    public struct CallAnalyticsJob: Swift.Sendable {
        /// Provides detailed information about a call analytics job, including information about skipped analytics features.
        public var callAnalyticsJobDetails: TranscribeClientTypes.CallAnalyticsJobDetails?
        /// The name of the Call Analytics job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var callAnalyticsJobName: Swift.String?
        /// Provides the status of the specified Call Analytics job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus?
        /// Indicates which speaker is on which channel.
        public var channelDefinitions: [TranscribeClientTypes.ChannelDefinition]?
        /// The date and time the specified Call Analytics job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// The date and time the specified Call Analytics job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) you included in your request.
        public var dataAccessRoleArn: Swift.String?
        /// If CallAnalyticsJobStatus is FAILED, FailureReason contains information about why the Call Analytics job request failed. The FailureReason field contains one of the following values:
        ///
        /// * Unsupported media format. The media format specified in MediaFormat isn't valid. Refer to refer to the MediaFormat parameter for a list of supported formats.
        ///
        /// * The media format provided does not match the detected media format. The media format specified in MediaFormat doesn't match the format of the input file. Check the media format of your media file and correct the specified value.
        ///
        /// * Invalid sample rate for audio file. The sample rate specified in MediaSampleRateHertz isn't valid. The sample rate must be between 8,000 and 48,000 hertz.
        ///
        /// * The sample rate provided does not match the detected sample rate. The sample rate specified in MediaSampleRateHertz doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.
        ///
        /// * Invalid file size: file size too large. The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to [Service quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe).
        ///
        /// * Invalid number of channels: number of channels too large. Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to [Service quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe).
        public var failureReason: Swift.String?
        /// The confidence score associated with the language identified in your media file. Confidence scores are values between 0 and 1; a larger value indicates a higher probability that the identified language correctly matches the language spoken in your media.
        public var identifiedLanguageScore: Swift.Float?
        /// The language code used to create your Call Analytics job. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. If you do not know the language spoken in your media file, you can omit this field and let Amazon Transcribe automatically identify the language of your media. To improve the accuracy of language identification, you can include several language codes and Amazon Transcribe chooses the closest match for your transcription.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// Provides the Amazon S3 location of the media file you used in your Call Analytics request.
        public var media: TranscribeClientTypes.Media?
        /// The format of the input media file.
        public var mediaFormat: TranscribeClientTypes.MediaFormat?
        /// The sample rate, in hertz, of the audio track in your input media file.
        public var mediaSampleRateHertz: Swift.Int?
        /// Provides information on any additional settings that were included in your request. Additional settings include content redaction and language identification settings.
        public var settings: TranscribeClientTypes.CallAnalyticsJobSettings?
        /// The date and time the specified Call Analytics job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?
        /// Provides you with the Amazon S3 URI you can use to access your transcript.
        public var transcript: TranscribeClientTypes.Transcript?

        public init(
            callAnalyticsJobDetails: TranscribeClientTypes.CallAnalyticsJobDetails? = nil,
            callAnalyticsJobName: Swift.String? = nil,
            callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus? = nil,
            channelDefinitions: [TranscribeClientTypes.ChannelDefinition]? = nil,
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            identifiedLanguageScore: Swift.Float? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            media: TranscribeClientTypes.Media? = nil,
            mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
            mediaSampleRateHertz: Swift.Int? = nil,
            settings: TranscribeClientTypes.CallAnalyticsJobSettings? = nil,
            startTime: Foundation.Date? = nil,
            transcript: TranscribeClientTypes.Transcript? = nil
        )
        {
            self.callAnalyticsJobDetails = callAnalyticsJobDetails
            self.callAnalyticsJobName = callAnalyticsJobName
            self.callAnalyticsJobStatus = callAnalyticsJobStatus
            self.channelDefinitions = channelDefinitions
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.dataAccessRoleArn = dataAccessRoleArn
            self.failureReason = failureReason
            self.identifiedLanguageScore = identifiedLanguageScore
            self.languageCode = languageCode
            self.media = media
            self.mediaFormat = mediaFormat
            self.mediaSampleRateHertz = mediaSampleRateHertz
            self.settings = settings
            self.startTime = startTime
            self.transcript = transcript
        }
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a specific Call Analytics job.
    public struct CallAnalyticsJobSummary: Swift.Sendable {
        /// Provides detailed information about a call analytics job, including information about skipped analytics features.
        public var callAnalyticsJobDetails: TranscribeClientTypes.CallAnalyticsJobDetails?
        /// The name of the Call Analytics job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var callAnalyticsJobName: Swift.String?
        /// Provides the status of your Call Analytics job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus?
        /// The date and time the specified Call Analytics job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// The date and time the specified Call Analytics job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// If CallAnalyticsJobStatus is FAILED, FailureReason contains information about why the Call Analytics job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The language code used to create your Call Analytics transcription.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The date and time your Call Analytics job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?

        public init(
            callAnalyticsJobDetails: TranscribeClientTypes.CallAnalyticsJobDetails? = nil,
            callAnalyticsJobName: Swift.String? = nil,
            callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus? = nil,
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.callAnalyticsJobDetails = callAnalyticsJobDetails
            self.callAnalyticsJobName = callAnalyticsJobName
            self.callAnalyticsJobStatus = callAnalyticsJobStatus
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.startTime = startTime
        }
    }
}

extension TranscribeClientTypes {

    public enum InputType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case postCall
        case realTime
        case sdkUnknown(Swift.String)

        public static var allCases: [InputType] {
            return [
                .postCall,
                .realTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .postCall: return "POST_CALL"
            case .realTime: return "REAL_TIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// A time range, in percentage, between two points in your media file. You can use StartPercentage and EndPercentage to search a custom segment. For example, setting StartPercentage to 10 and EndPercentage to 50 only searches for your specified criteria in the audio contained between the 10 percent mark and the 50 percent mark of your media file. You can use also First to search from the start of the media file until the time that you specify. Or use Last to search from the time that you specify until the end of the media file. For example, setting First to 10 only searches for your specified criteria in the audio contained in the first 10 percent of the media file. If you prefer to use milliseconds instead of percentage, see .
    public struct RelativeTimeRange: Swift.Sendable {
        /// The time, in percentage, when Amazon Transcribe stops searching for the specified criteria in your media file. If you include EndPercentage in your request, you must also include StartPercentage.
        public var endPercentage: Swift.Int?
        /// The time, in percentage, from the start of your media file until the specified value. Amazon Transcribe searches for your specified criteria in this time segment.
        public var first: Swift.Int?
        /// The time, in percentage, from the specified value until the end of your media file. Amazon Transcribe searches for your specified criteria in this time segment.
        public var last: Swift.Int?
        /// The time, in percentage, when Amazon Transcribe starts searching for the specified criteria in your media file. If you include StartPercentage in your request, you must also include EndPercentage.
        public var startPercentage: Swift.Int?

        public init(
            endPercentage: Swift.Int? = nil,
            first: Swift.Int? = nil,
            last: Swift.Int? = nil,
            startPercentage: Swift.Int? = nil
        )
        {
            self.endPercentage = endPercentage
            self.first = first
            self.last = last
            self.startPercentage = startPercentage
        }
    }
}

extension TranscribeClientTypes {

    /// Flag the presence or absence of interruptions in your Call Analytics transcription output. Rules using InterruptionFilter are designed to match:
    ///
    /// * Instances where an agent interrupts a customer
    ///
    /// * Instances where a customer interrupts an agent
    ///
    /// * Either participant interrupting the other
    ///
    /// * A lack of interruptions
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) for usage examples.
    public struct InterruptionFilter: Swift.Sendable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for an interruption. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag speech that does not contain interruptions. Set to FALSE to flag speech that contains interruptions.
        public var negate: Swift.Bool?
        /// Specify the interrupter that you want to flag. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for an interruption. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the duration of the interruptions in milliseconds. For example, you can flag speech that contains more than 10,000 milliseconds of interruptions.
        public var threshold: Swift.Int?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.participantRole = participantRole
            self.relativeTimeRange = relativeTimeRange
            self.threshold = threshold
        }
    }
}

extension TranscribeClientTypes {

    /// Flag the presence or absence of periods of silence in your Call Analytics transcription output. Rules using NonTalkTimeFilter are designed to match:
    ///
    /// * The presence of silence at specified periods throughout the call
    ///
    /// * The presence of speech at specified periods throughout the call
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) for usage examples.
    public struct NonTalkTimeFilter: Swift.Sendable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for a period of silence. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag periods of speech. Set to FALSE to flag periods of silence
        public var negate: Swift.Bool?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for a period of silence. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the duration, in milliseconds, of the period of silence that you want to flag. For example, you can flag a silent period that lasts 30,000 milliseconds.
        public var threshold: Swift.Int?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.relativeTimeRange = relativeTimeRange
            self.threshold = threshold
        }
    }
}

extension TranscribeClientTypes {

    public enum SentimentValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mixed
        case negative
        case neutral
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [SentimentValue] {
            return [
                .mixed,
                .negative,
                .neutral,
                .positive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mixed: return "MIXED"
            case .negative: return "NEGATIVE"
            case .neutral: return "NEUTRAL"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Flag the presence or absence of specific sentiments detected in your Call Analytics transcription output. Rules using SentimentFilter are designed to match:
    ///
    /// * The presence or absence of a positive sentiment felt by the customer, agent, or both at specified points in the call
    ///
    /// * The presence or absence of a negative sentiment felt by the customer, agent, or both at specified points in the call
    ///
    /// * The presence or absence of a neutral sentiment felt by the customer, agent, or both at specified points in the call
    ///
    /// * The presence or absence of a mixed sentiment felt by the customer, the agent, or both at specified points in the call
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) for usage examples.
    public struct SentimentFilter: Swift.Sendable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for the specified sentiments. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag the sentiments that you didn't include in your request. Set to FALSE to flag the sentiments that you specified in your request.
        public var negate: Swift.Bool?
        /// Specify the participant that you want to flag. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for the specified sentiments. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the sentiments that you want to flag.
        /// This member is required.
        public var sentiments: [TranscribeClientTypes.SentimentValue]?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            sentiments: [TranscribeClientTypes.SentimentValue]? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.participantRole = participantRole
            self.relativeTimeRange = relativeTimeRange
            self.sentiments = sentiments
        }
    }
}

extension TranscribeClientTypes {

    public enum TranscriptFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exact
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscriptFilterType] {
            return [
                .exact
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exact: return "EXACT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Flag the presence or absence of specific words or phrases detected in your Call Analytics transcription output. Rules using TranscriptFilter are designed to match:
    ///
    /// * Custom words or phrases spoken by the agent, the customer, or both
    ///
    /// * Custom words or phrases not spoken by the agent, the customer, or either
    ///
    /// * Custom words or phrases that occur at a specific time frame
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) and [Rule criteria for streaming categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-stream.html#tca-rules-stream) for usage examples.
    public struct TranscriptFilter: Swift.Sendable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for the specified key words or phrases. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag the absence of the phrase that you specified in your request. Set to FALSE to flag the presence of the phrase that you specified in your request.
        public var negate: Swift.Bool?
        /// Specify the participant that you want to flag. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for the specified key words or phrases. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the phrases that you want to flag.
        /// This member is required.
        public var targets: [Swift.String]?
        /// Flag the presence or absence of an exact match to the phrases that you specify. For example, if you specify the phrase "speak to a manager" as your Targets value, only that exact phrase is flagged. Note that semantic matching is not supported. For example, if your customer says "speak to the manager", instead of "speak to a manager", your content is not flagged.
        /// This member is required.
        public var transcriptFilterType: TranscribeClientTypes.TranscriptFilterType?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            targets: [Swift.String]? = nil,
            transcriptFilterType: TranscribeClientTypes.TranscriptFilterType? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.participantRole = participantRole
            self.relativeTimeRange = relativeTimeRange
            self.targets = targets
            self.transcriptFilterType = transcriptFilterType
        }
    }
}

extension TranscribeClientTypes {

    /// A rule is a set of criteria that you can specify to flag an attribute in your Call Analytics output. Rules define a Call Analytics category. Rules can include these parameters: , , , and . To learn more about Call Analytics rules and categories, see [Creating categories for post-call transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html) and [Creating categories for real-time transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-stream.html). To learn more about Call Analytics, see [Analyzing call center audio with Call Analytics](https://docs.aws.amazon.com/transcribe/latest/dg/call-analytics.html).
    public enum Rule: Swift.Sendable {
        /// Flag the presence or absence of periods of silence in your Call Analytics transcription output. Refer to for more detail.
        case nontalktimefilter(TranscribeClientTypes.NonTalkTimeFilter)
        /// Flag the presence or absence of interruptions in your Call Analytics transcription output. Refer to for more detail.
        case interruptionfilter(TranscribeClientTypes.InterruptionFilter)
        /// Flag the presence or absence of specific words or phrases in your Call Analytics transcription output. Refer to for more detail.
        case transcriptfilter(TranscribeClientTypes.TranscriptFilter)
        /// Flag the presence or absence of specific sentiments in your Call Analytics transcription output. Refer to for more detail.
        case sentimentfilter(TranscribeClientTypes.SentimentFilter)
        case sdkUnknown(Swift.String)
    }
}

extension TranscribeClientTypes {

    /// Provides you with the properties of the Call Analytics category you specified in your request. This includes the list of rules that define the specified category.
    public struct CategoryProperties: Swift.Sendable {
        /// The name of the Call Analytics category. Category names are case sensitive and must be unique within an Amazon Web Services account.
        public var categoryName: Swift.String?
        /// The date and time the specified Call Analytics category was created. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var createTime: Foundation.Date?
        /// The input type associated with the specified category. POST_CALL refers to a category that is applied to batch transcriptions; REAL_TIME refers to a category that is applied to streaming transcriptions.
        public var inputType: TranscribeClientTypes.InputType?
        /// The date and time the specified Call Analytics category was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-05T12:45:32.691000-07:00 represents 12:45 PM UTC-7 on May 5, 2022.
        public var lastUpdateTime: Foundation.Date?
        /// The rules used to define a Call Analytics category. Each category can have between 1 and 20 rules.
        public var rules: [TranscribeClientTypes.Rule]?

        public init(
            categoryName: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            inputType: TranscribeClientTypes.InputType? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            rules: [TranscribeClientTypes.Rule]? = nil
        )
        {
            self.categoryName = categoryName
            self.createTime = createTime
            self.inputType = inputType
            self.lastUpdateTime = lastUpdateTime
            self.rules = rules
        }
    }
}

extension TranscribeClientTypes {

    public enum CLMLanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case hiIn
        case jaJp
        case sdkUnknown(Swift.String)

        public static var allCases: [CLMLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .hiIn,
                .jaJp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .hiIn: return "hi-IN"
            case .jaJp: return "ja-JP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A resource already exists with this name. Resource names must be unique within an Amazon Web Services account.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was an internal error. Check the error message, correct the issue, and try your request again.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've either sent too many requests or your input file is too long. Wait before retrying your request, or use a smaller file and try your request again.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateCallAnalyticsCategoryInput: Swift.Sendable {
    /// A unique name, chosen by you, for your Call Analytics category. It's helpful to use a detailed naming system that will make sense to you in the future. For example, it's better to use sentiment-positive-last30seconds for a category over a generic name like test-category. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?
    /// Choose whether you want to create a real-time or a post-call category for your Call Analytics transcription. Specifying POST_CALL assigns your category to post-call transcriptions; categories with this input type cannot be applied to streaming (real-time) transcriptions. Specifying REAL_TIME assigns your category to streaming transcriptions; categories with this input type cannot be applied to post-call transcriptions. If you do not include InputType, your category is created as a post-call category by default.
    public var inputType: TranscribeClientTypes.InputType?
    /// Rules define a Call Analytics category. When creating a new category, you must create between 1 and 20 rules for that category. For each rule, you specify a filter you want applied to the attributes of a call. For example, you can choose a sentiment filter that detects if a customer's sentiment was positive during the last 30 seconds of the call.
    /// This member is required.
    public var rules: [TranscribeClientTypes.Rule]?

    public init(
        categoryName: Swift.String? = nil,
        inputType: TranscribeClientTypes.InputType? = nil,
        rules: [TranscribeClientTypes.Rule]? = nil
    )
    {
        self.categoryName = categoryName
        self.inputType = inputType
        self.rules = rules
    }
}

public struct CreateCallAnalyticsCategoryOutput: Swift.Sendable {
    /// Provides you with the properties of your new category, including its associated rules.
    public var categoryProperties: TranscribeClientTypes.CategoryProperties?

    public init(
        categoryProperties: TranscribeClientTypes.CategoryProperties? = nil
    )
    {
        self.categoryProperties = categoryProperties
    }
}

extension TranscribeClientTypes {

    /// Contains the Amazon S3 location of the training data you want to use to create a new custom language model, and permissions to access this location. When using InputDataConfig, you must include these sub-parameters: S3Uri and DataAccessRoleArn. You can optionally include TuningDataS3Uri.
    public struct InputDataConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The Amazon S3 location (URI) of the text files you want to use to train your custom language model. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-model-training-data/
        /// This member is required.
        public var s3Uri: Swift.String?
        /// The Amazon S3 location (URI) of the text files you want to use to tune your custom language model. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-model-tuning-data/
        public var tuningDataS3Uri: Swift.String?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            s3Uri: Swift.String? = nil,
            tuningDataS3Uri: Swift.String? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.s3Uri = s3Uri
            self.tuningDataS3Uri = tuningDataS3Uri
        }
    }
}

extension TranscribeClientTypes {

    /// Adds metadata, in the form of a key:value pair, to the specified resource. For example, you could add the tag Department:Sales to a resource to indicate that it pertains to your organization's sales department. You can also use tags for tag-based access control. To learn more about tagging, see [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public struct Tag: Swift.Sendable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag Department:Sales, the key is 'Department'.
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag Department:Sales, the value is 'Sales'. Note that you can set the value of a tag to an empty string, but you can't set the value of a tag to null. Omitting the tag value is the same as using an empty string.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateLanguageModelInput: Swift.Sendable {
    /// The Amazon Transcribe standard language model, or base model, used to create your custom language model. Amazon Transcribe offers two options for base models: Wideband and Narrowband. If the audio you want to transcribe has a sample rate of 16,000 Hz or greater, choose WideBand. To transcribe audio with a sample rate less than 16,000 Hz, choose NarrowBand.
    /// This member is required.
    public var baseModelName: TranscribeClientTypes.BaseModelName?
    /// Contains the Amazon S3 location of the training data you want to use to create a new custom language model, and permissions to access this location. When using InputDataConfig, you must include these sub-parameters: S3Uri, which is the Amazon S3 location of your training data, and DataAccessRoleArn, which is the Amazon Resource Name (ARN) of the role that has permission to access your specified Amazon S3 location. You can optionally include TuningDataS3Uri, which is the Amazon S3 location of your tuning data. If you specify different Amazon S3 locations for training and tuning data, the ARN you use must have permissions to access both locations.
    /// This member is required.
    public var inputDataConfig: TranscribeClientTypes.InputDataConfig?
    /// The language code that represents the language of your model. Each custom language model must contain terms in only one language, and the language you select for your custom language model must match the language of your training and tuning data. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. Note that US English (en-US) is the only language supported with Amazon Transcribe Medical. A custom language model can only be used to transcribe files in the same language as the model. For example, if you create a custom language model using US English (en-US), you can only apply this model to files that contain English audio.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.CLMLanguageCode?
    /// A unique name, chosen by you, for your custom language model. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom language model with the same name as an existing custom language model, you get a ConflictException error.
    /// This member is required.
    public var modelName: Swift.String?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom language model at the time you create this new model. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        baseModelName: TranscribeClientTypes.BaseModelName? = nil,
        inputDataConfig: TranscribeClientTypes.InputDataConfig? = nil,
        languageCode: TranscribeClientTypes.CLMLanguageCode? = nil,
        modelName: Swift.String? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.baseModelName = baseModelName
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.modelName = modelName
        self.tags = tags
    }
}

extension TranscribeClientTypes {

    public enum ModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLanguageModelOutput: Swift.Sendable {
    /// The Amazon Transcribe standard language model, or base model, you specified when creating your custom language model.
    public var baseModelName: TranscribeClientTypes.BaseModelName?
    /// Lists your data access role ARN (Amazon Resource Name) and the Amazon S3 locations you provided for your training (S3Uri) and tuning (TuningDataS3Uri) data.
    public var inputDataConfig: TranscribeClientTypes.InputDataConfig?
    /// The language code you selected for your custom language model.
    public var languageCode: TranscribeClientTypes.CLMLanguageCode?
    /// The name of your custom language model.
    public var modelName: Swift.String?
    /// The status of your custom language model. When the status displays as COMPLETED, your model is ready to use.
    public var modelStatus: TranscribeClientTypes.ModelStatus?

    public init(
        baseModelName: TranscribeClientTypes.BaseModelName? = nil,
        inputDataConfig: TranscribeClientTypes.InputDataConfig? = nil,
        languageCode: TranscribeClientTypes.CLMLanguageCode? = nil,
        modelName: Swift.String? = nil,
        modelStatus: TranscribeClientTypes.ModelStatus? = nil
    )
    {
        self.baseModelName = baseModelName
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.modelName = modelName
        self.modelStatus = modelStatus
    }
}

public struct CreateMedicalVocabularyInput: Swift.Sendable {
    /// The language code that represents the language of the entries in your custom vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom medical vocabulary at the time you create this new custom vocabulary. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// The Amazon S3 location (URI) of the text file that contains your custom medical vocabulary. The URI must be in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt
    /// This member is required.
    public var vocabularyFileUri: Swift.String?
    /// A unique name, chosen by you, for your new custom medical vocabulary. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom medical vocabulary with the same name as an existing custom medical vocabulary, you get a ConflictException error.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.tags = tags
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

extension TranscribeClientTypes {

    public enum VocabularyState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyState] {
            return [
                .failed,
                .pending,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMedicalVocabularyOutput: Swift.Sendable {
    /// If VocabularyState is FAILED, FailureReason contains information about why the medical transcription job request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom medical vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time you created your custom medical vocabulary. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name you chose for your custom medical vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom medical vocabulary. If the state is READY, you can use the custom vocabulary in a StartMedicalTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

public struct CreateVocabularyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary). If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The language code that represents the language of the entries in your custom vocabulary. Each custom vocabulary must contain terms in only one language. A custom vocabulary can only be used to transcribe files in the same language as the custom vocabulary. For example, if you create a custom vocabulary using US English (en-US), you can only apply this custom vocabulary to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Use this parameter if you want to create your custom vocabulary by including all desired terms, as comma-separated values, within your request. The other option for creating your custom vocabulary is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFileUri parameter. Note that if you include Phrases in your request, you cannot use VocabularyFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var phrases: [Swift.String]?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom vocabulary at the time you create this new custom vocabulary. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// The Amazon S3 location of the text file that contains your custom vocabulary. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt Note that if you include VocabularyFileUri in your request, you cannot use the Phrases flag; you must choose one or the other.
    public var vocabularyFileUri: Swift.String?
    /// A unique name, chosen by you, for your new custom vocabulary. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom vocabulary with the same name as an existing custom vocabulary, you get a ConflictException error.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        phrases: [Swift.String]? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.languageCode = languageCode
        self.phrases = phrases
        self.tags = tags
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

public struct CreateVocabularyOutput: Swift.Sendable {
    /// If VocabularyState is FAILED, FailureReason contains information about why the custom vocabulary request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom vocabulary.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time you created your custom vocabulary. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name you chose for your custom vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

public struct CreateVocabularyFilterInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary filter). If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The language code that represents the language of the entries in your vocabulary filter. Each custom vocabulary filter must contain terms in only one language. A custom vocabulary filter can only be used to transcribe files in the same language as the filter. For example, if you create a custom vocabulary filter using US English (en-US), you can only apply this filter to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom vocabulary filter at the time you create this new vocabulary filter. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// The Amazon S3 location of the text file that contains your custom vocabulary filter terms. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-filter-file.txt Note that if you include VocabularyFilterFileUri in your request, you cannot use Words; you must choose one or the other.
    public var vocabularyFilterFileUri: Swift.String?
    /// A unique name, chosen by you, for your new custom vocabulary filter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom vocabulary filter with the same name as an existing custom vocabulary filter, you get a ConflictException error.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?
    /// Use this parameter if you want to create your custom vocabulary filter by including all desired terms, as comma-separated values, within your request. The other option for creating your vocabulary filter is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFilterFileUri parameter. Note that if you include Words in your request, you cannot use VocabularyFilterFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var words: [Swift.String]?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        vocabularyFilterFileUri: Swift.String? = nil,
        vocabularyFilterName: Swift.String? = nil,
        words: [Swift.String]? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.languageCode = languageCode
        self.tags = tags
        self.vocabularyFilterFileUri = vocabularyFilterFileUri
        self.vocabularyFilterName = vocabularyFilterName
        self.words = words
    }
}

public struct CreateVocabularyFilterOutput: Swift.Sendable {
    /// The language code you selected for your custom vocabulary filter.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time you created your custom vocabulary filter. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name you chose for your custom vocabulary filter.
    public var vocabularyFilterName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyFilterName = vocabularyFilterName
    }
}

/// We can't find the requested resource. Check that the specified name is correct and try your request again.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteCallAnalyticsCategoryInput: Swift.Sendable {
    /// The name of the Call Analytics category you want to delete. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?

    public init(
        categoryName: Swift.String? = nil
    )
    {
        self.categoryName = categoryName
    }
}

public struct DeleteCallAnalyticsCategoryOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCallAnalyticsJobInput: Swift.Sendable {
    /// The name of the Call Analytics job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var callAnalyticsJobName: Swift.String?

    public init(
        callAnalyticsJobName: Swift.String? = nil
    )
    {
        self.callAnalyticsJobName = callAnalyticsJobName
    }
}

public struct DeleteCallAnalyticsJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLanguageModelInput: Swift.Sendable {
    /// The name of the custom language model you want to delete. Model names are case sensitive.
    /// This member is required.
    public var modelName: Swift.String?

    public init(
        modelName: Swift.String? = nil
    )
    {
        self.modelName = modelName
    }
}

public struct DeleteMedicalScribeJobInput: Swift.Sendable {
    /// The name of the Medical Scribe job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var medicalScribeJobName: Swift.String?

    public init(
        medicalScribeJobName: Swift.String? = nil
    )
    {
        self.medicalScribeJobName = medicalScribeJobName
    }
}

public struct DeleteMedicalTranscriptionJobInput: Swift.Sendable {
    /// The name of the medical transcription job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var medicalTranscriptionJobName: Swift.String?

    public init(
        medicalTranscriptionJobName: Swift.String? = nil
    )
    {
        self.medicalTranscriptionJobName = medicalTranscriptionJobName
    }
}

public struct DeleteMedicalVocabularyInput: Swift.Sendable {
    /// The name of the custom medical vocabulary you want to delete. Custom medical vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

public struct DeleteTranscriptionJobInput: Swift.Sendable {
    /// The name of the transcription job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var transcriptionJobName: Swift.String?

    public init(
        transcriptionJobName: Swift.String? = nil
    )
    {
        self.transcriptionJobName = transcriptionJobName
    }
}

public struct DeleteVocabularyInput: Swift.Sendable {
    /// The name of the custom vocabulary you want to delete. Custom vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

public struct DeleteVocabularyFilterInput: Swift.Sendable {
    /// The name of the custom vocabulary filter you want to delete. Custom vocabulary filter names are case sensitive.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?

    public init(
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.vocabularyFilterName = vocabularyFilterName
    }
}

public struct DescribeLanguageModelInput: Swift.Sendable {
    /// The name of the custom language model you want information about. Model names are case sensitive.
    /// This member is required.
    public var modelName: Swift.String?

    public init(
        modelName: Swift.String? = nil
    )
    {
        self.modelName = modelName
    }
}

extension TranscribeClientTypes {

    /// Provides information about a custom language model, including:
    ///
    /// * The base model name
    ///
    /// * When the model was created
    ///
    /// * The location of the files used to train the model
    ///
    /// * When the model was last modified
    ///
    /// * The name you chose for the model
    ///
    /// * The model's language
    ///
    /// * The model's processing state
    ///
    /// * Any available upgrades for the base model
    public struct LanguageModel: Swift.Sendable {
        /// The Amazon Transcribe standard language model, or base model, used to create your custom language model.
        public var baseModelName: TranscribeClientTypes.BaseModelName?
        /// The date and time the specified custom language model was created. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var createTime: Foundation.Date?
        /// If ModelStatus is FAILED, FailureReason contains information about why the custom language model request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The Amazon S3 location of the input files used to train and tune your custom language model, in addition to the data access role ARN (Amazon Resource Name) that has permissions to access these data.
        public var inputDataConfig: TranscribeClientTypes.InputDataConfig?
        /// The language code used to create your custom language model. Each custom language model must contain terms in only one language, and the language you select for your custom language model must match the language of your training and tuning data. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. Note that US English (en-US) is the only language supported with Amazon Transcribe Medical.
        public var languageCode: TranscribeClientTypes.CLMLanguageCode?
        /// The date and time the specified custom language model was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var lastModifiedTime: Foundation.Date?
        /// A unique name, chosen by you, for your custom language model. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var modelName: Swift.String?
        /// The status of the specified custom language model. When the status displays as COMPLETED the model is ready for use.
        public var modelStatus: TranscribeClientTypes.ModelStatus?
        /// Shows if a more current base model is available for use with the specified custom language model. If false, your custom language model is using the most up-to-date base model. If true, there is a newer base model available than the one your language model is using. Note that to update a base model, you must recreate the custom language model using the new base model. Base model upgrades for existing custom language models are not supported.
        public var upgradeAvailability: Swift.Bool?

        public init(
            baseModelName: TranscribeClientTypes.BaseModelName? = nil,
            createTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            inputDataConfig: TranscribeClientTypes.InputDataConfig? = nil,
            languageCode: TranscribeClientTypes.CLMLanguageCode? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            modelName: Swift.String? = nil,
            modelStatus: TranscribeClientTypes.ModelStatus? = nil,
            upgradeAvailability: Swift.Bool? = nil
        )
        {
            self.baseModelName = baseModelName
            self.createTime = createTime
            self.failureReason = failureReason
            self.inputDataConfig = inputDataConfig
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.modelName = modelName
            self.modelStatus = modelStatus
            self.upgradeAvailability = upgradeAvailability
        }
    }
}

public struct DescribeLanguageModelOutput: Swift.Sendable {
    /// Provides information about the specified custom language model. This parameter also shows if the base language model you used to create your custom language model has been updated. If Amazon Transcribe has updated the base model, you can create a new custom language model using the updated base model. If you tried to create a new custom language model and the request wasn't successful, you can use this DescribeLanguageModel to help identify the reason for this failure.
    public var languageModel: TranscribeClientTypes.LanguageModel?

    public init(
        languageModel: TranscribeClientTypes.LanguageModel? = nil
    )
    {
        self.languageModel = languageModel
    }
}

public struct GetCallAnalyticsCategoryInput: Swift.Sendable {
    /// The name of the Call Analytics category you want information about. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?

    public init(
        categoryName: Swift.String? = nil
    )
    {
        self.categoryName = categoryName
    }
}

public struct GetCallAnalyticsCategoryOutput: Swift.Sendable {
    /// Provides you with the properties of the Call Analytics category you specified in your GetCallAnalyticsCategory request.
    public var categoryProperties: TranscribeClientTypes.CategoryProperties?

    public init(
        categoryProperties: TranscribeClientTypes.CategoryProperties? = nil
    )
    {
        self.categoryProperties = categoryProperties
    }
}

public struct GetCallAnalyticsJobInput: Swift.Sendable {
    /// The name of the Call Analytics job you want information about. Job names are case sensitive.
    /// This member is required.
    public var callAnalyticsJobName: Swift.String?

    public init(
        callAnalyticsJobName: Swift.String? = nil
    )
    {
        self.callAnalyticsJobName = callAnalyticsJobName
    }
}

public struct GetCallAnalyticsJobOutput: Swift.Sendable {
    /// Provides detailed information about the specified Call Analytics job, including job status and, if applicable, failure reason.
    public var callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob?

    public init(
        callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob? = nil
    )
    {
        self.callAnalyticsJob = callAnalyticsJob
    }
}

public struct GetMedicalScribeJobInput: Swift.Sendable {
    /// The name of the Medical Scribe job you want information about. Job names are case sensitive.
    /// This member is required.
    public var medicalScribeJobName: Swift.String?

    public init(
        medicalScribeJobName: Swift.String? = nil
    )
    {
        self.medicalScribeJobName = medicalScribeJobName
    }
}

extension TranscribeClientTypes {

    public enum MedicalScribeParticipantRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clinician
        case patient
        case sdkUnknown(Swift.String)

        public static var allCases: [MedicalScribeParticipantRole] {
            return [
                .clinician,
                .patient
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clinician: return "CLINICIAN"
            case .patient: return "PATIENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Indicates which speaker is on which channel. The options are CLINICIAN and PATIENT
    public struct MedicalScribeChannelDefinition: Swift.Sendable {
        /// Specify the audio channel you want to define.
        /// This member is required.
        public var channelId: Swift.Int
        /// Specify the participant that you want to flag. The options are CLINICIAN and PATIENT
        /// This member is required.
        public var participantRole: TranscribeClientTypes.MedicalScribeParticipantRole?

        public init(
            channelId: Swift.Int = 0,
            participantRole: TranscribeClientTypes.MedicalScribeParticipantRole? = nil
        )
        {
            self.channelId = channelId
            self.participantRole = participantRole
        }
    }
}

extension TranscribeClientTypes {

    public enum MedicalScribeLanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [MedicalScribeLanguageCode] {
            return [
                .enUs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum MedicalScribeJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case queued
        case sdkUnknown(Swift.String)

        public static var allCases: [MedicalScribeJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .queued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// The location of the output of your Medical Scribe job. ClinicalDocumentUri holds the Amazon S3 URI for the Clinical Document and TranscriptFileUri holds the Amazon S3 URI for the Transcript.
    public struct MedicalScribeOutput: Swift.Sendable {
        /// Holds the Amazon S3 URI for the Clinical Document.
        /// This member is required.
        public var clinicalDocumentUri: Swift.String?
        /// Holds the Amazon S3 URI for the Transcript.
        /// This member is required.
        public var transcriptFileUri: Swift.String?

        public init(
            clinicalDocumentUri: Swift.String? = nil,
            transcriptFileUri: Swift.String? = nil
        )
        {
            self.clinicalDocumentUri = clinicalDocumentUri
            self.transcriptFileUri = transcriptFileUri
        }
    }
}

extension TranscribeClientTypes {

    /// Makes it possible to control how your Medical Scribe job is processed using a MedicalScribeSettings object. Specify ChannelIdentification if ChannelDefinitions are set. Enabled ShowSpeakerLabels if ChannelIdentification and ChannelDefinitions are not set. One and only one of ChannelIdentification and ShowSpeakerLabels must be set. If ShowSpeakerLabels is set, MaxSpeakerLabels must also be set. Use Settings to specify a vocabulary or vocabulary filter or both using VocabularyName, VocabularyFilterName. VocabularyFilterMethod must be specified if VocabularyFilterName is set.
    public struct MedicalScribeSettings: Swift.Sendable {
        /// Enables channel identification in multi-channel audio. Channel identification transcribes the audio on each channel independently, then appends the output for each channel into one transcript. For more information, see [Transcribing multi-channel audio](https://docs.aws.amazon.com/transcribe/latest/dg/channel-id.html).
        public var channelIdentification: Swift.Bool?
        /// Specify the maximum number of speakers you want to partition in your media. Note that if your media contains more speakers than the specified number, multiple speakers are treated as a single speaker. If you specify the MaxSpeakerLabels field, you must set the ShowSpeakerLabels field to true.
        public var maxSpeakerLabels: Swift.Int?
        /// Enables speaker partitioning (diarization) in your Medical Scribe output. Speaker partitioning labels the speech from individual speakers in your media file. If you enable ShowSpeakerLabels in your request, you must also include MaxSpeakerLabels. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html).
        public var showSpeakerLabels: Swift.Bool?
        /// Specify how you want your custom vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter you want to include in your Medical Scribe request. Custom vocabulary filter names are case sensitive. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to include in your Medical Scribe request. Custom vocabulary names are case sensitive.
        public var vocabularyName: Swift.String?

        public init(
            channelIdentification: Swift.Bool? = nil,
            maxSpeakerLabels: Swift.Int? = nil,
            showSpeakerLabels: Swift.Bool? = nil,
            vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.channelIdentification = channelIdentification
            self.maxSpeakerLabels = maxSpeakerLabels
            self.showSpeakerLabels = showSpeakerLabels
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a Medical Scribe job. To view the status of the specified Medical Scribe job, check the MedicalScribeJobStatus field. If the status is COMPLETED, the job is finished and you can find the results at the locations specified in MedicalScribeOutput. If the status is FAILED, FailureReason provides details on why your Medical Scribe job failed.
    public struct MedicalScribeJob: Swift.Sendable {
        /// Makes it possible to specify which speaker is on which channel. For example, if the clinician is the first participant to speak, you would set ChannelId of the first ChannelDefinition in the list to 0 (to indicate the first channel) and ParticipantRole to CLINICIAN (to indicate that it's the clinician speaking). Then you would set the ChannelId of the second ChannelDefinition in the list to 1 (to indicate the second channel) and ParticipantRole to PATIENT (to indicate that it's the patient speaking).
        public var channelDefinitions: [TranscribeClientTypes.MedicalScribeChannelDefinition]?
        /// The date and time the specified Medical Scribe job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a Medical Scribe job that finished processing at 12:32 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// The date and time the specified Medical Scribe job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a Medical Scribe job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files, write to the output bucket, and use your KMS key if supplied. If the role that you specify doesn’t have the appropriate permissions your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
        public var dataAccessRoleArn: Swift.String?
        /// If MedicalScribeJobStatus is FAILED, FailureReason contains information about why the transcription job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The language code used to create your Medical Scribe job. US English (en-US) is the only supported language for Medical Scribe jobs.
        public var languageCode: TranscribeClientTypes.MedicalScribeLanguageCode?
        /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the MediaFormat parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
        public var media: TranscribeClientTypes.Media?
        /// The name of the Medical Scribe job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var medicalScribeJobName: Swift.String?
        /// Provides the status of the specified Medical Scribe job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in MedicalScribeOutput If the status is FAILED, FailureReason provides details on why your Medical Scribe job failed.
        public var medicalScribeJobStatus: TranscribeClientTypes.MedicalScribeJobStatus?
        /// The location of the output of your Medical Scribe job. ClinicalDocumentUri holds the Amazon S3 URI for the Clinical Document and TranscriptFileUri holds the Amazon S3 URI for the Transcript.
        public var medicalScribeOutput: TranscribeClientTypes.MedicalScribeOutput?
        /// Makes it possible to control how your Medical Scribe job is processed using a MedicalScribeSettings object. Specify ChannelIdentification if ChannelDefinitions are set. Enabled ShowSpeakerLabels if ChannelIdentification and ChannelDefinitions are not set. One and only one of ChannelIdentification and ShowSpeakerLabels must be set. If ShowSpeakerLabels is set, MaxSpeakerLabels must also be set. Use Settings to specify a vocabulary or vocabulary filter or both using VocabularyName, VocabularyFilterName. VocabularyFilterMethod must be specified if VocabularyFilterName is set.
        public var settings: TranscribeClientTypes.MedicalScribeSettings?
        /// The date and time your Medical Scribe job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a Medical Scribe job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?
        /// Adds one or more custom tags, each in the form of a key:value pair, to the Medica Scribe job. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
        public var tags: [TranscribeClientTypes.Tag]?

        public init(
            channelDefinitions: [TranscribeClientTypes.MedicalScribeChannelDefinition]? = nil,
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.MedicalScribeLanguageCode? = nil,
            media: TranscribeClientTypes.Media? = nil,
            medicalScribeJobName: Swift.String? = nil,
            medicalScribeJobStatus: TranscribeClientTypes.MedicalScribeJobStatus? = nil,
            medicalScribeOutput: TranscribeClientTypes.MedicalScribeOutput? = nil,
            settings: TranscribeClientTypes.MedicalScribeSettings? = nil,
            startTime: Foundation.Date? = nil,
            tags: [TranscribeClientTypes.Tag]? = nil
        )
        {
            self.channelDefinitions = channelDefinitions
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.dataAccessRoleArn = dataAccessRoleArn
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.media = media
            self.medicalScribeJobName = medicalScribeJobName
            self.medicalScribeJobStatus = medicalScribeJobStatus
            self.medicalScribeOutput = medicalScribeOutput
            self.settings = settings
            self.startTime = startTime
            self.tags = tags
        }
    }
}

public struct GetMedicalScribeJobOutput: Swift.Sendable {
    /// Provides detailed information about the specified Medical Scribe job, including job status and, if applicable, failure reason
    public var medicalScribeJob: TranscribeClientTypes.MedicalScribeJob?

    public init(
        medicalScribeJob: TranscribeClientTypes.MedicalScribeJob? = nil
    )
    {
        self.medicalScribeJob = medicalScribeJob
    }
}

public struct GetMedicalTranscriptionJobInput: Swift.Sendable {
    /// The name of the medical transcription job you want information about. Job names are case sensitive.
    /// This member is required.
    public var medicalTranscriptionJobName: Swift.String?

    public init(
        medicalTranscriptionJobName: Swift.String? = nil
    )
    {
        self.medicalTranscriptionJobName = medicalTranscriptionJobName
    }
}

extension TranscribeClientTypes {

    public enum MedicalContentIdentificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [MedicalContentIdentificationType] {
            return [
                .phi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Allows additional optional settings in your request, including channel identification, alternative transcriptions, and speaker partitioning. You can use that to apply custom vocabularies to your medical transcription job.
    public struct MedicalTranscriptionSetting: Swift.Sendable {
        /// Enables channel identification in multi-channel audio. Channel identification transcribes the audio on each channel independently, then appends the output for each channel into one transcript. If you have multi-channel audio and do not enable channel identification, your audio is transcribed in a continuous manner and your transcript does not separate the speech by channel. For more information, see [Transcribing multi-channel audio](https://docs.aws.amazon.com/transcribe/latest/dg/channel-id.html).
        public var channelIdentification: Swift.Bool?
        /// Indicate the maximum number of alternative transcriptions you want Amazon Transcribe Medical to include in your transcript. If you select a number greater than the number of alternative transcriptions generated by Amazon Transcribe Medical, only the actual number of alternative transcriptions are included. If you include MaxAlternatives in your request, you must also include ShowAlternatives with a value of true. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var maxAlternatives: Swift.Int?
        /// Specify the maximum number of speakers you want to partition in your media. Note that if your media contains more speakers than the specified number, multiple speakers are treated as a single speaker. If you specify the MaxSpeakerLabels field, you must set the ShowSpeakerLabels field to true.
        public var maxSpeakerLabels: Swift.Int?
        /// To include alternative transcriptions within your transcription output, include ShowAlternatives in your transcription request. If you include ShowAlternatives, you must also include MaxAlternatives, which is the maximum number of alternative transcriptions you want Amazon Transcribe Medical to generate. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var showAlternatives: Swift.Bool?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. If you enable ShowSpeakerLabels in your request, you must also include MaxSpeakerLabels. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html).
        public var showSpeakerLabels: Swift.Bool?
        /// The name of the custom vocabulary you want to use when processing your medical transcription job. Custom vocabulary names are case sensitive. The language of the specified custom vocabulary must match the language code that you specify in your transcription request. If the languages do not match, the custom vocabulary isn't applied. There are no errors or warnings associated with a language mismatch. US English (en-US) is the only valid language for Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init(
            channelIdentification: Swift.Bool? = nil,
            maxAlternatives: Swift.Int? = nil,
            maxSpeakerLabels: Swift.Int? = nil,
            showAlternatives: Swift.Bool? = nil,
            showSpeakerLabels: Swift.Bool? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.channelIdentification = channelIdentification
            self.maxAlternatives = maxAlternatives
            self.maxSpeakerLabels = maxSpeakerLabels
            self.showAlternatives = showAlternatives
            self.showSpeakerLabels = showSpeakerLabels
            self.vocabularyName = vocabularyName
        }
    }
}

extension TranscribeClientTypes {

    public enum Specialty: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case primarycare
        case sdkUnknown(Swift.String)

        public static var allCases: [Specialty] {
            return [
                .primarycare
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .primarycare: return "PRIMARYCARE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Provides you with the Amazon S3 URI you can use to access your transcript.
    public struct MedicalTranscript: Swift.Sendable {
        /// The Amazon S3 location of your transcript. You can use this URI to access or download your transcript. Note that this is the Amazon S3 location you specified in your request using the OutputBucketName parameter.
        public var transcriptFileUri: Swift.String?

        public init(
            transcriptFileUri: Swift.String? = nil
        )
        {
            self.transcriptFileUri = transcriptFileUri
        }
    }
}

extension TranscribeClientTypes {

    public enum TranscriptionJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case queued
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscriptionJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .queued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .conversation,
                .dictation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a medical transcription job. To view the status of the specified medical transcription job, check the TranscriptionJobStatus field. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed.
    public struct MedicalTranscriptionJob: Swift.Sendable {
        /// The date and time the specified medical transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// Indicates whether content identification was enabled for your transcription request.
        public var contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
        /// The date and time the specified medical transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job request failed. The FailureReason field contains one of the following values:
        ///
        /// * Unsupported media format. The media format specified in MediaFormat isn't valid. Refer to refer to the MediaFormat parameter for a list of supported formats.
        ///
        /// * The media format provided does not match the detected media format. The media format specified in MediaFormat doesn't match the format of the input file. Check the media format of your media file and correct the specified value.
        ///
        /// * Invalid sample rate for audio file. The sample rate specified in MediaSampleRateHertz isn't valid. The sample rate must be between 16,000 and 48,000 hertz.
        ///
        /// * The sample rate provided does not match the detected sample rate. The sample rate specified in MediaSampleRateHertz doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.
        ///
        /// * Invalid file size: file size too large. The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to [Service quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe).
        ///
        /// * Invalid number of channels: number of channels too large. Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to [Service quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe).
        public var failureReason: Swift.String?
        /// The language code used to create your medical transcription job. US English (en-US) is the only supported language for medical transcriptions.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the MediaFormat parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
        public var media: TranscribeClientTypes.Media?
        /// The format of the input media file.
        public var mediaFormat: TranscribeClientTypes.MediaFormat?
        /// The sample rate, in hertz, of the audio track in your input media file.
        public var mediaSampleRateHertz: Swift.Int?
        /// The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var medicalTranscriptionJobName: Swift.String?
        /// Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.
        public var settings: TranscribeClientTypes.MedicalTranscriptionSetting?
        /// Describes the medical specialty represented in your media.
        public var specialty: TranscribeClientTypes.Specialty?
        /// The date and time the specified medical transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?
        /// The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.
        public var tags: [TranscribeClientTypes.Tag]?
        /// Provides you with the Amazon S3 URI you can use to access your transcript.
        public var transcript: TranscribeClientTypes.MedicalTranscript?
        /// Provides the status of the specified medical transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?
        /// Indicates whether the input media is a dictation or a conversation, as specified in the StartMedicalTranscriptionJob request.
        public var type: TranscribeClientTypes.ModelType?

        public init(
            completionTime: Foundation.Date? = nil,
            contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType? = nil,
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            media: TranscribeClientTypes.Media? = nil,
            mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
            mediaSampleRateHertz: Swift.Int? = nil,
            medicalTranscriptionJobName: Swift.String? = nil,
            settings: TranscribeClientTypes.MedicalTranscriptionSetting? = nil,
            specialty: TranscribeClientTypes.Specialty? = nil,
            startTime: Foundation.Date? = nil,
            tags: [TranscribeClientTypes.Tag]? = nil,
            transcript: TranscribeClientTypes.MedicalTranscript? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil,
            type: TranscribeClientTypes.ModelType? = nil
        )
        {
            self.completionTime = completionTime
            self.contentIdentificationType = contentIdentificationType
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.media = media
            self.mediaFormat = mediaFormat
            self.mediaSampleRateHertz = mediaSampleRateHertz
            self.medicalTranscriptionJobName = medicalTranscriptionJobName
            self.settings = settings
            self.specialty = specialty
            self.startTime = startTime
            self.tags = tags
            self.transcript = transcript
            self.transcriptionJobStatus = transcriptionJobStatus
            self.type = type
        }
    }
}

public struct GetMedicalTranscriptionJobOutput: Swift.Sendable {
    /// Provides detailed information about the specified medical transcription job, including job status and, if applicable, failure reason.
    public var medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob?

    public init(
        medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob? = nil
    )
    {
        self.medicalTranscriptionJob = medicalTranscriptionJob
    }
}

public struct GetMedicalVocabularyInput: Swift.Sendable {
    /// The name of the custom medical vocabulary you want information about. Custom medical vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

public struct GetMedicalVocabularyOutput: Swift.Sendable {
    /// The Amazon S3 location where the specified custom medical vocabulary is stored; use this URI to view or download the custom vocabulary.
    public var downloadUri: Swift.String?
    /// If VocabularyState is FAILED, FailureReason contains information about why the custom medical vocabulary request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom medical vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom medical vocabulary was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the custom medical vocabulary you requested information about.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom medical vocabulary. If the state is READY, you can use the custom vocabulary in a StartMedicalTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        downloadUri: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.downloadUri = downloadUri
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

public struct GetTranscriptionJobInput: Swift.Sendable {
    /// The name of the transcription job you want information about. Job names are case sensitive.
    /// This member is required.
    public var transcriptionJobName: Swift.String?

    public init(
        transcriptionJobName: Swift.String? = nil
    )
    {
        self.transcriptionJobName = transcriptionJobName
    }
}

extension TranscribeClientTypes {

    /// Makes it possible to control how your transcription job is processed. Currently, the only JobExecutionSettings modification you can choose is enabling job queueing using the AllowDeferredExecution sub-parameter. If you include JobExecutionSettings in your request, you must also include the sub-parameters: AllowDeferredExecution and DataAccessRoleArn.
    public struct JobExecutionSettings: Swift.Sendable {
        /// Makes it possible to enable job queuing when your concurrent request limit is exceeded. When AllowDeferredExecution is set to true, transcription job requests are placed in a queue until the number of jobs falls below the concurrent request limit. If AllowDeferredExecution is set to false and the number of transcription job requests exceed the concurrent request limit, you get a LimitExceededException error. If you include AllowDeferredExecution in your request, you must also include DataAccessRoleArn.
        public var allowDeferredExecution: Swift.Bool?
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). Note that if you include DataAccessRoleArn in your request, you must also include AllowDeferredExecution.
        public var dataAccessRoleArn: Swift.String?

        public init(
            allowDeferredExecution: Swift.Bool? = nil,
            dataAccessRoleArn: Swift.String? = nil
        )
        {
            self.allowDeferredExecution = allowDeferredExecution
            self.dataAccessRoleArn = dataAccessRoleArn
        }
    }
}

extension TranscribeClientTypes {

    /// Provides information on the speech contained in a discreet utterance when multi-language identification is enabled in your request. This utterance represents a block of speech consisting of one language, preceded or followed by a block of speech in a different language.
    public struct LanguageCodeItem: Swift.Sendable {
        /// Provides the total time, in seconds, each identified language is spoken in your media.
        public var durationInSeconds: Swift.Float?
        /// Provides the language code for each language identified in your media.
        public var languageCode: TranscribeClientTypes.LanguageCode?

        public init(
            durationInSeconds: Swift.Float? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.languageCode = languageCode
        }
    }
}

extension TranscribeClientTypes {

    /// Provides the name of the custom language model that was included in the specified transcription job. Only use ModelSettings with the LanguageModelName sub-parameter if you're not using automatic language identification (). If using LanguageIdSettings in your request, this parameter contains a LanguageModelName sub-parameter.
    public struct ModelSettings: Swift.Sendable {
        /// The name of the custom language model you want to use when processing your transcription job. Note that custom language model names are case sensitive. The language of the specified custom language model must match the language code that you specify in your transcription request. If the languages do not match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.
        public var languageModelName: Swift.String?

        public init(
            languageModelName: Swift.String? = nil
        )
        {
            self.languageModelName = languageModelName
        }
    }
}

extension TranscribeClientTypes {

    /// Allows additional optional settings in your request, including channel identification, alternative transcriptions, and speaker partitioning. You can use that to apply custom vocabularies to your transcription job.
    public struct Settings: Swift.Sendable {
        /// Enables channel identification in multi-channel audio. Channel identification transcribes the audio on each channel independently, then appends the output for each channel into one transcript. For more information, see [Transcribing multi-channel audio](https://docs.aws.amazon.com/transcribe/latest/dg/channel-id.html).
        public var channelIdentification: Swift.Bool?
        /// Indicate the maximum number of alternative transcriptions you want Amazon Transcribe to include in your transcript. If you select a number greater than the number of alternative transcriptions generated by Amazon Transcribe, only the actual number of alternative transcriptions are included. If you include MaxAlternatives in your request, you must also include ShowAlternatives with a value of true. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var maxAlternatives: Swift.Int?
        /// Specify the maximum number of speakers you want to partition in your media. Note that if your media contains more speakers than the specified number, multiple speakers are treated as a single speaker. If you specify the MaxSpeakerLabels field, you must set the ShowSpeakerLabels field to true.
        public var maxSpeakerLabels: Swift.Int?
        /// To include alternative transcriptions within your transcription output, include ShowAlternatives in your transcription request. If you have multi-channel audio and do not enable channel identification, your audio is transcribed in a continuous manner and your transcript does not separate the speech by channel. If you include ShowAlternatives, you must also include MaxAlternatives, which is the maximum number of alternative transcriptions you want Amazon Transcribe to generate. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var showAlternatives: Swift.Bool?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. If you enable ShowSpeakerLabels in your request, you must also include MaxSpeakerLabels. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html).
        public var showSpeakerLabels: Swift.Bool?
        /// Specify how you want your custom vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter you want to use in your transcription job request. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to use in your transcription job request. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var vocabularyName: Swift.String?

        public init(
            channelIdentification: Swift.Bool? = nil,
            maxAlternatives: Swift.Int? = nil,
            maxSpeakerLabels: Swift.Int? = nil,
            showAlternatives: Swift.Bool? = nil,
            showSpeakerLabels: Swift.Bool? = nil,
            vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.channelIdentification = channelIdentification
            self.maxAlternatives = maxAlternatives
            self.maxSpeakerLabels = maxSpeakerLabels
            self.showAlternatives = showAlternatives
            self.showSpeakerLabels = showSpeakerLabels
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }
}

extension TranscribeClientTypes {

    public enum SubtitleFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case srt
        case vtt
        case sdkUnknown(Swift.String)

        public static var allCases: [SubtitleFormat] {
            return [
                .srt,
                .vtt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .srt: return "srt"
            case .vtt: return "vtt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Provides information about your subtitle file, including format, start index, and Amazon S3 location.
    public struct SubtitlesOutput: Swift.Sendable {
        /// Provides the format of your subtitle files. If your request included both WebVTT (vtt) and SubRip (srt) formats, both formats are shown.
        public var formats: [TranscribeClientTypes.SubtitleFormat]?
        /// Provides the start index value for your subtitle files. If you did not specify a value in your request, the default value of 0 is used.
        public var outputStartIndex: Swift.Int?
        /// The Amazon S3 location of your transcript. You can use this URI to access or download your subtitle file. Your subtitle file is stored in the same location as your transcript. If you specified both WebVTT and SubRip subtitle formats, two URIs are provided. If you included OutputBucketName in your transcription job request, this is the URI of that bucket. If you also included OutputKey in your request, your output is located in the path you specified in your request. If you didn't include OutputBucketName in your transcription job request, your subtitle file is stored in a service-managed bucket, and TranscriptFileUri provides you with a temporary URI you can use for secure access to your subtitle file. Temporary URIs for service-managed Amazon S3 buckets are only valid for 15 minutes. If you get an AccesDenied error, you can get a new temporary URI by running a GetTranscriptionJob or ListTranscriptionJob request.
        public var subtitleFileUris: [Swift.String]?

        public init(
            formats: [TranscribeClientTypes.SubtitleFormat]? = nil,
            outputStartIndex: Swift.Int? = nil,
            subtitleFileUris: [Swift.String]? = nil
        )
        {
            self.formats = formats
            self.outputStartIndex = outputStartIndex
            self.subtitleFileUris = subtitleFileUris
        }
    }
}

extension TranscribeClientTypes {

    public enum ToxicityCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [ToxicityCategory] {
            return [
                .all
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Contains ToxicityCategories, which is a required parameter if you want to enable toxicity detection (ToxicityDetection) in your transcription request.
    public struct ToxicityDetectionSettings: Swift.Sendable {
        /// If you include ToxicityDetection in your transcription request, you must also include ToxicityCategories. The only accepted value for this parameter is ALL.
        /// This member is required.
        public var toxicityCategories: [TranscribeClientTypes.ToxicityCategory]?

        public init(
            toxicityCategories: [TranscribeClientTypes.ToxicityCategory]? = nil
        )
        {
            self.toxicityCategories = toxicityCategories
        }
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a transcription job. To view the status of the specified transcription job, check the TranscriptionJobStatus field. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed. If you enabled content redaction, the redacted transcript can be found at the location specified in RedactedTranscriptFileUri.
    public struct TranscriptionJob: Swift.Sendable {
        /// The date and time the specified transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// Indicates whether redaction was enabled in your transcript.
        public var contentRedaction: TranscribeClientTypes.ContentRedaction?
        /// The date and time the specified transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job request failed. The FailureReason field contains one of the following values:
        ///
        /// * Unsupported media format. The media format specified in MediaFormat isn't valid. Refer to refer to the MediaFormat parameter for a list of supported formats.
        ///
        /// * The media format provided does not match the detected media format. The media format specified in MediaFormat doesn't match the format of the input file. Check the media format of your media file and correct the specified value.
        ///
        /// * Invalid sample rate for audio file. The sample rate specified in MediaSampleRateHertz isn't valid. The sample rate must be between 8,000 and 48,000 hertz.
        ///
        /// * The sample rate provided does not match the detected sample rate. The sample rate specified in MediaSampleRateHertz doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.
        ///
        /// * Invalid file size: file size too large. The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to [Service quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe).
        ///
        /// * Invalid number of channels: number of channels too large. Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to [Service quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe).
        public var failureReason: Swift.String?
        /// The confidence score associated with the language identified in your media file. Confidence scores are values between 0 and 1; a larger value indicates a higher probability that the identified language correctly matches the language spoken in your media.
        public var identifiedLanguageScore: Swift.Float?
        /// Indicates whether automatic language identification was enabled (TRUE) for the specified transcription job.
        public var identifyLanguage: Swift.Bool?
        /// Indicates whether automatic multi-language identification was enabled (TRUE) for the specified transcription job.
        public var identifyMultipleLanguages: Swift.Bool?
        /// Provides information about how your transcription job was processed. This parameter shows if your request was queued and what data access role was used.
        public var jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings?
        /// The language code used to create your transcription job. This parameter is used with single-language identification. For multi-language identification requests, refer to the plural version of this parameter, LanguageCodes.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The language codes used to create your transcription job. This parameter is used with multi-language identification. For single-language identification requests, refer to the singular version of this parameter, LanguageCode.
        public var languageCodes: [TranscribeClientTypes.LanguageCodeItem]?
        /// Provides the name and language of all custom language models, custom vocabularies, and custom vocabulary filters that you included in your request.
        public var languageIdSettings: [Swift.String: TranscribeClientTypes.LanguageIdSettings]?
        /// Provides the language codes you specified in your request.
        public var languageOptions: [TranscribeClientTypes.LanguageCode]?
        /// Provides the Amazon S3 location of the media file you used in your request.
        public var media: TranscribeClientTypes.Media?
        /// The format of the input media file.
        public var mediaFormat: TranscribeClientTypes.MediaFormat?
        /// The sample rate, in hertz, of the audio track in your input media file.
        public var mediaSampleRateHertz: Swift.Int?
        /// Provides information on the custom language model you included in your request.
        public var modelSettings: TranscribeClientTypes.ModelSettings?
        /// Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.
        public var settings: TranscribeClientTypes.Settings?
        /// The date and time the specified transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?
        /// Indicates whether subtitles were generated with your transcription.
        public var subtitles: TranscribeClientTypes.SubtitlesOutput?
        /// The tags, each in the form of a key:value pair, assigned to the specified transcription job.
        public var tags: [TranscribeClientTypes.Tag]?
        /// Provides information about the toxicity detection settings applied to your transcription.
        public var toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
        /// Provides you with the Amazon S3 URI you can use to access your transcript.
        public var transcript: TranscribeClientTypes.Transcript?
        /// The name of the transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var transcriptionJobName: Swift.String?
        /// Provides the status of the specified transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?

        public init(
            completionTime: Foundation.Date? = nil,
            contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            identifiedLanguageScore: Swift.Float? = nil,
            identifyLanguage: Swift.Bool? = nil,
            identifyMultipleLanguages: Swift.Bool? = nil,
            jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            languageCodes: [TranscribeClientTypes.LanguageCodeItem]? = nil,
            languageIdSettings: [Swift.String: TranscribeClientTypes.LanguageIdSettings]? = nil,
            languageOptions: [TranscribeClientTypes.LanguageCode]? = nil,
            media: TranscribeClientTypes.Media? = nil,
            mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
            mediaSampleRateHertz: Swift.Int? = nil,
            modelSettings: TranscribeClientTypes.ModelSettings? = nil,
            settings: TranscribeClientTypes.Settings? = nil,
            startTime: Foundation.Date? = nil,
            subtitles: TranscribeClientTypes.SubtitlesOutput? = nil,
            tags: [TranscribeClientTypes.Tag]? = nil,
            toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]? = nil,
            transcript: TranscribeClientTypes.Transcript? = nil,
            transcriptionJobName: Swift.String? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.contentRedaction = contentRedaction
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.identifiedLanguageScore = identifiedLanguageScore
            self.identifyLanguage = identifyLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.jobExecutionSettings = jobExecutionSettings
            self.languageCode = languageCode
            self.languageCodes = languageCodes
            self.languageIdSettings = languageIdSettings
            self.languageOptions = languageOptions
            self.media = media
            self.mediaFormat = mediaFormat
            self.mediaSampleRateHertz = mediaSampleRateHertz
            self.modelSettings = modelSettings
            self.settings = settings
            self.startTime = startTime
            self.subtitles = subtitles
            self.tags = tags
            self.toxicityDetection = toxicityDetection
            self.transcript = transcript
            self.transcriptionJobName = transcriptionJobName
            self.transcriptionJobStatus = transcriptionJobStatus
        }
    }
}

public struct GetTranscriptionJobOutput: Swift.Sendable {
    /// Provides detailed information about the specified transcription job, including job status and, if applicable, failure reason.
    public var transcriptionJob: TranscribeClientTypes.TranscriptionJob?

    public init(
        transcriptionJob: TranscribeClientTypes.TranscriptionJob? = nil
    )
    {
        self.transcriptionJob = transcriptionJob
    }
}

public struct GetVocabularyInput: Swift.Sendable {
    /// The name of the custom vocabulary you want information about. Custom vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

public struct GetVocabularyOutput: Swift.Sendable {
    /// The Amazon S3 location where the custom vocabulary is stored; use this URI to view or download the custom vocabulary.
    public var downloadUri: Swift.String?
    /// If VocabularyState is FAILED, FailureReason contains information about why the custom vocabulary request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom vocabulary.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the custom vocabulary you requested information about.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        downloadUri: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.downloadUri = downloadUri
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

public struct GetVocabularyFilterInput: Swift.Sendable {
    /// The name of the custom vocabulary filter you want information about. Custom vocabulary filter names are case sensitive.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?

    public init(
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.vocabularyFilterName = vocabularyFilterName
    }
}

public struct GetVocabularyFilterOutput: Swift.Sendable {
    /// The Amazon S3 location where the custom vocabulary filter is stored; use this URI to view or download the custom vocabulary filter.
    public var downloadUri: Swift.String?
    /// The language code you selected for your custom vocabulary filter.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary filter was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the custom vocabulary filter you requested information about.
    public var vocabularyFilterName: Swift.String?

    public init(
        downloadUri: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.downloadUri = downloadUri
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyFilterName = vocabularyFilterName
    }
}

public struct ListCallAnalyticsCategoriesInput: Swift.Sendable {
    /// The maximum number of Call Analytics categories to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListCallAnalyticsCategories request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCallAnalyticsCategoriesOutput: Swift.Sendable {
    /// Provides detailed information about your Call Analytics categories, including all the rules associated with each category.
    public var categories: [TranscribeClientTypes.CategoryProperties]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        categories: [TranscribeClientTypes.CategoryProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categories = categories
        self.nextToken = nextToken
    }
}

public struct ListCallAnalyticsJobsInput: Swift.Sendable {
    /// Returns only the Call Analytics jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of Call Analytics jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListCallAnalyticsJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only Call Analytics jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you do not include Status, all Call Analytics jobs are returned.
    public var status: TranscribeClientTypes.CallAnalyticsJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.CallAnalyticsJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListCallAnalyticsJobsOutput: Swift.Sendable {
    /// Provides a summary of information about each result.
    public var callAnalyticsJobSummaries: [TranscribeClientTypes.CallAnalyticsJobSummary]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all Call Analytics jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.CallAnalyticsJobStatus?

    public init(
        callAnalyticsJobSummaries: [TranscribeClientTypes.CallAnalyticsJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.CallAnalyticsJobStatus? = nil
    )
    {
        self.callAnalyticsJobSummaries = callAnalyticsJobSummaries
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListLanguageModelsInput: Swift.Sendable {
    /// The maximum number of custom language models to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom language models that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListLanguageModels request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only custom language models with the specified status. Language models are ordered by creation date, with the newest model first. If you do not include StatusEquals, all custom language models are returned.
    public var statusEquals: TranscribeClientTypes.ModelStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        statusEquals: TranscribeClientTypes.ModelStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.statusEquals = statusEquals
    }
}

public struct ListLanguageModelsOutput: Swift.Sendable {
    /// Provides information about the custom language models that match the criteria specified in your request.
    public var models: [TranscribeClientTypes.LanguageModel]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        models: [TranscribeClientTypes.LanguageModel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

public struct ListMedicalScribeJobsInput: Swift.Sendable {
    /// Returns only the Medical Scribe jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of Medical Scribe jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListMedicalScribeJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only Medical Scribe jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you do not include Status, all Medical Scribe jobs are returned.
    public var status: TranscribeClientTypes.MedicalScribeJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.MedicalScribeJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a specific Medical Scribe job.
    public struct MedicalScribeJobSummary: Swift.Sendable {
        /// The date and time the specified Medical Scribe job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a Medical Scribe job that finished processing at 12:32 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// The date and time the specified Medical Scribe job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a Medical Scribe job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// If MedicalScribeJobStatus is FAILED, FailureReason contains information about why the transcription job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The language code used to create your Medical Scribe job. US English (en-US) is the only supported language for Medical Scribe jobs.
        public var languageCode: TranscribeClientTypes.MedicalScribeLanguageCode?
        /// The name of the Medical Scribe job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var medicalScribeJobName: Swift.String?
        /// Provides the status of the specified Medical Scribe job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in MedicalScribeOutput If the status is FAILED, FailureReason provides details on why your Medical Scribe job failed.
        public var medicalScribeJobStatus: TranscribeClientTypes.MedicalScribeJobStatus?
        /// The date and time your Medical Scribe job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a Medical Scribe job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?

        public init(
            completionTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.MedicalScribeLanguageCode? = nil,
            medicalScribeJobName: Swift.String? = nil,
            medicalScribeJobStatus: TranscribeClientTypes.MedicalScribeJobStatus? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.medicalScribeJobName = medicalScribeJobName
            self.medicalScribeJobStatus = medicalScribeJobStatus
            self.startTime = startTime
        }
    }
}

public struct ListMedicalScribeJobsOutput: Swift.Sendable {
    /// Provides a summary of information about each result.
    public var medicalScribeJobSummaries: [TranscribeClientTypes.MedicalScribeJobSummary]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all Medical Scribe jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.MedicalScribeJobStatus?

    public init(
        medicalScribeJobSummaries: [TranscribeClientTypes.MedicalScribeJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.MedicalScribeJobStatus? = nil
    )
    {
        self.medicalScribeJobSummaries = medicalScribeJobSummaries
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListMedicalTranscriptionJobsInput: Swift.Sendable {
    /// Returns only the medical transcription jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of medical transcription jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListMedicalTranscriptionJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only medical transcription jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you do not include Status, all medical transcription jobs are returned.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension TranscribeClientTypes {

    public enum OutputLocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerBucket
        case serviceBucket
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputLocationType] {
            return [
                .customerBucket,
                .serviceBucket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerBucket: return "CUSTOMER_BUCKET"
            case .serviceBucket: return "SERVICE_BUCKET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a specific medical transcription job.
    public struct MedicalTranscriptionJobSummary: Swift.Sendable {
        /// The date and time the specified medical transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// Labels all personal health information (PHI) identified in your transcript. For more information, see [Identifying personal health information (PHI) in a transcription](https://docs.aws.amazon.com/transcribe/latest/dg/phi-id.html).
        public var contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
        /// The date and time the specified medical transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The language code used to create your medical transcription. US English (en-US) is the only supported language for medical transcriptions.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var medicalTranscriptionJobName: Swift.String?
        /// Indicates where the specified medical transcription output is stored. If the value is CUSTOMER_BUCKET, the location is the Amazon S3 bucket you specified using the OutputBucketName parameter in your request. If you also included OutputKey in your request, your output is located in the path you specified in your request. If the value is SERVICE_BUCKET, the location is a service-managed Amazon S3 bucket. To access a transcript stored in a service-managed bucket, use the URI shown in the TranscriptFileUri field.
        public var outputLocationType: TranscribeClientTypes.OutputLocationType?
        /// Provides the medical specialty represented in your media.
        public var specialty: TranscribeClientTypes.Specialty?
        /// The date and time your medical transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?
        /// Provides the status of your medical transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?
        /// Indicates whether the input media is a dictation or a conversation, as specified in the StartMedicalTranscriptionJob request.
        public var type: TranscribeClientTypes.ModelType?

        public init(
            completionTime: Foundation.Date? = nil,
            contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType? = nil,
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            medicalTranscriptionJobName: Swift.String? = nil,
            outputLocationType: TranscribeClientTypes.OutputLocationType? = nil,
            specialty: TranscribeClientTypes.Specialty? = nil,
            startTime: Foundation.Date? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil,
            type: TranscribeClientTypes.ModelType? = nil
        )
        {
            self.completionTime = completionTime
            self.contentIdentificationType = contentIdentificationType
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.medicalTranscriptionJobName = medicalTranscriptionJobName
            self.outputLocationType = outputLocationType
            self.specialty = specialty
            self.startTime = startTime
            self.transcriptionJobStatus = transcriptionJobStatus
            self.type = type
        }
    }
}

public struct ListMedicalTranscriptionJobsOutput: Swift.Sendable {
    /// Provides a summary of information about each result.
    public var medicalTranscriptionJobSummaries: [TranscribeClientTypes.MedicalTranscriptionJobSummary]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all medical transcription jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?

    public init(
        medicalTranscriptionJobSummaries: [TranscribeClientTypes.MedicalTranscriptionJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil
    )
    {
        self.medicalTranscriptionJobSummaries = medicalTranscriptionJobSummaries
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListMedicalVocabulariesInput: Swift.Sendable {
    /// The maximum number of custom medical vocabularies to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom medical vocabularies that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListMedicalVocabularies request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only custom medical vocabularies with the specified state. Custom vocabularies are ordered by creation date, with the newest vocabulary first. If you do not include StateEquals, all custom medical vocabularies are returned.
    public var stateEquals: TranscribeClientTypes.VocabularyState?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        stateEquals: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.stateEquals = stateEquals
    }
}

extension TranscribeClientTypes {

    /// Provides information about a custom vocabulary, including the language of the custom vocabulary, when it was last modified, its name, and the processing state.
    public struct VocabularyInfo: Swift.Sendable {
        /// The language code used to create your custom vocabulary. Each custom vocabulary must contain terms in only one language. A custom vocabulary can only be used to transcribe files in the same language as the custom vocabulary. For example, if you create a custom vocabulary using US English (en-US), you can only apply this custom vocabulary to files that contain English audio.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The date and time the specified custom vocabulary was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var lastModifiedTime: Foundation.Date?
        /// A unique name, chosen by you, for your custom vocabulary. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var vocabularyName: Swift.String?
        /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
        public var vocabularyState: TranscribeClientTypes.VocabularyState?

        public init(
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyState: TranscribeClientTypes.VocabularyState? = nil
        )
        {
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.vocabularyName = vocabularyName
            self.vocabularyState = vocabularyState
        }
    }
}

public struct ListMedicalVocabulariesOutput: Swift.Sendable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all custom medical vocabularies that have the status specified in your request. Custom vocabularies are ordered by creation date, with the newest vocabulary first.
    public var status: TranscribeClientTypes.VocabularyState?
    /// Provides information about the custom medical vocabularies that match the criteria specified in your request.
    public var vocabularies: [TranscribeClientTypes.VocabularyInfo]?

    public init(
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.VocabularyState? = nil,
        vocabularies: [TranscribeClientTypes.VocabularyInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
        self.vocabularies = vocabularies
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Returns a list of all tags associated with the specified Amazon Resource Name (ARN). ARNs have the format arn:partition:service:region:account-id:resource-type/resource-id. For example, arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name. Valid values for resource-type are: transcription-job, medical-transcription-job, vocabulary, medical-vocabulary, vocabulary-filter, and language-model.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) specified in your request.
    public var resourceArn: Swift.String?
    /// Lists all tags associated with the given transcription job, vocabulary, model, or resource.
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct ListTranscriptionJobsInput: Swift.Sendable {
    /// Returns only the transcription jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of transcription jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListTranscriptionJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only transcription jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you do not include Status, all transcription jobs are returned.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension TranscribeClientTypes {

    /// Provides detailed information about a specific transcription job.
    public struct TranscriptionJobSummary: Swift.Sendable {
        /// The date and time the specified transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: Foundation.Date?
        /// The content redaction settings of the transcription job.
        public var contentRedaction: TranscribeClientTypes.ContentRedaction?
        /// The date and time the specified transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: Foundation.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The confidence score associated with the language identified in your media file. Confidence scores are values between 0 and 1; a larger value indicates a higher probability that the identified language correctly matches the language spoken in your media.
        public var identifiedLanguageScore: Swift.Float?
        /// Indicates whether automatic language identification was enabled (TRUE) for the specified transcription job.
        public var identifyLanguage: Swift.Bool?
        /// Indicates whether automatic multi-language identification was enabled (TRUE) for the specified transcription job.
        public var identifyMultipleLanguages: Swift.Bool?
        /// The language code used to create your transcription.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The language codes used to create your transcription job. This parameter is used with multi-language identification. For single-language identification, the singular version of this parameter, LanguageCode, is present.
        public var languageCodes: [TranscribeClientTypes.LanguageCodeItem]?
        /// Provides the name of the custom language model that was included in the specified transcription job. Only use ModelSettings with the LanguageModelName sub-parameter if you're not using automatic language identification (). If using LanguageIdSettings in your request, this parameter contains a LanguageModelName sub-parameter.
        public var modelSettings: TranscribeClientTypes.ModelSettings?
        /// Indicates where the specified transcription output is stored. If the value is CUSTOMER_BUCKET, the location is the Amazon S3 bucket you specified using the OutputBucketName parameter in your request. If you also included OutputKey in your request, your output is located in the path you specified in your request. If the value is SERVICE_BUCKET, the location is a service-managed Amazon S3 bucket. To access a transcript stored in a service-managed bucket, use the URI shown in the TranscriptFileUri or RedactedTranscriptFileUri field.
        public var outputLocationType: TranscribeClientTypes.OutputLocationType?
        /// The date and time your transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: Foundation.Date?
        /// Indicates whether toxicity detection was enabled for the specified transcription job.
        public var toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
        /// The name of the transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var transcriptionJobName: Swift.String?
        /// Provides the status of your transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?

        public init(
            completionTime: Foundation.Date? = nil,
            contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            identifiedLanguageScore: Swift.Float? = nil,
            identifyLanguage: Swift.Bool? = nil,
            identifyMultipleLanguages: Swift.Bool? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            languageCodes: [TranscribeClientTypes.LanguageCodeItem]? = nil,
            modelSettings: TranscribeClientTypes.ModelSettings? = nil,
            outputLocationType: TranscribeClientTypes.OutputLocationType? = nil,
            startTime: Foundation.Date? = nil,
            toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]? = nil,
            transcriptionJobName: Swift.String? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.contentRedaction = contentRedaction
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.identifiedLanguageScore = identifiedLanguageScore
            self.identifyLanguage = identifyLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.languageCode = languageCode
            self.languageCodes = languageCodes
            self.modelSettings = modelSettings
            self.outputLocationType = outputLocationType
            self.startTime = startTime
            self.toxicityDetection = toxicityDetection
            self.transcriptionJobName = transcriptionJobName
            self.transcriptionJobStatus = transcriptionJobStatus
        }
    }
}

public struct ListTranscriptionJobsOutput: Swift.Sendable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all transcription jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?
    /// Provides a summary of information about each result.
    public var transcriptionJobSummaries: [TranscribeClientTypes.TranscriptionJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil,
        transcriptionJobSummaries: [TranscribeClientTypes.TranscriptionJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
        self.transcriptionJobSummaries = transcriptionJobSummaries
    }
}

public struct ListVocabulariesInput: Swift.Sendable {
    /// The maximum number of custom vocabularies to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom vocabularies that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListVocabularies request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only custom vocabularies with the specified state. Vocabularies are ordered by creation date, with the newest vocabulary first. If you do not include StateEquals, all custom medical vocabularies are returned.
    public var stateEquals: TranscribeClientTypes.VocabularyState?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        stateEquals: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.stateEquals = stateEquals
    }
}

public struct ListVocabulariesOutput: Swift.Sendable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all custom vocabularies that have the status specified in your request. Vocabularies are ordered by creation date, with the newest vocabulary first.
    public var status: TranscribeClientTypes.VocabularyState?
    /// Provides information about the custom vocabularies that match the criteria specified in your request.
    public var vocabularies: [TranscribeClientTypes.VocabularyInfo]?

    public init(
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.VocabularyState? = nil,
        vocabularies: [TranscribeClientTypes.VocabularyInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
        self.vocabularies = vocabularies
    }
}

public struct ListVocabularyFiltersInput: Swift.Sendable {
    /// The maximum number of custom vocabulary filters to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you do not specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom vocabulary filters that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListVocabularyFilters request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
    }
}

extension TranscribeClientTypes {

    /// Provides information about a custom vocabulary filter, including the language of the filter, when it was last modified, and its name.
    public struct VocabularyFilterInfo: Swift.Sendable {
        /// The language code that represents the language of the entries in your vocabulary filter. Each custom vocabulary filter must contain terms in only one language. A custom vocabulary filter can only be used to transcribe files in the same language as the filter. For example, if you create a custom vocabulary filter using US English (en-US), you can only apply this filter to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The date and time the specified custom vocabulary filter was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var lastModifiedTime: Foundation.Date?
        /// A unique name, chosen by you, for your custom vocabulary filter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var vocabularyFilterName: Swift.String?

        public init(
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            vocabularyFilterName: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.vocabularyFilterName = vocabularyFilterName
        }
    }
}

public struct ListVocabularyFiltersOutput: Swift.Sendable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Provides information about the custom vocabulary filters that match the criteria specified in your request.
    public var vocabularyFilters: [TranscribeClientTypes.VocabularyFilterInfo]?

    public init(
        nextToken: Swift.String? = nil,
        vocabularyFilters: [TranscribeClientTypes.VocabularyFilterInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.vocabularyFilters = vocabularyFilters
    }
}

public struct StartCallAnalyticsJobInput: Swift.Sendable {
    /// A unique name, chosen by you, for your Call Analytics job. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var callAnalyticsJobName: Swift.String?
    /// Makes it possible to specify which speaker is on which channel. For example, if your agent is the first participant to speak, you would set ChannelId to 0 (to indicate the first channel) and ParticipantRole to AGENT (to indicate that it's the agent speaking).
    public var channelDefinitions: [TranscribeClientTypes.ChannelDefinition]?
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// Describes the Amazon S3 location of the media file you want to use in your Call Analytics request.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// The KMS key you want to use to encrypt your Call Analytics output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you do not specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). If you specify a KMS key to encrypt your output, you must also specify an output location using the OutputLocation parameter. Note that the role making the request must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// The Amazon S3 location where you want your Call Analytics transcription output stored. You can use any of the following formats to specify the output location:
    ///
    /// * s3://DOC-EXAMPLE-BUCKET
    ///
    /// * s3://DOC-EXAMPLE-BUCKET/my-output-folder/
    ///
    /// * s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json
    ///
    ///
    /// Unless you specify a file name (option 3), the name of your output file has a default value that matches the name you specified for your transcription job using the CallAnalyticsJobName parameter. You can specify a KMS key to encrypt your output using the OutputEncryptionKMSKeyId parameter. If you do not specify a KMS key, Amazon Transcribe uses the default Amazon S3 key for server-side encryption. If you do not specify OutputLocation, your transcript is placed in a service-managed Amazon S3 bucket and you are provided with a URI to access your transcript.
    public var outputLocation: Swift.String?
    /// Specify additional optional settings in your request, including content redaction; allows you to apply custom language models, vocabulary filters, and custom vocabularies to your Call Analytics job.
    public var settings: TranscribeClientTypes.CallAnalyticsJobSettings?

    public init(
        callAnalyticsJobName: Swift.String? = nil,
        channelDefinitions: [TranscribeClientTypes.ChannelDefinition]? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        media: TranscribeClientTypes.Media? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        outputLocation: Swift.String? = nil,
        settings: TranscribeClientTypes.CallAnalyticsJobSettings? = nil
    )
    {
        self.callAnalyticsJobName = callAnalyticsJobName
        self.channelDefinitions = channelDefinitions
        self.dataAccessRoleArn = dataAccessRoleArn
        self.media = media
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.outputLocation = outputLocation
        self.settings = settings
    }
}

public struct StartCallAnalyticsJobOutput: Swift.Sendable {
    /// Provides detailed information about the current Call Analytics job, including job status and, if applicable, failure reason.
    public var callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob?

    public init(
        callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob? = nil
    )
    {
        self.callAnalyticsJob = callAnalyticsJob
    }
}

public struct StartMedicalScribeJobInput: Swift.Sendable {
    /// Makes it possible to specify which speaker is on which channel. For example, if the clinician is the first participant to speak, you would set ChannelId of the first ChannelDefinition in the list to 0 (to indicate the first channel) and ParticipantRole to CLINICIAN (to indicate that it's the clinician speaking). Then you would set the ChannelId of the second ChannelDefinition in the list to 1 (to indicate the second channel) and ParticipantRole to PATIENT (to indicate that it's the patient speaking).
    public var channelDefinitions: [TranscribeClientTypes.MedicalScribeChannelDefinition]?
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files, write to the output bucket, and use your KMS key if supplied. If the role that you specify doesn’t have the appropriate permissions your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added layer of security for your data. For more information, see [KMS encryption context](https://docs.aws.amazon.com/transcribe/latest/dg/key-management.html#kms-context) and [Asymmetric keys in KMS](https://docs.aws.amazon.com/transcribe/latest/dg/symmetric-asymmetric.html).
    public var kmsEncryptionContext: [Swift.String: Swift.String]?
    /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the MediaFormat parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// A unique name, chosen by you, for your Medical Scribe job. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var medicalScribeJobName: Swift.String?
    /// The name of the Amazon S3 bucket where you want your Medical Scribe output stored. Do not include the S3:// prefix of the specified bucket. Note that the role specified in the DataAccessRoleArn request parameter must have permission to use the specified location. You can change Amazon S3 permissions using the [Amazon Web Services Management Console](https://console.aws.amazon.com/s3). See also [Permissions Required for IAM User Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user).
    /// This member is required.
    public var outputBucketName: Swift.String?
    /// The KMS key you want to use to encrypt your Medical Scribe output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you do not specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). Note that the role specified in the DataAccessRoleArn request parameter must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// Makes it possible to control how your Medical Scribe job is processed using a MedicalScribeSettings object. Specify ChannelIdentification if ChannelDefinitions are set. Enabled ShowSpeakerLabels if ChannelIdentification and ChannelDefinitions are not set. One and only one of ChannelIdentification and ShowSpeakerLabels must be set. If ShowSpeakerLabels is set, MaxSpeakerLabels must also be set. Use Settings to specify a vocabulary or vocabulary filter or both using VocabularyName, VocabularyFilterName. VocabularyFilterMethod must be specified if VocabularyFilterName is set.
    /// This member is required.
    public var settings: TranscribeClientTypes.MedicalScribeSettings?
    /// Adds one or more custom tags, each in the form of a key:value pair, to the Medica Scribe job. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        channelDefinitions: [TranscribeClientTypes.MedicalScribeChannelDefinition]? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
        media: TranscribeClientTypes.Media? = nil,
        medicalScribeJobName: Swift.String? = nil,
        outputBucketName: Swift.String? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        settings: TranscribeClientTypes.MedicalScribeSettings? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.channelDefinitions = channelDefinitions
        self.dataAccessRoleArn = dataAccessRoleArn
        self.kmsEncryptionContext = kmsEncryptionContext
        self.media = media
        self.medicalScribeJobName = medicalScribeJobName
        self.outputBucketName = outputBucketName
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.settings = settings
        self.tags = tags
    }
}

public struct StartMedicalScribeJobOutput: Swift.Sendable {
    /// Provides detailed information about the current Medical Scribe job, including job status and, if applicable, failure reason.
    public var medicalScribeJob: TranscribeClientTypes.MedicalScribeJob?

    public init(
        medicalScribeJob: TranscribeClientTypes.MedicalScribeJob? = nil
    )
    {
        self.medicalScribeJob = medicalScribeJob
    }
}

public struct StartMedicalTranscriptionJobInput: Swift.Sendable {
    /// Labels all personal health information (PHI) identified in your transcript. For more information, see [Identifying personal health information (PHI) in a transcription](https://docs.aws.amazon.com/transcribe/latest/dg/phi-id.html).
    public var contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
    /// A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added layer of security for your data. For more information, see [KMS encryption context](https://docs.aws.amazon.com/transcribe/latest/dg/key-management.html#kms-context) and [Asymmetric keys in KMS](https://docs.aws.amazon.com/transcribe/latest/dg/symmetric-asymmetric.html).
    public var kmsEncryptionContext: [Swift.String: Swift.String]?
    /// The language code that represents the language spoken in the input media file. US English (en-US) is the only valid value for medical transcription jobs. Any other value you enter for language code results in a BadRequestException error.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the MediaFormat parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// Specify the format of your input media file.
    public var mediaFormat: TranscribeClientTypes.MediaFormat?
    /// The sample rate, in hertz, of the audio track in your input media file. If you do not specify the media sample rate, Amazon Transcribe Medical determines it for you. If you specify the sample rate, it must match the rate detected by Amazon Transcribe Medical; if there's a mismatch between the value that you specify and the value detected, your job fails. Therefore, in most cases, it's advised to omit MediaSampleRateHertz and let Amazon Transcribe Medical determine the sample rate.
    public var mediaSampleRateHertz: Swift.Int?
    /// A unique name, chosen by you, for your medical transcription job. The name that you specify is also used as the default name of your transcription output file. If you want to specify a different name for your transcription output, use the OutputKey parameter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var medicalTranscriptionJobName: Swift.String?
    /// The name of the Amazon S3 bucket where you want your medical transcription output stored. Do not include the S3:// prefix of the specified bucket. If you want your output to go to a sub-folder of this bucket, specify it using the OutputKey parameter; OutputBucketName only accepts the name of a bucket. For example, if you want your output stored in S3://DOC-EXAMPLE-BUCKET, set OutputBucketName to DOC-EXAMPLE-BUCKET. However, if you want your output stored in S3://DOC-EXAMPLE-BUCKET/test-files/, set OutputBucketName to DOC-EXAMPLE-BUCKET and OutputKey to test-files/. Note that Amazon Transcribe must have permission to use the specified location. You can change Amazon S3 permissions using the [Amazon Web Services Management Console](https://console.aws.amazon.com/s3). See also [Permissions Required for IAM User Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user).
    /// This member is required.
    public var outputBucketName: Swift.String?
    /// The KMS key you want to use to encrypt your medical transcription output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you do not specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). If you specify a KMS key to encrypt your output, you must also specify an output location using the OutputLocation parameter. Note that the role making the request must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// Use in combination with OutputBucketName to specify the output location of your transcript and, optionally, a unique name for your output file. The default name for your transcription output is the same as the name you specified for your medical transcription job (MedicalTranscriptionJobName). Here are some examples of how you can use OutputKey:
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the MedicalTranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript/my-first-transcription.json.
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'test-files/my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the MedicalTranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'test-files/my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript/my-first-transcription.json.
    ///
    ///
    /// If you specify the name of an Amazon S3 bucket sub-folder that doesn't exist, one is created for you.
    public var outputKey: Swift.String?
    /// Specify additional optional settings in your request, including channel identification, alternative transcriptions, and speaker partitioning. You can use that to apply custom vocabularies to your transcription job.
    public var settings: TranscribeClientTypes.MedicalTranscriptionSetting?
    /// Specify the predominant medical specialty represented in your media. For batch transcriptions, PRIMARYCARE is the only valid value. If you require additional specialties, refer to .
    /// This member is required.
    public var specialty: TranscribeClientTypes.Specialty?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new medical transcription job at the time you start this new job. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// Specify whether your input media contains only one person (DICTATION) or contains a conversation between two people (CONVERSATION). For example, DICTATION could be used for a medical professional wanting to transcribe voice memos; CONVERSATION could be used for transcribing the doctor-patient dialogue during the patient's office visit.
    /// This member is required.
    public var type: TranscribeClientTypes.ModelType?

    public init(
        contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType? = nil,
        kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        media: TranscribeClientTypes.Media? = nil,
        mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        medicalTranscriptionJobName: Swift.String? = nil,
        outputBucketName: Swift.String? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        outputKey: Swift.String? = nil,
        settings: TranscribeClientTypes.MedicalTranscriptionSetting? = nil,
        specialty: TranscribeClientTypes.Specialty? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        type: TranscribeClientTypes.ModelType? = nil
    )
    {
        self.contentIdentificationType = contentIdentificationType
        self.kmsEncryptionContext = kmsEncryptionContext
        self.languageCode = languageCode
        self.media = media
        self.mediaFormat = mediaFormat
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.medicalTranscriptionJobName = medicalTranscriptionJobName
        self.outputBucketName = outputBucketName
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.outputKey = outputKey
        self.settings = settings
        self.specialty = specialty
        self.tags = tags
        self.type = type
    }
}

public struct StartMedicalTranscriptionJobOutput: Swift.Sendable {
    /// Provides detailed information about the current medical transcription job, including job status and, if applicable, failure reason.
    public var medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob?

    public init(
        medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob? = nil
    )
    {
        self.medicalTranscriptionJob = medicalTranscriptionJob
    }
}

extension TranscribeClientTypes {

    /// Generate subtitles for your media file with your transcription request. You can choose a start index of 0 or 1, and you can specify either WebVTT or SubRip (or both) as your output format. Note that your subtitle files are placed in the same location as your transcription output.
    public struct Subtitles: Swift.Sendable {
        /// Specify the output format for your subtitle file; if you select both WebVTT (vtt) and SubRip (srt) formats, two output files are generated.
        public var formats: [TranscribeClientTypes.SubtitleFormat]?
        /// Specify the starting value that is assigned to the first subtitle segment. The default start index for Amazon Transcribe is 0, which differs from the more widely used standard of 1. If you're uncertain which value to use, we recommend choosing 1, as this may improve compatibility with other services.
        public var outputStartIndex: Swift.Int?

        public init(
            formats: [TranscribeClientTypes.SubtitleFormat]? = nil,
            outputStartIndex: Swift.Int? = nil
        )
        {
            self.formats = formats
            self.outputStartIndex = outputStartIndex
        }
    }
}

public struct StartTranscriptionJobInput: Swift.Sendable {
    /// Makes it possible to redact or flag specified personally identifiable information (PII) in your transcript. If you use ContentRedaction, you must also include the sub-parameters: RedactionOutput and RedactionType. You can optionally include PiiEntityTypes to choose which types of PII you want to redact. If you do not include PiiEntityTypes in your request, all PII is redacted.
    public var contentRedaction: TranscribeClientTypes.ContentRedaction?
    /// Enables automatic language identification in your transcription job request. Use this parameter if your media file contains only one language. If your media contains multiple languages, use IdentifyMultipleLanguages instead. If you include IdentifyLanguage, you can optionally include a list of language codes, using LanguageOptions, that you think may be present in your media file. Including LanguageOptions restricts IdentifyLanguage to only the language options that you specify, which can improve transcription accuracy. If you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter to your automatic language identification request, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). If you include LanguageIdSettings, also include LanguageOptions. Note that you must include one of LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages in your request. If you include more than one of these parameters, your transcription job fails.
    public var identifyLanguage: Swift.Bool?
    /// Enables automatic multi-language identification in your transcription job request. Use this parameter if your media file contains more than one language. If your media contains only one language, use IdentifyLanguage instead. If you include IdentifyMultipleLanguages, you can optionally include a list of language codes, using LanguageOptions, that you think may be present in your media file. Including LanguageOptions restricts IdentifyLanguage to only the language options that you specify, which can improve transcription accuracy. If you want to apply a custom vocabulary or a custom vocabulary filter to your automatic language identification request, include LanguageIdSettings with the relevant sub-parameters (VocabularyName and VocabularyFilterName). If you include LanguageIdSettings, also include LanguageOptions. Note that you must include one of LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages in your request. If you include more than one of these parameters, your transcription job fails.
    public var identifyMultipleLanguages: Swift.Bool?
    /// Makes it possible to control how your transcription job is processed. Currently, the only JobExecutionSettings modification you can choose is enabling job queueing using the AllowDeferredExecution sub-parameter. If you include JobExecutionSettings in your request, you must also include the sub-parameters: AllowDeferredExecution and DataAccessRoleArn.
    public var jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings?
    /// A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added layer of security for your data. For more information, see [KMS encryption context](https://docs.aws.amazon.com/transcribe/latest/dg/key-management.html#kms-context) and [Asymmetric keys in KMS](https://docs.aws.amazon.com/transcribe/latest/dg/symmetric-asymmetric.html).
    public var kmsEncryptionContext: [Swift.String: Swift.String]?
    /// The language code that represents the language spoken in the input media file. If you're unsure of the language spoken in your media file, consider using IdentifyLanguage or IdentifyMultipleLanguages to enable automatic language identification. Note that you must include one of LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages in your request. If you include more than one of these parameters, your transcription job fails. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. To transcribe speech in Modern Standard Arabic (ar-SA), your media file must be encoded at a sample rate of 16,000 Hz or higher.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// If using automatic language identification in your request and you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). Note that multi-language identification (IdentifyMultipleLanguages) doesn't support custom language models. LanguageIdSettings supports two to five language codes. Each language code you include can have an associated custom language model, custom vocabulary, and custom vocabulary filter. The language codes that you specify must match the languages of the associated custom language models, custom vocabularies, and custom vocabulary filters. It's recommended that you include LanguageOptions when using LanguageIdSettings to ensure that the correct language dialect is identified. For example, if you specify a custom vocabulary that is in en-US but Amazon Transcribe determines that the language spoken in your media is en-AU, your custom vocabulary is not applied to your transcription. If you include LanguageOptions and include en-US as the only English language dialect, your custom vocabulary is applied to your transcription. If you want to include a custom language model with your request but do not want to use automatic language identification, use instead the  parameter with the LanguageModelName sub-parameter. If you want to include a custom vocabulary or a custom vocabulary filter (or both) with your request but do not want to use automatic language identification, use instead the  parameter with the VocabularyName or VocabularyFilterName (or both) sub-parameter.
    public var languageIdSettings: [Swift.String: TranscribeClientTypes.LanguageIdSettings]?
    /// You can specify two or more language codes that represent the languages you think may be present in your media. Including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. If you include LanguageOptions in your request, you must also include IdentifyLanguage. For more information, refer to [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html). To transcribe speech in Modern Standard Arabic (ar-SA), your media file must be encoded at a sample rate of 16,000 Hz or higher.
    public var languageOptions: [TranscribeClientTypes.LanguageCode]?
    /// Describes the Amazon S3 location of the media file you want to use in your request.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// Specify the format of your input media file.
    public var mediaFormat: TranscribeClientTypes.MediaFormat?
    /// The sample rate, in hertz, of the audio track in your input media file. If you do not specify the media sample rate, Amazon Transcribe determines it for you. If you specify the sample rate, it must match the rate detected by Amazon Transcribe. If there's a mismatch between the value that you specify and the value detected, your job fails. In most cases, you can omit MediaSampleRateHertz and let Amazon Transcribe determine the sample rate.
    public var mediaSampleRateHertz: Swift.Int?
    /// Specify the custom language model you want to include with your transcription job. If you include ModelSettings in your request, you must include the LanguageModelName sub-parameter. For more information, see [Custom language models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html).
    public var modelSettings: TranscribeClientTypes.ModelSettings?
    /// The name of the Amazon S3 bucket where you want your transcription output stored. Do not include the S3:// prefix of the specified bucket. If you want your output to go to a sub-folder of this bucket, specify it using the OutputKey parameter; OutputBucketName only accepts the name of a bucket. For example, if you want your output stored in S3://DOC-EXAMPLE-BUCKET, set OutputBucketName to DOC-EXAMPLE-BUCKET. However, if you want your output stored in S3://DOC-EXAMPLE-BUCKET/test-files/, set OutputBucketName to DOC-EXAMPLE-BUCKET and OutputKey to test-files/. Note that Amazon Transcribe must have permission to use the specified location. You can change Amazon S3 permissions using the [Amazon Web Services Management Console](https://console.aws.amazon.com/s3). See also [Permissions Required for IAM User Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user). If you do not specify OutputBucketName, your transcript is placed in a service-managed Amazon S3 bucket and you are provided with a URI to access your transcript.
    public var outputBucketName: Swift.String?
    /// The KMS key you want to use to encrypt your transcription output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you do not specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). If you specify a KMS key to encrypt your output, you must also specify an output location using the OutputLocation parameter. Note that the role making the request must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// Use in combination with OutputBucketName to specify the output location of your transcript and, optionally, a unique name for your output file. The default name for your transcription output is the same as the name you specified for your transcription job (TranscriptionJobName). Here are some examples of how you can use OutputKey:
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the TranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript/my-first-transcription.json.
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'test-files/my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the TranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'test-files/my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript/my-first-transcription.json.
    ///
    ///
    /// If you specify the name of an Amazon S3 bucket sub-folder that doesn't exist, one is created for you.
    public var outputKey: Swift.String?
    /// Specify additional optional settings in your request, including channel identification, alternative transcriptions, speaker partitioning. You can use that to apply custom vocabularies and vocabulary filters. If you want to include a custom vocabulary or a custom vocabulary filter (or both) with your request but do not want to use automatic language identification, use Settings with the VocabularyName or VocabularyFilterName (or both) sub-parameter. If you're using automatic language identification with your request and want to include a custom language model, a custom vocabulary, or a custom vocabulary filter, use instead the  parameter with the LanguageModelName, VocabularyName or VocabularyFilterName sub-parameters.
    public var settings: TranscribeClientTypes.Settings?
    /// Produces subtitle files for your input media. You can specify WebVTT (*.vtt) and SubRip (*.srt) formats.
    public var subtitles: TranscribeClientTypes.Subtitles?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new transcription job at the time you start this new job. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// Enables toxic speech detection in your transcript. If you include ToxicityDetection in your request, you must also include ToxicityCategories. For information on the types of toxic speech Amazon Transcribe can detect, see [Detecting toxic speech](https://docs.aws.amazon.com/transcribe/latest/dg/toxic-language.html).
    public var toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
    /// A unique name, chosen by you, for your transcription job. The name that you specify is also used as the default name of your transcription output file. If you want to specify a different name for your transcription output, use the OutputKey parameter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var transcriptionJobName: Swift.String?

    public init(
        contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
        identifyLanguage: Swift.Bool? = nil,
        identifyMultipleLanguages: Swift.Bool? = nil,
        jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings? = nil,
        kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        languageIdSettings: [Swift.String: TranscribeClientTypes.LanguageIdSettings]? = nil,
        languageOptions: [TranscribeClientTypes.LanguageCode]? = nil,
        media: TranscribeClientTypes.Media? = nil,
        mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        modelSettings: TranscribeClientTypes.ModelSettings? = nil,
        outputBucketName: Swift.String? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        outputKey: Swift.String? = nil,
        settings: TranscribeClientTypes.Settings? = nil,
        subtitles: TranscribeClientTypes.Subtitles? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]? = nil,
        transcriptionJobName: Swift.String? = nil
    )
    {
        self.contentRedaction = contentRedaction
        self.identifyLanguage = identifyLanguage
        self.identifyMultipleLanguages = identifyMultipleLanguages
        self.jobExecutionSettings = jobExecutionSettings
        self.kmsEncryptionContext = kmsEncryptionContext
        self.languageCode = languageCode
        self.languageIdSettings = languageIdSettings
        self.languageOptions = languageOptions
        self.media = media
        self.mediaFormat = mediaFormat
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.modelSettings = modelSettings
        self.outputBucketName = outputBucketName
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.outputKey = outputKey
        self.settings = settings
        self.subtitles = subtitles
        self.tags = tags
        self.toxicityDetection = toxicityDetection
        self.transcriptionJobName = transcriptionJobName
    }
}

public struct StartTranscriptionJobOutput: Swift.Sendable {
    /// Provides detailed information about the current transcription job, including job status and, if applicable, failure reason.
    public var transcriptionJob: TranscribeClientTypes.TranscriptionJob?

    public init(
        transcriptionJob: TranscribeClientTypes.TranscriptionJob? = nil
    )
    {
        self.transcriptionJob = transcriptionJob
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource you want to tag. ARNs have the format arn:partition:service:region:account-id:resource-type/resource-id. For example, arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name. Valid values for resource-type are: transcription-job, medical-transcription-job, vocabulary, medical-vocabulary, vocabulary-filter, and language-model.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds one or more custom tags, each in the form of a key:value pair, to the specified resource. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    /// This member is required.
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to remove tags from. ARNs have the format arn:partition:service:region:account-id:resource-type/resource-id. For example, arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name. Valid values for resource-type are: transcription-job, medical-transcription-job, vocabulary, medical-vocabulary, vocabulary-filter, and language-model.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Removes the specified tag keys from the specified Amazon Transcribe resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCallAnalyticsCategoryInput: Swift.Sendable {
    /// The name of the Call Analytics category you want to update. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?
    /// Choose whether you want to update a real-time or a post-call category. The input type you specify must match the input type specified when the category was created. For example, if you created a category with the POST_CALL input type, you must use POST_CALL as the input type when updating this category.
    public var inputType: TranscribeClientTypes.InputType?
    /// The rules used for the updated Call Analytics category. The rules you provide in this field replace the ones that are currently being used in the specified category.
    /// This member is required.
    public var rules: [TranscribeClientTypes.Rule]?

    public init(
        categoryName: Swift.String? = nil,
        inputType: TranscribeClientTypes.InputType? = nil,
        rules: [TranscribeClientTypes.Rule]? = nil
    )
    {
        self.categoryName = categoryName
        self.inputType = inputType
        self.rules = rules
    }
}

public struct UpdateCallAnalyticsCategoryOutput: Swift.Sendable {
    /// Provides you with the properties of the Call Analytics category you specified in your UpdateCallAnalyticsCategory request.
    public var categoryProperties: TranscribeClientTypes.CategoryProperties?

    public init(
        categoryProperties: TranscribeClientTypes.CategoryProperties? = nil
    )
    {
        self.categoryProperties = categoryProperties
    }
}

public struct UpdateMedicalVocabularyInput: Swift.Sendable {
    /// The language code that represents the language of the entries in the custom vocabulary you want to update. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The Amazon S3 location of the text file that contains your custom medical vocabulary. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt
    /// This member is required.
    public var vocabularyFileUri: Swift.String?
    /// The name of the custom medical vocabulary you want to update. Custom medical vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

public struct UpdateMedicalVocabularyOutput: Swift.Sendable {
    /// The language code you selected for your custom medical vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom medical vocabulary was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the updated custom medical vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom medical vocabulary. If the state is READY, you can use the custom vocabulary in a StartMedicalTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

public struct UpdateVocabularyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary). If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The language code that represents the language of the entries in the custom vocabulary you want to update. Each custom vocabulary must contain terms in only one language. A custom vocabulary can only be used to transcribe files in the same language as the custom vocabulary. For example, if you create a custom vocabulary using US English (en-US), you can only apply this custom vocabulary to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Use this parameter if you want to update your custom vocabulary by including all desired terms, as comma-separated values, within your request. The other option for updating your custom vocabulary is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFileUri parameter. Note that if you include Phrases in your request, you cannot use VocabularyFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var phrases: [Swift.String]?
    /// The Amazon S3 location of the text file that contains your custom vocabulary. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt Note that if you include VocabularyFileUri in your request, you cannot use the Phrases flag; you must choose one or the other.
    public var vocabularyFileUri: Swift.String?
    /// The name of the custom vocabulary you want to update. Custom vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        phrases: [Swift.String]? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.languageCode = languageCode
        self.phrases = phrases
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

public struct UpdateVocabularyOutput: Swift.Sendable {
    /// The language code you selected for your custom vocabulary.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the updated custom vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

public struct UpdateVocabularyFilterInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary filter). If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The Amazon S3 location of the text file that contains your custom vocabulary filter terms. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-filter-file.txt Note that if you include VocabularyFilterFileUri in your request, you cannot use Words; you must choose one or the other.
    public var vocabularyFilterFileUri: Swift.String?
    /// The name of the custom vocabulary filter you want to update. Custom vocabulary filter names are case sensitive.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?
    /// Use this parameter if you want to update your custom vocabulary filter by including all desired terms, as comma-separated values, within your request. The other option for updating your vocabulary filter is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFilterFileUri parameter. Note that if you include Words in your request, you cannot use VocabularyFilterFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var words: [Swift.String]?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        vocabularyFilterFileUri: Swift.String? = nil,
        vocabularyFilterName: Swift.String? = nil,
        words: [Swift.String]? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.vocabularyFilterFileUri = vocabularyFilterFileUri
        self.vocabularyFilterName = vocabularyFilterName
        self.words = words
    }
}

public struct UpdateVocabularyFilterOutput: Swift.Sendable {
    /// The language code you selected for your custom vocabulary filter.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary filter was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the updated custom vocabulary filter.
    public var vocabularyFilterName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyFilterName = vocabularyFilterName
    }
}

extension CreateCallAnalyticsCategoryInput {

    static func urlPathProvider(_ value: CreateCallAnalyticsCategoryInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLanguageModelInput {

    static func urlPathProvider(_ value: CreateLanguageModelInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMedicalVocabularyInput {

    static func urlPathProvider(_ value: CreateMedicalVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVocabularyInput {

    static func urlPathProvider(_ value: CreateVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVocabularyFilterInput {

    static func urlPathProvider(_ value: CreateVocabularyFilterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCallAnalyticsCategoryInput {

    static func urlPathProvider(_ value: DeleteCallAnalyticsCategoryInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCallAnalyticsJobInput {

    static func urlPathProvider(_ value: DeleteCallAnalyticsJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLanguageModelInput {

    static func urlPathProvider(_ value: DeleteLanguageModelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMedicalScribeJobInput {

    static func urlPathProvider(_ value: DeleteMedicalScribeJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMedicalTranscriptionJobInput {

    static func urlPathProvider(_ value: DeleteMedicalTranscriptionJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMedicalVocabularyInput {

    static func urlPathProvider(_ value: DeleteMedicalVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTranscriptionJobInput {

    static func urlPathProvider(_ value: DeleteTranscriptionJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVocabularyInput {

    static func urlPathProvider(_ value: DeleteVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVocabularyFilterInput {

    static func urlPathProvider(_ value: DeleteVocabularyFilterInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLanguageModelInput {

    static func urlPathProvider(_ value: DescribeLanguageModelInput) -> Swift.String? {
        return "/"
    }
}

extension GetCallAnalyticsCategoryInput {

    static func urlPathProvider(_ value: GetCallAnalyticsCategoryInput) -> Swift.String? {
        return "/"
    }
}

extension GetCallAnalyticsJobInput {

    static func urlPathProvider(_ value: GetCallAnalyticsJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetMedicalScribeJobInput {

    static func urlPathProvider(_ value: GetMedicalScribeJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetMedicalTranscriptionJobInput {

    static func urlPathProvider(_ value: GetMedicalTranscriptionJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetMedicalVocabularyInput {

    static func urlPathProvider(_ value: GetMedicalVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension GetTranscriptionJobInput {

    static func urlPathProvider(_ value: GetTranscriptionJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetVocabularyInput {

    static func urlPathProvider(_ value: GetVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension GetVocabularyFilterInput {

    static func urlPathProvider(_ value: GetVocabularyFilterInput) -> Swift.String? {
        return "/"
    }
}

extension ListCallAnalyticsCategoriesInput {

    static func urlPathProvider(_ value: ListCallAnalyticsCategoriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListCallAnalyticsCategoriesInput {

    static func queryItemProvider(_ value: ListCallAnalyticsCategoriesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListCallAnalyticsJobsInput {

    static func urlPathProvider(_ value: ListCallAnalyticsJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCallAnalyticsJobsInput {

    static func queryItemProvider(_ value: ListCallAnalyticsJobsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListLanguageModelsInput {

    static func urlPathProvider(_ value: ListLanguageModelsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLanguageModelsInput {

    static func queryItemProvider(_ value: ListLanguageModelsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListMedicalScribeJobsInput {

    static func urlPathProvider(_ value: ListMedicalScribeJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMedicalScribeJobsInput {

    static func queryItemProvider(_ value: ListMedicalScribeJobsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListMedicalTranscriptionJobsInput {

    static func urlPathProvider(_ value: ListMedicalTranscriptionJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMedicalTranscriptionJobsInput {

    static func queryItemProvider(_ value: ListMedicalTranscriptionJobsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListMedicalVocabulariesInput {

    static func urlPathProvider(_ value: ListMedicalVocabulariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListMedicalVocabulariesInput {

    static func queryItemProvider(_ value: ListMedicalVocabulariesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTranscriptionJobsInput {

    static func urlPathProvider(_ value: ListTranscriptionJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTranscriptionJobsInput {

    static func queryItemProvider(_ value: ListTranscriptionJobsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListVocabulariesInput {

    static func urlPathProvider(_ value: ListVocabulariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListVocabulariesInput {

    static func queryItemProvider(_ value: ListVocabulariesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListVocabularyFiltersInput {

    static func urlPathProvider(_ value: ListVocabularyFiltersInput) -> Swift.String? {
        return "/"
    }
}

extension ListVocabularyFiltersInput {

    static func queryItemProvider(_ value: ListVocabularyFiltersInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension StartCallAnalyticsJobInput {

    static func urlPathProvider(_ value: StartCallAnalyticsJobInput) -> Swift.String? {
        return "/"
    }
}

extension StartMedicalScribeJobInput {

    static func urlPathProvider(_ value: StartMedicalScribeJobInput) -> Swift.String? {
        return "/"
    }
}

extension StartMedicalTranscriptionJobInput {

    static func urlPathProvider(_ value: StartMedicalTranscriptionJobInput) -> Swift.String? {
        return "/"
    }
}

extension StartTranscriptionJobInput {

    static func urlPathProvider(_ value: StartTranscriptionJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCallAnalyticsCategoryInput {

    static func urlPathProvider(_ value: UpdateCallAnalyticsCategoryInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMedicalVocabularyInput {

    static func urlPathProvider(_ value: UpdateMedicalVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVocabularyInput {

    static func urlPathProvider(_ value: UpdateVocabularyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVocabularyFilterInput {

    static func urlPathProvider(_ value: UpdateVocabularyFilterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCallAnalyticsCategoryInput {

    static func write(value: CreateCallAnalyticsCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputType"].write(value.inputType)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: TranscribeClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLanguageModelInput {

    static func write(value: CreateLanguageModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseModelName"].write(value.baseModelName)
        try writer["InputDataConfig"].write(value.inputDataConfig, with: TranscribeClientTypes.InputDataConfig.write(value:to:))
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMedicalVocabularyInput {

    static func write(value: CreateMedicalVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VocabularyFileUri"].write(value.vocabularyFileUri)
    }
}

extension CreateVocabularyInput {

    static func write(value: CreateVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Phrases"].writeList(value.phrases, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VocabularyFileUri"].write(value.vocabularyFileUri)
    }
}

extension CreateVocabularyFilterInput {

    static func write(value: CreateVocabularyFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VocabularyFilterFileUri"].write(value.vocabularyFilterFileUri)
        try writer["Words"].writeList(value.words, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteCallAnalyticsCategoryInput {

    static func write(value: DeleteCallAnalyticsCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteCallAnalyticsJobInput {

    static func write(value: DeleteCallAnalyticsJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteLanguageModelInput {

    static func write(value: DeleteLanguageModelInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteMedicalScribeJobInput {

    static func write(value: DeleteMedicalScribeJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteMedicalTranscriptionJobInput {

    static func write(value: DeleteMedicalTranscriptionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteMedicalVocabularyInput {

    static func write(value: DeleteMedicalVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteTranscriptionJobInput {

    static func write(value: DeleteTranscriptionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteVocabularyInput {

    static func write(value: DeleteVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteVocabularyFilterInput {

    static func write(value: DeleteVocabularyFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeLanguageModelInput {

    static func write(value: DescribeLanguageModelInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetCallAnalyticsCategoryInput {

    static func write(value: GetCallAnalyticsCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetCallAnalyticsJobInput {

    static func write(value: GetCallAnalyticsJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetMedicalScribeJobInput {

    static func write(value: GetMedicalScribeJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetMedicalTranscriptionJobInput {

    static func write(value: GetMedicalTranscriptionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetMedicalVocabularyInput {

    static func write(value: GetMedicalVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetTranscriptionJobInput {

    static func write(value: GetTranscriptionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetVocabularyInput {

    static func write(value: GetVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetVocabularyFilterInput {

    static func write(value: GetVocabularyFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListCallAnalyticsCategoriesInput {

    static func write(value: ListCallAnalyticsCategoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListCallAnalyticsJobsInput {

    static func write(value: ListCallAnalyticsJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListLanguageModelsInput {

    static func write(value: ListLanguageModelsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListMedicalScribeJobsInput {

    static func write(value: ListMedicalScribeJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListMedicalTranscriptionJobsInput {

    static func write(value: ListMedicalTranscriptionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListMedicalVocabulariesInput {

    static func write(value: ListMedicalVocabulariesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTranscriptionJobsInput {

    static func write(value: ListTranscriptionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListVocabulariesInput {

    static func write(value: ListVocabulariesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListVocabularyFiltersInput {

    static func write(value: ListVocabularyFiltersInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension StartCallAnalyticsJobInput {

    static func write(value: StartCallAnalyticsJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelDefinitions"].writeList(value.channelDefinitions, memberWritingClosure: TranscribeClientTypes.ChannelDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["Media"].write(value.media, with: TranscribeClientTypes.Media.write(value:to:))
        try writer["OutputEncryptionKMSKeyId"].write(value.outputEncryptionKMSKeyId)
        try writer["OutputLocation"].write(value.outputLocation)
        try writer["Settings"].write(value.settings, with: TranscribeClientTypes.CallAnalyticsJobSettings.write(value:to:))
    }
}

extension StartMedicalScribeJobInput {

    static func write(value: StartMedicalScribeJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelDefinitions"].writeList(value.channelDefinitions, memberWritingClosure: TranscribeClientTypes.MedicalScribeChannelDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["KMSEncryptionContext"].writeMap(value.kmsEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Media"].write(value.media, with: TranscribeClientTypes.Media.write(value:to:))
        try writer["OutputBucketName"].write(value.outputBucketName)
        try writer["OutputEncryptionKMSKeyId"].write(value.outputEncryptionKMSKeyId)
        try writer["Settings"].write(value.settings, with: TranscribeClientTypes.MedicalScribeSettings.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartMedicalTranscriptionJobInput {

    static func write(value: StartMedicalTranscriptionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["KMSEncryptionContext"].writeMap(value.kmsEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Media"].write(value.media, with: TranscribeClientTypes.Media.write(value:to:))
        try writer["MediaFormat"].write(value.mediaFormat)
        try writer["MediaSampleRateHertz"].write(value.mediaSampleRateHertz)
        try writer["OutputBucketName"].write(value.outputBucketName)
        try writer["OutputEncryptionKMSKeyId"].write(value.outputEncryptionKMSKeyId)
        try writer["OutputKey"].write(value.outputKey)
        try writer["Settings"].write(value.settings, with: TranscribeClientTypes.MedicalTranscriptionSetting.write(value:to:))
        try writer["Specialty"].write(value.specialty)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension StartTranscriptionJobInput {

    static func write(value: StartTranscriptionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentRedaction"].write(value.contentRedaction, with: TranscribeClientTypes.ContentRedaction.write(value:to:))
        try writer["IdentifyLanguage"].write(value.identifyLanguage)
        try writer["IdentifyMultipleLanguages"].write(value.identifyMultipleLanguages)
        try writer["JobExecutionSettings"].write(value.jobExecutionSettings, with: TranscribeClientTypes.JobExecutionSettings.write(value:to:))
        try writer["KMSEncryptionContext"].writeMap(value.kmsEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LanguageIdSettings"].writeMap(value.languageIdSettings, valueWritingClosure: TranscribeClientTypes.LanguageIdSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["LanguageOptions"].writeList(value.languageOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TranscribeClientTypes.LanguageCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Media"].write(value.media, with: TranscribeClientTypes.Media.write(value:to:))
        try writer["MediaFormat"].write(value.mediaFormat)
        try writer["MediaSampleRateHertz"].write(value.mediaSampleRateHertz)
        try writer["ModelSettings"].write(value.modelSettings, with: TranscribeClientTypes.ModelSettings.write(value:to:))
        try writer["OutputBucketName"].write(value.outputBucketName)
        try writer["OutputEncryptionKMSKeyId"].write(value.outputEncryptionKMSKeyId)
        try writer["OutputKey"].write(value.outputKey)
        try writer["Settings"].write(value.settings, with: TranscribeClientTypes.Settings.write(value:to:))
        try writer["Subtitles"].write(value.subtitles, with: TranscribeClientTypes.Subtitles.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ToxicityDetection"].writeList(value.toxicityDetection, memberWritingClosure: TranscribeClientTypes.ToxicityDetectionSettings.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TranscribeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCallAnalyticsCategoryInput {

    static func write(value: UpdateCallAnalyticsCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputType"].write(value.inputType)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: TranscribeClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMedicalVocabularyInput {

    static func write(value: UpdateMedicalVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LanguageCode"].write(value.languageCode)
        try writer["VocabularyFileUri"].write(value.vocabularyFileUri)
    }
}

extension UpdateVocabularyInput {

    static func write(value: UpdateVocabularyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Phrases"].writeList(value.phrases, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VocabularyFileUri"].write(value.vocabularyFileUri)
    }
}

extension UpdateVocabularyFilterInput {

    static func write(value: UpdateVocabularyFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["VocabularyFilterFileUri"].write(value.vocabularyFilterFileUri)
        try writer["Words"].writeList(value.words, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCallAnalyticsCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCallAnalyticsCategoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCallAnalyticsCategoryOutput()
        value.categoryProperties = try reader["CategoryProperties"].readIfPresent(with: TranscribeClientTypes.CategoryProperties.read(from:))
        return value
    }
}

extension CreateLanguageModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLanguageModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLanguageModelOutput()
        value.baseModelName = try reader["BaseModelName"].readIfPresent()
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: TranscribeClientTypes.InputDataConfig.read(from:))
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.modelName = try reader["ModelName"].readIfPresent()
        value.modelStatus = try reader["ModelStatus"].readIfPresent()
        return value
    }
}

extension CreateMedicalVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMedicalVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMedicalVocabularyOutput()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension CreateVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVocabularyOutput()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension CreateVocabularyFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVocabularyFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVocabularyFilterOutput()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        return value
    }
}

extension DeleteCallAnalyticsCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCallAnalyticsCategoryOutput {
        return DeleteCallAnalyticsCategoryOutput()
    }
}

extension DeleteCallAnalyticsJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCallAnalyticsJobOutput {
        return DeleteCallAnalyticsJobOutput()
    }
}

extension DeleteLanguageModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLanguageModelOutput {
        return DeleteLanguageModelOutput()
    }
}

extension DeleteMedicalScribeJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMedicalScribeJobOutput {
        return DeleteMedicalScribeJobOutput()
    }
}

extension DeleteMedicalTranscriptionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMedicalTranscriptionJobOutput {
        return DeleteMedicalTranscriptionJobOutput()
    }
}

extension DeleteMedicalVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMedicalVocabularyOutput {
        return DeleteMedicalVocabularyOutput()
    }
}

extension DeleteTranscriptionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTranscriptionJobOutput {
        return DeleteTranscriptionJobOutput()
    }
}

extension DeleteVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVocabularyOutput {
        return DeleteVocabularyOutput()
    }
}

extension DeleteVocabularyFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVocabularyFilterOutput {
        return DeleteVocabularyFilterOutput()
    }
}

extension DescribeLanguageModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLanguageModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLanguageModelOutput()
        value.languageModel = try reader["LanguageModel"].readIfPresent(with: TranscribeClientTypes.LanguageModel.read(from:))
        return value
    }
}

extension GetCallAnalyticsCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCallAnalyticsCategoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCallAnalyticsCategoryOutput()
        value.categoryProperties = try reader["CategoryProperties"].readIfPresent(with: TranscribeClientTypes.CategoryProperties.read(from:))
        return value
    }
}

extension GetCallAnalyticsJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCallAnalyticsJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCallAnalyticsJobOutput()
        value.callAnalyticsJob = try reader["CallAnalyticsJob"].readIfPresent(with: TranscribeClientTypes.CallAnalyticsJob.read(from:))
        return value
    }
}

extension GetMedicalScribeJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMedicalScribeJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMedicalScribeJobOutput()
        value.medicalScribeJob = try reader["MedicalScribeJob"].readIfPresent(with: TranscribeClientTypes.MedicalScribeJob.read(from:))
        return value
    }
}

extension GetMedicalTranscriptionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMedicalTranscriptionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMedicalTranscriptionJobOutput()
        value.medicalTranscriptionJob = try reader["MedicalTranscriptionJob"].readIfPresent(with: TranscribeClientTypes.MedicalTranscriptionJob.read(from:))
        return value
    }
}

extension GetMedicalVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMedicalVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMedicalVocabularyOutput()
        value.downloadUri = try reader["DownloadUri"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension GetTranscriptionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTranscriptionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTranscriptionJobOutput()
        value.transcriptionJob = try reader["TranscriptionJob"].readIfPresent(with: TranscribeClientTypes.TranscriptionJob.read(from:))
        return value
    }
}

extension GetVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVocabularyOutput()
        value.downloadUri = try reader["DownloadUri"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension GetVocabularyFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVocabularyFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVocabularyFilterOutput()
        value.downloadUri = try reader["DownloadUri"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        return value
    }
}

extension ListCallAnalyticsCategoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCallAnalyticsCategoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCallAnalyticsCategoriesOutput()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.CategoryProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCallAnalyticsJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCallAnalyticsJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCallAnalyticsJobsOutput()
        value.callAnalyticsJobSummaries = try reader["CallAnalyticsJobSummaries"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.CallAnalyticsJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ListLanguageModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLanguageModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLanguageModelsOutput()
        value.models = try reader["Models"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.LanguageModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMedicalScribeJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMedicalScribeJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMedicalScribeJobsOutput()
        value.medicalScribeJobSummaries = try reader["MedicalScribeJobSummaries"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.MedicalScribeJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ListMedicalTranscriptionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMedicalTranscriptionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMedicalTranscriptionJobsOutput()
        value.medicalTranscriptionJobSummaries = try reader["MedicalTranscriptionJobSummaries"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.MedicalTranscriptionJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ListMedicalVocabulariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMedicalVocabulariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMedicalVocabulariesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.vocabularies = try reader["Vocabularies"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.VocabularyInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTranscriptionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTranscriptionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTranscriptionJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.transcriptionJobSummaries = try reader["TranscriptionJobSummaries"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.TranscriptionJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVocabulariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVocabulariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVocabulariesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.vocabularies = try reader["Vocabularies"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.VocabularyInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVocabularyFiltersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVocabularyFiltersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVocabularyFiltersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.vocabularyFilters = try reader["VocabularyFilters"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.VocabularyFilterInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartCallAnalyticsJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCallAnalyticsJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCallAnalyticsJobOutput()
        value.callAnalyticsJob = try reader["CallAnalyticsJob"].readIfPresent(with: TranscribeClientTypes.CallAnalyticsJob.read(from:))
        return value
    }
}

extension StartMedicalScribeJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMedicalScribeJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMedicalScribeJobOutput()
        value.medicalScribeJob = try reader["MedicalScribeJob"].readIfPresent(with: TranscribeClientTypes.MedicalScribeJob.read(from:))
        return value
    }
}

extension StartMedicalTranscriptionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMedicalTranscriptionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMedicalTranscriptionJobOutput()
        value.medicalTranscriptionJob = try reader["MedicalTranscriptionJob"].readIfPresent(with: TranscribeClientTypes.MedicalTranscriptionJob.read(from:))
        return value
    }
}

extension StartTranscriptionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTranscriptionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTranscriptionJobOutput()
        value.transcriptionJob = try reader["TranscriptionJob"].readIfPresent(with: TranscribeClientTypes.TranscriptionJob.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCallAnalyticsCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCallAnalyticsCategoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCallAnalyticsCategoryOutput()
        value.categoryProperties = try reader["CategoryProperties"].readIfPresent(with: TranscribeClientTypes.CategoryProperties.read(from:))
        return value
    }
}

extension UpdateMedicalVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMedicalVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMedicalVocabularyOutput()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension UpdateVocabularyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVocabularyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVocabularyOutput()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension UpdateVocabularyFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVocabularyFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVocabularyFilterOutput()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        return value
    }
}

enum CreateCallAnalyticsCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLanguageModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMedicalVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVocabularyFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCallAnalyticsCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCallAnalyticsJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLanguageModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMedicalScribeJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMedicalTranscriptionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMedicalVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTranscriptionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVocabularyFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLanguageModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCallAnalyticsCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCallAnalyticsJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMedicalScribeJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMedicalTranscriptionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMedicalVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTranscriptionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVocabularyFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCallAnalyticsCategoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCallAnalyticsJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLanguageModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMedicalScribeJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMedicalTranscriptionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMedicalVocabulariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTranscriptionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVocabulariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVocabularyFiltersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCallAnalyticsJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMedicalScribeJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMedicalTranscriptionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTranscriptionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCallAnalyticsCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMedicalVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVocabularyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVocabularyFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TranscribeClientTypes.CategoryProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.CategoryProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.CategoryProperties()
        value.categoryName = try reader["CategoryName"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inputType = try reader["InputType"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.Rule {

    static func write(value: TranscribeClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .interruptionfilter(interruptionfilter):
                try writer["InterruptionFilter"].write(interruptionfilter, with: TranscribeClientTypes.InterruptionFilter.write(value:to:))
            case let .nontalktimefilter(nontalktimefilter):
                try writer["NonTalkTimeFilter"].write(nontalktimefilter, with: TranscribeClientTypes.NonTalkTimeFilter.write(value:to:))
            case let .sentimentfilter(sentimentfilter):
                try writer["SentimentFilter"].write(sentimentfilter, with: TranscribeClientTypes.SentimentFilter.write(value:to:))
            case let .transcriptfilter(transcriptfilter):
                try writer["TranscriptFilter"].write(transcriptfilter, with: TranscribeClientTypes.TranscriptFilter.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "NonTalkTimeFilter":
                return .nontalktimefilter(try reader["NonTalkTimeFilter"].read(with: TranscribeClientTypes.NonTalkTimeFilter.read(from:)))
            case "InterruptionFilter":
                return .interruptionfilter(try reader["InterruptionFilter"].read(with: TranscribeClientTypes.InterruptionFilter.read(from:)))
            case "TranscriptFilter":
                return .transcriptfilter(try reader["TranscriptFilter"].read(with: TranscribeClientTypes.TranscriptFilter.read(from:)))
            case "SentimentFilter":
                return .sentimentfilter(try reader["SentimentFilter"].read(with: TranscribeClientTypes.SentimentFilter.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension TranscribeClientTypes.SentimentFilter {

    static func write(value: TranscribeClientTypes.SentimentFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbsoluteTimeRange"].write(value.absoluteTimeRange, with: TranscribeClientTypes.AbsoluteTimeRange.write(value:to:))
        try writer["Negate"].write(value.negate)
        try writer["ParticipantRole"].write(value.participantRole)
        try writer["RelativeTimeRange"].write(value.relativeTimeRange, with: TranscribeClientTypes.RelativeTimeRange.write(value:to:))
        try writer["Sentiments"].writeList(value.sentiments, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TranscribeClientTypes.SentimentValue>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.SentimentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.SentimentFilter()
        value.sentiments = try reader["Sentiments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TranscribeClientTypes.SentimentValue>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.absoluteTimeRange = try reader["AbsoluteTimeRange"].readIfPresent(with: TranscribeClientTypes.AbsoluteTimeRange.read(from:))
        value.relativeTimeRange = try reader["RelativeTimeRange"].readIfPresent(with: TranscribeClientTypes.RelativeTimeRange.read(from:))
        value.participantRole = try reader["ParticipantRole"].readIfPresent()
        value.negate = try reader["Negate"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.RelativeTimeRange {

    static func write(value: TranscribeClientTypes.RelativeTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndPercentage"].write(value.endPercentage)
        try writer["First"].write(value.first)
        try writer["Last"].write(value.last)
        try writer["StartPercentage"].write(value.startPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.RelativeTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.RelativeTimeRange()
        value.startPercentage = try reader["StartPercentage"].readIfPresent()
        value.endPercentage = try reader["EndPercentage"].readIfPresent()
        value.first = try reader["First"].readIfPresent()
        value.last = try reader["Last"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.AbsoluteTimeRange {

    static func write(value: TranscribeClientTypes.AbsoluteTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].write(value.endTime)
        try writer["First"].write(value.first)
        try writer["Last"].write(value.last)
        try writer["StartTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.AbsoluteTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.AbsoluteTimeRange()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.first = try reader["First"].readIfPresent()
        value.last = try reader["Last"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.TranscriptFilter {

    static func write(value: TranscribeClientTypes.TranscriptFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbsoluteTimeRange"].write(value.absoluteTimeRange, with: TranscribeClientTypes.AbsoluteTimeRange.write(value:to:))
        try writer["Negate"].write(value.negate)
        try writer["ParticipantRole"].write(value.participantRole)
        try writer["RelativeTimeRange"].write(value.relativeTimeRange, with: TranscribeClientTypes.RelativeTimeRange.write(value:to:))
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TranscriptFilterType"].write(value.transcriptFilterType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.TranscriptFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.TranscriptFilter()
        value.transcriptFilterType = try reader["TranscriptFilterType"].readIfPresent() ?? .sdkUnknown("")
        value.absoluteTimeRange = try reader["AbsoluteTimeRange"].readIfPresent(with: TranscribeClientTypes.AbsoluteTimeRange.read(from:))
        value.relativeTimeRange = try reader["RelativeTimeRange"].readIfPresent(with: TranscribeClientTypes.RelativeTimeRange.read(from:))
        value.participantRole = try reader["ParticipantRole"].readIfPresent()
        value.negate = try reader["Negate"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TranscribeClientTypes.InterruptionFilter {

    static func write(value: TranscribeClientTypes.InterruptionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbsoluteTimeRange"].write(value.absoluteTimeRange, with: TranscribeClientTypes.AbsoluteTimeRange.write(value:to:))
        try writer["Negate"].write(value.negate)
        try writer["ParticipantRole"].write(value.participantRole)
        try writer["RelativeTimeRange"].write(value.relativeTimeRange, with: TranscribeClientTypes.RelativeTimeRange.write(value:to:))
        try writer["Threshold"].write(value.threshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.InterruptionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.InterruptionFilter()
        value.threshold = try reader["Threshold"].readIfPresent()
        value.participantRole = try reader["ParticipantRole"].readIfPresent()
        value.absoluteTimeRange = try reader["AbsoluteTimeRange"].readIfPresent(with: TranscribeClientTypes.AbsoluteTimeRange.read(from:))
        value.relativeTimeRange = try reader["RelativeTimeRange"].readIfPresent(with: TranscribeClientTypes.RelativeTimeRange.read(from:))
        value.negate = try reader["Negate"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.NonTalkTimeFilter {

    static func write(value: TranscribeClientTypes.NonTalkTimeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbsoluteTimeRange"].write(value.absoluteTimeRange, with: TranscribeClientTypes.AbsoluteTimeRange.write(value:to:))
        try writer["Negate"].write(value.negate)
        try writer["RelativeTimeRange"].write(value.relativeTimeRange, with: TranscribeClientTypes.RelativeTimeRange.write(value:to:))
        try writer["Threshold"].write(value.threshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.NonTalkTimeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.NonTalkTimeFilter()
        value.threshold = try reader["Threshold"].readIfPresent()
        value.absoluteTimeRange = try reader["AbsoluteTimeRange"].readIfPresent(with: TranscribeClientTypes.AbsoluteTimeRange.read(from:))
        value.relativeTimeRange = try reader["RelativeTimeRange"].readIfPresent(with: TranscribeClientTypes.RelativeTimeRange.read(from:))
        value.negate = try reader["Negate"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.InputDataConfig {

    static func write(value: TranscribeClientTypes.InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["S3Uri"].write(value.s3Uri)
        try writer["TuningDataS3Uri"].write(value.tuningDataS3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.InputDataConfig()
        value.s3Uri = try reader["S3Uri"].readIfPresent() ?? ""
        value.tuningDataS3Uri = try reader["TuningDataS3Uri"].readIfPresent()
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension TranscribeClientTypes.LanguageModel {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.LanguageModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.LanguageModel()
        value.modelName = try reader["ModelName"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.baseModelName = try reader["BaseModelName"].readIfPresent()
        value.modelStatus = try reader["ModelStatus"].readIfPresent()
        value.upgradeAvailability = try reader["UpgradeAvailability"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: TranscribeClientTypes.InputDataConfig.read(from:))
        return value
    }
}

extension TranscribeClientTypes.CallAnalyticsJob {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.CallAnalyticsJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.CallAnalyticsJob()
        value.callAnalyticsJobName = try reader["CallAnalyticsJobName"].readIfPresent()
        value.callAnalyticsJobStatus = try reader["CallAnalyticsJobStatus"].readIfPresent()
        value.callAnalyticsJobDetails = try reader["CallAnalyticsJobDetails"].readIfPresent(with: TranscribeClientTypes.CallAnalyticsJobDetails.read(from:))
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.mediaSampleRateHertz = try reader["MediaSampleRateHertz"].readIfPresent()
        value.mediaFormat = try reader["MediaFormat"].readIfPresent()
        value.media = try reader["Media"].readIfPresent(with: TranscribeClientTypes.Media.read(from:))
        value.transcript = try reader["Transcript"].readIfPresent(with: TranscribeClientTypes.Transcript.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.identifiedLanguageScore = try reader["IdentifiedLanguageScore"].readIfPresent()
        value.settings = try reader["Settings"].readIfPresent(with: TranscribeClientTypes.CallAnalyticsJobSettings.read(from:))
        value.channelDefinitions = try reader["ChannelDefinitions"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.ChannelDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.ChannelDefinition {

    static func write(value: TranscribeClientTypes.ChannelDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelId"].write(value.channelId)
        try writer["ParticipantRole"].write(value.participantRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.ChannelDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.ChannelDefinition()
        value.channelId = try reader["ChannelId"].readIfPresent() ?? 0
        value.participantRole = try reader["ParticipantRole"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.CallAnalyticsJobSettings {

    static func write(value: TranscribeClientTypes.CallAnalyticsJobSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentRedaction"].write(value.contentRedaction, with: TranscribeClientTypes.ContentRedaction.write(value:to:))
        try writer["LanguageIdSettings"].writeMap(value.languageIdSettings, valueWritingClosure: TranscribeClientTypes.LanguageIdSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["LanguageModelName"].write(value.languageModelName)
        try writer["LanguageOptions"].writeList(value.languageOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TranscribeClientTypes.LanguageCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Summarization"].write(value.summarization, with: TranscribeClientTypes.Summarization.write(value:to:))
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyName"].write(value.vocabularyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.CallAnalyticsJobSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.CallAnalyticsJobSettings()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.vocabularyFilterMethod = try reader["VocabularyFilterMethod"].readIfPresent()
        value.languageModelName = try reader["LanguageModelName"].readIfPresent()
        value.contentRedaction = try reader["ContentRedaction"].readIfPresent(with: TranscribeClientTypes.ContentRedaction.read(from:))
        value.languageOptions = try reader["LanguageOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TranscribeClientTypes.LanguageCode>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.languageIdSettings = try reader["LanguageIdSettings"].readMapIfPresent(valueReadingClosure: TranscribeClientTypes.LanguageIdSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.summarization = try reader["Summarization"].readIfPresent(with: TranscribeClientTypes.Summarization.read(from:))
        return value
    }
}

extension TranscribeClientTypes.Summarization {

    static func write(value: TranscribeClientTypes.Summarization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GenerateAbstractiveSummary"].write(value.generateAbstractiveSummary)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.Summarization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.Summarization()
        value.generateAbstractiveSummary = try reader["GenerateAbstractiveSummary"].readIfPresent() ?? false
        return value
    }
}

extension TranscribeClientTypes.LanguageIdSettings {

    static func write(value: TranscribeClientTypes.LanguageIdSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LanguageModelName"].write(value.languageModelName)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyName"].write(value.vocabularyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.LanguageIdSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.LanguageIdSettings()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.languageModelName = try reader["LanguageModelName"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.ContentRedaction {

    static func write(value: TranscribeClientTypes.ContentRedaction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PiiEntityTypes"].writeList(value.piiEntityTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TranscribeClientTypes.PiiEntityType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RedactionOutput"].write(value.redactionOutput)
        try writer["RedactionType"].write(value.redactionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.ContentRedaction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.ContentRedaction()
        value.redactionType = try reader["RedactionType"].readIfPresent() ?? .sdkUnknown("")
        value.redactionOutput = try reader["RedactionOutput"].readIfPresent() ?? .sdkUnknown("")
        value.piiEntityTypes = try reader["PiiEntityTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TranscribeClientTypes.PiiEntityType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.Transcript {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.Transcript {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.Transcript()
        value.transcriptFileUri = try reader["TranscriptFileUri"].readIfPresent()
        value.redactedTranscriptFileUri = try reader["RedactedTranscriptFileUri"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.Media {

    static func write(value: TranscribeClientTypes.Media?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaFileUri"].write(value.mediaFileUri)
        try writer["RedactedMediaFileUri"].write(value.redactedMediaFileUri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.Media {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.Media()
        value.mediaFileUri = try reader["MediaFileUri"].readIfPresent()
        value.redactedMediaFileUri = try reader["RedactedMediaFileUri"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.CallAnalyticsJobDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.CallAnalyticsJobDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.CallAnalyticsJobDetails()
        value.skipped = try reader["Skipped"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.CallAnalyticsSkippedFeature.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.CallAnalyticsSkippedFeature {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.CallAnalyticsSkippedFeature {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.CallAnalyticsSkippedFeature()
        value.feature = try reader["Feature"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.MedicalScribeJob {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalScribeJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalScribeJob()
        value.medicalScribeJobName = try reader["MedicalScribeJobName"].readIfPresent()
        value.medicalScribeJobStatus = try reader["MedicalScribeJobStatus"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.media = try reader["Media"].readIfPresent(with: TranscribeClientTypes.Media.read(from:))
        value.medicalScribeOutput = try reader["MedicalScribeOutput"].readIfPresent(with: TranscribeClientTypes.MedicalScribeOutput.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.settings = try reader["Settings"].readIfPresent(with: TranscribeClientTypes.MedicalScribeSettings.read(from:))
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.channelDefinitions = try reader["ChannelDefinitions"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.MedicalScribeChannelDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.Tag {

    static func write(value: TranscribeClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension TranscribeClientTypes.MedicalScribeChannelDefinition {

    static func write(value: TranscribeClientTypes.MedicalScribeChannelDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelId"].write(value.channelId)
        try writer["ParticipantRole"].write(value.participantRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalScribeChannelDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalScribeChannelDefinition()
        value.channelId = try reader["ChannelId"].readIfPresent() ?? 0
        value.participantRole = try reader["ParticipantRole"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TranscribeClientTypes.MedicalScribeSettings {

    static func write(value: TranscribeClientTypes.MedicalScribeSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelIdentification"].write(value.channelIdentification)
        try writer["MaxSpeakerLabels"].write(value.maxSpeakerLabels)
        try writer["ShowSpeakerLabels"].write(value.showSpeakerLabels)
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyName"].write(value.vocabularyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalScribeSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalScribeSettings()
        value.showSpeakerLabels = try reader["ShowSpeakerLabels"].readIfPresent()
        value.maxSpeakerLabels = try reader["MaxSpeakerLabels"].readIfPresent()
        value.channelIdentification = try reader["ChannelIdentification"].readIfPresent()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.vocabularyFilterMethod = try reader["VocabularyFilterMethod"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.MedicalScribeOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalScribeOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalScribeOutput()
        value.transcriptFileUri = try reader["TranscriptFileUri"].readIfPresent() ?? ""
        value.clinicalDocumentUri = try reader["ClinicalDocumentUri"].readIfPresent() ?? ""
        return value
    }
}

extension TranscribeClientTypes.MedicalTranscriptionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalTranscriptionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalTranscriptionJob()
        value.medicalTranscriptionJobName = try reader["MedicalTranscriptionJobName"].readIfPresent()
        value.transcriptionJobStatus = try reader["TranscriptionJobStatus"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.mediaSampleRateHertz = try reader["MediaSampleRateHertz"].readIfPresent()
        value.mediaFormat = try reader["MediaFormat"].readIfPresent()
        value.media = try reader["Media"].readIfPresent(with: TranscribeClientTypes.Media.read(from:))
        value.transcript = try reader["Transcript"].readIfPresent(with: TranscribeClientTypes.MedicalTranscript.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.settings = try reader["Settings"].readIfPresent(with: TranscribeClientTypes.MedicalTranscriptionSetting.read(from:))
        value.contentIdentificationType = try reader["ContentIdentificationType"].readIfPresent()
        value.specialty = try reader["Specialty"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.MedicalTranscriptionSetting {

    static func write(value: TranscribeClientTypes.MedicalTranscriptionSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelIdentification"].write(value.channelIdentification)
        try writer["MaxAlternatives"].write(value.maxAlternatives)
        try writer["MaxSpeakerLabels"].write(value.maxSpeakerLabels)
        try writer["ShowAlternatives"].write(value.showAlternatives)
        try writer["ShowSpeakerLabels"].write(value.showSpeakerLabels)
        try writer["VocabularyName"].write(value.vocabularyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalTranscriptionSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalTranscriptionSetting()
        value.showSpeakerLabels = try reader["ShowSpeakerLabels"].readIfPresent()
        value.maxSpeakerLabels = try reader["MaxSpeakerLabels"].readIfPresent()
        value.channelIdentification = try reader["ChannelIdentification"].readIfPresent()
        value.showAlternatives = try reader["ShowAlternatives"].readIfPresent()
        value.maxAlternatives = try reader["MaxAlternatives"].readIfPresent()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.MedicalTranscript {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalTranscript {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalTranscript()
        value.transcriptFileUri = try reader["TranscriptFileUri"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.TranscriptionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.TranscriptionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.TranscriptionJob()
        value.transcriptionJobName = try reader["TranscriptionJobName"].readIfPresent()
        value.transcriptionJobStatus = try reader["TranscriptionJobStatus"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.mediaSampleRateHertz = try reader["MediaSampleRateHertz"].readIfPresent()
        value.mediaFormat = try reader["MediaFormat"].readIfPresent()
        value.media = try reader["Media"].readIfPresent(with: TranscribeClientTypes.Media.read(from:))
        value.transcript = try reader["Transcript"].readIfPresent(with: TranscribeClientTypes.Transcript.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.settings = try reader["Settings"].readIfPresent(with: TranscribeClientTypes.Settings.read(from:))
        value.modelSettings = try reader["ModelSettings"].readIfPresent(with: TranscribeClientTypes.ModelSettings.read(from:))
        value.jobExecutionSettings = try reader["JobExecutionSettings"].readIfPresent(with: TranscribeClientTypes.JobExecutionSettings.read(from:))
        value.contentRedaction = try reader["ContentRedaction"].readIfPresent(with: TranscribeClientTypes.ContentRedaction.read(from:))
        value.identifyLanguage = try reader["IdentifyLanguage"].readIfPresent()
        value.identifyMultipleLanguages = try reader["IdentifyMultipleLanguages"].readIfPresent()
        value.languageOptions = try reader["LanguageOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TranscribeClientTypes.LanguageCode>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.identifiedLanguageScore = try reader["IdentifiedLanguageScore"].readIfPresent()
        value.languageCodes = try reader["LanguageCodes"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.LanguageCodeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subtitles = try reader["Subtitles"].readIfPresent(with: TranscribeClientTypes.SubtitlesOutput.read(from:))
        value.languageIdSettings = try reader["LanguageIdSettings"].readMapIfPresent(valueReadingClosure: TranscribeClientTypes.LanguageIdSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.toxicityDetection = try reader["ToxicityDetection"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.ToxicityDetectionSettings.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.ToxicityDetectionSettings {

    static func write(value: TranscribeClientTypes.ToxicityDetectionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ToxicityCategories"].writeList(value.toxicityCategories, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TranscribeClientTypes.ToxicityCategory>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.ToxicityDetectionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.ToxicityDetectionSettings()
        value.toxicityCategories = try reader["ToxicityCategories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TranscribeClientTypes.ToxicityCategory>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TranscribeClientTypes.SubtitlesOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.SubtitlesOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.SubtitlesOutput()
        value.formats = try reader["Formats"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TranscribeClientTypes.SubtitleFormat>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subtitleFileUris = try reader["SubtitleFileUris"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputStartIndex = try reader["OutputStartIndex"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.LanguageCodeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.LanguageCodeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.LanguageCodeItem()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.durationInSeconds = try reader["DurationInSeconds"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.JobExecutionSettings {

    static func write(value: TranscribeClientTypes.JobExecutionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowDeferredExecution"].write(value.allowDeferredExecution)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.JobExecutionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.JobExecutionSettings()
        value.allowDeferredExecution = try reader["AllowDeferredExecution"].readIfPresent()
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.ModelSettings {

    static func write(value: TranscribeClientTypes.ModelSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LanguageModelName"].write(value.languageModelName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.ModelSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.ModelSettings()
        value.languageModelName = try reader["LanguageModelName"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.Settings {

    static func write(value: TranscribeClientTypes.Settings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelIdentification"].write(value.channelIdentification)
        try writer["MaxAlternatives"].write(value.maxAlternatives)
        try writer["MaxSpeakerLabels"].write(value.maxSpeakerLabels)
        try writer["ShowAlternatives"].write(value.showAlternatives)
        try writer["ShowSpeakerLabels"].write(value.showSpeakerLabels)
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyName"].write(value.vocabularyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.Settings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.Settings()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.showSpeakerLabels = try reader["ShowSpeakerLabels"].readIfPresent()
        value.maxSpeakerLabels = try reader["MaxSpeakerLabels"].readIfPresent()
        value.channelIdentification = try reader["ChannelIdentification"].readIfPresent()
        value.showAlternatives = try reader["ShowAlternatives"].readIfPresent()
        value.maxAlternatives = try reader["MaxAlternatives"].readIfPresent()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.vocabularyFilterMethod = try reader["VocabularyFilterMethod"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.CallAnalyticsJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.CallAnalyticsJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.CallAnalyticsJobSummary()
        value.callAnalyticsJobName = try reader["CallAnalyticsJobName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.callAnalyticsJobStatus = try reader["CallAnalyticsJobStatus"].readIfPresent()
        value.callAnalyticsJobDetails = try reader["CallAnalyticsJobDetails"].readIfPresent(with: TranscribeClientTypes.CallAnalyticsJobDetails.read(from:))
        value.failureReason = try reader["FailureReason"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.MedicalScribeJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalScribeJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalScribeJobSummary()
        value.medicalScribeJobName = try reader["MedicalScribeJobName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.medicalScribeJobStatus = try reader["MedicalScribeJobStatus"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.MedicalTranscriptionJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.MedicalTranscriptionJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.MedicalTranscriptionJobSummary()
        value.medicalTranscriptionJobName = try reader["MedicalTranscriptionJobName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.transcriptionJobStatus = try reader["TranscriptionJobStatus"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.outputLocationType = try reader["OutputLocationType"].readIfPresent()
        value.specialty = try reader["Specialty"].readIfPresent()
        value.contentIdentificationType = try reader["ContentIdentificationType"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.VocabularyInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.VocabularyInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.VocabularyInfo()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vocabularyState = try reader["VocabularyState"].readIfPresent()
        return value
    }
}

extension TranscribeClientTypes.TranscriptionJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.TranscriptionJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.TranscriptionJobSummary()
        value.transcriptionJobName = try reader["TranscriptionJobName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.transcriptionJobStatus = try reader["TranscriptionJobStatus"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.outputLocationType = try reader["OutputLocationType"].readIfPresent()
        value.contentRedaction = try reader["ContentRedaction"].readIfPresent(with: TranscribeClientTypes.ContentRedaction.read(from:))
        value.modelSettings = try reader["ModelSettings"].readIfPresent(with: TranscribeClientTypes.ModelSettings.read(from:))
        value.identifyLanguage = try reader["IdentifyLanguage"].readIfPresent()
        value.identifyMultipleLanguages = try reader["IdentifyMultipleLanguages"].readIfPresent()
        value.identifiedLanguageScore = try reader["IdentifiedLanguageScore"].readIfPresent()
        value.languageCodes = try reader["LanguageCodes"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.LanguageCodeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.toxicityDetection = try reader["ToxicityDetection"].readListIfPresent(memberReadingClosure: TranscribeClientTypes.ToxicityDetectionSettings.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TranscribeClientTypes.VocabularyFilterInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TranscribeClientTypes.VocabularyFilterInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TranscribeClientTypes.VocabularyFilterInfo()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TranscribeClientTypes.Subtitles {

    static func write(value: TranscribeClientTypes.Subtitles?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Formats"].writeList(value.formats, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TranscribeClientTypes.SubtitleFormat>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutputStartIndex"].write(value.outputStartIndex)
    }
}

public enum TranscribeClientTypes {}
