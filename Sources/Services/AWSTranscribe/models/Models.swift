// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension TranscribeClientTypes.AbsoluteTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case first = "First"
        case last = "Last"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let first = self.first {
            try encodeContainer.encode(first, forKey: .first)
        }
        if let last = self.last {
            try encodeContainer.encode(last, forKey: .last)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endTime)
        endTime = endTimeDecoded
        let firstDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .first)
        first = firstDecoded
        let lastDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .last)
        last = lastDecoded
    }
}

extension TranscribeClientTypes {
    /// A time range, in milliseconds, between two points in your media file. You can use StartTime and EndTime to search a custom segment. For example, setting StartTime to 10000 and EndTime to 50000 only searches for your specified criteria in the audio contained between the 10,000 millisecond mark and the 50,000 millisecond mark of your media file. You must use StartTime and EndTime as a set; that is, if you include one, you must include both. You can use also First to search from the start of the audio until the time that you specify, or Last to search from the time that you specify until the end of the audio. For example, setting First to 50000 only searches for your specified criteria in the audio contained between the start of the media file to the 50,000 millisecond mark. You can use First and Last independently of each other. If you prefer to use percentage instead of milliseconds, see .
    public struct AbsoluteTimeRange: Swift.Equatable {
        /// The time, in milliseconds, when Amazon Transcribe stops searching for the specified criteria in your audio. If you include EndTime in your request, you must also include StartTime.
        public var endTime: Swift.Int?
        /// The time, in milliseconds, from the start of your media file until the specified value. Amazon Transcribe searches for your specified criteria in this time segment.
        public var first: Swift.Int?
        /// The time, in milliseconds, from the specified value until the end of your media file. Amazon Transcribe searches for your specified criteria in this time segment.
        public var last: Swift.Int?
        /// The time, in milliseconds, when Amazon Transcribe starts searching for the specified criteria in your audio. If you include StartTime in your request, you must also include EndTime.
        public var startTime: Swift.Int?

        public init(
            endTime: Swift.Int? = nil,
            first: Swift.Int? = nil,
            last: Swift.Int? = nil,
            startTime: Swift.Int? = nil
        )
        {
            self.endTime = endTime
            self.first = first
            self.last = last
            self.startTime = startTime
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request didn't pass one or more validation tests. This can occur when the entity you're trying to delete doesn't exist or if it's in a non-terminal state (such as IN PROGRESS). See the exception message field for more information.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeClientTypes {
    public enum BaseModelName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case narrowBand
        case wideBand
        case sdkUnknown(Swift.String)

        public static var allCases: [BaseModelName] {
            return [
                .narrowBand,
                .wideBand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .narrowBand: return "NarrowBand"
            case .wideBand: return "WideBand"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BaseModelName(rawValue: rawValue) ?? BaseModelName.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes {
    public enum CLMLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case hiIn
        case jaJp
        case sdkUnknown(Swift.String)

        public static var allCases: [CLMLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .hiIn,
                .jaJp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .hiIn: return "hi-IN"
            case .jaJp: return "ja-JP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CLMLanguageCode(rawValue: rawValue) ?? CLMLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.CallAnalyticsJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callAnalyticsJobName = "CallAnalyticsJobName"
        case callAnalyticsJobStatus = "CallAnalyticsJobStatus"
        case channelDefinitions = "ChannelDefinitions"
        case completionTime = "CompletionTime"
        case creationTime = "CreationTime"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case failureReason = "FailureReason"
        case identifiedLanguageScore = "IdentifiedLanguageScore"
        case languageCode = "LanguageCode"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case settings = "Settings"
        case startTime = "StartTime"
        case transcript = "Transcript"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callAnalyticsJobName = self.callAnalyticsJobName {
            try encodeContainer.encode(callAnalyticsJobName, forKey: .callAnalyticsJobName)
        }
        if let callAnalyticsJobStatus = self.callAnalyticsJobStatus {
            try encodeContainer.encode(callAnalyticsJobStatus.rawValue, forKey: .callAnalyticsJobStatus)
        }
        if let channelDefinitions = channelDefinitions {
            var channelDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channelDefinitions)
            for channeldefinition0 in channelDefinitions {
                try channelDefinitionsContainer.encode(channeldefinition0)
            }
        }
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let identifiedLanguageScore = self.identifiedLanguageScore {
            try encodeContainer.encode(identifiedLanguageScore, forKey: .identifiedLanguageScore)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let media = self.media {
            try encodeContainer.encode(media, forKey: .media)
        }
        if let mediaFormat = self.mediaFormat {
            try encodeContainer.encode(mediaFormat.rawValue, forKey: .mediaFormat)
        }
        if let mediaSampleRateHertz = self.mediaSampleRateHertz {
            try encodeContainer.encode(mediaSampleRateHertz, forKey: .mediaSampleRateHertz)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let transcript = self.transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callAnalyticsJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callAnalyticsJobName)
        callAnalyticsJobName = callAnalyticsJobNameDecoded
        let callAnalyticsJobStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJobStatus.self, forKey: .callAnalyticsJobStatus)
        callAnalyticsJobStatus = callAnalyticsJobStatusDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let mediaSampleRateHertzDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaSampleRateHertz)
        mediaSampleRateHertz = mediaSampleRateHertzDecoded
        let mediaFormatDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MediaFormat.self, forKey: .mediaFormat)
        mediaFormat = mediaFormatDecoded
        let mediaDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Media.self, forKey: .media)
        media = mediaDecoded
        let transcriptDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Transcript.self, forKey: .transcript)
        transcript = transcriptDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let identifiedLanguageScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .identifiedLanguageScore)
        identifiedLanguageScore = identifiedLanguageScoreDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJobSettings.self, forKey: .settings)
        settings = settingsDecoded
        let channelDefinitionsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.ChannelDefinition?].self, forKey: .channelDefinitions)
        var channelDefinitionsDecoded0:[TranscribeClientTypes.ChannelDefinition]? = nil
        if let channelDefinitionsContainer = channelDefinitionsContainer {
            channelDefinitionsDecoded0 = [TranscribeClientTypes.ChannelDefinition]()
            for structure0 in channelDefinitionsContainer {
                if let structure0 = structure0 {
                    channelDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        channelDefinitions = channelDefinitionsDecoded0
    }
}

extension TranscribeClientTypes {
    /// Provides detailed information about a Call Analytics job. To view the job's status, refer to CallAnalyticsJobStatus. If the status is COMPLETED, the job is finished. You can find your completed transcript at the URI specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed. If you enabled personally identifiable information (PII) redaction, the redacted transcript appears at the location specified in RedactedTranscriptFileUri. If you chose to redact the audio in your media file, you can find your redacted media file at the location specified in the RedactedMediaFileUri field of your response.
    public struct CallAnalyticsJob: Swift.Equatable {
        /// The name of the Call Analytics job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var callAnalyticsJobName: Swift.String?
        /// Provides the status of the specified Call Analytics job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus?
        /// Indicates which speaker is on which channel.
        public var channelDefinitions: [TranscribeClientTypes.ChannelDefinition]?
        /// The date and time the specified Call Analytics job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: ClientRuntime.Date?
        /// The date and time the specified Call Analytics job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) you included in your request.
        public var dataAccessRoleArn: Swift.String?
        /// If CallAnalyticsJobStatus is FAILED, FailureReason contains information about why the Call Analytics job request failed. The FailureReason field contains one of the following values:
        ///
        /// * Unsupported media format. The media format specified in MediaFormat isn't valid. Refer to MediaFormat for a list of supported formats.
        ///
        /// * The media format provided does not match the detected media format. The media format specified in MediaFormat doesn't match the format of the input file. Check the media format of your media file and correct the specified value.
        ///
        /// * Invalid sample rate for audio file. The sample rate specified in MediaSampleRateHertz isn't valid. The sample rate must be between 8,000 and 48,000 hertz.
        ///
        /// * The sample rate provided does not match the detected sample rate. The sample rate specified in MediaSampleRateHertz doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.
        ///
        /// * Invalid file size: file size too large. The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to [Guidelines and quotas](https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits).
        ///
        /// * Invalid number of channels: number of channels too large. Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to [Guidelines and quotas](https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits).
        public var failureReason: Swift.String?
        /// The confidence score associated with the language identified in your media file. Confidence scores are values between 0 and 1; a larger value indicates a higher probability that the identified language correctly matches the language spoken in your media.
        public var identifiedLanguageScore: Swift.Float?
        /// The language code used to create your Call Analytics job. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. If you don't know the language spoken in your media file, you can omit this field and let Amazon Transcribe automatically identify the language of your media. To improve the accuracy of language identification, you can include several language codes and Amazon Transcribe chooses the closest match for your transcription.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// Provides the Amazon S3 location of the media file you used in your Call Analytics request.
        public var media: TranscribeClientTypes.Media?
        /// The format of the input media file.
        public var mediaFormat: TranscribeClientTypes.MediaFormat?
        /// The sample rate, in hertz, of the audio track in your input media file.
        public var mediaSampleRateHertz: Swift.Int?
        /// Provides information on any additional settings that were included in your request. Additional settings include content redaction and language identification settings.
        public var settings: TranscribeClientTypes.CallAnalyticsJobSettings?
        /// The date and time the specified Call Analytics job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: ClientRuntime.Date?
        /// Provides you with the Amazon S3 URI you can use to access your transcript.
        public var transcript: TranscribeClientTypes.Transcript?

        public init(
            callAnalyticsJobName: Swift.String? = nil,
            callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus? = nil,
            channelDefinitions: [TranscribeClientTypes.ChannelDefinition]? = nil,
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            identifiedLanguageScore: Swift.Float? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            media: TranscribeClientTypes.Media? = nil,
            mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
            mediaSampleRateHertz: Swift.Int? = nil,
            settings: TranscribeClientTypes.CallAnalyticsJobSettings? = nil,
            startTime: ClientRuntime.Date? = nil,
            transcript: TranscribeClientTypes.Transcript? = nil
        )
        {
            self.callAnalyticsJobName = callAnalyticsJobName
            self.callAnalyticsJobStatus = callAnalyticsJobStatus
            self.channelDefinitions = channelDefinitions
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.dataAccessRoleArn = dataAccessRoleArn
            self.failureReason = failureReason
            self.identifiedLanguageScore = identifiedLanguageScore
            self.languageCode = languageCode
            self.media = media
            self.mediaFormat = mediaFormat
            self.mediaSampleRateHertz = mediaSampleRateHertz
            self.settings = settings
            self.startTime = startTime
            self.transcript = transcript
        }
    }

}

extension TranscribeClientTypes.CallAnalyticsJobSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentRedaction = "ContentRedaction"
        case languageIdSettings = "LanguageIdSettings"
        case languageModelName = "LanguageModelName"
        case languageOptions = "LanguageOptions"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentRedaction = self.contentRedaction {
            try encodeContainer.encode(contentRedaction, forKey: .contentRedaction)
        }
        if let languageIdSettings = languageIdSettings {
            var languageIdSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .languageIdSettings)
            for (dictKey0, languageIdSettingsMap0) in languageIdSettings {
                try languageIdSettingsContainer.encode(languageIdSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let languageOptions = languageOptions {
            var languageOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languageOptions)
            for languagecode0 in languageOptions {
                try languageOptionsContainer.encode(languagecode0.rawValue)
            }
        }
        if let vocabularyFilterMethod = self.vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
        let contentRedactionDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ContentRedaction.self, forKey: .contentRedaction)
        contentRedaction = contentRedactionDecoded
        let languageOptionsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.LanguageCode?].self, forKey: .languageOptions)
        var languageOptionsDecoded0:[TranscribeClientTypes.LanguageCode]? = nil
        if let languageOptionsContainer = languageOptionsContainer {
            languageOptionsDecoded0 = [TranscribeClientTypes.LanguageCode]()
            for enum0 in languageOptionsContainer {
                if let enum0 = enum0 {
                    languageOptionsDecoded0?.append(enum0)
                }
            }
        }
        languageOptions = languageOptionsDecoded0
        let languageIdSettingsContainer = try containerValues.decodeIfPresent([Swift.String: TranscribeClientTypes.LanguageIdSettings?].self, forKey: .languageIdSettings)
        var languageIdSettingsDecoded0: [Swift.String:TranscribeClientTypes.LanguageIdSettings]? = nil
        if let languageIdSettingsContainer = languageIdSettingsContainer {
            languageIdSettingsDecoded0 = [Swift.String:TranscribeClientTypes.LanguageIdSettings]()
            for (key0, languageidsettings0) in languageIdSettingsContainer {
                if let languageidsettings0 = languageidsettings0 {
                    languageIdSettingsDecoded0?[key0] = languageidsettings0
                }
            }
        }
        languageIdSettings = languageIdSettingsDecoded0
    }
}

extension TranscribeClientTypes {
    /// Provides additional optional settings for your request, including content redaction, automatic language identification; allows you to apply custom language models, custom vocabulary filters, and custom vocabularies.
    public struct CallAnalyticsJobSettings: Swift.Equatable {
        /// Makes it possible to redact or flag specified personally identifiable information (PII) in your transcript. If you use ContentRedaction, you must also include the sub-parameters: PiiEntityTypes, RedactionOutput, and RedactionType.
        public var contentRedaction: TranscribeClientTypes.ContentRedaction?
        /// If using automatic language identification in your request and you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). LanguageIdSettings supports two to five language codes. Each language code you include can have an associated custom language model, custom vocabulary, and custom vocabulary filter. The language codes that you specify must match the languages of the associated custom language models, custom vocabularies, and custom vocabulary filters. It's recommended that you include LanguageOptions when using LanguageIdSettings to ensure that the correct language dialect is identified. For example, if you specify a custom vocabulary that is in en-US but Amazon Transcribe determines that the language spoken in your media is en-AU, your custom vocabulary is not applied to your transcription. If you include LanguageOptions and include en-US as the only English language dialect, your custom vocabulary is applied to your transcription. If you want to include a custom language model, custom vocabulary, or custom vocabulary filter with your request but do not want to use automatic language identification, use instead the  parameter with the LanguageModelName, VocabularyName, or VocabularyFilterName sub-parameters. For a list of languages supported with Call Analytics, refer to [Supported languages and language-specific features](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html).
        public var languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]?
        /// The name of the custom language model you want to use when processing your Call Analytics job. Note that custom language model names are case sensitive. The language of the specified custom language model must match the language code that you specify in your transcription request. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.
        public var languageModelName: Swift.String?
        /// You can specify two or more language codes that represent the languages you think may be present in your media. Including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. Including language options can improve the accuracy of language identification. For a list of languages supported with Call Analytics, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. To transcribe speech in Modern Standard Arabic (ar-SA), your media file must be encoded at a sample rate of 16,000 Hz or higher.
        public var languageOptions: [TranscribeClientTypes.LanguageCode]?
        /// Specify how you want your custom vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter you want to include in your Call Analytics transcription request. Custom vocabulary filter names are case sensitive. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to include in your Call Analytics transcription request. Custom vocabulary names are case sensitive.
        public var vocabularyName: Swift.String?

        public init(
            contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
            languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: [TranscribeClientTypes.LanguageCode]? = nil,
            vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentRedaction = contentRedaction
            self.languageIdSettings = languageIdSettings
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }

}

extension TranscribeClientTypes {
    public enum CallAnalyticsJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case queued
        case sdkUnknown(Swift.String)

        public static var allCases: [CallAnalyticsJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .queued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallAnalyticsJobStatus(rawValue: rawValue) ?? CallAnalyticsJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.CallAnalyticsJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callAnalyticsJobName = "CallAnalyticsJobName"
        case callAnalyticsJobStatus = "CallAnalyticsJobStatus"
        case completionTime = "CompletionTime"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callAnalyticsJobName = self.callAnalyticsJobName {
            try encodeContainer.encode(callAnalyticsJobName, forKey: .callAnalyticsJobName)
        }
        if let callAnalyticsJobStatus = self.callAnalyticsJobStatus {
            try encodeContainer.encode(callAnalyticsJobStatus.rawValue, forKey: .callAnalyticsJobStatus)
        }
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callAnalyticsJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callAnalyticsJobName)
        callAnalyticsJobName = callAnalyticsJobNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let callAnalyticsJobStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJobStatus.self, forKey: .callAnalyticsJobStatus)
        callAnalyticsJobStatus = callAnalyticsJobStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides detailed information about a specific Call Analytics job.
    public struct CallAnalyticsJobSummary: Swift.Equatable {
        /// The name of the Call Analytics job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var callAnalyticsJobName: Swift.String?
        /// Provides the status of your Call Analytics job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus?
        /// The date and time the specified Call Analytics job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: ClientRuntime.Date?
        /// The date and time the specified Call Analytics job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: ClientRuntime.Date?
        /// If CallAnalyticsJobStatus is FAILED, FailureReason contains information about why the Call Analytics job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The language code used to create your Call Analytics transcription.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The date and time your Call Analytics job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: ClientRuntime.Date?

        public init(
            callAnalyticsJobName: Swift.String? = nil,
            callAnalyticsJobStatus: TranscribeClientTypes.CallAnalyticsJobStatus? = nil,
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.callAnalyticsJobName = callAnalyticsJobName
            self.callAnalyticsJobStatus = callAnalyticsJobStatus
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.startTime = startTime
        }
    }

}

extension TranscribeClientTypes.CategoryProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryName = "CategoryName"
        case createTime = "CreateTime"
        case inputType = "InputType"
        case lastUpdateTime = "LastUpdateTime"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryName = self.categoryName {
            try encodeContainer.encode(categoryName, forKey: .categoryName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let inputType = self.inputType {
            try encodeContainer.encode(inputType.rawValue, forKey: .inputType)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryName)
        categoryName = categoryNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[TranscribeClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [TranscribeClientTypes.Rule]()
            for union0 in rulesContainer {
                if let union0 = union0 {
                    rulesDecoded0?.append(union0)
                }
            }
        }
        rules = rulesDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let inputTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.InputType.self, forKey: .inputType)
        inputType = inputTypeDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides you with the properties of the Call Analytics category you specified in your request. This includes the list of rules that define the specified category.
    public struct CategoryProperties: Swift.Equatable {
        /// The name of the Call Analytics category. Category names are case sensitive and must be unique within an Amazon Web Services account.
        public var categoryName: Swift.String?
        /// The date and time the specified Call Analytics category was created. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var createTime: ClientRuntime.Date?
        /// The input type associated with the specified category. POST_CALL refers to a category that is applied to batch transcriptions; REAL_TIME refers to a category that is applied to streaming transcriptions.
        public var inputType: TranscribeClientTypes.InputType?
        /// The date and time the specified Call Analytics category was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-05T12:45:32.691000-07:00 represents 12:45 PM UTC-7 on May 5, 2022.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The rules used to define a Call Analytics category. Each category can have between 1 and 20 rules.
        public var rules: [TranscribeClientTypes.Rule]?

        public init(
            categoryName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            inputType: TranscribeClientTypes.InputType? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            rules: [TranscribeClientTypes.Rule]? = nil
        )
        {
            self.categoryName = categoryName
            self.createTime = createTime
            self.inputType = inputType
            self.lastUpdateTime = lastUpdateTime
            self.rules = rules
        }
    }

}

extension TranscribeClientTypes.ChannelDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case participantRole = "ParticipantRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if channelId != 0 {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .channelId) ?? 0
        channelId = channelIdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
    }
}

extension TranscribeClientTypes {
    /// Makes it possible to specify which speaker is on which channel. For example, if your agent is the first participant to speak, you would set ChannelId to 0 (to indicate the first channel) and ParticipantRole to AGENT (to indicate that it's the agent speaking).
    public struct ChannelDefinition: Swift.Equatable {
        /// Specify the audio channel you want to define.
        public var channelId: Swift.Int
        /// Specify the speaker you want to define. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?

        public init(
            channelId: Swift.Int = 0,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil
        )
        {
            self.channelId = channelId
            self.participantRole = participantRole
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource already exists with this name. Resource names must be unique within an Amazon Web Services account.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeClientTypes.ContentRedaction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case piiEntityTypes = "PiiEntityTypes"
        case redactionOutput = "RedactionOutput"
        case redactionType = "RedactionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let piiEntityTypes = piiEntityTypes {
            var piiEntityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .piiEntityTypes)
            for piientitytype0 in piiEntityTypes {
                try piiEntityTypesContainer.encode(piientitytype0.rawValue)
            }
        }
        if let redactionOutput = self.redactionOutput {
            try encodeContainer.encode(redactionOutput.rawValue, forKey: .redactionOutput)
        }
        if let redactionType = self.redactionType {
            try encodeContainer.encode(redactionType.rawValue, forKey: .redactionType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redactionTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.RedactionType.self, forKey: .redactionType)
        redactionType = redactionTypeDecoded
        let redactionOutputDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.RedactionOutput.self, forKey: .redactionOutput)
        redactionOutput = redactionOutputDecoded
        let piiEntityTypesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.PiiEntityType?].self, forKey: .piiEntityTypes)
        var piiEntityTypesDecoded0:[TranscribeClientTypes.PiiEntityType]? = nil
        if let piiEntityTypesContainer = piiEntityTypesContainer {
            piiEntityTypesDecoded0 = [TranscribeClientTypes.PiiEntityType]()
            for enum0 in piiEntityTypesContainer {
                if let enum0 = enum0 {
                    piiEntityTypesDecoded0?.append(enum0)
                }
            }
        }
        piiEntityTypes = piiEntityTypesDecoded0
    }
}

extension TranscribeClientTypes {
    /// Makes it possible to redact or flag specified personally identifiable information (PII) in your transcript. If you use ContentRedaction, you must also include the sub-parameters: PiiEntityTypes, RedactionOutput, and RedactionType.
    public struct ContentRedaction: Swift.Equatable {
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL.
        public var piiEntityTypes: [TranscribeClientTypes.PiiEntityType]?
        /// Specify if you want only a redacted transcript, or if you want a redacted and an unredacted transcript. When you choose redacted Amazon Transcribe creates only a redacted transcript. When you choose redacted_and_unredacted Amazon Transcribe creates a redacted and an unredacted transcript (as two separate files).
        /// This member is required.
        public var redactionOutput: TranscribeClientTypes.RedactionOutput?
        /// Specify the category of information you want to redact; PII (personally identifiable information) is the only valid value. You can use PiiEntityTypes to choose which types of PII you want to redact.
        /// This member is required.
        public var redactionType: TranscribeClientTypes.RedactionType?

        public init(
            piiEntityTypes: [TranscribeClientTypes.PiiEntityType]? = nil,
            redactionOutput: TranscribeClientTypes.RedactionOutput? = nil,
            redactionType: TranscribeClientTypes.RedactionType? = nil
        )
        {
            self.piiEntityTypes = piiEntityTypes
            self.redactionOutput = redactionOutput
            self.redactionType = redactionType
        }
    }

}

extension CreateCallAnalyticsCategoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputType = "InputType"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputType = self.inputType {
            try encodeContainer.encode(inputType.rawValue, forKey: .inputType)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }
}

extension CreateCallAnalyticsCategoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCallAnalyticsCategoryInput: Swift.Equatable {
    /// A unique name, chosen by you, for your Call Analytics category. It's helpful to use a detailed naming system that will make sense to you in the future. For example, it's better to use sentiment-positive-last30seconds for a category over a generic name like test-category. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?
    /// Choose whether you want to create a real-time or a post-call category for your Call Analytics transcription. Specifying POST_CALL assigns your category to post-call transcriptions; categories with this input type cannot be applied to streaming (real-time) transcriptions. Specifying REAL_TIME assigns your category to streaming transcriptions; categories with this input type cannot be applied to post-call transcriptions. If you do not include InputType, your category is created as a post-call category by default.
    public var inputType: TranscribeClientTypes.InputType?
    /// Rules define a Call Analytics category. When creating a new category, you must create between 1 and 20 rules for that category. For each rule, you specify a filter you want applied to the attributes of a call. For example, you can choose a sentiment filter that detects if a customer's sentiment was positive during the last 30 seconds of the call.
    /// This member is required.
    public var rules: [TranscribeClientTypes.Rule]?

    public init(
        categoryName: Swift.String? = nil,
        inputType: TranscribeClientTypes.InputType? = nil,
        rules: [TranscribeClientTypes.Rule]? = nil
    )
    {
        self.categoryName = categoryName
        self.inputType = inputType
        self.rules = rules
    }
}

struct CreateCallAnalyticsCategoryInputBody: Swift.Equatable {
    let rules: [TranscribeClientTypes.Rule]?
    let inputType: TranscribeClientTypes.InputType?
}

extension CreateCallAnalyticsCategoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputType = "InputType"
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[TranscribeClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [TranscribeClientTypes.Rule]()
            for union0 in rulesContainer {
                if let union0 = union0 {
                    rulesDecoded0?.append(union0)
                }
            }
        }
        rules = rulesDecoded0
        let inputTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.InputType.self, forKey: .inputType)
        inputType = inputTypeDecoded
    }
}

extension CreateCallAnalyticsCategoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCallAnalyticsCategoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.categoryProperties = output.categoryProperties
        } else {
            self.categoryProperties = nil
        }
    }
}

public struct CreateCallAnalyticsCategoryOutput: Swift.Equatable {
    /// Provides you with the properties of your new category, including its associated rules.
    public var categoryProperties: TranscribeClientTypes.CategoryProperties?

    public init(
        categoryProperties: TranscribeClientTypes.CategoryProperties? = nil
    )
    {
        self.categoryProperties = categoryProperties
    }
}

struct CreateCallAnalyticsCategoryOutputBody: Swift.Equatable {
    let categoryProperties: TranscribeClientTypes.CategoryProperties?
}

extension CreateCallAnalyticsCategoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryProperties = "CategoryProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryPropertiesDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CategoryProperties.self, forKey: .categoryProperties)
        categoryProperties = categoryPropertiesDecoded
    }
}

enum CreateCallAnalyticsCategoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLanguageModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelName = "BaseModelName"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseModelName = self.baseModelName {
            try encodeContainer.encode(baseModelName.rawValue, forKey: .baseModelName)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateLanguageModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLanguageModelInput: Swift.Equatable {
    /// The Amazon Transcribe standard language model, or base model, used to create your custom language model. Amazon Transcribe offers two options for base models: Wideband and Narrowband. If the audio you want to transcribe has a sample rate of 16,000 Hz or greater, choose WideBand. To transcribe audio with a sample rate less than 16,000 Hz, choose NarrowBand.
    /// This member is required.
    public var baseModelName: TranscribeClientTypes.BaseModelName?
    /// Contains the Amazon S3 location of the training data you want to use to create a new custom language model, and permissions to access this location. When using InputDataConfig, you must include these sub-parameters: S3Uri, which is the Amazon S3 location of your training data, and DataAccessRoleArn, which is the Amazon Resource Name (ARN) of the role that has permission to access your specified Amazon S3 location. You can optionally include TuningDataS3Uri, which is the Amazon S3 location of your tuning data. If you specify different Amazon S3 locations for training and tuning data, the ARN you use must have permissions to access both locations.
    /// This member is required.
    public var inputDataConfig: TranscribeClientTypes.InputDataConfig?
    /// The language code that represents the language of your model. Each custom language model must contain terms in only one language, and the language you select for your custom language model must match the language of your training and tuning data. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. Note that US English (en-US) is the only language supported with Amazon Transcribe Medical. A custom language model can only be used to transcribe files in the same language as the model. For example, if you create a custom language model using US English (en-US), you can only apply this model to files that contain English audio.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.CLMLanguageCode?
    /// A unique name, chosen by you, for your custom language model. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom language model with the same name as an existing custom language model, you get a ConflictException error.
    /// This member is required.
    public var modelName: Swift.String?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom language model at the time you create this new model. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        baseModelName: TranscribeClientTypes.BaseModelName? = nil,
        inputDataConfig: TranscribeClientTypes.InputDataConfig? = nil,
        languageCode: TranscribeClientTypes.CLMLanguageCode? = nil,
        modelName: Swift.String? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.baseModelName = baseModelName
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.modelName = modelName
        self.tags = tags
    }
}

struct CreateLanguageModelInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.CLMLanguageCode?
    let baseModelName: TranscribeClientTypes.BaseModelName?
    let inputDataConfig: TranscribeClientTypes.InputDataConfig?
    let tags: [TranscribeClientTypes.Tag]?
}

extension CreateLanguageModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelName = "BaseModelName"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CLMLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let baseModelNameDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.BaseModelName.self, forKey: .baseModelName)
        baseModelName = baseModelNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLanguageModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLanguageModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseModelName = output.baseModelName
            self.inputDataConfig = output.inputDataConfig
            self.languageCode = output.languageCode
            self.modelName = output.modelName
            self.modelStatus = output.modelStatus
        } else {
            self.baseModelName = nil
            self.inputDataConfig = nil
            self.languageCode = nil
            self.modelName = nil
            self.modelStatus = nil
        }
    }
}

public struct CreateLanguageModelOutput: Swift.Equatable {
    /// The Amazon Transcribe standard language model, or base model, you specified when creating your custom language model.
    public var baseModelName: TranscribeClientTypes.BaseModelName?
    /// Lists your data access role ARN (Amazon Resource Name) and the Amazon S3 locations you provided for your training (S3Uri) and tuning (TuningDataS3Uri) data.
    public var inputDataConfig: TranscribeClientTypes.InputDataConfig?
    /// The language code you selected for your custom language model.
    public var languageCode: TranscribeClientTypes.CLMLanguageCode?
    /// The name of your custom language model.
    public var modelName: Swift.String?
    /// The status of your custom language model. When the status displays as COMPLETED, your model is ready to use.
    public var modelStatus: TranscribeClientTypes.ModelStatus?

    public init(
        baseModelName: TranscribeClientTypes.BaseModelName? = nil,
        inputDataConfig: TranscribeClientTypes.InputDataConfig? = nil,
        languageCode: TranscribeClientTypes.CLMLanguageCode? = nil,
        modelName: Swift.String? = nil,
        modelStatus: TranscribeClientTypes.ModelStatus? = nil
    )
    {
        self.baseModelName = baseModelName
        self.inputDataConfig = inputDataConfig
        self.languageCode = languageCode
        self.modelName = modelName
        self.modelStatus = modelStatus
    }
}

struct CreateLanguageModelOutputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.CLMLanguageCode?
    let baseModelName: TranscribeClientTypes.BaseModelName?
    let modelName: Swift.String?
    let inputDataConfig: TranscribeClientTypes.InputDataConfig?
    let modelStatus: TranscribeClientTypes.ModelStatus?
}

extension CreateLanguageModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelName = "BaseModelName"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case modelName = "ModelName"
        case modelStatus = "ModelStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CLMLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let baseModelNameDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.BaseModelName.self, forKey: .baseModelName)
        baseModelName = baseModelNameDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let modelStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelStatus.self, forKey: .modelStatus)
        modelStatus = modelStatusDecoded
    }
}

enum CreateLanguageModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMedicalVocabularyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case tags = "Tags"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vocabularyFileUri = self.vocabularyFileUri {
            try encodeContainer.encode(vocabularyFileUri, forKey: .vocabularyFileUri)
        }
    }
}

extension CreateMedicalVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMedicalVocabularyInput: Swift.Equatable {
    /// The language code that represents the language of the entries in your custom vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom medical vocabulary at the time you create this new custom vocabulary. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// The Amazon S3 location (URI) of the text file that contains your custom medical vocabulary. The URI must be in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt
    /// This member is required.
    public var vocabularyFileUri: Swift.String?
    /// A unique name, chosen by you, for your new custom medical vocabulary. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom medical vocabulary with the same name as an existing custom medical vocabulary, you get a ConflictException error.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.tags = tags
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

struct CreateMedicalVocabularyInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let vocabularyFileUri: Swift.String?
    let tags: [TranscribeClientTypes.Tag]?
}

extension CreateMedicalVocabularyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case tags = "Tags"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFileUri)
        vocabularyFileUri = vocabularyFileUriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMedicalVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMedicalVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.failureReason = output.failureReason
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyName = output.vocabularyName
            self.vocabularyState = output.vocabularyState
        } else {
            self.failureReason = nil
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyName = nil
            self.vocabularyState = nil
        }
    }
}

public struct CreateMedicalVocabularyOutput: Swift.Equatable {
    /// If VocabularyState is FAILED, FailureReason contains information about why the medical transcription job request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom medical vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time you created your custom medical vocabulary. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name you chose for your custom medical vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom medical vocabulary. If the state is READY, you can use the custom vocabulary in a StartMedicalTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

struct CreateMedicalVocabularyOutputBody: Swift.Equatable {
    let vocabularyName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let vocabularyState: TranscribeClientTypes.VocabularyState?
    let lastModifiedTime: ClientRuntime.Date?
    let failureReason: Swift.String?
}

extension CreateMedicalVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

enum CreateMedicalVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVocabularyFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case languageCode = "LanguageCode"
        case tags = "Tags"
        case vocabularyFilterFileUri = "VocabularyFilterFileUri"
        case words = "Words"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vocabularyFilterFileUri = self.vocabularyFilterFileUri {
            try encodeContainer.encode(vocabularyFilterFileUri, forKey: .vocabularyFilterFileUri)
        }
        if let words = words {
            var wordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .words)
            for word0 in words {
                try wordsContainer.encode(word0)
            }
        }
    }
}

extension CreateVocabularyFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVocabularyFilterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary filter). If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The language code that represents the language of the entries in your vocabulary filter. Each custom vocabulary filter must contain terms in only one language. A custom vocabulary filter can only be used to transcribe files in the same language as the filter. For example, if you create a custom vocabulary filter using US English (en-US), you can only apply this filter to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom vocabulary filter at the time you create this new vocabulary filter. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// The Amazon S3 location of the text file that contains your custom vocabulary filter terms. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-filter-file.txt Note that if you include VocabularyFilterFileUri in your request, you cannot use Words; you must choose one or the other.
    public var vocabularyFilterFileUri: Swift.String?
    /// A unique name, chosen by you, for your new custom vocabulary filter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom vocabulary filter with the same name as an existing custom vocabulary filter, you get a ConflictException error.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?
    /// Use this parameter if you want to create your custom vocabulary filter by including all desired terms, as comma-separated values, within your request. The other option for creating your vocabulary filter is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFilterFileUri parameter. Note that if you include Words in your request, you cannot use VocabularyFilterFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var words: [Swift.String]?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        vocabularyFilterFileUri: Swift.String? = nil,
        vocabularyFilterName: Swift.String? = nil,
        words: [Swift.String]? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.languageCode = languageCode
        self.tags = tags
        self.vocabularyFilterFileUri = vocabularyFilterFileUri
        self.vocabularyFilterName = vocabularyFilterName
        self.words = words
    }
}

struct CreateVocabularyFilterInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let words: [Swift.String]?
    let vocabularyFilterFileUri: Swift.String?
    let tags: [TranscribeClientTypes.Tag]?
    let dataAccessRoleArn: Swift.String?
}

extension CreateVocabularyFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case languageCode = "LanguageCode"
        case tags = "Tags"
        case vocabularyFilterFileUri = "VocabularyFilterFileUri"
        case words = "Words"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let wordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .words)
        var wordsDecoded0:[Swift.String]? = nil
        if let wordsContainer = wordsContainer {
            wordsDecoded0 = [Swift.String]()
            for string0 in wordsContainer {
                if let string0 = string0 {
                    wordsDecoded0?.append(string0)
                }
            }
        }
        words = wordsDecoded0
        let vocabularyFilterFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterFileUri)
        vocabularyFilterFileUri = vocabularyFilterFileUriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension CreateVocabularyFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVocabularyFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyFilterName = output.vocabularyFilterName
        } else {
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyFilterName = nil
        }
    }
}

public struct CreateVocabularyFilterOutput: Swift.Equatable {
    /// The language code you selected for your custom vocabulary filter.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time you created your custom vocabulary filter. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name you chose for your custom vocabulary filter.
    public var vocabularyFilterName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyFilterName = vocabularyFilterName
    }
}

struct CreateVocabularyFilterOutputBody: Swift.Equatable {
    let vocabularyFilterName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let lastModifiedTime: ClientRuntime.Date?
}

extension CreateVocabularyFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyFilterName = "VocabularyFilterName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

enum CreateVocabularyFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVocabularyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case languageCode = "LanguageCode"
        case phrases = "Phrases"
        case tags = "Tags"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let phrases = phrases {
            var phrasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phrases)
            for phrase0 in phrases {
                try phrasesContainer.encode(phrase0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vocabularyFileUri = self.vocabularyFileUri {
            try encodeContainer.encode(vocabularyFileUri, forKey: .vocabularyFileUri)
        }
    }
}

extension CreateVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVocabularyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary). If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The language code that represents the language of the entries in your custom vocabulary. Each custom vocabulary must contain terms in only one language. A custom vocabulary can only be used to transcribe files in the same language as the custom vocabulary. For example, if you create a custom vocabulary using US English (en-US), you can only apply this custom vocabulary to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Use this parameter if you want to create your custom vocabulary by including all desired terms, as comma-separated values, within your request. The other option for creating your custom vocabulary is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFileUri parameter. Note that if you include Phrases in your request, you cannot use VocabularyFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var phrases: [Swift.String]?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new custom vocabulary at the time you create this new custom vocabulary. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// The Amazon S3 location of the text file that contains your custom vocabulary. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt Note that if you include VocabularyFileUri in your request, you cannot use the Phrases flag; you must choose one or the other.
    public var vocabularyFileUri: Swift.String?
    /// A unique name, chosen by you, for your new custom vocabulary. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new custom vocabulary with the same name as an existing custom vocabulary, you get a ConflictException error.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        phrases: [Swift.String]? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.languageCode = languageCode
        self.phrases = phrases
        self.tags = tags
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

struct CreateVocabularyInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let phrases: [Swift.String]?
    let vocabularyFileUri: Swift.String?
    let tags: [TranscribeClientTypes.Tag]?
    let dataAccessRoleArn: Swift.String?
}

extension CreateVocabularyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case languageCode = "LanguageCode"
        case phrases = "Phrases"
        case tags = "Tags"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let phrasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phrases)
        var phrasesDecoded0:[Swift.String]? = nil
        if let phrasesContainer = phrasesContainer {
            phrasesDecoded0 = [Swift.String]()
            for string0 in phrasesContainer {
                if let string0 = string0 {
                    phrasesDecoded0?.append(string0)
                }
            }
        }
        phrases = phrasesDecoded0
        let vocabularyFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFileUri)
        vocabularyFileUri = vocabularyFileUriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension CreateVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.failureReason = output.failureReason
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyName = output.vocabularyName
            self.vocabularyState = output.vocabularyState
        } else {
            self.failureReason = nil
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyName = nil
            self.vocabularyState = nil
        }
    }
}

public struct CreateVocabularyOutput: Swift.Equatable {
    /// If VocabularyState is FAILED, FailureReason contains information about why the custom vocabulary request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom vocabulary.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time you created your custom vocabulary. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name you chose for your custom vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

struct CreateVocabularyOutputBody: Swift.Equatable {
    let vocabularyName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let vocabularyState: TranscribeClientTypes.VocabularyState?
    let lastModifiedTime: ClientRuntime.Date?
    let failureReason: Swift.String?
}

extension CreateVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

enum CreateVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCallAnalyticsCategoryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteCallAnalyticsCategoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCallAnalyticsCategoryInput: Swift.Equatable {
    /// The name of the Call Analytics category you want to delete. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?

    public init(
        categoryName: Swift.String? = nil
    )
    {
        self.categoryName = categoryName
    }
}

struct DeleteCallAnalyticsCategoryInputBody: Swift.Equatable {
}

extension DeleteCallAnalyticsCategoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCallAnalyticsCategoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCallAnalyticsCategoryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCallAnalyticsCategoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCallAnalyticsJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteCallAnalyticsJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCallAnalyticsJobInput: Swift.Equatable {
    /// The name of the Call Analytics job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var callAnalyticsJobName: Swift.String?

    public init(
        callAnalyticsJobName: Swift.String? = nil
    )
    {
        self.callAnalyticsJobName = callAnalyticsJobName
    }
}

struct DeleteCallAnalyticsJobInputBody: Swift.Equatable {
}

extension DeleteCallAnalyticsJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCallAnalyticsJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCallAnalyticsJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCallAnalyticsJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLanguageModelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteLanguageModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLanguageModelInput: Swift.Equatable {
    /// The name of the custom language model you want to delete. Model names are case sensitive.
    /// This member is required.
    public var modelName: Swift.String?

    public init(
        modelName: Swift.String? = nil
    )
    {
        self.modelName = modelName
    }
}

struct DeleteLanguageModelInputBody: Swift.Equatable {
}

extension DeleteLanguageModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLanguageModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLanguageModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLanguageModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMedicalTranscriptionJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteMedicalTranscriptionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMedicalTranscriptionJobInput: Swift.Equatable {
    /// The name of the medical transcription job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var medicalTranscriptionJobName: Swift.String?

    public init(
        medicalTranscriptionJobName: Swift.String? = nil
    )
    {
        self.medicalTranscriptionJobName = medicalTranscriptionJobName
    }
}

struct DeleteMedicalTranscriptionJobInputBody: Swift.Equatable {
}

extension DeleteMedicalTranscriptionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMedicalTranscriptionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMedicalTranscriptionJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMedicalTranscriptionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMedicalVocabularyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteMedicalVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMedicalVocabularyInput: Swift.Equatable {
    /// The name of the custom medical vocabulary you want to delete. Custom medical vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

struct DeleteMedicalVocabularyInputBody: Swift.Equatable {
}

extension DeleteMedicalVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMedicalVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMedicalVocabularyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMedicalVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTranscriptionJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteTranscriptionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTranscriptionJobInput: Swift.Equatable {
    /// The name of the transcription job you want to delete. Job names are case sensitive.
    /// This member is required.
    public var transcriptionJobName: Swift.String?

    public init(
        transcriptionJobName: Swift.String? = nil
    )
    {
        self.transcriptionJobName = transcriptionJobName
    }
}

struct DeleteTranscriptionJobInputBody: Swift.Equatable {
}

extension DeleteTranscriptionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTranscriptionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTranscriptionJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTranscriptionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVocabularyFilterInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteVocabularyFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVocabularyFilterInput: Swift.Equatable {
    /// The name of the custom vocabulary filter you want to delete. Custom vocabulary filter names are case sensitive.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?

    public init(
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.vocabularyFilterName = vocabularyFilterName
    }
}

struct DeleteVocabularyFilterInputBody: Swift.Equatable {
}

extension DeleteVocabularyFilterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVocabularyFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVocabularyFilterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVocabularyFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVocabularyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVocabularyInput: Swift.Equatable {
    /// The name of the custom vocabulary you want to delete. Custom vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

struct DeleteVocabularyInputBody: Swift.Equatable {
}

extension DeleteVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVocabularyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLanguageModelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeLanguageModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLanguageModelInput: Swift.Equatable {
    /// The name of the custom language model you want information about. Model names are case sensitive.
    /// This member is required.
    public var modelName: Swift.String?

    public init(
        modelName: Swift.String? = nil
    )
    {
        self.modelName = modelName
    }
}

struct DescribeLanguageModelInputBody: Swift.Equatable {
}

extension DescribeLanguageModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLanguageModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLanguageModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.languageModel = output.languageModel
        } else {
            self.languageModel = nil
        }
    }
}

public struct DescribeLanguageModelOutput: Swift.Equatable {
    /// Provides information about the specified custom language model. This parameter also shows if the base language model you used to create your custom language model has been updated. If Amazon Transcribe has updated the base model, you can create a new custom language model using the updated base model. If you tried to create a new custom language model and the request wasn't successful, you can use this DescribeLanguageModel to help identify the reason for this failure.
    public var languageModel: TranscribeClientTypes.LanguageModel?

    public init(
        languageModel: TranscribeClientTypes.LanguageModel? = nil
    )
    {
        self.languageModel = languageModel
    }
}

struct DescribeLanguageModelOutputBody: Swift.Equatable {
    let languageModel: TranscribeClientTypes.LanguageModel?
}

extension DescribeLanguageModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageModel = "LanguageModel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageModelDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageModel.self, forKey: .languageModel)
        languageModel = languageModelDecoded
    }
}

enum DescribeLanguageModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCallAnalyticsCategoryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetCallAnalyticsCategoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCallAnalyticsCategoryInput: Swift.Equatable {
    /// The name of the Call Analytics category you want information about. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?

    public init(
        categoryName: Swift.String? = nil
    )
    {
        self.categoryName = categoryName
    }
}

struct GetCallAnalyticsCategoryInputBody: Swift.Equatable {
}

extension GetCallAnalyticsCategoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCallAnalyticsCategoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCallAnalyticsCategoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.categoryProperties = output.categoryProperties
        } else {
            self.categoryProperties = nil
        }
    }
}

public struct GetCallAnalyticsCategoryOutput: Swift.Equatable {
    /// Provides you with the properties of the Call Analytics category you specified in your GetCallAnalyticsCategory request.
    public var categoryProperties: TranscribeClientTypes.CategoryProperties?

    public init(
        categoryProperties: TranscribeClientTypes.CategoryProperties? = nil
    )
    {
        self.categoryProperties = categoryProperties
    }
}

struct GetCallAnalyticsCategoryOutputBody: Swift.Equatable {
    let categoryProperties: TranscribeClientTypes.CategoryProperties?
}

extension GetCallAnalyticsCategoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryProperties = "CategoryProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryPropertiesDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CategoryProperties.self, forKey: .categoryProperties)
        categoryProperties = categoryPropertiesDecoded
    }
}

enum GetCallAnalyticsCategoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCallAnalyticsJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetCallAnalyticsJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCallAnalyticsJobInput: Swift.Equatable {
    /// The name of the Call Analytics job you want information about. Job names are case sensitive.
    /// This member is required.
    public var callAnalyticsJobName: Swift.String?

    public init(
        callAnalyticsJobName: Swift.String? = nil
    )
    {
        self.callAnalyticsJobName = callAnalyticsJobName
    }
}

struct GetCallAnalyticsJobInputBody: Swift.Equatable {
}

extension GetCallAnalyticsJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCallAnalyticsJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCallAnalyticsJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.callAnalyticsJob = output.callAnalyticsJob
        } else {
            self.callAnalyticsJob = nil
        }
    }
}

public struct GetCallAnalyticsJobOutput: Swift.Equatable {
    /// Provides detailed information about the specified Call Analytics job, including job status and, if applicable, failure reason.
    public var callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob?

    public init(
        callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob? = nil
    )
    {
        self.callAnalyticsJob = callAnalyticsJob
    }
}

struct GetCallAnalyticsJobOutputBody: Swift.Equatable {
    let callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob?
}

extension GetCallAnalyticsJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callAnalyticsJob = "CallAnalyticsJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callAnalyticsJobDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJob.self, forKey: .callAnalyticsJob)
        callAnalyticsJob = callAnalyticsJobDecoded
    }
}

enum GetCallAnalyticsJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMedicalTranscriptionJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetMedicalTranscriptionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMedicalTranscriptionJobInput: Swift.Equatable {
    /// The name of the medical transcription job you want information about. Job names are case sensitive.
    /// This member is required.
    public var medicalTranscriptionJobName: Swift.String?

    public init(
        medicalTranscriptionJobName: Swift.String? = nil
    )
    {
        self.medicalTranscriptionJobName = medicalTranscriptionJobName
    }
}

struct GetMedicalTranscriptionJobInputBody: Swift.Equatable {
}

extension GetMedicalTranscriptionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMedicalTranscriptionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMedicalTranscriptionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.medicalTranscriptionJob = output.medicalTranscriptionJob
        } else {
            self.medicalTranscriptionJob = nil
        }
    }
}

public struct GetMedicalTranscriptionJobOutput: Swift.Equatable {
    /// Provides detailed information about the specified medical transcription job, including job status and, if applicable, failure reason.
    public var medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob?

    public init(
        medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob? = nil
    )
    {
        self.medicalTranscriptionJob = medicalTranscriptionJob
    }
}

struct GetMedicalTranscriptionJobOutputBody: Swift.Equatable {
    let medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob?
}

extension GetMedicalTranscriptionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case medicalTranscriptionJob = "MedicalTranscriptionJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let medicalTranscriptionJobDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalTranscriptionJob.self, forKey: .medicalTranscriptionJob)
        medicalTranscriptionJob = medicalTranscriptionJobDecoded
    }
}

enum GetMedicalTranscriptionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMedicalVocabularyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetMedicalVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMedicalVocabularyInput: Swift.Equatable {
    /// The name of the custom medical vocabulary you want information about. Custom medical vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

struct GetMedicalVocabularyInputBody: Swift.Equatable {
}

extension GetMedicalVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMedicalVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMedicalVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.downloadUri = output.downloadUri
            self.failureReason = output.failureReason
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyName = output.vocabularyName
            self.vocabularyState = output.vocabularyState
        } else {
            self.downloadUri = nil
            self.failureReason = nil
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyName = nil
            self.vocabularyState = nil
        }
    }
}

public struct GetMedicalVocabularyOutput: Swift.Equatable {
    /// The S3 location where the specified custom medical vocabulary is stored; use this URI to view or download the custom vocabulary.
    public var downloadUri: Swift.String?
    /// If VocabularyState is FAILED, FailureReason contains information about why the custom medical vocabulary request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom medical vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom medical vocabulary was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the custom medical vocabulary you requested information about.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom medical vocabulary. If the state is READY, you can use the custom vocabulary in a StartMedicalTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        downloadUri: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.downloadUri = downloadUri
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

struct GetMedicalVocabularyOutputBody: Swift.Equatable {
    let vocabularyName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let vocabularyState: TranscribeClientTypes.VocabularyState?
    let lastModifiedTime: ClientRuntime.Date?
    let failureReason: Swift.String?
    let downloadUri: Swift.String?
}

extension GetMedicalVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUri = "DownloadUri"
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let downloadUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUri)
        downloadUri = downloadUriDecoded
    }
}

enum GetMedicalVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTranscriptionJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetTranscriptionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTranscriptionJobInput: Swift.Equatable {
    /// The name of the transcription job you want information about. Job names are case sensitive.
    /// This member is required.
    public var transcriptionJobName: Swift.String?

    public init(
        transcriptionJobName: Swift.String? = nil
    )
    {
        self.transcriptionJobName = transcriptionJobName
    }
}

struct GetTranscriptionJobInputBody: Swift.Equatable {
}

extension GetTranscriptionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTranscriptionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTranscriptionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.transcriptionJob = output.transcriptionJob
        } else {
            self.transcriptionJob = nil
        }
    }
}

public struct GetTranscriptionJobOutput: Swift.Equatable {
    /// Provides detailed information about the specified transcription job, including job status and, if applicable, failure reason.
    public var transcriptionJob: TranscribeClientTypes.TranscriptionJob?

    public init(
        transcriptionJob: TranscribeClientTypes.TranscriptionJob? = nil
    )
    {
        self.transcriptionJob = transcriptionJob
    }
}

struct GetTranscriptionJobOutputBody: Swift.Equatable {
    let transcriptionJob: TranscribeClientTypes.TranscriptionJob?
}

extension GetTranscriptionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionJob = "TranscriptionJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionJobDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJob.self, forKey: .transcriptionJob)
        transcriptionJob = transcriptionJobDecoded
    }
}

enum GetTranscriptionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVocabularyFilterInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetVocabularyFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVocabularyFilterInput: Swift.Equatable {
    /// The name of the custom vocabulary filter you want information about. Custom vocabulary filter names are case sensitive.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?

    public init(
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.vocabularyFilterName = vocabularyFilterName
    }
}

struct GetVocabularyFilterInputBody: Swift.Equatable {
}

extension GetVocabularyFilterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVocabularyFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVocabularyFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.downloadUri = output.downloadUri
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyFilterName = output.vocabularyFilterName
        } else {
            self.downloadUri = nil
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyFilterName = nil
        }
    }
}

public struct GetVocabularyFilterOutput: Swift.Equatable {
    /// The Amazon S3 location where the custom vocabulary filter is stored; use this URI to view or download the custom vocabulary filter.
    public var downloadUri: Swift.String?
    /// The language code you selected for your custom vocabulary filter.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary filter was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the custom vocabulary filter you requested information about.
    public var vocabularyFilterName: Swift.String?

    public init(
        downloadUri: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.downloadUri = downloadUri
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyFilterName = vocabularyFilterName
    }
}

struct GetVocabularyFilterOutputBody: Swift.Equatable {
    let vocabularyFilterName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let lastModifiedTime: ClientRuntime.Date?
    let downloadUri: Swift.String?
}

extension GetVocabularyFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUri = "DownloadUri"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyFilterName = "VocabularyFilterName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let downloadUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUri)
        downloadUri = downloadUriDecoded
    }
}

enum GetVocabularyFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVocabularyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVocabularyInput: Swift.Equatable {
    /// The name of the custom vocabulary you want information about. Custom vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        vocabularyName: Swift.String? = nil
    )
    {
        self.vocabularyName = vocabularyName
    }
}

struct GetVocabularyInputBody: Swift.Equatable {
}

extension GetVocabularyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.downloadUri = output.downloadUri
            self.failureReason = output.failureReason
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyName = output.vocabularyName
            self.vocabularyState = output.vocabularyState
        } else {
            self.downloadUri = nil
            self.failureReason = nil
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyName = nil
            self.vocabularyState = nil
        }
    }
}

public struct GetVocabularyOutput: Swift.Equatable {
    /// The S3 location where the custom vocabulary is stored; use this URI to view or download the custom vocabulary.
    public var downloadUri: Swift.String?
    /// If VocabularyState is FAILED, FailureReason contains information about why the custom vocabulary request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
    public var failureReason: Swift.String?
    /// The language code you selected for your custom vocabulary.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the custom vocabulary you requested information about.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        downloadUri: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.downloadUri = downloadUri
        self.failureReason = failureReason
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

struct GetVocabularyOutputBody: Swift.Equatable {
    let vocabularyName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let vocabularyState: TranscribeClientTypes.VocabularyState?
    let lastModifiedTime: ClientRuntime.Date?
    let failureReason: Swift.String?
    let downloadUri: Swift.String?
}

extension GetVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUri = "DownloadUri"
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let downloadUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUri)
        downloadUri = downloadUriDecoded
    }
}

enum GetVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TranscribeClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case s3Uri = "S3Uri"
        case tuningDataS3Uri = "TuningDataS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
        if let tuningDataS3Uri = self.tuningDataS3Uri {
            try encodeContainer.encode(tuningDataS3Uri, forKey: .tuningDataS3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let tuningDataS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tuningDataS3Uri)
        tuningDataS3Uri = tuningDataS3UriDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension TranscribeClientTypes {
    /// Contains the Amazon S3 location of the training data you want to use to create a new custom language model, and permissions to access this location. When using InputDataConfig, you must include these sub-parameters: S3Uri and DataAccessRoleArn. You can optionally include TuningDataS3Uri.
    public struct InputDataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The Amazon S3 location (URI) of the text files you want to use to train your custom language model. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-model-training-data/
        /// This member is required.
        public var s3Uri: Swift.String?
        /// The Amazon S3 location (URI) of the text files you want to use to tune your custom language model. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-model-tuning-data/
        public var tuningDataS3Uri: Swift.String?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            s3Uri: Swift.String? = nil,
            tuningDataS3Uri: Swift.String? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.s3Uri = s3Uri
            self.tuningDataS3Uri = tuningDataS3Uri
        }
    }

}

extension TranscribeClientTypes {
    public enum InputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case postCall
        case realTime
        case sdkUnknown(Swift.String)

        public static var allCases: [InputType] {
            return [
                .postCall,
                .realTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .postCall: return "POST_CALL"
            case .realTime: return "REAL_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputType(rawValue: rawValue) ?? InputType.sdkUnknown(rawValue)
        }
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an internal error. Check the error message, correct the issue, and try your request again.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeClientTypes.InterruptionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTimeRange = "AbsoluteTimeRange"
        case negate = "Negate"
        case participantRole = "ParticipantRole"
        case relativeTimeRange = "RelativeTimeRange"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTimeRange = self.absoluteTimeRange {
            try encodeContainer.encode(absoluteTimeRange, forKey: .absoluteTimeRange)
        }
        if let negate = self.negate {
            try encodeContainer.encode(negate, forKey: .negate)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let relativeTimeRange = self.relativeTimeRange {
            try encodeContainer.encode(relativeTimeRange, forKey: .relativeTimeRange)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .threshold)
        threshold = thresholdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let absoluteTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.AbsoluteTimeRange.self, forKey: .absoluteTimeRange)
        absoluteTimeRange = absoluteTimeRangeDecoded
        let relativeTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.RelativeTimeRange.self, forKey: .relativeTimeRange)
        relativeTimeRange = relativeTimeRangeDecoded
        let negateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negate)
        negate = negateDecoded
    }
}

extension TranscribeClientTypes {
    /// Flag the presence or absence of interruptions in your Call Analytics transcription output. Rules using InterruptionFilter are designed to match:
    ///
    /// * Instances where an agent interrupts a customer
    ///
    /// * Instances where a customer interrupts an agent
    ///
    /// * Either participant interrupting the other
    ///
    /// * A lack of interruptions
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) for usage examples.
    public struct InterruptionFilter: Swift.Equatable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for an interruption. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag speech that does not contain interruptions. Set to FALSE to flag speech that contains interruptions.
        public var negate: Swift.Bool?
        /// Specify the interrupter that you want to flag. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for an interruption. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the duration of the interruptions in milliseconds. For example, you can flag speech that contains more than 10,000 milliseconds of interruptions.
        public var threshold: Swift.Int?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.participantRole = participantRole
            self.relativeTimeRange = relativeTimeRange
            self.threshold = threshold
        }
    }

}

extension TranscribeClientTypes.JobExecutionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowDeferredExecution = "AllowDeferredExecution"
        case dataAccessRoleArn = "DataAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowDeferredExecution = self.allowDeferredExecution {
            try encodeContainer.encode(allowDeferredExecution, forKey: .allowDeferredExecution)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowDeferredExecutionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowDeferredExecution)
        allowDeferredExecution = allowDeferredExecutionDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension TranscribeClientTypes {
    /// Makes it possible to control how your transcription job is processed. Currently, the only JobExecutionSettings modification you can choose is enabling job queueing using the AllowDeferredExecution sub-parameter. If you include JobExecutionSettings in your request, you must also include the sub-parameters: AllowDeferredExecution and DataAccessRoleArn.
    public struct JobExecutionSettings: Swift.Equatable {
        /// Makes it possible to enable job queuing when your concurrent request limit is exceeded. When AllowDeferredExecution is set to true, transcription job requests are placed in a queue until the number of jobs falls below the concurrent request limit. If AllowDeferredExecution is set to false and the number of transcription job requests exceed the concurrent request limit, you get a LimitExceededException error. If you include AllowDeferredExecution in your request, you must also include DataAccessRoleArn.
        public var allowDeferredExecution: Swift.Bool?
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). Note that if you include DataAccessRoleArn in your request, you must also include AllowDeferredExecution.
        public var dataAccessRoleArn: Swift.String?

        public init(
            allowDeferredExecution: Swift.Bool? = nil,
            dataAccessRoleArn: Swift.String? = nil
        )
        {
            self.allowDeferredExecution = allowDeferredExecution
            self.dataAccessRoleArn = dataAccessRoleArn
        }
    }

}

extension TranscribeClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afZa
        case arAe
        case arSa
        case daDk
        case deCh
        case deDe
        case enAb
        case enAu
        case enGb
        case enIe
        case enIn
        case enNz
        case enUs
        case enWl
        case enZa
        case esEs
        case esUs
        case faIr
        case frCa
        case frFr
        case heIl
        case hiIn
        case idId
        case itIt
        case jaJp
        case koKr
        case msMy
        case nlNl
        case ptBr
        case ptPt
        case ruRu
        case svSe
        case taIn
        case teIn
        case thTh
        case trTr
        case viVn
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .afZa,
                .arAe,
                .arSa,
                .daDk,
                .deCh,
                .deDe,
                .enAb,
                .enAu,
                .enGb,
                .enIe,
                .enIn,
                .enNz,
                .enUs,
                .enWl,
                .enZa,
                .esEs,
                .esUs,
                .faIr,
                .frCa,
                .frFr,
                .heIl,
                .hiIn,
                .idId,
                .itIt,
                .jaJp,
                .koKr,
                .msMy,
                .nlNl,
                .ptBr,
                .ptPt,
                .ruRu,
                .svSe,
                .taIn,
                .teIn,
                .thTh,
                .trTr,
                .viVn,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afZa: return "af-ZA"
            case .arAe: return "ar-AE"
            case .arSa: return "ar-SA"
            case .daDk: return "da-DK"
            case .deCh: return "de-CH"
            case .deDe: return "de-DE"
            case .enAb: return "en-AB"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enIe: return "en-IE"
            case .enIn: return "en-IN"
            case .enNz: return "en-NZ"
            case .enUs: return "en-US"
            case .enWl: return "en-WL"
            case .enZa: return "en-ZA"
            case .esEs: return "es-ES"
            case .esUs: return "es-US"
            case .faIr: return "fa-IR"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .heIl: return "he-IL"
            case .hiIn: return "hi-IN"
            case .idId: return "id-ID"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .msMy: return "ms-MY"
            case .nlNl: return "nl-NL"
            case .ptBr: return "pt-BR"
            case .ptPt: return "pt-PT"
            case .ruRu: return "ru-RU"
            case .svSe: return "sv-SE"
            case .taIn: return "ta-IN"
            case .teIn: return "te-IN"
            case .thTh: return "th-TH"
            case .trTr: return "tr-TR"
            case .viVn: return "vi-VN"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.LanguageCodeItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case languageCode = "LanguageCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides information on the speech contained in a discreet utterance when multi-language identification is enabled in your request. This utterance represents a block of speech consisting of one language, preceded or followed by a block of speech in a different language.
    public struct LanguageCodeItem: Swift.Equatable {
        /// Provides the total time, in seconds, each identified language is spoken in your media.
        public var durationInSeconds: Swift.Float?
        /// Provides the language code for each language identified in your media.
        public var languageCode: TranscribeClientTypes.LanguageCode?

        public init(
            durationInSeconds: Swift.Float? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.languageCode = languageCode
        }
    }

}

extension TranscribeClientTypes.LanguageIdSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageModelName = "LanguageModelName"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
    }
}

extension TranscribeClientTypes {
    /// If using automatic language identification in your request and you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). Note that multi-language identification (IdentifyMultipleLanguages) doesn't support custom language models. LanguageIdSettings supports two to five language codes. Each language code you include can have an associated custom language model, custom vocabulary, and custom vocabulary filter. The language codes that you specify must match the languages of the associated custom language models, custom vocabularies, and custom vocabulary filters. It's recommended that you include LanguageOptions when using LanguageIdSettings to ensure that the correct language dialect is identified. For example, if you specify a custom vocabulary that is in en-US but Amazon Transcribe determines that the language spoken in your media is en-AU, your custom vocabulary is not applied to your transcription. If you include LanguageOptions and include en-US as the only English language dialect, your custom vocabulary is applied to your transcription. If you want to include a custom language model with your request but do not want to use automatic language identification, use instead the  parameter with the LanguageModelName sub-parameter. If you want to include a custom vocabulary or a custom vocabulary filter (or both) with your request but do not want to use automatic language identification, use instead the  parameter with the VocabularyName or VocabularyFilterName (or both) sub-parameter.
    public struct LanguageIdSettings: Swift.Equatable {
        /// The name of the custom language model you want to use when processing your transcription job. Note that custom language model names are case sensitive. The language of the specified custom language model must match the language code that you specify in your transcription request. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.
        public var languageModelName: Swift.String?
        /// The name of the custom vocabulary filter you want to use when processing your transcription job. Custom vocabulary filter names are case sensitive. The language of the specified custom vocabulary filter must match the language code that you specify in your transcription request. If the languages don't match, the custom vocabulary filter isn't applied. There are no errors or warnings associated with a language mismatch. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to use when processing your transcription job. Custom vocabulary names are case sensitive. The language of the specified custom vocabulary must match the language code that you specify in your transcription request. If the languages don't match, the custom vocabulary isn't applied. There are no errors or warnings associated with a language mismatch.
        public var vocabularyName: Swift.String?

        public init(
            languageModelName: Swift.String? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.languageModelName = languageModelName
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }

}

extension TranscribeClientTypes.LanguageModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelName = "BaseModelName"
        case createTime = "CreateTime"
        case failureReason = "FailureReason"
        case inputDataConfig = "InputDataConfig"
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case modelName = "ModelName"
        case modelStatus = "ModelStatus"
        case upgradeAvailability = "UpgradeAvailability"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseModelName = self.baseModelName {
            try encodeContainer.encode(baseModelName.rawValue, forKey: .baseModelName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let modelStatus = self.modelStatus {
            try encodeContainer.encode(modelStatus.rawValue, forKey: .modelStatus)
        }
        if let upgradeAvailability = self.upgradeAvailability {
            try encodeContainer.encode(upgradeAvailability, forKey: .upgradeAvailability)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CLMLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let baseModelNameDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.BaseModelName.self, forKey: .baseModelName)
        baseModelName = baseModelNameDecoded
        let modelStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelStatus.self, forKey: .modelStatus)
        modelStatus = modelStatusDecoded
        let upgradeAvailabilityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .upgradeAvailability)
        upgradeAvailability = upgradeAvailabilityDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides information about a custom language model, including:
    ///
    /// * The base model name
    ///
    /// * When the model was created
    ///
    /// * The location of the files used to train the model
    ///
    /// * When the model was last modified
    ///
    /// * The name you chose for the model
    ///
    /// * The model's language
    ///
    /// * The model's processing state
    ///
    /// * Any available upgrades for the base model
    public struct LanguageModel: Swift.Equatable {
        /// The Amazon Transcribe standard language model, or base model, used to create your custom language model.
        public var baseModelName: TranscribeClientTypes.BaseModelName?
        /// The date and time the specified custom language model was created. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var createTime: ClientRuntime.Date?
        /// If ModelStatus is FAILED, FailureReason contains information about why the custom language model request failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The Amazon S3 location of the input files used to train and tune your custom language model, in addition to the data access role ARN (Amazon Resource Name) that has permissions to access these data.
        public var inputDataConfig: TranscribeClientTypes.InputDataConfig?
        /// The language code used to create your custom language model. Each custom language model must contain terms in only one language, and the language you select for your custom language model must match the language of your training and tuning data. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. Note that U.S. English (en-US) is the only language supported with Amazon Transcribe Medical.
        public var languageCode: TranscribeClientTypes.CLMLanguageCode?
        /// The date and time the specified custom language model was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A unique name, chosen by you, for your custom language model. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var modelName: Swift.String?
        /// The status of the specified custom language model. When the status displays as COMPLETED the model is ready for use.
        public var modelStatus: TranscribeClientTypes.ModelStatus?
        /// Shows if a more current base model is available for use with the specified custom language model. If false, your custom language model is using the most up-to-date base model. If true, there is a newer base model available than the one your language model is using. Note that to update a base model, you must recreate the custom language model using the new base model. Base model upgrades for existing custom language models are not supported.
        public var upgradeAvailability: Swift.Bool?

        public init(
            baseModelName: TranscribeClientTypes.BaseModelName? = nil,
            createTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            inputDataConfig: TranscribeClientTypes.InputDataConfig? = nil,
            languageCode: TranscribeClientTypes.CLMLanguageCode? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            modelName: Swift.String? = nil,
            modelStatus: TranscribeClientTypes.ModelStatus? = nil,
            upgradeAvailability: Swift.Bool? = nil
        )
        {
            self.baseModelName = baseModelName
            self.createTime = createTime
            self.failureReason = failureReason
            self.inputDataConfig = inputDataConfig
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.modelName = modelName
            self.modelStatus = modelStatus
            self.upgradeAvailability = upgradeAvailability
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've either sent too many requests or your input file is too long. Wait before retrying your request, or use a smaller file and try your request again.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCallAnalyticsCategoriesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListCallAnalyticsCategoriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListCallAnalyticsCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCallAnalyticsCategoriesInput: Swift.Equatable {
    /// The maximum number of Call Analytics categories to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListCallAnalyticsCategories request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCallAnalyticsCategoriesInputBody: Swift.Equatable {
}

extension ListCallAnalyticsCategoriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCallAnalyticsCategoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCallAnalyticsCategoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.categories = output.categories
            self.nextToken = output.nextToken
        } else {
            self.categories = nil
            self.nextToken = nil
        }
    }
}

public struct ListCallAnalyticsCategoriesOutput: Swift.Equatable {
    /// Provides detailed information about your Call Analytics categories, including all the rules associated with each category.
    public var categories: [TranscribeClientTypes.CategoryProperties]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        categories: [TranscribeClientTypes.CategoryProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categories = categories
        self.nextToken = nextToken
    }
}

struct ListCallAnalyticsCategoriesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let categories: [TranscribeClientTypes.CategoryProperties]?
}

extension ListCallAnalyticsCategoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categories = "Categories"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.CategoryProperties?].self, forKey: .categories)
        var categoriesDecoded0:[TranscribeClientTypes.CategoryProperties]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [TranscribeClientTypes.CategoryProperties]()
            for structure0 in categoriesContainer {
                if let structure0 = structure0 {
                    categoriesDecoded0?.append(structure0)
                }
            }
        }
        categories = categoriesDecoded0
    }
}

enum ListCallAnalyticsCategoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCallAnalyticsJobsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListCallAnalyticsJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListCallAnalyticsJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCallAnalyticsJobsInput: Swift.Equatable {
    /// Returns only the Call Analytics jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of Call Analytics jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListCallAnalyticsJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only Call Analytics jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you don't include Status, all Call Analytics jobs are returned.
    public var status: TranscribeClientTypes.CallAnalyticsJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.CallAnalyticsJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListCallAnalyticsJobsInputBody: Swift.Equatable {
}

extension ListCallAnalyticsJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCallAnalyticsJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCallAnalyticsJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.callAnalyticsJobSummaries = output.callAnalyticsJobSummaries
            self.nextToken = output.nextToken
            self.status = output.status
        } else {
            self.callAnalyticsJobSummaries = nil
            self.nextToken = nil
            self.status = nil
        }
    }
}

public struct ListCallAnalyticsJobsOutput: Swift.Equatable {
    /// Provides a summary of information about each result.
    public var callAnalyticsJobSummaries: [TranscribeClientTypes.CallAnalyticsJobSummary]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all Call Analytics jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.CallAnalyticsJobStatus?

    public init(
        callAnalyticsJobSummaries: [TranscribeClientTypes.CallAnalyticsJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.CallAnalyticsJobStatus? = nil
    )
    {
        self.callAnalyticsJobSummaries = callAnalyticsJobSummaries
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListCallAnalyticsJobsOutputBody: Swift.Equatable {
    let status: TranscribeClientTypes.CallAnalyticsJobStatus?
    let nextToken: Swift.String?
    let callAnalyticsJobSummaries: [TranscribeClientTypes.CallAnalyticsJobSummary]?
}

extension ListCallAnalyticsJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callAnalyticsJobSummaries = "CallAnalyticsJobSummaries"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJobStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let callAnalyticsJobSummariesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.CallAnalyticsJobSummary?].self, forKey: .callAnalyticsJobSummaries)
        var callAnalyticsJobSummariesDecoded0:[TranscribeClientTypes.CallAnalyticsJobSummary]? = nil
        if let callAnalyticsJobSummariesContainer = callAnalyticsJobSummariesContainer {
            callAnalyticsJobSummariesDecoded0 = [TranscribeClientTypes.CallAnalyticsJobSummary]()
            for structure0 in callAnalyticsJobSummariesContainer {
                if let structure0 = structure0 {
                    callAnalyticsJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        callAnalyticsJobSummaries = callAnalyticsJobSummariesDecoded0
    }
}

enum ListCallAnalyticsJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLanguageModelsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListLanguageModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListLanguageModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLanguageModelsInput: Swift.Equatable {
    /// The maximum number of custom language models to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom language models that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListLanguageModels request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only custom language models with the specified status. Language models are ordered by creation date, with the newest model first. If you don't include StatusEquals, all custom language models are returned.
    public var statusEquals: TranscribeClientTypes.ModelStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        statusEquals: TranscribeClientTypes.ModelStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.statusEquals = statusEquals
    }
}

struct ListLanguageModelsInputBody: Swift.Equatable {
}

extension ListLanguageModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLanguageModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLanguageModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct ListLanguageModelsOutput: Swift.Equatable {
    /// Provides information about the custom language models that match the criteria specified in your request.
    public var models: [TranscribeClientTypes.LanguageModel]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        models: [TranscribeClientTypes.LanguageModel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct ListLanguageModelsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let models: [TranscribeClientTypes.LanguageModel]?
}

extension ListLanguageModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case models = "Models"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.LanguageModel?].self, forKey: .models)
        var modelsDecoded0:[TranscribeClientTypes.LanguageModel]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [TranscribeClientTypes.LanguageModel]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
    }
}

enum ListLanguageModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMedicalTranscriptionJobsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListMedicalTranscriptionJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListMedicalTranscriptionJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMedicalTranscriptionJobsInput: Swift.Equatable {
    /// Returns only the medical transcription jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of medical transcription jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListMedicalTranscriptionJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only medical transcription jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you don't include Status, all medical transcription jobs are returned.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListMedicalTranscriptionJobsInputBody: Swift.Equatable {
}

extension ListMedicalTranscriptionJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMedicalTranscriptionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMedicalTranscriptionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.medicalTranscriptionJobSummaries = output.medicalTranscriptionJobSummaries
            self.nextToken = output.nextToken
            self.status = output.status
        } else {
            self.medicalTranscriptionJobSummaries = nil
            self.nextToken = nil
            self.status = nil
        }
    }
}

public struct ListMedicalTranscriptionJobsOutput: Swift.Equatable {
    /// Provides a summary of information about each result.
    public var medicalTranscriptionJobSummaries: [TranscribeClientTypes.MedicalTranscriptionJobSummary]?
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all medical transcription jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?

    public init(
        medicalTranscriptionJobSummaries: [TranscribeClientTypes.MedicalTranscriptionJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil
    )
    {
        self.medicalTranscriptionJobSummaries = medicalTranscriptionJobSummaries
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListMedicalTranscriptionJobsOutputBody: Swift.Equatable {
    let status: TranscribeClientTypes.TranscriptionJobStatus?
    let nextToken: Swift.String?
    let medicalTranscriptionJobSummaries: [TranscribeClientTypes.MedicalTranscriptionJobSummary]?
}

extension ListMedicalTranscriptionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case medicalTranscriptionJobSummaries = "MedicalTranscriptionJobSummaries"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJobStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let medicalTranscriptionJobSummariesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.MedicalTranscriptionJobSummary?].self, forKey: .medicalTranscriptionJobSummaries)
        var medicalTranscriptionJobSummariesDecoded0:[TranscribeClientTypes.MedicalTranscriptionJobSummary]? = nil
        if let medicalTranscriptionJobSummariesContainer = medicalTranscriptionJobSummariesContainer {
            medicalTranscriptionJobSummariesDecoded0 = [TranscribeClientTypes.MedicalTranscriptionJobSummary]()
            for structure0 in medicalTranscriptionJobSummariesContainer {
                if let structure0 = structure0 {
                    medicalTranscriptionJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        medicalTranscriptionJobSummaries = medicalTranscriptionJobSummariesDecoded0
    }
}

enum ListMedicalTranscriptionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMedicalVocabulariesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListMedicalVocabulariesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListMedicalVocabulariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMedicalVocabulariesInput: Swift.Equatable {
    /// The maximum number of custom medical vocabularies to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom medical vocabularies that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListMedicalVocabularies request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only custom medical vocabularies with the specified state. Custom vocabularies are ordered by creation date, with the newest vocabulary first. If you don't include StateEquals, all custom medical vocabularies are returned.
    public var stateEquals: TranscribeClientTypes.VocabularyState?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        stateEquals: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.stateEquals = stateEquals
    }
}

struct ListMedicalVocabulariesInputBody: Swift.Equatable {
}

extension ListMedicalVocabulariesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMedicalVocabulariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMedicalVocabulariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.status = output.status
            self.vocabularies = output.vocabularies
        } else {
            self.nextToken = nil
            self.status = nil
            self.vocabularies = nil
        }
    }
}

public struct ListMedicalVocabulariesOutput: Swift.Equatable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all custom medical vocabularies that have the status specified in your request. Custom vocabularies are ordered by creation date, with the newest vocabulary first.
    public var status: TranscribeClientTypes.VocabularyState?
    /// Provides information about the custom medical vocabularies that match the criteria specified in your request.
    public var vocabularies: [TranscribeClientTypes.VocabularyInfo]?

    public init(
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.VocabularyState? = nil,
        vocabularies: [TranscribeClientTypes.VocabularyInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
        self.vocabularies = vocabularies
    }
}

struct ListMedicalVocabulariesOutputBody: Swift.Equatable {
    let status: TranscribeClientTypes.VocabularyState?
    let nextToken: Swift.String?
    let vocabularies: [TranscribeClientTypes.VocabularyInfo]?
}

extension ListMedicalVocabulariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
        case vocabularies = "Vocabularies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let vocabulariesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.VocabularyInfo?].self, forKey: .vocabularies)
        var vocabulariesDecoded0:[TranscribeClientTypes.VocabularyInfo]? = nil
        if let vocabulariesContainer = vocabulariesContainer {
            vocabulariesDecoded0 = [TranscribeClientTypes.VocabularyInfo]()
            for structure0 in vocabulariesContainer {
                if let structure0 = structure0 {
                    vocabulariesDecoded0?.append(structure0)
                }
            }
        }
        vocabularies = vocabulariesDecoded0
    }
}

enum ListMedicalVocabulariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Returns a list of all tags associated with the specified Amazon Resource Name (ARN). ARNs have the format arn:partition:service:region:account-id:resource-type/resource-id. For example, arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name. Valid values for resource-type are: transcription-job, medical-transcription-job, vocabulary, medical-vocabulary, vocabulary-filter, and language-model.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) specified in your request.
    public var resourceArn: Swift.String?
    /// Lists all tags associated with the given transcription job, vocabulary, model, or resource.
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [TranscribeClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTranscriptionJobsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTranscriptionJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListTranscriptionJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTranscriptionJobsInput: Swift.Equatable {
    /// Returns only the transcription jobs that contain the specified string. The search is not case sensitive.
    public var jobNameContains: Swift.String?
    /// The maximum number of transcription jobs to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// If your ListTranscriptionJobs request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only transcription jobs with the specified status. Jobs are ordered by creation date, with the newest job first. If you don't include Status, all transcription jobs are returned.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?

    public init(
        jobNameContains: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil
    )
    {
        self.jobNameContains = jobNameContains
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListTranscriptionJobsInputBody: Swift.Equatable {
}

extension ListTranscriptionJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTranscriptionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTranscriptionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.status = output.status
            self.transcriptionJobSummaries = output.transcriptionJobSummaries
        } else {
            self.nextToken = nil
            self.status = nil
            self.transcriptionJobSummaries = nil
        }
    }
}

public struct ListTranscriptionJobsOutput: Swift.Equatable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all transcription jobs that have the status specified in your request. Jobs are ordered by creation date, with the newest job first.
    public var status: TranscribeClientTypes.TranscriptionJobStatus?
    /// Provides a summary of information about each result.
    public var transcriptionJobSummaries: [TranscribeClientTypes.TranscriptionJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.TranscriptionJobStatus? = nil,
        transcriptionJobSummaries: [TranscribeClientTypes.TranscriptionJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
        self.transcriptionJobSummaries = transcriptionJobSummaries
    }
}

struct ListTranscriptionJobsOutputBody: Swift.Equatable {
    let status: TranscribeClientTypes.TranscriptionJobStatus?
    let nextToken: Swift.String?
    let transcriptionJobSummaries: [TranscribeClientTypes.TranscriptionJobSummary]?
}

extension ListTranscriptionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
        case transcriptionJobSummaries = "TranscriptionJobSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJobStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let transcriptionJobSummariesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.TranscriptionJobSummary?].self, forKey: .transcriptionJobSummaries)
        var transcriptionJobSummariesDecoded0:[TranscribeClientTypes.TranscriptionJobSummary]? = nil
        if let transcriptionJobSummariesContainer = transcriptionJobSummariesContainer {
            transcriptionJobSummariesDecoded0 = [TranscribeClientTypes.TranscriptionJobSummary]()
            for structure0 in transcriptionJobSummariesContainer {
                if let structure0 = structure0 {
                    transcriptionJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        transcriptionJobSummaries = transcriptionJobSummariesDecoded0
    }
}

enum ListTranscriptionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVocabulariesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListVocabulariesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListVocabulariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVocabulariesInput: Swift.Equatable {
    /// The maximum number of custom vocabularies to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom vocabularies that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListVocabularies request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Returns only custom vocabularies with the specified state. Vocabularies are ordered by creation date, with the newest vocabulary first. If you don't include StateEquals, all custom medical vocabularies are returned.
    public var stateEquals: TranscribeClientTypes.VocabularyState?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        stateEquals: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.stateEquals = stateEquals
    }
}

struct ListVocabulariesInputBody: Swift.Equatable {
}

extension ListVocabulariesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVocabulariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVocabulariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.status = output.status
            self.vocabularies = output.vocabularies
        } else {
            self.nextToken = nil
            self.status = nil
            self.vocabularies = nil
        }
    }
}

public struct ListVocabulariesOutput: Swift.Equatable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Lists all custom vocabularies that have the status specified in your request. Vocabularies are ordered by creation date, with the newest vocabulary first.
    public var status: TranscribeClientTypes.VocabularyState?
    /// Provides information about the custom vocabularies that match the criteria specified in your request.
    public var vocabularies: [TranscribeClientTypes.VocabularyInfo]?

    public init(
        nextToken: Swift.String? = nil,
        status: TranscribeClientTypes.VocabularyState? = nil,
        vocabularies: [TranscribeClientTypes.VocabularyInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
        self.vocabularies = vocabularies
    }
}

struct ListVocabulariesOutputBody: Swift.Equatable {
    let status: TranscribeClientTypes.VocabularyState?
    let nextToken: Swift.String?
    let vocabularies: [TranscribeClientTypes.VocabularyInfo]?
}

extension ListVocabulariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
        case vocabularies = "Vocabularies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let vocabulariesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.VocabularyInfo?].self, forKey: .vocabularies)
        var vocabulariesDecoded0:[TranscribeClientTypes.VocabularyInfo]? = nil
        if let vocabulariesContainer = vocabulariesContainer {
            vocabulariesDecoded0 = [TranscribeClientTypes.VocabularyInfo]()
            for structure0 in vocabulariesContainer {
                if let structure0 = structure0 {
                    vocabulariesDecoded0?.append(structure0)
                }
            }
        }
        vocabularies = vocabulariesDecoded0
    }
}

enum ListVocabulariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVocabularyFiltersInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListVocabularyFiltersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListVocabularyFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVocabularyFiltersInput: Swift.Equatable {
    /// The maximum number of custom vocabulary filters to return in each page of results. If there are fewer results than the value that you specify, only the actual results are returned. If you don't specify a value, a default of 5 is used.
    public var maxResults: Swift.Int?
    /// Returns only the custom vocabulary filters that contain the specified string. The search is not case sensitive.
    public var nameContains: Swift.String?
    /// If your ListVocabularyFilters request returns more results than can be displayed, NextToken is displayed in the response with an associated string. To get the next page of results, copy this string and repeat your request, including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
    }
}

struct ListVocabularyFiltersInputBody: Swift.Equatable {
}

extension ListVocabularyFiltersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVocabularyFiltersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVocabularyFiltersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vocabularyFilters = output.vocabularyFilters
        } else {
            self.nextToken = nil
            self.vocabularyFilters = nil
        }
    }
}

public struct ListVocabularyFiltersOutput: Swift.Equatable {
    /// If NextToken is present in your response, it indicates that not all results are displayed. To view the next set of results, copy the string associated with the NextToken parameter in your results output, then run your request again including NextToken with the value of the copied string. Repeat as needed to view all your results.
    public var nextToken: Swift.String?
    /// Provides information about the custom vocabulary filters that match the criteria specified in your request.
    public var vocabularyFilters: [TranscribeClientTypes.VocabularyFilterInfo]?

    public init(
        nextToken: Swift.String? = nil,
        vocabularyFilters: [TranscribeClientTypes.VocabularyFilterInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.vocabularyFilters = vocabularyFilters
    }
}

struct ListVocabularyFiltersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let vocabularyFilters: [TranscribeClientTypes.VocabularyFilterInfo]?
}

extension ListVocabularyFiltersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case vocabularyFilters = "VocabularyFilters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let vocabularyFiltersContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.VocabularyFilterInfo?].self, forKey: .vocabularyFilters)
        var vocabularyFiltersDecoded0:[TranscribeClientTypes.VocabularyFilterInfo]? = nil
        if let vocabularyFiltersContainer = vocabularyFiltersContainer {
            vocabularyFiltersDecoded0 = [TranscribeClientTypes.VocabularyFilterInfo]()
            for structure0 in vocabularyFiltersContainer {
                if let structure0 = structure0 {
                    vocabularyFiltersDecoded0?.append(structure0)
                }
            }
        }
        vocabularyFilters = vocabularyFiltersDecoded0
    }
}

enum ListVocabularyFiltersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TranscribeClientTypes.Media: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaFileUri = "MediaFileUri"
        case redactedMediaFileUri = "RedactedMediaFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaFileUri = self.mediaFileUri {
            try encodeContainer.encode(mediaFileUri, forKey: .mediaFileUri)
        }
        if let redactedMediaFileUri = self.redactedMediaFileUri {
            try encodeContainer.encode(redactedMediaFileUri, forKey: .redactedMediaFileUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaFileUri)
        mediaFileUri = mediaFileUriDecoded
        let redactedMediaFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redactedMediaFileUri)
        redactedMediaFileUri = redactedMediaFileUriDecoded
    }
}

extension TranscribeClientTypes {
    /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the [MediaFormat](https://docs.aws.amazon.com/APIReference/API_StartTranscriptionJob.html#transcribe-StartTranscriptionJob-request-MediaFormat) parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
    public struct Media: Swift.Equatable {
        /// The Amazon S3 location of the media file you want to transcribe. For example:
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/my-media-file.flac
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/media-files/my-media-file.flac
        ///
        ///
        /// Note that the Amazon S3 bucket that contains your input media must be located in the same Amazon Web Services Region where you're making your transcription request.
        public var mediaFileUri: Swift.String?
        /// The Amazon S3 location of the media file you want to redact. For example:
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/my-media-file.flac
        ///
        /// * s3://DOC-EXAMPLE-BUCKET/media-files/my-media-file.flac
        ///
        ///
        /// Note that the Amazon S3 bucket that contains your input media must be located in the same Amazon Web Services Region where you're making your transcription request. RedactedMediaFileUri produces a redacted audio file in addition to a redacted transcript. It is only supported for Call Analytics (StartCallAnalyticsJob) transcription requests.
        public var redactedMediaFileUri: Swift.String?

        public init(
            mediaFileUri: Swift.String? = nil,
            redactedMediaFileUri: Swift.String? = nil
        )
        {
            self.mediaFileUri = mediaFileUri
            self.redactedMediaFileUri = redactedMediaFileUri
        }
    }

}

extension TranscribeClientTypes {
    public enum MediaFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amr
        case flac
        case mp3
        case mp4
        case ogg
        case wav
        case webm
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaFormat] {
            return [
                .amr,
                .flac,
                .mp3,
                .mp4,
                .ogg,
                .wav,
                .webm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amr: return "amr"
            case .flac: return "flac"
            case .mp3: return "mp3"
            case .mp4: return "mp4"
            case .ogg: return "ogg"
            case .wav: return "wav"
            case .webm: return "webm"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaFormat(rawValue: rawValue) ?? MediaFormat.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes {
    public enum MedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [MedicalContentIdentificationType] {
            return [
                .phi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MedicalContentIdentificationType(rawValue: rawValue) ?? MedicalContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.MedicalTranscript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptFileUri = "TranscriptFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptFileUri = self.transcriptFileUri {
            try encodeContainer.encode(transcriptFileUri, forKey: .transcriptFileUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcriptFileUri)
        transcriptFileUri = transcriptFileUriDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides you with the Amazon S3 URI you can use to access your transcript.
    public struct MedicalTranscript: Swift.Equatable {
        /// The Amazon S3 location of your transcript. You can use this URI to access or download your transcript. Note that this is the Amazon S3 location you specified in your request using the OutputBucketName parameter.
        public var transcriptFileUri: Swift.String?

        public init(
            transcriptFileUri: Swift.String? = nil
        )
        {
            self.transcriptFileUri = transcriptFileUri
        }
    }

}

extension TranscribeClientTypes.MedicalTranscriptionJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case contentIdentificationType = "ContentIdentificationType"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case medicalTranscriptionJobName = "MedicalTranscriptionJobName"
        case settings = "Settings"
        case specialty = "Specialty"
        case startTime = "StartTime"
        case tags = "Tags"
        case transcript = "Transcript"
        case transcriptionJobStatus = "TranscriptionJobStatus"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let media = self.media {
            try encodeContainer.encode(media, forKey: .media)
        }
        if let mediaFormat = self.mediaFormat {
            try encodeContainer.encode(mediaFormat.rawValue, forKey: .mediaFormat)
        }
        if let mediaSampleRateHertz = self.mediaSampleRateHertz {
            try encodeContainer.encode(mediaSampleRateHertz, forKey: .mediaSampleRateHertz)
        }
        if let medicalTranscriptionJobName = self.medicalTranscriptionJobName {
            try encodeContainer.encode(medicalTranscriptionJobName, forKey: .medicalTranscriptionJobName)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let specialty = self.specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let transcript = self.transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
        if let transcriptionJobStatus = self.transcriptionJobStatus {
            try encodeContainer.encode(transcriptionJobStatus.rawValue, forKey: .transcriptionJobStatus)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let medicalTranscriptionJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .medicalTranscriptionJobName)
        medicalTranscriptionJobName = medicalTranscriptionJobNameDecoded
        let transcriptionJobStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJobStatus.self, forKey: .transcriptionJobStatus)
        transcriptionJobStatus = transcriptionJobStatusDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let mediaSampleRateHertzDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaSampleRateHertz)
        mediaSampleRateHertz = mediaSampleRateHertzDecoded
        let mediaFormatDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MediaFormat.self, forKey: .mediaFormat)
        mediaFormat = mediaFormatDecoded
        let mediaDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Media.self, forKey: .media)
        media = mediaDecoded
        let transcriptDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalTranscript.self, forKey: .transcript)
        transcript = transcriptDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalTranscriptionSetting.self, forKey: .settings)
        settings = settingsDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Specialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TranscribeClientTypes {
    /// Provides detailed information about a medical transcription job. To view the status of the specified medical transcription job, check the TranscriptionJobStatus field. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed.
    public struct MedicalTranscriptionJob: Swift.Equatable {
        /// The date and time the specified medical transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: ClientRuntime.Date?
        /// Indicates whether content identification was enabled for your transcription request.
        public var contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
        /// The date and time the specified medical transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: ClientRuntime.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job request failed. The FailureReason field contains one of the following values:
        ///
        /// * Unsupported media format. The media format specified in MediaFormat isn't valid. Refer to MediaFormat for a list of supported formats.
        ///
        /// * The media format provided does not match the detected media format. The media format specified in MediaFormat doesn't match the format of the input file. Check the media format of your media file and correct the specified value.
        ///
        /// * Invalid sample rate for audio file. The sample rate specified in MediaSampleRateHertz isn't valid. The sample rate must be between 16,000 and 48,000 hertz.
        ///
        /// * The sample rate provided does not match the detected sample rate. The sample rate specified in MediaSampleRateHertz doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.
        ///
        /// * Invalid file size: file size too large. The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to [Guidelines and quotas](https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits).
        ///
        /// * Invalid number of channels: number of channels too large. Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to [Guidelines and quotas](https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits).
        public var failureReason: Swift.String?
        /// The language code used to create your medical transcription job. US English (en-US) is the only supported language for medical transcriptions.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the [MediaFormat](https://docs.aws.amazon.com/APIReference/API_StartTranscriptionJob.html#transcribe-StartTranscriptionJob-request-MediaFormat) parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
        public var media: TranscribeClientTypes.Media?
        /// The format of the input media file.
        public var mediaFormat: TranscribeClientTypes.MediaFormat?
        /// The sample rate, in hertz, of the audio track in your input media file.
        public var mediaSampleRateHertz: Swift.Int?
        /// The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var medicalTranscriptionJobName: Swift.String?
        /// Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.
        public var settings: TranscribeClientTypes.MedicalTranscriptionSetting?
        /// Describes the medical specialty represented in your media.
        public var specialty: TranscribeClientTypes.Specialty?
        /// The date and time the specified medical transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: ClientRuntime.Date?
        /// The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.
        public var tags: [TranscribeClientTypes.Tag]?
        /// Provides you with the Amazon S3 URI you can use to access your transcript.
        public var transcript: TranscribeClientTypes.MedicalTranscript?
        /// Provides the status of the specified medical transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?
        /// Indicates whether the input media is a dictation or a conversation, as specified in the StartMedicalTranscriptionJob request.
        public var type: TranscribeClientTypes.ModelType?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            media: TranscribeClientTypes.Media? = nil,
            mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
            mediaSampleRateHertz: Swift.Int? = nil,
            medicalTranscriptionJobName: Swift.String? = nil,
            settings: TranscribeClientTypes.MedicalTranscriptionSetting? = nil,
            specialty: TranscribeClientTypes.Specialty? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [TranscribeClientTypes.Tag]? = nil,
            transcript: TranscribeClientTypes.MedicalTranscript? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil,
            type: TranscribeClientTypes.ModelType? = nil
        )
        {
            self.completionTime = completionTime
            self.contentIdentificationType = contentIdentificationType
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.media = media
            self.mediaFormat = mediaFormat
            self.mediaSampleRateHertz = mediaSampleRateHertz
            self.medicalTranscriptionJobName = medicalTranscriptionJobName
            self.settings = settings
            self.specialty = specialty
            self.startTime = startTime
            self.tags = tags
            self.transcript = transcript
            self.transcriptionJobStatus = transcriptionJobStatus
            self.type = type
        }
    }

}

extension TranscribeClientTypes.MedicalTranscriptionJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case contentIdentificationType = "ContentIdentificationType"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case languageCode = "LanguageCode"
        case medicalTranscriptionJobName = "MedicalTranscriptionJobName"
        case outputLocationType = "OutputLocationType"
        case specialty = "Specialty"
        case startTime = "StartTime"
        case transcriptionJobStatus = "TranscriptionJobStatus"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let medicalTranscriptionJobName = self.medicalTranscriptionJobName {
            try encodeContainer.encode(medicalTranscriptionJobName, forKey: .medicalTranscriptionJobName)
        }
        if let outputLocationType = self.outputLocationType {
            try encodeContainer.encode(outputLocationType.rawValue, forKey: .outputLocationType)
        }
        if let specialty = self.specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let transcriptionJobStatus = self.transcriptionJobStatus {
            try encodeContainer.encode(transcriptionJobStatus.rawValue, forKey: .transcriptionJobStatus)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let medicalTranscriptionJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .medicalTranscriptionJobName)
        medicalTranscriptionJobName = medicalTranscriptionJobNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let transcriptionJobStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJobStatus.self, forKey: .transcriptionJobStatus)
        transcriptionJobStatus = transcriptionJobStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let outputLocationTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.OutputLocationType.self, forKey: .outputLocationType)
        outputLocationType = outputLocationTypeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Specialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides detailed information about a specific medical transcription job.
    public struct MedicalTranscriptionJobSummary: Swift.Equatable {
        /// The date and time the specified medical transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: ClientRuntime.Date?
        /// Labels all personal health information (PHI) identified in your transcript. For more information, see [Identifying personal health information (PHI) in a transcription](https://docs.aws.amazon.com/transcribe/latest/dg/phi-id.html).
        public var contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
        /// The date and time the specified medical transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: ClientRuntime.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The language code used to create your medical transcription. US English (en-US) is the only supported language for medical transcriptions.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var medicalTranscriptionJobName: Swift.String?
        /// Indicates where the specified medical transcription output is stored. If the value is CUSTOMER_BUCKET, the location is the Amazon S3 bucket you specified using the OutputBucketName parameter in your request. If you also included OutputKey in your request, your output is located in the path you specified in your request. If the value is SERVICE_BUCKET, the location is a service-managed Amazon S3 bucket. To access a transcript stored in a service-managed bucket, use the URI shown in the TranscriptFileUri field.
        public var outputLocationType: TranscribeClientTypes.OutputLocationType?
        /// Provides the medical specialty represented in your media.
        public var specialty: TranscribeClientTypes.Specialty?
        /// The date and time your medical transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: ClientRuntime.Date?
        /// Provides the status of your medical transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?
        /// Indicates whether the input media is a dictation or a conversation, as specified in the StartMedicalTranscriptionJob request.
        public var type: TranscribeClientTypes.ModelType?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            medicalTranscriptionJobName: Swift.String? = nil,
            outputLocationType: TranscribeClientTypes.OutputLocationType? = nil,
            specialty: TranscribeClientTypes.Specialty? = nil,
            startTime: ClientRuntime.Date? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil,
            type: TranscribeClientTypes.ModelType? = nil
        )
        {
            self.completionTime = completionTime
            self.contentIdentificationType = contentIdentificationType
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.languageCode = languageCode
            self.medicalTranscriptionJobName = medicalTranscriptionJobName
            self.outputLocationType = outputLocationType
            self.specialty = specialty
            self.startTime = startTime
            self.transcriptionJobStatus = transcriptionJobStatus
            self.type = type
        }
    }

}

extension TranscribeClientTypes.MedicalTranscriptionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelIdentification = "ChannelIdentification"
        case maxAlternatives = "MaxAlternatives"
        case maxSpeakerLabels = "MaxSpeakerLabels"
        case showAlternatives = "ShowAlternatives"
        case showSpeakerLabels = "ShowSpeakerLabels"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelIdentification = self.channelIdentification {
            try encodeContainer.encode(channelIdentification, forKey: .channelIdentification)
        }
        if let maxAlternatives = self.maxAlternatives {
            try encodeContainer.encode(maxAlternatives, forKey: .maxAlternatives)
        }
        if let maxSpeakerLabels = self.maxSpeakerLabels {
            try encodeContainer.encode(maxSpeakerLabels, forKey: .maxSpeakerLabels)
        }
        if let showAlternatives = self.showAlternatives {
            try encodeContainer.encode(showAlternatives, forKey: .showAlternatives)
        }
        if let showSpeakerLabels = self.showSpeakerLabels {
            try encodeContainer.encode(showSpeakerLabels, forKey: .showSpeakerLabels)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showSpeakerLabelsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showSpeakerLabels)
        showSpeakerLabels = showSpeakerLabelsDecoded
        let maxSpeakerLabelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSpeakerLabels)
        maxSpeakerLabels = maxSpeakerLabelsDecoded
        let channelIdentificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .channelIdentification)
        channelIdentification = channelIdentificationDecoded
        let showAlternativesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showAlternatives)
        showAlternatives = showAlternativesDecoded
        let maxAlternativesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAlternatives)
        maxAlternatives = maxAlternativesDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
    }
}

extension TranscribeClientTypes {
    /// Allows additional optional settings in your request, including channel identification, alternative transcriptions, and speaker partitioning. You can use that to apply custom vocabularies to your medical transcription job.
    public struct MedicalTranscriptionSetting: Swift.Equatable {
        /// Enables channel identification in multi-channel audio. Channel identification transcribes the audio on each channel independently, then appends the output for each channel into one transcript. If you have multi-channel audio and do not enable channel identification, your audio is transcribed in a continuous manner and your transcript does not separate the speech by channel. You can't include both ShowSpeakerLabels and ChannelIdentification in the same request. Including both parameters returns a BadRequestException. For more information, see [Transcribing multi-channel audio](https://docs.aws.amazon.com/transcribe/latest/dg/channel-id.html).
        public var channelIdentification: Swift.Bool?
        /// Indicate the maximum number of alternative transcriptions you want Amazon Transcribe Medical to include in your transcript. If you select a number greater than the number of alternative transcriptions generated by Amazon Transcribe Medical, only the actual number of alternative transcriptions are included. If you include MaxAlternatives in your request, you must also include ShowAlternatives with a value of true. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var maxAlternatives: Swift.Int?
        /// Specify the maximum number of speakers you want to partition in your media. Note that if your media contains more speakers than the specified number, multiple speakers are treated as a single speaker. If you specify the MaxSpeakerLabels field, you must set the ShowSpeakerLabels field to true.
        public var maxSpeakerLabels: Swift.Int?
        /// To include alternative transcriptions within your transcription output, include ShowAlternatives in your transcription request. If you include ShowAlternatives, you must also include MaxAlternatives, which is the maximum number of alternative transcriptions you want Amazon Transcribe Medical to generate. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var showAlternatives: Swift.Bool?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. If you enable ShowSpeakerLabels in your request, you must also include MaxSpeakerLabels. You can't include ShowSpeakerLabels and ChannelIdentification in the same request. Including both parameters returns a BadRequestException. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html).
        public var showSpeakerLabels: Swift.Bool?
        /// The name of the custom vocabulary you want to use when processing your medical transcription job. Custom vocabulary names are case sensitive. The language of the specified custom vocabulary must match the language code that you specify in your transcription request. If the languages don't match, the custom vocabulary isn't applied. There are no errors or warnings associated with a language mismatch. US English (en-US) is the only valid language for Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init(
            channelIdentification: Swift.Bool? = nil,
            maxAlternatives: Swift.Int? = nil,
            maxSpeakerLabels: Swift.Int? = nil,
            showAlternatives: Swift.Bool? = nil,
            showSpeakerLabels: Swift.Bool? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.channelIdentification = channelIdentification
            self.maxAlternatives = maxAlternatives
            self.maxSpeakerLabels = maxSpeakerLabels
            self.showAlternatives = showAlternatives
            self.showSpeakerLabels = showSpeakerLabels
            self.vocabularyName = vocabularyName
        }
    }

}

extension TranscribeClientTypes.ModelSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageModelName = "LanguageModelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides the name of the custom language model that was included in the specified transcription job. Only use ModelSettings with the LanguageModelName sub-parameter if you're not using automatic language identification (). If using LanguageIdSettings in your request, this parameter contains a LanguageModelName sub-parameter.
    public struct ModelSettings: Swift.Equatable {
        /// The name of the custom language model you want to use when processing your transcription job. Note that custom language model names are case sensitive. The language of the specified custom language model must match the language code that you specify in your transcription request. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.
        public var languageModelName: Swift.String?

        public init(
            languageModelName: Swift.String? = nil
        )
        {
            self.languageModelName = languageModelName
        }
    }

}

extension TranscribeClientTypes {
    public enum ModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.NonTalkTimeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTimeRange = "AbsoluteTimeRange"
        case negate = "Negate"
        case relativeTimeRange = "RelativeTimeRange"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTimeRange = self.absoluteTimeRange {
            try encodeContainer.encode(absoluteTimeRange, forKey: .absoluteTimeRange)
        }
        if let negate = self.negate {
            try encodeContainer.encode(negate, forKey: .negate)
        }
        if let relativeTimeRange = self.relativeTimeRange {
            try encodeContainer.encode(relativeTimeRange, forKey: .relativeTimeRange)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .threshold)
        threshold = thresholdDecoded
        let absoluteTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.AbsoluteTimeRange.self, forKey: .absoluteTimeRange)
        absoluteTimeRange = absoluteTimeRangeDecoded
        let relativeTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.RelativeTimeRange.self, forKey: .relativeTimeRange)
        relativeTimeRange = relativeTimeRangeDecoded
        let negateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negate)
        negate = negateDecoded
    }
}

extension TranscribeClientTypes {
    /// Flag the presence or absence of periods of silence in your Call Analytics transcription output. Rules using NonTalkTimeFilter are designed to match:
    ///
    /// * The presence of silence at specified periods throughout the call
    ///
    /// * The presence of speech at specified periods throughout the call
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) for usage examples.
    public struct NonTalkTimeFilter: Swift.Equatable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for a period of silence. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag periods of speech. Set to FALSE to flag periods of silence
        public var negate: Swift.Bool?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for a period of silence. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the duration, in milliseconds, of the period of silence that you want to flag. For example, you can flag a silent period that lasts 30,000 milliseconds.
        public var threshold: Swift.Int?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.relativeTimeRange = relativeTimeRange
            self.threshold = threshold
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can't find the requested resource. Check that the specified name is correct and try your request again.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeClientTypes {
    public enum OutputLocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerBucket
        case serviceBucket
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputLocationType] {
            return [
                .customerBucket,
                .serviceBucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerBucket: return "CUSTOMER_BUCKET"
            case .serviceBucket: return "SERVICE_BUCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputLocationType(rawValue: rawValue) ?? OutputLocationType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes {
    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes {
    public enum PiiEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case all
        case bankAccountNumber
        case bankRouting
        case creditDebitCvv
        case creditDebitExpiry
        case creditDebitNumber
        case email
        case name
        case phone
        case pin
        case ssn
        case sdkUnknown(Swift.String)

        public static var allCases: [PiiEntityType] {
            return [
                .address,
                .all,
                .bankAccountNumber,
                .bankRouting,
                .creditDebitCvv,
                .creditDebitExpiry,
                .creditDebitNumber,
                .email,
                .name,
                .phone,
                .pin,
                .ssn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .all: return "ALL"
            case .bankAccountNumber: return "BANK_ACCOUNT_NUMBER"
            case .bankRouting: return "BANK_ROUTING"
            case .creditDebitCvv: return "CREDIT_DEBIT_CVV"
            case .creditDebitExpiry: return "CREDIT_DEBIT_EXPIRY"
            case .creditDebitNumber: return "CREDIT_DEBIT_NUMBER"
            case .email: return "EMAIL"
            case .name: return "NAME"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .ssn: return "SSN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PiiEntityType(rawValue: rawValue) ?? PiiEntityType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes {
    public enum RedactionOutput: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case redacted
        case redactedAndUnredacted
        case sdkUnknown(Swift.String)

        public static var allCases: [RedactionOutput] {
            return [
                .redacted,
                .redactedAndUnredacted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .redacted: return "redacted"
            case .redactedAndUnredacted: return "redacted_and_unredacted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RedactionOutput(rawValue: rawValue) ?? RedactionOutput.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes {
    public enum RedactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [RedactionType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RedactionType(rawValue: rawValue) ?? RedactionType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.RelativeTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPercentage = "EndPercentage"
        case first = "First"
        case last = "Last"
        case startPercentage = "StartPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endPercentage = self.endPercentage {
            try encodeContainer.encode(endPercentage, forKey: .endPercentage)
        }
        if let first = self.first {
            try encodeContainer.encode(first, forKey: .first)
        }
        if let last = self.last {
            try encodeContainer.encode(last, forKey: .last)
        }
        if let startPercentage = self.startPercentage {
            try encodeContainer.encode(startPercentage, forKey: .startPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startPercentage)
        startPercentage = startPercentageDecoded
        let endPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endPercentage)
        endPercentage = endPercentageDecoded
        let firstDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .first)
        first = firstDecoded
        let lastDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .last)
        last = lastDecoded
    }
}

extension TranscribeClientTypes {
    /// A time range, in percentage, between two points in your media file. You can use StartPercentage and EndPercentage to search a custom segment. For example, setting StartPercentage to 10 and EndPercentage to 50 only searches for your specified criteria in the audio contained between the 10 percent mark and the 50 percent mark of your media file. You can use also First to search from the start of the media file until the time that you specify. Or use Last to search from the time that you specify until the end of the media file. For example, setting First to 10 only searches for your specified criteria in the audio contained in the first 10 percent of the media file. If you prefer to use milliseconds instead of percentage, see .
    public struct RelativeTimeRange: Swift.Equatable {
        /// The time, in percentage, when Amazon Transcribe stops searching for the specified criteria in your media file. If you include EndPercentage in your request, you must also include StartPercentage.
        public var endPercentage: Swift.Int?
        /// The time, in percentage, from the start of your media file until the specified value. Amazon Transcribe searches for your specified criteria in this time segment.
        public var first: Swift.Int?
        /// The time, in percentage, from the specified value until the end of your media file. Amazon Transcribe searches for your specified criteria in this time segment.
        public var last: Swift.Int?
        /// The time, in percentage, when Amazon Transcribe starts searching for the specified criteria in your media file. If you include StartPercentage in your request, you must also include EndPercentage.
        public var startPercentage: Swift.Int?

        public init(
            endPercentage: Swift.Int? = nil,
            first: Swift.Int? = nil,
            last: Swift.Int? = nil,
            startPercentage: Swift.Int? = nil
        )
        {
            self.endPercentage = endPercentage
            self.first = first
            self.last = last
            self.startPercentage = startPercentage
        }
    }

}

extension TranscribeClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interruptionfilter = "InterruptionFilter"
        case nontalktimefilter = "NonTalkTimeFilter"
        case sentimentfilter = "SentimentFilter"
        case transcriptfilter = "TranscriptFilter"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .interruptionfilter(interruptionfilter):
                try container.encode(interruptionfilter, forKey: .interruptionfilter)
            case let .nontalktimefilter(nontalktimefilter):
                try container.encode(nontalktimefilter, forKey: .nontalktimefilter)
            case let .sentimentfilter(sentimentfilter):
                try container.encode(sentimentfilter, forKey: .sentimentfilter)
            case let .transcriptfilter(transcriptfilter):
                try container.encode(transcriptfilter, forKey: .transcriptfilter)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let nontalktimefilterDecoded = try values.decodeIfPresent(TranscribeClientTypes.NonTalkTimeFilter.self, forKey: .nontalktimefilter)
        if let nontalktimefilter = nontalktimefilterDecoded {
            self = .nontalktimefilter(nontalktimefilter)
            return
        }
        let interruptionfilterDecoded = try values.decodeIfPresent(TranscribeClientTypes.InterruptionFilter.self, forKey: .interruptionfilter)
        if let interruptionfilter = interruptionfilterDecoded {
            self = .interruptionfilter(interruptionfilter)
            return
        }
        let transcriptfilterDecoded = try values.decodeIfPresent(TranscribeClientTypes.TranscriptFilter.self, forKey: .transcriptfilter)
        if let transcriptfilter = transcriptfilterDecoded {
            self = .transcriptfilter(transcriptfilter)
            return
        }
        let sentimentfilterDecoded = try values.decodeIfPresent(TranscribeClientTypes.SentimentFilter.self, forKey: .sentimentfilter)
        if let sentimentfilter = sentimentfilterDecoded {
            self = .sentimentfilter(sentimentfilter)
            return
        }
        self = .sdkUnknown("")
    }
}

extension TranscribeClientTypes {
    /// A rule is a set of criteria that you can specify to flag an attribute in your Call Analytics output. Rules define a Call Analytics category. Rules can include these parameters: , , , and . To learn more about Call Analytics rules and categories, see [Creating categories for post-call transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html) and [Creating categories for real-time transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-stream.html). To learn more about Call Analytics, see [Analyzing call center audio with Call Analytics](https://docs.aws.amazon.com/transcribe/latest/dg/call-analytics.html).
    public enum Rule: Swift.Equatable {
        /// Flag the presence or absence of periods of silence in your Call Analytics transcription output. Refer to for more detail.
        case nontalktimefilter(TranscribeClientTypes.NonTalkTimeFilter)
        /// Flag the presence or absence of interruptions in your Call Analytics transcription output. Refer to for more detail.
        case interruptionfilter(TranscribeClientTypes.InterruptionFilter)
        /// Flag the presence or absence of specific words or phrases in your Call Analytics transcription output. Refer to for more detail.
        case transcriptfilter(TranscribeClientTypes.TranscriptFilter)
        /// Flag the presence or absence of specific sentiments in your Call Analytics transcription output. Refer to for more detail.
        case sentimentfilter(TranscribeClientTypes.SentimentFilter)
        case sdkUnknown(Swift.String)
    }

}

extension TranscribeClientTypes.SentimentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTimeRange = "AbsoluteTimeRange"
        case negate = "Negate"
        case participantRole = "ParticipantRole"
        case relativeTimeRange = "RelativeTimeRange"
        case sentiments = "Sentiments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTimeRange = self.absoluteTimeRange {
            try encodeContainer.encode(absoluteTimeRange, forKey: .absoluteTimeRange)
        }
        if let negate = self.negate {
            try encodeContainer.encode(negate, forKey: .negate)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let relativeTimeRange = self.relativeTimeRange {
            try encodeContainer.encode(relativeTimeRange, forKey: .relativeTimeRange)
        }
        if let sentiments = sentiments {
            var sentimentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sentiments)
            for sentimentvalue0 in sentiments {
                try sentimentsContainer.encode(sentimentvalue0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.SentimentValue?].self, forKey: .sentiments)
        var sentimentsDecoded0:[TranscribeClientTypes.SentimentValue]? = nil
        if let sentimentsContainer = sentimentsContainer {
            sentimentsDecoded0 = [TranscribeClientTypes.SentimentValue]()
            for enum0 in sentimentsContainer {
                if let enum0 = enum0 {
                    sentimentsDecoded0?.append(enum0)
                }
            }
        }
        sentiments = sentimentsDecoded0
        let absoluteTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.AbsoluteTimeRange.self, forKey: .absoluteTimeRange)
        absoluteTimeRange = absoluteTimeRangeDecoded
        let relativeTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.RelativeTimeRange.self, forKey: .relativeTimeRange)
        relativeTimeRange = relativeTimeRangeDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let negateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negate)
        negate = negateDecoded
    }
}

extension TranscribeClientTypes {
    /// Flag the presence or absence of specific sentiments detected in your Call Analytics transcription output. Rules using SentimentFilter are designed to match:
    ///
    /// * The presence or absence of a positive sentiment felt by the customer, agent, or both at specified points in the call
    ///
    /// * The presence or absence of a negative sentiment felt by the customer, agent, or both at specified points in the call
    ///
    /// * The presence or absence of a neutral sentiment felt by the customer, agent, or both at specified points in the call
    ///
    /// * The presence or absence of a mixed sentiment felt by the customer, the agent, or both at specified points in the call
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) for usage examples.
    public struct SentimentFilter: Swift.Equatable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for the specified sentiments. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag the sentiments that you didn't include in your request. Set to FALSE to flag the sentiments that you specified in your request.
        public var negate: Swift.Bool?
        /// Specify the participant that you want to flag. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for the specified sentiments. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the sentiments that you want to flag.
        /// This member is required.
        public var sentiments: [TranscribeClientTypes.SentimentValue]?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            sentiments: [TranscribeClientTypes.SentimentValue]? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.participantRole = participantRole
            self.relativeTimeRange = relativeTimeRange
            self.sentiments = sentiments
        }
    }

}

extension TranscribeClientTypes {
    public enum SentimentValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mixed
        case negative
        case neutral
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [SentimentValue] {
            return [
                .mixed,
                .negative,
                .neutral,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mixed: return "MIXED"
            case .negative: return "NEGATIVE"
            case .neutral: return "NEUTRAL"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SentimentValue(rawValue: rawValue) ?? SentimentValue.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelIdentification = "ChannelIdentification"
        case maxAlternatives = "MaxAlternatives"
        case maxSpeakerLabels = "MaxSpeakerLabels"
        case showAlternatives = "ShowAlternatives"
        case showSpeakerLabels = "ShowSpeakerLabels"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelIdentification = self.channelIdentification {
            try encodeContainer.encode(channelIdentification, forKey: .channelIdentification)
        }
        if let maxAlternatives = self.maxAlternatives {
            try encodeContainer.encode(maxAlternatives, forKey: .maxAlternatives)
        }
        if let maxSpeakerLabels = self.maxSpeakerLabels {
            try encodeContainer.encode(maxSpeakerLabels, forKey: .maxSpeakerLabels)
        }
        if let showAlternatives = self.showAlternatives {
            try encodeContainer.encode(showAlternatives, forKey: .showAlternatives)
        }
        if let showSpeakerLabels = self.showSpeakerLabels {
            try encodeContainer.encode(showSpeakerLabels, forKey: .showSpeakerLabels)
        }
        if let vocabularyFilterMethod = self.vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let showSpeakerLabelsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showSpeakerLabels)
        showSpeakerLabels = showSpeakerLabelsDecoded
        let maxSpeakerLabelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSpeakerLabels)
        maxSpeakerLabels = maxSpeakerLabelsDecoded
        let channelIdentificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .channelIdentification)
        channelIdentification = channelIdentificationDecoded
        let showAlternativesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showAlternatives)
        showAlternatives = showAlternativesDecoded
        let maxAlternativesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAlternatives)
        maxAlternatives = maxAlternativesDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
    }
}

extension TranscribeClientTypes {
    /// Allows additional optional settings in your request, including channel identification, alternative transcriptions, and speaker partitioning. You can use that to apply custom vocabularies to your transcription job.
    public struct Settings: Swift.Equatable {
        /// Enables channel identification in multi-channel audio. Channel identification transcribes the audio on each channel independently, then appends the output for each channel into one transcript. You can't include both ShowSpeakerLabels and ChannelIdentification in the same request. Including both parameters returns a BadRequestException. For more information, see [Transcribing multi-channel audio](https://docs.aws.amazon.com/transcribe/latest/dg/channel-id.html).
        public var channelIdentification: Swift.Bool?
        /// Indicate the maximum number of alternative transcriptions you want Amazon Transcribe to include in your transcript. If you select a number greater than the number of alternative transcriptions generated by Amazon Transcribe, only the actual number of alternative transcriptions are included. If you include MaxAlternatives in your request, you must also include ShowAlternatives with a value of true. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var maxAlternatives: Swift.Int?
        /// Specify the maximum number of speakers you want to partition in your media. Note that if your media contains more speakers than the specified number, multiple speakers are treated as a single speaker. If you specify the MaxSpeakerLabels field, you must set the ShowSpeakerLabels field to true.
        public var maxSpeakerLabels: Swift.Int?
        /// To include alternative transcriptions within your transcription output, include ShowAlternatives in your transcription request. If you have multi-channel audio and do not enable channel identification, your audio is transcribed in a continuous manner and your transcript does not separate the speech by channel. If you include ShowAlternatives, you must also include MaxAlternatives, which is the maximum number of alternative transcriptions you want Amazon Transcribe to generate. For more information, see [Alternative transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/how-alternatives.html).
        public var showAlternatives: Swift.Bool?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. If you enable ShowSpeakerLabels in your request, you must also include MaxSpeakerLabels. You can't include both ShowSpeakerLabels and ChannelIdentification in the same request. Including both parameters returns a BadRequestException. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html).
        public var showSpeakerLabels: Swift.Bool?
        /// Specify how you want your custom vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter you want to use in your transcription job request. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. Note that if you include VocabularyFilterName in your request, you must also include VocabularyFilterMethod.
        public var vocabularyFilterName: Swift.String?
        /// The name of the custom vocabulary you want to use in your transcription job request. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var vocabularyName: Swift.String?

        public init(
            channelIdentification: Swift.Bool? = nil,
            maxAlternatives: Swift.Int? = nil,
            maxSpeakerLabels: Swift.Int? = nil,
            showAlternatives: Swift.Bool? = nil,
            showSpeakerLabels: Swift.Bool? = nil,
            vocabularyFilterMethod: TranscribeClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.channelIdentification = channelIdentification
            self.maxAlternatives = maxAlternatives
            self.maxSpeakerLabels = maxSpeakerLabels
            self.showAlternatives = showAlternatives
            self.showSpeakerLabels = showSpeakerLabels
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }

}

extension TranscribeClientTypes {
    public enum Specialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case primarycare
        case sdkUnknown(Swift.String)

        public static var allCases: [Specialty] {
            return [
                .primarycare,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .primarycare: return "PRIMARYCARE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Specialty(rawValue: rawValue) ?? Specialty.sdkUnknown(rawValue)
        }
    }
}

extension StartCallAnalyticsJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelDefinitions = "ChannelDefinitions"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case media = "Media"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputLocation = "OutputLocation"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelDefinitions = channelDefinitions {
            var channelDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channelDefinitions)
            for channeldefinition0 in channelDefinitions {
                try channelDefinitionsContainer.encode(channeldefinition0)
            }
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let media = self.media {
            try encodeContainer.encode(media, forKey: .media)
        }
        if let outputEncryptionKMSKeyId = self.outputEncryptionKMSKeyId {
            try encodeContainer.encode(outputEncryptionKMSKeyId, forKey: .outputEncryptionKMSKeyId)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }
}

extension StartCallAnalyticsJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartCallAnalyticsJobInput: Swift.Equatable {
    /// A unique name, chosen by you, for your Call Analytics job. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var callAnalyticsJobName: Swift.String?
    /// Makes it possible to specify which speaker is on which channel. For example, if your agent is the first participant to speak, you would set ChannelId to 0 (to indicate the first channel) and ParticipantRole to AGENT (to indicate that it's the agent speaking).
    public var channelDefinitions: [TranscribeClientTypes.ChannelDefinition]?
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// Describes the Amazon S3 location of the media file you want to use in your Call Analytics request.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// The KMS key you want to use to encrypt your Call Analytics output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you don't specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). If you specify a KMS key to encrypt your output, you must also specify an output location using the OutputLocation parameter. Note that the role making the request must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// The Amazon S3 location where you want your Call Analytics transcription output stored. You can use any of the following formats to specify the output location:
    ///
    /// * s3://DOC-EXAMPLE-BUCKET
    ///
    /// * s3://DOC-EXAMPLE-BUCKET/my-output-folder/
    ///
    /// * s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json
    ///
    ///
    /// Unless you specify a file name (option 3), the name of your output file has a default value that matches the name you specified for your transcription job using the CallAnalyticsJobName parameter. You can specify a KMS key to encrypt your output using the OutputEncryptionKMSKeyId parameter. If you don't specify a KMS key, Amazon Transcribe uses the default Amazon S3 key for server-side encryption. If you don't specify OutputLocation, your transcript is placed in a service-managed Amazon S3 bucket and you are provided with a URI to access your transcript.
    public var outputLocation: Swift.String?
    /// Specify additional optional settings in your request, including content redaction; allows you to apply custom language models, vocabulary filters, and custom vocabularies to your Call Analytics job.
    public var settings: TranscribeClientTypes.CallAnalyticsJobSettings?

    public init(
        callAnalyticsJobName: Swift.String? = nil,
        channelDefinitions: [TranscribeClientTypes.ChannelDefinition]? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        media: TranscribeClientTypes.Media? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        outputLocation: Swift.String? = nil,
        settings: TranscribeClientTypes.CallAnalyticsJobSettings? = nil
    )
    {
        self.callAnalyticsJobName = callAnalyticsJobName
        self.channelDefinitions = channelDefinitions
        self.dataAccessRoleArn = dataAccessRoleArn
        self.media = media
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.outputLocation = outputLocation
        self.settings = settings
    }
}

struct StartCallAnalyticsJobInputBody: Swift.Equatable {
    let media: TranscribeClientTypes.Media?
    let outputLocation: Swift.String?
    let outputEncryptionKMSKeyId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let settings: TranscribeClientTypes.CallAnalyticsJobSettings?
    let channelDefinitions: [TranscribeClientTypes.ChannelDefinition]?
}

extension StartCallAnalyticsJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelDefinitions = "ChannelDefinitions"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case media = "Media"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputLocation = "OutputLocation"
        case settings = "Settings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Media.self, forKey: .media)
        media = mediaDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let outputEncryptionKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputEncryptionKMSKeyId)
        outputEncryptionKMSKeyId = outputEncryptionKMSKeyIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJobSettings.self, forKey: .settings)
        settings = settingsDecoded
        let channelDefinitionsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.ChannelDefinition?].self, forKey: .channelDefinitions)
        var channelDefinitionsDecoded0:[TranscribeClientTypes.ChannelDefinition]? = nil
        if let channelDefinitionsContainer = channelDefinitionsContainer {
            channelDefinitionsDecoded0 = [TranscribeClientTypes.ChannelDefinition]()
            for structure0 in channelDefinitionsContainer {
                if let structure0 = structure0 {
                    channelDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        channelDefinitions = channelDefinitionsDecoded0
    }
}

extension StartCallAnalyticsJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartCallAnalyticsJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.callAnalyticsJob = output.callAnalyticsJob
        } else {
            self.callAnalyticsJob = nil
        }
    }
}

public struct StartCallAnalyticsJobOutput: Swift.Equatable {
    /// Provides detailed information about the current Call Analytics job, including job status and, if applicable, failure reason.
    public var callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob?

    public init(
        callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob? = nil
    )
    {
        self.callAnalyticsJob = callAnalyticsJob
    }
}

struct StartCallAnalyticsJobOutputBody: Swift.Equatable {
    let callAnalyticsJob: TranscribeClientTypes.CallAnalyticsJob?
}

extension StartCallAnalyticsJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callAnalyticsJob = "CallAnalyticsJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callAnalyticsJobDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CallAnalyticsJob.self, forKey: .callAnalyticsJob)
        callAnalyticsJob = callAnalyticsJobDecoded
    }
}

enum StartCallAnalyticsJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMedicalTranscriptionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case kmsEncryptionContext = "KMSEncryptionContext"
        case languageCode = "LanguageCode"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case outputBucketName = "OutputBucketName"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputKey = "OutputKey"
        case settings = "Settings"
        case specialty = "Specialty"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let kmsEncryptionContext = kmsEncryptionContext {
            var kmsEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .kmsEncryptionContext)
            for (dictKey0, kmsEncryptionContextMap0) in kmsEncryptionContext {
                try kmsEncryptionContextContainer.encode(kmsEncryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let media = self.media {
            try encodeContainer.encode(media, forKey: .media)
        }
        if let mediaFormat = self.mediaFormat {
            try encodeContainer.encode(mediaFormat.rawValue, forKey: .mediaFormat)
        }
        if let mediaSampleRateHertz = self.mediaSampleRateHertz {
            try encodeContainer.encode(mediaSampleRateHertz, forKey: .mediaSampleRateHertz)
        }
        if let outputBucketName = self.outputBucketName {
            try encodeContainer.encode(outputBucketName, forKey: .outputBucketName)
        }
        if let outputEncryptionKMSKeyId = self.outputEncryptionKMSKeyId {
            try encodeContainer.encode(outputEncryptionKMSKeyId, forKey: .outputEncryptionKMSKeyId)
        }
        if let outputKey = self.outputKey {
            try encodeContainer.encode(outputKey, forKey: .outputKey)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let specialty = self.specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension StartMedicalTranscriptionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMedicalTranscriptionJobInput: Swift.Equatable {
    /// Labels all personal health information (PHI) identified in your transcript. For more information, see [Identifying personal health information (PHI) in a transcription](https://docs.aws.amazon.com/transcribe/latest/dg/phi-id.html).
    public var contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
    /// A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added layer of security for your data. For more information, see [KMS encryption context](https://docs.aws.amazon.com/transcribe/latest/dg/key-management.html#kms-context) and [Asymmetric keys in KMS](https://docs.aws.amazon.com/transcribe/latest/dg/symmetric-asymmetric.html).
    public var kmsEncryptionContext: [Swift.String:Swift.String]?
    /// The language code that represents the language spoken in the input media file. US English (en-US) is the only valid value for medical transcription jobs. Any other value you enter for language code results in a BadRequestException error.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Describes the Amazon S3 location of the media file you want to use in your request. For information on supported media formats, refer to the [MediaFormat](https://docs.aws.amazon.com/APIReference/API_StartTranscriptionJob.html#transcribe-StartTranscriptionJob-request-MediaFormat) parameter or the [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) section in the Amazon S3 Developer Guide.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// Specify the format of your input media file.
    public var mediaFormat: TranscribeClientTypes.MediaFormat?
    /// The sample rate, in hertz, of the audio track in your input media file. If you don't specify the media sample rate, Amazon Transcribe Medical determines it for you. If you specify the sample rate, it must match the rate detected by Amazon Transcribe Medical; if there's a mismatch between the value that you specify and the value detected, your job fails. Therefore, in most cases, it's advised to omit MediaSampleRateHertz and let Amazon Transcribe Medical determine the sample rate.
    public var mediaSampleRateHertz: Swift.Int?
    /// A unique name, chosen by you, for your medical transcription job. The name that you specify is also used as the default name of your transcription output file. If you want to specify a different name for your transcription output, use the OutputKey parameter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var medicalTranscriptionJobName: Swift.String?
    /// The name of the Amazon S3 bucket where you want your medical transcription output stored. Do not include the S3:// prefix of the specified bucket. If you want your output to go to a sub-folder of this bucket, specify it using the OutputKey parameter; OutputBucketName only accepts the name of a bucket. For example, if you want your output stored in S3://DOC-EXAMPLE-BUCKET, set OutputBucketName to DOC-EXAMPLE-BUCKET. However, if you want your output stored in S3://DOC-EXAMPLE-BUCKET/test-files/, set OutputBucketName to DOC-EXAMPLE-BUCKET and OutputKey to test-files/. Note that Amazon Transcribe must have permission to use the specified location. You can change Amazon S3 permissions using the [Amazon Web Services Management Console](https://console.aws.amazon.com/s3). See also [Permissions Required for IAM User Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user).
    /// This member is required.
    public var outputBucketName: Swift.String?
    /// The KMS key you want to use to encrypt your medical transcription output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you don't specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). If you specify a KMS key to encrypt your output, you must also specify an output location using the OutputLocation parameter. Note that the role making the request must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// Use in combination with OutputBucketName to specify the output location of your transcript and, optionally, a unique name for your output file. The default name for your transcription output is the same as the name you specified for your medical transcription job (MedicalTranscriptionJobName). Here are some examples of how you can use OutputKey:
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the MedicalTranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript/my-first-transcription.json.
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'test-files/my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the MedicalTranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'test-files/my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript/my-first-transcription.json.
    ///
    ///
    /// If you specify the name of an Amazon S3 bucket sub-folder that doesn't exist, one is created for you.
    public var outputKey: Swift.String?
    /// Specify additional optional settings in your request, including channel identification, alternative transcriptions, and speaker partitioning. You can use that to apply custom vocabularies to your transcription job.
    public var settings: TranscribeClientTypes.MedicalTranscriptionSetting?
    /// Specify the predominant medical specialty represented in your media. For batch transcriptions, PRIMARYCARE is the only valid value. If you require additional specialties, refer to .
    /// This member is required.
    public var specialty: TranscribeClientTypes.Specialty?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new medical transcription job at the time you start this new job. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// Specify whether your input media contains only one person (DICTATION) or contains a conversation between two people (CONVERSATION). For example, DICTATION could be used for a medical professional wanting to transcribe voice memos; CONVERSATION could be used for transcribing the doctor-patient dialogue during the patient's office visit.
    /// This member is required.
    public var type: TranscribeClientTypes.ModelType?

    public init(
        contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType? = nil,
        kmsEncryptionContext: [Swift.String:Swift.String]? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        media: TranscribeClientTypes.Media? = nil,
        mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        medicalTranscriptionJobName: Swift.String? = nil,
        outputBucketName: Swift.String? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        outputKey: Swift.String? = nil,
        settings: TranscribeClientTypes.MedicalTranscriptionSetting? = nil,
        specialty: TranscribeClientTypes.Specialty? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        type: TranscribeClientTypes.ModelType? = nil
    )
    {
        self.contentIdentificationType = contentIdentificationType
        self.kmsEncryptionContext = kmsEncryptionContext
        self.languageCode = languageCode
        self.media = media
        self.mediaFormat = mediaFormat
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.medicalTranscriptionJobName = medicalTranscriptionJobName
        self.outputBucketName = outputBucketName
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.outputKey = outputKey
        self.settings = settings
        self.specialty = specialty
        self.tags = tags
        self.type = type
    }
}

struct StartMedicalTranscriptionJobInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let mediaSampleRateHertz: Swift.Int?
    let mediaFormat: TranscribeClientTypes.MediaFormat?
    let media: TranscribeClientTypes.Media?
    let outputBucketName: Swift.String?
    let outputKey: Swift.String?
    let outputEncryptionKMSKeyId: Swift.String?
    let kmsEncryptionContext: [Swift.String:Swift.String]?
    let settings: TranscribeClientTypes.MedicalTranscriptionSetting?
    let contentIdentificationType: TranscribeClientTypes.MedicalContentIdentificationType?
    let specialty: TranscribeClientTypes.Specialty?
    let type: TranscribeClientTypes.ModelType?
    let tags: [TranscribeClientTypes.Tag]?
}

extension StartMedicalTranscriptionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case kmsEncryptionContext = "KMSEncryptionContext"
        case languageCode = "LanguageCode"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case outputBucketName = "OutputBucketName"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputKey = "OutputKey"
        case settings = "Settings"
        case specialty = "Specialty"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let mediaSampleRateHertzDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaSampleRateHertz)
        mediaSampleRateHertz = mediaSampleRateHertzDecoded
        let mediaFormatDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MediaFormat.self, forKey: .mediaFormat)
        mediaFormat = mediaFormatDecoded
        let mediaDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Media.self, forKey: .media)
        media = mediaDecoded
        let outputBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputBucketName)
        outputBucketName = outputBucketNameDecoded
        let outputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputEncryptionKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputEncryptionKMSKeyId)
        outputEncryptionKMSKeyId = outputEncryptionKMSKeyIdDecoded
        let kmsEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .kmsEncryptionContext)
        var kmsEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let kmsEncryptionContextContainer = kmsEncryptionContextContainer {
            kmsEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in kmsEncryptionContextContainer {
                if let nonemptystring0 = nonemptystring0 {
                    kmsEncryptionContextDecoded0?[key0] = nonemptystring0
                }
            }
        }
        kmsEncryptionContext = kmsEncryptionContextDecoded0
        let settingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalTranscriptionSetting.self, forKey: .settings)
        settings = settingsDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Specialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartMedicalTranscriptionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMedicalTranscriptionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.medicalTranscriptionJob = output.medicalTranscriptionJob
        } else {
            self.medicalTranscriptionJob = nil
        }
    }
}

public struct StartMedicalTranscriptionJobOutput: Swift.Equatable {
    /// Provides detailed information about the current medical transcription job, including job status and, if applicable, failure reason.
    public var medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob?

    public init(
        medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob? = nil
    )
    {
        self.medicalTranscriptionJob = medicalTranscriptionJob
    }
}

struct StartMedicalTranscriptionJobOutputBody: Swift.Equatable {
    let medicalTranscriptionJob: TranscribeClientTypes.MedicalTranscriptionJob?
}

extension StartMedicalTranscriptionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case medicalTranscriptionJob = "MedicalTranscriptionJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let medicalTranscriptionJobDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MedicalTranscriptionJob.self, forKey: .medicalTranscriptionJob)
        medicalTranscriptionJob = medicalTranscriptionJobDecoded
    }
}

enum StartMedicalTranscriptionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartTranscriptionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentRedaction = "ContentRedaction"
        case identifyLanguage = "IdentifyLanguage"
        case identifyMultipleLanguages = "IdentifyMultipleLanguages"
        case jobExecutionSettings = "JobExecutionSettings"
        case kmsEncryptionContext = "KMSEncryptionContext"
        case languageCode = "LanguageCode"
        case languageIdSettings = "LanguageIdSettings"
        case languageOptions = "LanguageOptions"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case modelSettings = "ModelSettings"
        case outputBucketName = "OutputBucketName"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputKey = "OutputKey"
        case settings = "Settings"
        case subtitles = "Subtitles"
        case tags = "Tags"
        case toxicityDetection = "ToxicityDetection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentRedaction = self.contentRedaction {
            try encodeContainer.encode(contentRedaction, forKey: .contentRedaction)
        }
        if let identifyLanguage = self.identifyLanguage {
            try encodeContainer.encode(identifyLanguage, forKey: .identifyLanguage)
        }
        if let identifyMultipleLanguages = self.identifyMultipleLanguages {
            try encodeContainer.encode(identifyMultipleLanguages, forKey: .identifyMultipleLanguages)
        }
        if let jobExecutionSettings = self.jobExecutionSettings {
            try encodeContainer.encode(jobExecutionSettings, forKey: .jobExecutionSettings)
        }
        if let kmsEncryptionContext = kmsEncryptionContext {
            var kmsEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .kmsEncryptionContext)
            for (dictKey0, kmsEncryptionContextMap0) in kmsEncryptionContext {
                try kmsEncryptionContextContainer.encode(kmsEncryptionContextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageIdSettings = languageIdSettings {
            var languageIdSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .languageIdSettings)
            for (dictKey0, languageIdSettingsMap0) in languageIdSettings {
                try languageIdSettingsContainer.encode(languageIdSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let languageOptions = languageOptions {
            var languageOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languageOptions)
            for languagecode0 in languageOptions {
                try languageOptionsContainer.encode(languagecode0.rawValue)
            }
        }
        if let media = self.media {
            try encodeContainer.encode(media, forKey: .media)
        }
        if let mediaFormat = self.mediaFormat {
            try encodeContainer.encode(mediaFormat.rawValue, forKey: .mediaFormat)
        }
        if let mediaSampleRateHertz = self.mediaSampleRateHertz {
            try encodeContainer.encode(mediaSampleRateHertz, forKey: .mediaSampleRateHertz)
        }
        if let modelSettings = self.modelSettings {
            try encodeContainer.encode(modelSettings, forKey: .modelSettings)
        }
        if let outputBucketName = self.outputBucketName {
            try encodeContainer.encode(outputBucketName, forKey: .outputBucketName)
        }
        if let outputEncryptionKMSKeyId = self.outputEncryptionKMSKeyId {
            try encodeContainer.encode(outputEncryptionKMSKeyId, forKey: .outputEncryptionKMSKeyId)
        }
        if let outputKey = self.outputKey {
            try encodeContainer.encode(outputKey, forKey: .outputKey)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let subtitles = self.subtitles {
            try encodeContainer.encode(subtitles, forKey: .subtitles)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let toxicityDetection = toxicityDetection {
            var toxicityDetectionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toxicityDetection)
            for toxicitydetectionsettings0 in toxicityDetection {
                try toxicityDetectionContainer.encode(toxicitydetectionsettings0)
            }
        }
    }
}

extension StartTranscriptionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartTranscriptionJobInput: Swift.Equatable {
    /// Makes it possible to redact or flag specified personally identifiable information (PII) in your transcript. If you use ContentRedaction, you must also include the sub-parameters: PiiEntityTypes, RedactionOutput, and RedactionType.
    public var contentRedaction: TranscribeClientTypes.ContentRedaction?
    /// Enables automatic language identification in your transcription job request. Use this parameter if your media file contains only one language. If your media contains multiple languages, use IdentifyMultipleLanguages instead. If you include IdentifyLanguage, you can optionally include a list of language codes, using LanguageOptions, that you think may be present in your media file. Including LanguageOptions restricts IdentifyLanguage to only the language options that you specify, which can improve transcription accuracy. If you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter to your automatic language identification request, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). If you include LanguageIdSettings, also include LanguageOptions. Note that you must include one of LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages in your request. If you include more than one of these parameters, your transcription job fails.
    public var identifyLanguage: Swift.Bool?
    /// Enables automatic multi-language identification in your transcription job request. Use this parameter if your media file contains more than one language. If your media contains only one language, use IdentifyLanguage instead. If you include IdentifyMultipleLanguages, you can optionally include a list of language codes, using LanguageOptions, that you think may be present in your media file. Including LanguageOptions restricts IdentifyLanguage to only the language options that you specify, which can improve transcription accuracy. If you want to apply a custom vocabulary or a custom vocabulary filter to your automatic language identification request, include LanguageIdSettings with the relevant sub-parameters (VocabularyName and VocabularyFilterName). If you include LanguageIdSettings, also include LanguageOptions. Note that you must include one of LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages in your request. If you include more than one of these parameters, your transcription job fails.
    public var identifyMultipleLanguages: Swift.Bool?
    /// Makes it possible to control how your transcription job is processed. Currently, the only JobExecutionSettings modification you can choose is enabling job queueing using the AllowDeferredExecution sub-parameter. If you include JobExecutionSettings in your request, you must also include the sub-parameters: AllowDeferredExecution and DataAccessRoleArn.
    public var jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings?
    /// A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added layer of security for your data. For more information, see [KMS encryption context](https://docs.aws.amazon.com/transcribe/latest/dg/key-management.html#kms-context) and [Asymmetric keys in KMS](https://docs.aws.amazon.com/transcribe/latest/dg/symmetric-asymmetric.html).
    public var kmsEncryptionContext: [Swift.String:Swift.String]?
    /// The language code that represents the language spoken in the input media file. If you're unsure of the language spoken in your media file, consider using IdentifyLanguage or IdentifyMultipleLanguages to enable automatic language identification. Note that you must include one of LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages in your request. If you include more than one of these parameters, your transcription job fails. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table. To transcribe speech in Modern Standard Arabic (ar-SA), your media file must be encoded at a sample rate of 16,000 Hz or higher.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// If using automatic language identification in your request and you want to apply a custom language model, a custom vocabulary, or a custom vocabulary filter, include LanguageIdSettings with the relevant sub-parameters (VocabularyName, LanguageModelName, and VocabularyFilterName). Note that multi-language identification (IdentifyMultipleLanguages) doesn't support custom language models. LanguageIdSettings supports two to five language codes. Each language code you include can have an associated custom language model, custom vocabulary, and custom vocabulary filter. The language codes that you specify must match the languages of the associated custom language models, custom vocabularies, and custom vocabulary filters. It's recommended that you include LanguageOptions when using LanguageIdSettings to ensure that the correct language dialect is identified. For example, if you specify a custom vocabulary that is in en-US but Amazon Transcribe determines that the language spoken in your media is en-AU, your custom vocabulary is not applied to your transcription. If you include LanguageOptions and include en-US as the only English language dialect, your custom vocabulary is applied to your transcription. If you want to include a custom language model with your request but do not want to use automatic language identification, use instead the  parameter with the LanguageModelName sub-parameter. If you want to include a custom vocabulary or a custom vocabulary filter (or both) with your request but do not want to use automatic language identification, use instead the  parameter with the VocabularyName or VocabularyFilterName (or both) sub-parameter.
    public var languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]?
    /// You can specify two or more language codes that represent the languages you think may be present in your media. Including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. If you include LanguageOptions in your request, you must also include IdentifyLanguage. For more information, refer to [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html). To transcribe speech in Modern Standard Arabic (ar-SA), your media file must be encoded at a sample rate of 16,000 Hz or higher.
    public var languageOptions: [TranscribeClientTypes.LanguageCode]?
    /// Describes the Amazon S3 location of the media file you want to use in your request.
    /// This member is required.
    public var media: TranscribeClientTypes.Media?
    /// Specify the format of your input media file.
    public var mediaFormat: TranscribeClientTypes.MediaFormat?
    /// The sample rate, in hertz, of the audio track in your input media file. If you don't specify the media sample rate, Amazon Transcribe determines it for you. If you specify the sample rate, it must match the rate detected by Amazon Transcribe. If there's a mismatch between the value that you specify and the value detected, your job fails. In most cases, you can omit MediaSampleRateHertz and let Amazon Transcribe determine the sample rate.
    public var mediaSampleRateHertz: Swift.Int?
    /// Specify the custom language model you want to include with your transcription job. If you include ModelSettings in your request, you must include the LanguageModelName sub-parameter. For more information, see [Custom language models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html).
    public var modelSettings: TranscribeClientTypes.ModelSettings?
    /// The name of the Amazon S3 bucket where you want your transcription output stored. Do not include the S3:// prefix of the specified bucket. If you want your output to go to a sub-folder of this bucket, specify it using the OutputKey parameter; OutputBucketName only accepts the name of a bucket. For example, if you want your output stored in S3://DOC-EXAMPLE-BUCKET, set OutputBucketName to DOC-EXAMPLE-BUCKET. However, if you want your output stored in S3://DOC-EXAMPLE-BUCKET/test-files/, set OutputBucketName to DOC-EXAMPLE-BUCKET and OutputKey to test-files/. Note that Amazon Transcribe must have permission to use the specified location. You can change Amazon S3 permissions using the [Amazon Web Services Management Console](https://console.aws.amazon.com/s3). See also [Permissions Required for IAM User Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user). If you don't specify OutputBucketName, your transcript is placed in a service-managed Amazon S3 bucket and you are provided with a URI to access your transcript.
    public var outputBucketName: Swift.String?
    /// The KMS key you want to use to encrypt your transcription output. If using a key located in the current Amazon Web Services account, you can specify your KMS key in one of four ways:
    ///
    /// * Use the KMS key ID itself. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use an alias for the KMS key ID. For example, alias/ExampleAlias.
    ///
    /// * Use the Amazon Resource Name (ARN) for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If using a key located in a different Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:
    ///
    /// * Use the ARN for the KMS key ID. For example, arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Use the ARN for the KMS key alias. For example, arn:aws:kms:region:account-ID:alias/ExampleAlias.
    ///
    ///
    /// If you don't specify an encryption key, your output is encrypted with the default Amazon S3 key (SSE-S3). If you specify a KMS key to encrypt your output, you must also specify an output location using the OutputLocation parameter. Note that the role making the request must have permission to use the specified KMS key.
    public var outputEncryptionKMSKeyId: Swift.String?
    /// Use in combination with OutputBucketName to specify the output location of your transcript and, optionally, a unique name for your output file. The default name for your transcription output is the same as the name you specified for your transcription job (TranscriptionJobName). Here are some examples of how you can use OutputKey:
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the TranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/my-transcript/my-first-transcription.json.
    ///
    /// * If you specify 'DOC-EXAMPLE-BUCKET' as the OutputBucketName and 'test-files/my-transcript.json' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript.json.
    ///
    /// * If you specify 'my-first-transcription' as the TranscriptionJobName, 'DOC-EXAMPLE-BUCKET' as the OutputBucketName, and 'test-files/my-transcript' as the OutputKey, your transcription output path is s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript/my-first-transcription.json.
    ///
    ///
    /// If you specify the name of an Amazon S3 bucket sub-folder that doesn't exist, one is created for you.
    public var outputKey: Swift.String?
    /// Specify additional optional settings in your request, including channel identification, alternative transcriptions, speaker partitioning. You can use that to apply custom vocabularies and vocabulary filters. If you want to include a custom vocabulary or a custom vocabulary filter (or both) with your request but do not want to use automatic language identification, use Settings with the VocabularyName or VocabularyFilterName (or both) sub-parameter. If you're using automatic language identification with your request and want to include a custom language model, a custom vocabulary, or a custom vocabulary filter, use instead the  parameter with the LanguageModelName, VocabularyName or VocabularyFilterName sub-parameters.
    public var settings: TranscribeClientTypes.Settings?
    /// Produces subtitle files for your input media. You can specify WebVTT (*.vtt) and SubRip (*.srt) formats.
    public var subtitles: TranscribeClientTypes.Subtitles?
    /// Adds one or more custom tags, each in the form of a key:value pair, to a new transcription job at the time you start this new job. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public var tags: [TranscribeClientTypes.Tag]?
    /// Enables toxic speech detection in your transcript. If you include ToxicityDetection in your request, you must also include ToxicityCategories. For information on the types of toxic speech Amazon Transcribe can detect, see [Detecting toxic speech](https://docs.aws.amazon.com/transcribe/latest/dg/toxic-language.html).
    public var toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
    /// A unique name, chosen by you, for your transcription job. The name that you specify is also used as the default name of your transcription output file. If you want to specify a different name for your transcription output, use the OutputKey parameter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account. If you try to create a new job with the same name as an existing job, you get a ConflictException error.
    /// This member is required.
    public var transcriptionJobName: Swift.String?

    public init(
        contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
        identifyLanguage: Swift.Bool? = nil,
        identifyMultipleLanguages: Swift.Bool? = nil,
        jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings? = nil,
        kmsEncryptionContext: [Swift.String:Swift.String]? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]? = nil,
        languageOptions: [TranscribeClientTypes.LanguageCode]? = nil,
        media: TranscribeClientTypes.Media? = nil,
        mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        modelSettings: TranscribeClientTypes.ModelSettings? = nil,
        outputBucketName: Swift.String? = nil,
        outputEncryptionKMSKeyId: Swift.String? = nil,
        outputKey: Swift.String? = nil,
        settings: TranscribeClientTypes.Settings? = nil,
        subtitles: TranscribeClientTypes.Subtitles? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil,
        toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]? = nil,
        transcriptionJobName: Swift.String? = nil
    )
    {
        self.contentRedaction = contentRedaction
        self.identifyLanguage = identifyLanguage
        self.identifyMultipleLanguages = identifyMultipleLanguages
        self.jobExecutionSettings = jobExecutionSettings
        self.kmsEncryptionContext = kmsEncryptionContext
        self.languageCode = languageCode
        self.languageIdSettings = languageIdSettings
        self.languageOptions = languageOptions
        self.media = media
        self.mediaFormat = mediaFormat
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.modelSettings = modelSettings
        self.outputBucketName = outputBucketName
        self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
        self.outputKey = outputKey
        self.settings = settings
        self.subtitles = subtitles
        self.tags = tags
        self.toxicityDetection = toxicityDetection
        self.transcriptionJobName = transcriptionJobName
    }
}

struct StartTranscriptionJobInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let mediaSampleRateHertz: Swift.Int?
    let mediaFormat: TranscribeClientTypes.MediaFormat?
    let media: TranscribeClientTypes.Media?
    let outputBucketName: Swift.String?
    let outputKey: Swift.String?
    let outputEncryptionKMSKeyId: Swift.String?
    let kmsEncryptionContext: [Swift.String:Swift.String]?
    let settings: TranscribeClientTypes.Settings?
    let modelSettings: TranscribeClientTypes.ModelSettings?
    let jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings?
    let contentRedaction: TranscribeClientTypes.ContentRedaction?
    let identifyLanguage: Swift.Bool?
    let identifyMultipleLanguages: Swift.Bool?
    let languageOptions: [TranscribeClientTypes.LanguageCode]?
    let subtitles: TranscribeClientTypes.Subtitles?
    let tags: [TranscribeClientTypes.Tag]?
    let languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]?
    let toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
}

extension StartTranscriptionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentRedaction = "ContentRedaction"
        case identifyLanguage = "IdentifyLanguage"
        case identifyMultipleLanguages = "IdentifyMultipleLanguages"
        case jobExecutionSettings = "JobExecutionSettings"
        case kmsEncryptionContext = "KMSEncryptionContext"
        case languageCode = "LanguageCode"
        case languageIdSettings = "LanguageIdSettings"
        case languageOptions = "LanguageOptions"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case modelSettings = "ModelSettings"
        case outputBucketName = "OutputBucketName"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputKey = "OutputKey"
        case settings = "Settings"
        case subtitles = "Subtitles"
        case tags = "Tags"
        case toxicityDetection = "ToxicityDetection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let mediaSampleRateHertzDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaSampleRateHertz)
        mediaSampleRateHertz = mediaSampleRateHertzDecoded
        let mediaFormatDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MediaFormat.self, forKey: .mediaFormat)
        mediaFormat = mediaFormatDecoded
        let mediaDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Media.self, forKey: .media)
        media = mediaDecoded
        let outputBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputBucketName)
        outputBucketName = outputBucketNameDecoded
        let outputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputEncryptionKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputEncryptionKMSKeyId)
        outputEncryptionKMSKeyId = outputEncryptionKMSKeyIdDecoded
        let kmsEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .kmsEncryptionContext)
        var kmsEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let kmsEncryptionContextContainer = kmsEncryptionContextContainer {
            kmsEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in kmsEncryptionContextContainer {
                if let nonemptystring0 = nonemptystring0 {
                    kmsEncryptionContextDecoded0?[key0] = nonemptystring0
                }
            }
        }
        kmsEncryptionContext = kmsEncryptionContextDecoded0
        let settingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
        let modelSettingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelSettings.self, forKey: .modelSettings)
        modelSettings = modelSettingsDecoded
        let jobExecutionSettingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.JobExecutionSettings.self, forKey: .jobExecutionSettings)
        jobExecutionSettings = jobExecutionSettingsDecoded
        let contentRedactionDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ContentRedaction.self, forKey: .contentRedaction)
        contentRedaction = contentRedactionDecoded
        let identifyLanguageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyLanguage)
        identifyLanguage = identifyLanguageDecoded
        let identifyMultipleLanguagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyMultipleLanguages)
        identifyMultipleLanguages = identifyMultipleLanguagesDecoded
        let languageOptionsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.LanguageCode?].self, forKey: .languageOptions)
        var languageOptionsDecoded0:[TranscribeClientTypes.LanguageCode]? = nil
        if let languageOptionsContainer = languageOptionsContainer {
            languageOptionsDecoded0 = [TranscribeClientTypes.LanguageCode]()
            for enum0 in languageOptionsContainer {
                if let enum0 = enum0 {
                    languageOptionsDecoded0?.append(enum0)
                }
            }
        }
        languageOptions = languageOptionsDecoded0
        let subtitlesDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Subtitles.self, forKey: .subtitles)
        subtitles = subtitlesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let languageIdSettingsContainer = try containerValues.decodeIfPresent([Swift.String: TranscribeClientTypes.LanguageIdSettings?].self, forKey: .languageIdSettings)
        var languageIdSettingsDecoded0: [Swift.String:TranscribeClientTypes.LanguageIdSettings]? = nil
        if let languageIdSettingsContainer = languageIdSettingsContainer {
            languageIdSettingsDecoded0 = [Swift.String:TranscribeClientTypes.LanguageIdSettings]()
            for (key0, languageidsettings0) in languageIdSettingsContainer {
                if let languageidsettings0 = languageidsettings0 {
                    languageIdSettingsDecoded0?[key0] = languageidsettings0
                }
            }
        }
        languageIdSettings = languageIdSettingsDecoded0
        let toxicityDetectionContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.ToxicityDetectionSettings?].self, forKey: .toxicityDetection)
        var toxicityDetectionDecoded0:[TranscribeClientTypes.ToxicityDetectionSettings]? = nil
        if let toxicityDetectionContainer = toxicityDetectionContainer {
            toxicityDetectionDecoded0 = [TranscribeClientTypes.ToxicityDetectionSettings]()
            for structure0 in toxicityDetectionContainer {
                if let structure0 = structure0 {
                    toxicityDetectionDecoded0?.append(structure0)
                }
            }
        }
        toxicityDetection = toxicityDetectionDecoded0
    }
}

extension StartTranscriptionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTranscriptionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.transcriptionJob = output.transcriptionJob
        } else {
            self.transcriptionJob = nil
        }
    }
}

public struct StartTranscriptionJobOutput: Swift.Equatable {
    /// Provides detailed information about the current transcription job, including job status and, if applicable, failure reason.
    public var transcriptionJob: TranscribeClientTypes.TranscriptionJob?

    public init(
        transcriptionJob: TranscribeClientTypes.TranscriptionJob? = nil
    )
    {
        self.transcriptionJob = transcriptionJob
    }
}

struct StartTranscriptionJobOutputBody: Swift.Equatable {
    let transcriptionJob: TranscribeClientTypes.TranscriptionJob?
}

extension StartTranscriptionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionJob = "TranscriptionJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionJobDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJob.self, forKey: .transcriptionJob)
        transcriptionJob = transcriptionJobDecoded
    }
}

enum StartTranscriptionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TranscribeClientTypes {
    public enum SubtitleFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case srt
        case vtt
        case sdkUnknown(Swift.String)

        public static var allCases: [SubtitleFormat] {
            return [
                .srt,
                .vtt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .srt: return "srt"
            case .vtt: return "vtt"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubtitleFormat(rawValue: rawValue) ?? SubtitleFormat.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.Subtitles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formats = "Formats"
        case outputStartIndex = "OutputStartIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formats = formats {
            var formatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formats)
            for subtitleformat0 in formats {
                try formatsContainer.encode(subtitleformat0.rawValue)
            }
        }
        if let outputStartIndex = self.outputStartIndex {
            try encodeContainer.encode(outputStartIndex, forKey: .outputStartIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.SubtitleFormat?].self, forKey: .formats)
        var formatsDecoded0:[TranscribeClientTypes.SubtitleFormat]? = nil
        if let formatsContainer = formatsContainer {
            formatsDecoded0 = [TranscribeClientTypes.SubtitleFormat]()
            for enum0 in formatsContainer {
                if let enum0 = enum0 {
                    formatsDecoded0?.append(enum0)
                }
            }
        }
        formats = formatsDecoded0
        let outputStartIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputStartIndex)
        outputStartIndex = outputStartIndexDecoded
    }
}

extension TranscribeClientTypes {
    /// Generate subtitles for your media file with your transcription request. You can choose a start index of 0 or 1, and you can specify either WebVTT or SubRip (or both) as your output format. Note that your subtitle files are placed in the same location as your transcription output.
    public struct Subtitles: Swift.Equatable {
        /// Specify the output format for your subtitle file; if you select both WebVTT (vtt) and SubRip (srt) formats, two output files are generated.
        public var formats: [TranscribeClientTypes.SubtitleFormat]?
        /// Specify the starting value that is assigned to the first subtitle segment. The default start index for Amazon Transcribe is 0, which differs from the more widely used standard of 1. If you're uncertain which value to use, we recommend choosing 1, as this may improve compatibility with other services.
        public var outputStartIndex: Swift.Int?

        public init(
            formats: [TranscribeClientTypes.SubtitleFormat]? = nil,
            outputStartIndex: Swift.Int? = nil
        )
        {
            self.formats = formats
            self.outputStartIndex = outputStartIndex
        }
    }

}

extension TranscribeClientTypes.SubtitlesOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formats = "Formats"
        case outputStartIndex = "OutputStartIndex"
        case subtitleFileUris = "SubtitleFileUris"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formats = formats {
            var formatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formats)
            for subtitleformat0 in formats {
                try formatsContainer.encode(subtitleformat0.rawValue)
            }
        }
        if let outputStartIndex = self.outputStartIndex {
            try encodeContainer.encode(outputStartIndex, forKey: .outputStartIndex)
        }
        if let subtitleFileUris = subtitleFileUris {
            var subtitleFileUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subtitleFileUris)
            for uri0 in subtitleFileUris {
                try subtitleFileUrisContainer.encode(uri0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.SubtitleFormat?].self, forKey: .formats)
        var formatsDecoded0:[TranscribeClientTypes.SubtitleFormat]? = nil
        if let formatsContainer = formatsContainer {
            formatsDecoded0 = [TranscribeClientTypes.SubtitleFormat]()
            for enum0 in formatsContainer {
                if let enum0 = enum0 {
                    formatsDecoded0?.append(enum0)
                }
            }
        }
        formats = formatsDecoded0
        let subtitleFileUrisContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subtitleFileUris)
        var subtitleFileUrisDecoded0:[Swift.String]? = nil
        if let subtitleFileUrisContainer = subtitleFileUrisContainer {
            subtitleFileUrisDecoded0 = [Swift.String]()
            for string0 in subtitleFileUrisContainer {
                if let string0 = string0 {
                    subtitleFileUrisDecoded0?.append(string0)
                }
            }
        }
        subtitleFileUris = subtitleFileUrisDecoded0
        let outputStartIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputStartIndex)
        outputStartIndex = outputStartIndexDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides information about your subtitle file, including format, start index, and Amazon S3 location.
    public struct SubtitlesOutput: Swift.Equatable {
        /// Provides the format of your subtitle files. If your request included both WebVTT (vtt) and SubRip (srt) formats, both formats are shown.
        public var formats: [TranscribeClientTypes.SubtitleFormat]?
        /// Provides the start index value for your subtitle files. If you did not specify a value in your request, the default value of 0 is used.
        public var outputStartIndex: Swift.Int?
        /// The Amazon S3 location of your transcript. You can use this URI to access or download your subtitle file. Your subtitle file is stored in the same location as your transcript. If you specified both WebVTT and SubRip subtitle formats, two URIs are provided. If you included OutputBucketName in your transcription job request, this is the URI of that bucket. If you also included OutputKey in your request, your output is located in the path you specified in your request. If you didn't include OutputBucketName in your transcription job request, your subtitle file is stored in a service-managed bucket, and TranscriptFileUri provides you with a temporary URI you can use for secure access to your subtitle file. Temporary URIs for service-managed Amazon S3 buckets are only valid for 15 minutes. If you get an AccesDenied error, you can get a new temporary URI by running a GetTranscriptionJob or ListTranscriptionJob request.
        public var subtitleFileUris: [Swift.String]?

        public init(
            formats: [TranscribeClientTypes.SubtitleFormat]? = nil,
            outputStartIndex: Swift.Int? = nil,
            subtitleFileUris: [Swift.String]? = nil
        )
        {
            self.formats = formats
            self.outputStartIndex = outputStartIndex
            self.subtitleFileUris = subtitleFileUris
        }
    }

}

extension TranscribeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TranscribeClientTypes {
    /// Adds metadata, in the form of a key:value pair, to the specified resource. For example, you could add the tag Department:Sales to a resource to indicate that it pertains to your organization's sales department. You can also use tags for tag-based access control. To learn more about tagging, see [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    public struct Tag: Swift.Equatable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag Department:Sales, the key is 'Department'.
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag Department:Sales, the value is 'Sales'. Note that you can set the value of a tag to an empty string, but you can't set the value of a tag to null. Omitting the tag value is the same as using an empty string.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to tag. ARNs have the format arn:partition:service:region:account-id:resource-type/resource-id. For example, arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name. Valid values for resource-type are: transcription-job, medical-transcription-job, vocabulary, medical-vocabulary, vocabulary-filter, and language-model.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds one or more custom tags, each in the form of a key:value pair, to the specified resource. To learn more about using tags with Amazon Transcribe, refer to [Tagging resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
    /// This member is required.
    public var tags: [TranscribeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [TranscribeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [TranscribeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TranscribeClientTypes {
    public enum ToxicityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [ToxicityCategory] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ToxicityCategory(rawValue: rawValue) ?? ToxicityCategory.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.ToxicityDetectionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case toxicityCategories = "ToxicityCategories"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let toxicityCategories = toxicityCategories {
            var toxicityCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toxicityCategories)
            for toxicitycategory0 in toxicityCategories {
                try toxicityCategoriesContainer.encode(toxicitycategory0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toxicityCategoriesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.ToxicityCategory?].self, forKey: .toxicityCategories)
        var toxicityCategoriesDecoded0:[TranscribeClientTypes.ToxicityCategory]? = nil
        if let toxicityCategoriesContainer = toxicityCategoriesContainer {
            toxicityCategoriesDecoded0 = [TranscribeClientTypes.ToxicityCategory]()
            for enum0 in toxicityCategoriesContainer {
                if let enum0 = enum0 {
                    toxicityCategoriesDecoded0?.append(enum0)
                }
            }
        }
        toxicityCategories = toxicityCategoriesDecoded0
    }
}

extension TranscribeClientTypes {
    /// Contains ToxicityCategories, which is a required parameter if you want to enable toxicity detection (ToxicityDetection) in your transcription request.
    public struct ToxicityDetectionSettings: Swift.Equatable {
        /// If you include ToxicityDetection in your transcription request, you must also include ToxicityCategories. The only accepted value for this parameter is ALL.
        /// This member is required.
        public var toxicityCategories: [TranscribeClientTypes.ToxicityCategory]?

        public init(
            toxicityCategories: [TranscribeClientTypes.ToxicityCategory]? = nil
        )
        {
            self.toxicityCategories = toxicityCategories
        }
    }

}

extension TranscribeClientTypes.Transcript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case redactedTranscriptFileUri = "RedactedTranscriptFileUri"
        case transcriptFileUri = "TranscriptFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let redactedTranscriptFileUri = self.redactedTranscriptFileUri {
            try encodeContainer.encode(redactedTranscriptFileUri, forKey: .redactedTranscriptFileUri)
        }
        if let transcriptFileUri = self.transcriptFileUri {
            try encodeContainer.encode(transcriptFileUri, forKey: .transcriptFileUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcriptFileUri)
        transcriptFileUri = transcriptFileUriDecoded
        let redactedTranscriptFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redactedTranscriptFileUri)
        redactedTranscriptFileUri = redactedTranscriptFileUriDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides you with the Amazon S3 URI you can use to access your transcript.
    public struct Transcript: Swift.Equatable {
        /// The Amazon S3 location of your redacted transcript. You can use this URI to access or download your transcript. If you included OutputBucketName in your transcription job request, this is the URI of that bucket. If you also included OutputKey in your request, your output is located in the path you specified in your request. If you didn't include OutputBucketName in your transcription job request, your transcript is stored in a service-managed bucket, and RedactedTranscriptFileUri provides you with a temporary URI you can use for secure access to your transcript. Temporary URIs for service-managed Amazon S3 buckets are only valid for 15 minutes. If you get an AccesDenied error, you can get a new temporary URI by running a GetTranscriptionJob or ListTranscriptionJob request.
        public var redactedTranscriptFileUri: Swift.String?
        /// The Amazon S3 location of your transcript. You can use this URI to access or download your transcript. If you included OutputBucketName in your transcription job request, this is the URI of that bucket. If you also included OutputKey in your request, your output is located in the path you specified in your request. If you didn't include OutputBucketName in your transcription job request, your transcript is stored in a service-managed bucket, and TranscriptFileUri provides you with a temporary URI you can use for secure access to your transcript. Temporary URIs for service-managed Amazon S3 buckets are only valid for 15 minutes. If you get an AccesDenied error, you can get a new temporary URI by running a GetTranscriptionJob or ListTranscriptionJob request.
        public var transcriptFileUri: Swift.String?

        public init(
            redactedTranscriptFileUri: Swift.String? = nil,
            transcriptFileUri: Swift.String? = nil
        )
        {
            self.redactedTranscriptFileUri = redactedTranscriptFileUri
            self.transcriptFileUri = transcriptFileUri
        }
    }

}

extension TranscribeClientTypes.TranscriptFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTimeRange = "AbsoluteTimeRange"
        case negate = "Negate"
        case participantRole = "ParticipantRole"
        case relativeTimeRange = "RelativeTimeRange"
        case targets = "Targets"
        case transcriptFilterType = "TranscriptFilterType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTimeRange = self.absoluteTimeRange {
            try encodeContainer.encode(absoluteTimeRange, forKey: .absoluteTimeRange)
        }
        if let negate = self.negate {
            try encodeContainer.encode(negate, forKey: .negate)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let relativeTimeRange = self.relativeTimeRange {
            try encodeContainer.encode(relativeTimeRange, forKey: .relativeTimeRange)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for nonemptystring0 in targets {
                try targetsContainer.encode(nonemptystring0)
            }
        }
        if let transcriptFilterType = self.transcriptFilterType {
            try encodeContainer.encode(transcriptFilterType.rawValue, forKey: .transcriptFilterType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptFilterTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptFilterType.self, forKey: .transcriptFilterType)
        transcriptFilterType = transcriptFilterTypeDecoded
        let absoluteTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.AbsoluteTimeRange.self, forKey: .absoluteTimeRange)
        absoluteTimeRange = absoluteTimeRangeDecoded
        let relativeTimeRangeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.RelativeTimeRange.self, forKey: .relativeTimeRange)
        relativeTimeRange = relativeTimeRangeDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let negateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negate)
        negate = negateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension TranscribeClientTypes {
    /// Flag the presence or absence of specific words or phrases detected in your Call Analytics transcription output. Rules using TranscriptFilter are designed to match:
    ///
    /// * Custom words or phrases spoken by the agent, the customer, or both
    ///
    /// * Custom words or phrases not spoken by the agent, the customer, or either
    ///
    /// * Custom words or phrases that occur at a specific time frame
    ///
    ///
    /// See [Rule criteria for post-call categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html#tca-rules-batch) and [Rule criteria for streaming categories](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-stream.html#tca-rules-stream) for usage examples.
    public struct TranscriptFilter: Swift.Equatable {
        /// Makes it possible to specify a time range (in milliseconds) in your audio, during which you want to search for the specified key words or phrases. See for more detail.
        public var absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange?
        /// Set to TRUE to flag the absence of the phrase that you specified in your request. Set to FALSE to flag the presence of the phrase that you specified in your request.
        public var negate: Swift.Bool?
        /// Specify the participant that you want to flag. Omitting this parameter is equivalent to specifying both participants.
        public var participantRole: TranscribeClientTypes.ParticipantRole?
        /// Makes it possible to specify a time range (in percentage) in your media file, during which you want to search for the specified key words or phrases. See for more detail.
        public var relativeTimeRange: TranscribeClientTypes.RelativeTimeRange?
        /// Specify the phrases that you want to flag.
        /// This member is required.
        public var targets: [Swift.String]?
        /// Flag the presence or absence of an exact match to the phrases that you specify. For example, if you specify the phrase "speak to a manager" as your Targets value, only that exact phrase is flagged. Note that semantic matching is not supported. For example, if your customer says "speak to the manager", instead of "speak to a manager", your content is not flagged.
        /// This member is required.
        public var transcriptFilterType: TranscribeClientTypes.TranscriptFilterType?

        public init(
            absoluteTimeRange: TranscribeClientTypes.AbsoluteTimeRange? = nil,
            negate: Swift.Bool? = nil,
            participantRole: TranscribeClientTypes.ParticipantRole? = nil,
            relativeTimeRange: TranscribeClientTypes.RelativeTimeRange? = nil,
            targets: [Swift.String]? = nil,
            transcriptFilterType: TranscribeClientTypes.TranscriptFilterType? = nil
        )
        {
            self.absoluteTimeRange = absoluteTimeRange
            self.negate = negate
            self.participantRole = participantRole
            self.relativeTimeRange = relativeTimeRange
            self.targets = targets
            self.transcriptFilterType = transcriptFilterType
        }
    }

}

extension TranscribeClientTypes {
    public enum TranscriptFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exact
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscriptFilterType] {
            return [
                .exact,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exact: return "EXACT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscriptFilterType(rawValue: rawValue) ?? TranscriptFilterType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.TranscriptionJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case contentRedaction = "ContentRedaction"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case identifiedLanguageScore = "IdentifiedLanguageScore"
        case identifyLanguage = "IdentifyLanguage"
        case identifyMultipleLanguages = "IdentifyMultipleLanguages"
        case jobExecutionSettings = "JobExecutionSettings"
        case languageCode = "LanguageCode"
        case languageCodes = "LanguageCodes"
        case languageIdSettings = "LanguageIdSettings"
        case languageOptions = "LanguageOptions"
        case media = "Media"
        case mediaFormat = "MediaFormat"
        case mediaSampleRateHertz = "MediaSampleRateHertz"
        case modelSettings = "ModelSettings"
        case settings = "Settings"
        case startTime = "StartTime"
        case subtitles = "Subtitles"
        case tags = "Tags"
        case toxicityDetection = "ToxicityDetection"
        case transcript = "Transcript"
        case transcriptionJobName = "TranscriptionJobName"
        case transcriptionJobStatus = "TranscriptionJobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let contentRedaction = self.contentRedaction {
            try encodeContainer.encode(contentRedaction, forKey: .contentRedaction)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let identifiedLanguageScore = self.identifiedLanguageScore {
            try encodeContainer.encode(identifiedLanguageScore, forKey: .identifiedLanguageScore)
        }
        if let identifyLanguage = self.identifyLanguage {
            try encodeContainer.encode(identifyLanguage, forKey: .identifyLanguage)
        }
        if let identifyMultipleLanguages = self.identifyMultipleLanguages {
            try encodeContainer.encode(identifyMultipleLanguages, forKey: .identifyMultipleLanguages)
        }
        if let jobExecutionSettings = self.jobExecutionSettings {
            try encodeContainer.encode(jobExecutionSettings, forKey: .jobExecutionSettings)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageCodes = languageCodes {
            var languageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languageCodes)
            for languagecodeitem0 in languageCodes {
                try languageCodesContainer.encode(languagecodeitem0)
            }
        }
        if let languageIdSettings = languageIdSettings {
            var languageIdSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .languageIdSettings)
            for (dictKey0, languageIdSettingsMap0) in languageIdSettings {
                try languageIdSettingsContainer.encode(languageIdSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let languageOptions = languageOptions {
            var languageOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languageOptions)
            for languagecode0 in languageOptions {
                try languageOptionsContainer.encode(languagecode0.rawValue)
            }
        }
        if let media = self.media {
            try encodeContainer.encode(media, forKey: .media)
        }
        if let mediaFormat = self.mediaFormat {
            try encodeContainer.encode(mediaFormat.rawValue, forKey: .mediaFormat)
        }
        if let mediaSampleRateHertz = self.mediaSampleRateHertz {
            try encodeContainer.encode(mediaSampleRateHertz, forKey: .mediaSampleRateHertz)
        }
        if let modelSettings = self.modelSettings {
            try encodeContainer.encode(modelSettings, forKey: .modelSettings)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let subtitles = self.subtitles {
            try encodeContainer.encode(subtitles, forKey: .subtitles)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let toxicityDetection = toxicityDetection {
            var toxicityDetectionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toxicityDetection)
            for toxicitydetectionsettings0 in toxicityDetection {
                try toxicityDetectionContainer.encode(toxicitydetectionsettings0)
            }
        }
        if let transcript = self.transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
        if let transcriptionJobName = self.transcriptionJobName {
            try encodeContainer.encode(transcriptionJobName, forKey: .transcriptionJobName)
        }
        if let transcriptionJobStatus = self.transcriptionJobStatus {
            try encodeContainer.encode(transcriptionJobStatus.rawValue, forKey: .transcriptionJobStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcriptionJobName)
        transcriptionJobName = transcriptionJobNameDecoded
        let transcriptionJobStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJobStatus.self, forKey: .transcriptionJobStatus)
        transcriptionJobStatus = transcriptionJobStatusDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let mediaSampleRateHertzDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaSampleRateHertz)
        mediaSampleRateHertz = mediaSampleRateHertzDecoded
        let mediaFormatDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.MediaFormat.self, forKey: .mediaFormat)
        mediaFormat = mediaFormatDecoded
        let mediaDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Media.self, forKey: .media)
        media = mediaDecoded
        let transcriptDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Transcript.self, forKey: .transcript)
        transcript = transcriptDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
        let modelSettingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelSettings.self, forKey: .modelSettings)
        modelSettings = modelSettingsDecoded
        let jobExecutionSettingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.JobExecutionSettings.self, forKey: .jobExecutionSettings)
        jobExecutionSettings = jobExecutionSettingsDecoded
        let contentRedactionDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ContentRedaction.self, forKey: .contentRedaction)
        contentRedaction = contentRedactionDecoded
        let identifyLanguageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyLanguage)
        identifyLanguage = identifyLanguageDecoded
        let identifyMultipleLanguagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyMultipleLanguages)
        identifyMultipleLanguages = identifyMultipleLanguagesDecoded
        let languageOptionsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.LanguageCode?].self, forKey: .languageOptions)
        var languageOptionsDecoded0:[TranscribeClientTypes.LanguageCode]? = nil
        if let languageOptionsContainer = languageOptionsContainer {
            languageOptionsDecoded0 = [TranscribeClientTypes.LanguageCode]()
            for enum0 in languageOptionsContainer {
                if let enum0 = enum0 {
                    languageOptionsDecoded0?.append(enum0)
                }
            }
        }
        languageOptions = languageOptionsDecoded0
        let identifiedLanguageScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .identifiedLanguageScore)
        identifiedLanguageScore = identifiedLanguageScoreDecoded
        let languageCodesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.LanguageCodeItem?].self, forKey: .languageCodes)
        var languageCodesDecoded0:[TranscribeClientTypes.LanguageCodeItem]? = nil
        if let languageCodesContainer = languageCodesContainer {
            languageCodesDecoded0 = [TranscribeClientTypes.LanguageCodeItem]()
            for structure0 in languageCodesContainer {
                if let structure0 = structure0 {
                    languageCodesDecoded0?.append(structure0)
                }
            }
        }
        languageCodes = languageCodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TranscribeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TranscribeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let subtitlesDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.SubtitlesOutput.self, forKey: .subtitles)
        subtitles = subtitlesDecoded
        let languageIdSettingsContainer = try containerValues.decodeIfPresent([Swift.String: TranscribeClientTypes.LanguageIdSettings?].self, forKey: .languageIdSettings)
        var languageIdSettingsDecoded0: [Swift.String:TranscribeClientTypes.LanguageIdSettings]? = nil
        if let languageIdSettingsContainer = languageIdSettingsContainer {
            languageIdSettingsDecoded0 = [Swift.String:TranscribeClientTypes.LanguageIdSettings]()
            for (key0, languageidsettings0) in languageIdSettingsContainer {
                if let languageidsettings0 = languageidsettings0 {
                    languageIdSettingsDecoded0?[key0] = languageidsettings0
                }
            }
        }
        languageIdSettings = languageIdSettingsDecoded0
        let toxicityDetectionContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.ToxicityDetectionSettings?].self, forKey: .toxicityDetection)
        var toxicityDetectionDecoded0:[TranscribeClientTypes.ToxicityDetectionSettings]? = nil
        if let toxicityDetectionContainer = toxicityDetectionContainer {
            toxicityDetectionDecoded0 = [TranscribeClientTypes.ToxicityDetectionSettings]()
            for structure0 in toxicityDetectionContainer {
                if let structure0 = structure0 {
                    toxicityDetectionDecoded0?.append(structure0)
                }
            }
        }
        toxicityDetection = toxicityDetectionDecoded0
    }
}

extension TranscribeClientTypes {
    /// Provides detailed information about a transcription job. To view the status of the specified transcription job, check the TranscriptionJobStatus field. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri. If the status is FAILED, FailureReason provides details on why your transcription job failed. If you enabled content redaction, the redacted transcript can be found at the location specified in RedactedTranscriptFileUri.
    public struct TranscriptionJob: Swift.Equatable {
        /// The date and time the specified transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: ClientRuntime.Date?
        /// Indicates whether redaction was enabled in your transcript.
        public var contentRedaction: TranscribeClientTypes.ContentRedaction?
        /// The date and time the specified transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: ClientRuntime.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job request failed. The FailureReason field contains one of the following values:
        ///
        /// * Unsupported media format. The media format specified in MediaFormat isn't valid. Refer to MediaFormat for a list of supported formats.
        ///
        /// * The media format provided does not match the detected media format. The media format specified in MediaFormat doesn't match the format of the input file. Check the media format of your media file and correct the specified value.
        ///
        /// * Invalid sample rate for audio file. The sample rate specified in MediaSampleRateHertz isn't valid. The sample rate must be between 8,000 and 48,000 hertz.
        ///
        /// * The sample rate provided does not match the detected sample rate. The sample rate specified in MediaSampleRateHertz doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.
        ///
        /// * Invalid file size: file size too large. The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to [Guidelines and quotas](https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits).
        ///
        /// * Invalid number of channels: number of channels too large. Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to [Guidelines and quotas](https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits).
        public var failureReason: Swift.String?
        /// The confidence score associated with the language identified in your media file. Confidence scores are values between 0 and 1; a larger value indicates a higher probability that the identified language correctly matches the language spoken in your media.
        public var identifiedLanguageScore: Swift.Float?
        /// Indicates whether automatic language identification was enabled (TRUE) for the specified transcription job.
        public var identifyLanguage: Swift.Bool?
        /// Indicates whether automatic multi-language identification was enabled (TRUE) for the specified transcription job.
        public var identifyMultipleLanguages: Swift.Bool?
        /// Provides information about how your transcription job was processed. This parameter shows if your request was queued and what data access role was used.
        public var jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings?
        /// The language code used to create your transcription job. This parameter is used with single-language identification. For multi-language identification requests, refer to the plural version of this parameter, LanguageCodes.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The language codes used to create your transcription job. This parameter is used with multi-language identification. For single-language identification requests, refer to the singular version of this parameter, LanguageCode.
        public var languageCodes: [TranscribeClientTypes.LanguageCodeItem]?
        /// Provides the name and language of all custom language models, custom vocabularies, and custom vocabulary filters that you included in your request.
        public var languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]?
        /// Provides the language codes you specified in your request.
        public var languageOptions: [TranscribeClientTypes.LanguageCode]?
        /// Provides the Amazon S3 location of the media file you used in your request.
        public var media: TranscribeClientTypes.Media?
        /// The format of the input media file.
        public var mediaFormat: TranscribeClientTypes.MediaFormat?
        /// The sample rate, in hertz, of the audio track in your input media file.
        public var mediaSampleRateHertz: Swift.Int?
        /// Provides information on the custom language model you included in your request.
        public var modelSettings: TranscribeClientTypes.ModelSettings?
        /// Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.
        public var settings: TranscribeClientTypes.Settings?
        /// The date and time the specified transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: ClientRuntime.Date?
        /// Indicates whether subtitles were generated with your transcription.
        public var subtitles: TranscribeClientTypes.SubtitlesOutput?
        /// The tags, each in the form of a key:value pair, assigned to the specified transcription job.
        public var tags: [TranscribeClientTypes.Tag]?
        /// Provides information about the toxicity detection settings applied to your transcription.
        public var toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
        /// Provides you with the Amazon S3 URI you can use to access your transcript.
        public var transcript: TranscribeClientTypes.Transcript?
        /// The name of the transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var transcriptionJobName: Swift.String?
        /// Provides the status of the specified transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            identifiedLanguageScore: Swift.Float? = nil,
            identifyLanguage: Swift.Bool? = nil,
            identifyMultipleLanguages: Swift.Bool? = nil,
            jobExecutionSettings: TranscribeClientTypes.JobExecutionSettings? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            languageCodes: [TranscribeClientTypes.LanguageCodeItem]? = nil,
            languageIdSettings: [Swift.String:TranscribeClientTypes.LanguageIdSettings]? = nil,
            languageOptions: [TranscribeClientTypes.LanguageCode]? = nil,
            media: TranscribeClientTypes.Media? = nil,
            mediaFormat: TranscribeClientTypes.MediaFormat? = nil,
            mediaSampleRateHertz: Swift.Int? = nil,
            modelSettings: TranscribeClientTypes.ModelSettings? = nil,
            settings: TranscribeClientTypes.Settings? = nil,
            startTime: ClientRuntime.Date? = nil,
            subtitles: TranscribeClientTypes.SubtitlesOutput? = nil,
            tags: [TranscribeClientTypes.Tag]? = nil,
            toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]? = nil,
            transcript: TranscribeClientTypes.Transcript? = nil,
            transcriptionJobName: Swift.String? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.contentRedaction = contentRedaction
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.identifiedLanguageScore = identifiedLanguageScore
            self.identifyLanguage = identifyLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.jobExecutionSettings = jobExecutionSettings
            self.languageCode = languageCode
            self.languageCodes = languageCodes
            self.languageIdSettings = languageIdSettings
            self.languageOptions = languageOptions
            self.media = media
            self.mediaFormat = mediaFormat
            self.mediaSampleRateHertz = mediaSampleRateHertz
            self.modelSettings = modelSettings
            self.settings = settings
            self.startTime = startTime
            self.subtitles = subtitles
            self.tags = tags
            self.toxicityDetection = toxicityDetection
            self.transcript = transcript
            self.transcriptionJobName = transcriptionJobName
            self.transcriptionJobStatus = transcriptionJobStatus
        }
    }

}

extension TranscribeClientTypes {
    public enum TranscriptionJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case queued
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscriptionJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .queued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscriptionJobStatus(rawValue: rawValue) ?? TranscriptionJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.TranscriptionJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case contentRedaction = "ContentRedaction"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case identifiedLanguageScore = "IdentifiedLanguageScore"
        case identifyLanguage = "IdentifyLanguage"
        case identifyMultipleLanguages = "IdentifyMultipleLanguages"
        case languageCode = "LanguageCode"
        case languageCodes = "LanguageCodes"
        case modelSettings = "ModelSettings"
        case outputLocationType = "OutputLocationType"
        case startTime = "StartTime"
        case toxicityDetection = "ToxicityDetection"
        case transcriptionJobName = "TranscriptionJobName"
        case transcriptionJobStatus = "TranscriptionJobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let contentRedaction = self.contentRedaction {
            try encodeContainer.encode(contentRedaction, forKey: .contentRedaction)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let identifiedLanguageScore = self.identifiedLanguageScore {
            try encodeContainer.encode(identifiedLanguageScore, forKey: .identifiedLanguageScore)
        }
        if let identifyLanguage = self.identifyLanguage {
            try encodeContainer.encode(identifyLanguage, forKey: .identifyLanguage)
        }
        if let identifyMultipleLanguages = self.identifyMultipleLanguages {
            try encodeContainer.encode(identifyMultipleLanguages, forKey: .identifyMultipleLanguages)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageCodes = languageCodes {
            var languageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languageCodes)
            for languagecodeitem0 in languageCodes {
                try languageCodesContainer.encode(languagecodeitem0)
            }
        }
        if let modelSettings = self.modelSettings {
            try encodeContainer.encode(modelSettings, forKey: .modelSettings)
        }
        if let outputLocationType = self.outputLocationType {
            try encodeContainer.encode(outputLocationType.rawValue, forKey: .outputLocationType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let toxicityDetection = toxicityDetection {
            var toxicityDetectionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toxicityDetection)
            for toxicitydetectionsettings0 in toxicityDetection {
                try toxicityDetectionContainer.encode(toxicitydetectionsettings0)
            }
        }
        if let transcriptionJobName = self.transcriptionJobName {
            try encodeContainer.encode(transcriptionJobName, forKey: .transcriptionJobName)
        }
        if let transcriptionJobStatus = self.transcriptionJobStatus {
            try encodeContainer.encode(transcriptionJobStatus.rawValue, forKey: .transcriptionJobStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcriptionJobName)
        transcriptionJobName = transcriptionJobNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let transcriptionJobStatusDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.TranscriptionJobStatus.self, forKey: .transcriptionJobStatus)
        transcriptionJobStatus = transcriptionJobStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let outputLocationTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.OutputLocationType.self, forKey: .outputLocationType)
        outputLocationType = outputLocationTypeDecoded
        let contentRedactionDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ContentRedaction.self, forKey: .contentRedaction)
        contentRedaction = contentRedactionDecoded
        let modelSettingsDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.ModelSettings.self, forKey: .modelSettings)
        modelSettings = modelSettingsDecoded
        let identifyLanguageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyLanguage)
        identifyLanguage = identifyLanguageDecoded
        let identifyMultipleLanguagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyMultipleLanguages)
        identifyMultipleLanguages = identifyMultipleLanguagesDecoded
        let identifiedLanguageScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .identifiedLanguageScore)
        identifiedLanguageScore = identifiedLanguageScoreDecoded
        let languageCodesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.LanguageCodeItem?].self, forKey: .languageCodes)
        var languageCodesDecoded0:[TranscribeClientTypes.LanguageCodeItem]? = nil
        if let languageCodesContainer = languageCodesContainer {
            languageCodesDecoded0 = [TranscribeClientTypes.LanguageCodeItem]()
            for structure0 in languageCodesContainer {
                if let structure0 = structure0 {
                    languageCodesDecoded0?.append(structure0)
                }
            }
        }
        languageCodes = languageCodesDecoded0
        let toxicityDetectionContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.ToxicityDetectionSettings?].self, forKey: .toxicityDetection)
        var toxicityDetectionDecoded0:[TranscribeClientTypes.ToxicityDetectionSettings]? = nil
        if let toxicityDetectionContainer = toxicityDetectionContainer {
            toxicityDetectionDecoded0 = [TranscribeClientTypes.ToxicityDetectionSettings]()
            for structure0 in toxicityDetectionContainer {
                if let structure0 = structure0 {
                    toxicityDetectionDecoded0?.append(structure0)
                }
            }
        }
        toxicityDetection = toxicityDetectionDecoded0
    }
}

extension TranscribeClientTypes {
    /// Provides detailed information about a specific transcription job.
    public struct TranscriptionJobSummary: Swift.Equatable {
        /// The date and time the specified transcription job finished processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:33:13.922000-07:00 represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.
        public var completionTime: ClientRuntime.Date?
        /// The content redaction settings of the transcription job.
        public var contentRedaction: TranscribeClientTypes.ContentRedaction?
        /// The date and time the specified transcription job request was made. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var creationTime: ClientRuntime.Date?
        /// If TranscriptionJobStatus is FAILED, FailureReason contains information about why the transcription job failed. See also: [Common Errors](https://docs.aws.amazon.com/transcribe/latest/APIReference/CommonErrors.html).
        public var failureReason: Swift.String?
        /// The confidence score associated with the language identified in your media file. Confidence scores are values between 0 and 1; a larger value indicates a higher probability that the identified language correctly matches the language spoken in your media.
        public var identifiedLanguageScore: Swift.Float?
        /// Indicates whether automatic language identification was enabled (TRUE) for the specified transcription job.
        public var identifyLanguage: Swift.Bool?
        /// Indicates whether automatic multi-language identification was enabled (TRUE) for the specified transcription job.
        public var identifyMultipleLanguages: Swift.Bool?
        /// The language code used to create your transcription.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The language codes used to create your transcription job. This parameter is used with multi-language identification. For single-language identification, the singular version of this parameter, LanguageCode, is present.
        public var languageCodes: [TranscribeClientTypes.LanguageCodeItem]?
        /// Provides the name of the custom language model that was included in the specified transcription job. Only use ModelSettings with the LanguageModelName sub-parameter if you're not using automatic language identification (). If using LanguageIdSettings in your request, this parameter contains a LanguageModelName sub-parameter.
        public var modelSettings: TranscribeClientTypes.ModelSettings?
        /// Indicates where the specified transcription output is stored. If the value is CUSTOMER_BUCKET, the location is the Amazon S3 bucket you specified using the OutputBucketName parameter in your request. If you also included OutputKey in your request, your output is located in the path you specified in your request. If the value is SERVICE_BUCKET, the location is a service-managed Amazon S3 bucket. To access a transcript stored in a service-managed bucket, use the URI shown in the TranscriptFileUri or RedactedTranscriptFileUri field.
        public var outputLocationType: TranscribeClientTypes.OutputLocationType?
        /// The date and time your transcription job began processing. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.789000-07:00 represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.
        public var startTime: ClientRuntime.Date?
        /// Indicates whether toxicity detection was enabled for the specified transcription job.
        public var toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]?
        /// The name of the transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.
        public var transcriptionJobName: Swift.String?
        /// Provides the status of your transcription job. If the status is COMPLETED, the job is finished and you can find the results at the location specified in TranscriptFileUri (or RedactedTranscriptFileUri, if you requested transcript redaction). If the status is FAILED, FailureReason provides details on why your transcription job failed.
        public var transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            contentRedaction: TranscribeClientTypes.ContentRedaction? = nil,
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            identifiedLanguageScore: Swift.Float? = nil,
            identifyLanguage: Swift.Bool? = nil,
            identifyMultipleLanguages: Swift.Bool? = nil,
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            languageCodes: [TranscribeClientTypes.LanguageCodeItem]? = nil,
            modelSettings: TranscribeClientTypes.ModelSettings? = nil,
            outputLocationType: TranscribeClientTypes.OutputLocationType? = nil,
            startTime: ClientRuntime.Date? = nil,
            toxicityDetection: [TranscribeClientTypes.ToxicityDetectionSettings]? = nil,
            transcriptionJobName: Swift.String? = nil,
            transcriptionJobStatus: TranscribeClientTypes.TranscriptionJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.contentRedaction = contentRedaction
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.identifiedLanguageScore = identifiedLanguageScore
            self.identifyLanguage = identifyLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.languageCode = languageCode
            self.languageCodes = languageCodes
            self.modelSettings = modelSettings
            self.outputLocationType = outputLocationType
            self.startTime = startTime
            self.toxicityDetection = toxicityDetection
            self.transcriptionJobName = transcriptionJobName
            self.transcriptionJobStatus = transcriptionJobStatus
        }
    }

}

extension TranscribeClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .conversation,
                .dictation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to remove tags from. ARNs have the format arn:partition:service:region:account-id:resource-type/resource-id. For example, arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name. Valid values for resource-type are: transcription-job, medical-transcription-job, vocabulary, medical-vocabulary, vocabulary-filter, and language-model.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Removes the specified tag keys from the specified Amazon Transcribe resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCallAnalyticsCategoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputType = "InputType"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputType = self.inputType {
            try encodeContainer.encode(inputType.rawValue, forKey: .inputType)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }
}

extension UpdateCallAnalyticsCategoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCallAnalyticsCategoryInput: Swift.Equatable {
    /// The name of the Call Analytics category you want to update. Category names are case sensitive.
    /// This member is required.
    public var categoryName: Swift.String?
    /// Choose whether you want to update a real-time or a post-call category. The input type you specify must match the input type specified when the category was created. For example, if you created a category with the POST_CALL input type, you must use POST_CALL as the input type when updating this category.
    public var inputType: TranscribeClientTypes.InputType?
    /// The rules used for the updated Call Analytics category. The rules you provide in this field replace the ones that are currently being used in the specified category.
    /// This member is required.
    public var rules: [TranscribeClientTypes.Rule]?

    public init(
        categoryName: Swift.String? = nil,
        inputType: TranscribeClientTypes.InputType? = nil,
        rules: [TranscribeClientTypes.Rule]? = nil
    )
    {
        self.categoryName = categoryName
        self.inputType = inputType
        self.rules = rules
    }
}

struct UpdateCallAnalyticsCategoryInputBody: Swift.Equatable {
    let rules: [TranscribeClientTypes.Rule]?
    let inputType: TranscribeClientTypes.InputType?
}

extension UpdateCallAnalyticsCategoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputType = "InputType"
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([TranscribeClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[TranscribeClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [TranscribeClientTypes.Rule]()
            for union0 in rulesContainer {
                if let union0 = union0 {
                    rulesDecoded0?.append(union0)
                }
            }
        }
        rules = rulesDecoded0
        let inputTypeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.InputType.self, forKey: .inputType)
        inputType = inputTypeDecoded
    }
}

extension UpdateCallAnalyticsCategoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCallAnalyticsCategoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.categoryProperties = output.categoryProperties
        } else {
            self.categoryProperties = nil
        }
    }
}

public struct UpdateCallAnalyticsCategoryOutput: Swift.Equatable {
    /// Provides you with the properties of the Call Analytics category you specified in your UpdateCallAnalyticsCategory request.
    public var categoryProperties: TranscribeClientTypes.CategoryProperties?

    public init(
        categoryProperties: TranscribeClientTypes.CategoryProperties? = nil
    )
    {
        self.categoryProperties = categoryProperties
    }
}

struct UpdateCallAnalyticsCategoryOutputBody: Swift.Equatable {
    let categoryProperties: TranscribeClientTypes.CategoryProperties?
}

extension UpdateCallAnalyticsCategoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryProperties = "CategoryProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryPropertiesDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.CategoryProperties.self, forKey: .categoryProperties)
        categoryProperties = categoryPropertiesDecoded
    }
}

enum UpdateCallAnalyticsCategoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMedicalVocabularyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let vocabularyFileUri = self.vocabularyFileUri {
            try encodeContainer.encode(vocabularyFileUri, forKey: .vocabularyFileUri)
        }
    }
}

extension UpdateMedicalVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMedicalVocabularyInput: Swift.Equatable {
    /// The language code that represents the language of the entries in the custom vocabulary you want to update. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The Amazon S3 location of the text file that contains your custom medical vocabulary. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt
    /// This member is required.
    public var vocabularyFileUri: Swift.String?
    /// The name of the custom medical vocabulary you want to update. Custom medical vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

struct UpdateMedicalVocabularyInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let vocabularyFileUri: Swift.String?
}

extension UpdateMedicalVocabularyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFileUri)
        vocabularyFileUri = vocabularyFileUriDecoded
    }
}

extension UpdateMedicalVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMedicalVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyName = output.vocabularyName
            self.vocabularyState = output.vocabularyState
        } else {
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyName = nil
            self.vocabularyState = nil
        }
    }
}

public struct UpdateMedicalVocabularyOutput: Swift.Equatable {
    /// The language code you selected for your custom medical vocabulary. US English (en-US) is the only language supported with Amazon Transcribe Medical.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom medical vocabulary was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the updated custom medical vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom medical vocabulary. If the state is READY, you can use the custom vocabulary in a StartMedicalTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

struct UpdateMedicalVocabularyOutputBody: Swift.Equatable {
    let vocabularyName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let lastModifiedTime: ClientRuntime.Date?
    let vocabularyState: TranscribeClientTypes.VocabularyState?
}

extension UpdateMedicalVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
    }
}

enum UpdateMedicalVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVocabularyFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case vocabularyFilterFileUri = "VocabularyFilterFileUri"
        case words = "Words"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let vocabularyFilterFileUri = self.vocabularyFilterFileUri {
            try encodeContainer.encode(vocabularyFilterFileUri, forKey: .vocabularyFilterFileUri)
        }
        if let words = words {
            var wordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .words)
            for word0 in words {
                try wordsContainer.encode(word0)
            }
        }
    }
}

extension UpdateVocabularyFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVocabularyFilterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary filter). If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The Amazon S3 location of the text file that contains your custom vocabulary filter terms. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-filter-file.txt Note that if you include VocabularyFilterFileUri in your request, you cannot use Words; you must choose one or the other.
    public var vocabularyFilterFileUri: Swift.String?
    /// The name of the custom vocabulary filter you want to update. Custom vocabulary filter names are case sensitive.
    /// This member is required.
    public var vocabularyFilterName: Swift.String?
    /// Use this parameter if you want to update your custom vocabulary filter by including all desired terms, as comma-separated values, within your request. The other option for updating your vocabulary filter is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFilterFileUri parameter. Note that if you include Words in your request, you cannot use VocabularyFilterFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var words: [Swift.String]?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        vocabularyFilterFileUri: Swift.String? = nil,
        vocabularyFilterName: Swift.String? = nil,
        words: [Swift.String]? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.vocabularyFilterFileUri = vocabularyFilterFileUri
        self.vocabularyFilterName = vocabularyFilterName
        self.words = words
    }
}

struct UpdateVocabularyFilterInputBody: Swift.Equatable {
    let words: [Swift.String]?
    let vocabularyFilterFileUri: Swift.String?
    let dataAccessRoleArn: Swift.String?
}

extension UpdateVocabularyFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case vocabularyFilterFileUri = "VocabularyFilterFileUri"
        case words = "Words"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .words)
        var wordsDecoded0:[Swift.String]? = nil
        if let wordsContainer = wordsContainer {
            wordsDecoded0 = [Swift.String]()
            for string0 in wordsContainer {
                if let string0 = string0 {
                    wordsDecoded0?.append(string0)
                }
            }
        }
        words = wordsDecoded0
        let vocabularyFilterFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterFileUri)
        vocabularyFilterFileUri = vocabularyFilterFileUriDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension UpdateVocabularyFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVocabularyFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyFilterName = output.vocabularyFilterName
        } else {
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyFilterName = nil
        }
    }
}

public struct UpdateVocabularyFilterOutput: Swift.Equatable {
    /// The language code you selected for your custom vocabulary filter.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary filter was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the updated custom vocabulary filter.
    public var vocabularyFilterName: Swift.String?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyFilterName: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyFilterName = vocabularyFilterName
    }
}

struct UpdateVocabularyFilterOutputBody: Swift.Equatable {
    let vocabularyFilterName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let lastModifiedTime: ClientRuntime.Date?
}

extension UpdateVocabularyFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyFilterName = "VocabularyFilterName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

enum UpdateVocabularyFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVocabularyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case languageCode = "LanguageCode"
        case phrases = "Phrases"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let phrases = phrases {
            var phrasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phrases)
            for phrase0 in phrases {
                try phrasesContainer.encode(phrase0)
            }
        }
        if let vocabularyFileUri = self.vocabularyFileUri {
            try encodeContainer.encode(vocabularyFileUri, forKey: .vocabularyFileUri)
        }
    }
}

extension UpdateVocabularyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVocabularyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files (in this case, your custom vocabulary). If the role that you specify doesnt have the appropriate permissions to access the specified Amazon S3 location, your request fails. IAM role ARNs have the format arn:partition:iam::account:role/role-name-with-path. For example: arn:aws:iam::111122223333:role/Admin. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    public var dataAccessRoleArn: Swift.String?
    /// The language code that represents the language of the entries in the custom vocabulary you want to update. Each custom vocabulary must contain terms in only one language. A custom vocabulary can only be used to transcribe files in the same language as the custom vocabulary. For example, if you create a custom vocabulary using US English (en-US), you can only apply this custom vocabulary to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
    /// This member is required.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// Use this parameter if you want to update your custom vocabulary by including all desired terms, as comma-separated values, within your request. The other option for updating your custom vocabulary is to save your entries in a text file and upload them to an Amazon S3 bucket, then specify the location of your file using the VocabularyFileUri parameter. Note that if you include Phrases in your request, you cannot use VocabularyFileUri; you must choose one or the other. Each language has a character set that contains all allowed characters for that specific language. If you use unsupported characters, your custom vocabulary filter request fails. Refer to [Character Sets for Custom Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html) to get the character set for your language.
    public var phrases: [Swift.String]?
    /// The Amazon S3 location of the text file that contains your custom vocabulary. The URI must be located in the same Amazon Web Services Region as the resource you're calling. Here's an example URI path: s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt Note that if you include VocabularyFileUri in your request, you cannot use the Phrases flag; you must choose one or the other.
    public var vocabularyFileUri: Swift.String?
    /// The name of the custom vocabulary you want to update. Custom vocabulary names are case sensitive.
    /// This member is required.
    public var vocabularyName: Swift.String?

    public init(
        dataAccessRoleArn: Swift.String? = nil,
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        phrases: [Swift.String]? = nil,
        vocabularyFileUri: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.languageCode = languageCode
        self.phrases = phrases
        self.vocabularyFileUri = vocabularyFileUri
        self.vocabularyName = vocabularyName
    }
}

struct UpdateVocabularyInputBody: Swift.Equatable {
    let languageCode: TranscribeClientTypes.LanguageCode?
    let phrases: [Swift.String]?
    let vocabularyFileUri: Swift.String?
    let dataAccessRoleArn: Swift.String?
}

extension UpdateVocabularyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case languageCode = "LanguageCode"
        case phrases = "Phrases"
        case vocabularyFileUri = "VocabularyFileUri"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let phrasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phrases)
        var phrasesDecoded0:[Swift.String]? = nil
        if let phrasesContainer = phrasesContainer {
            phrasesDecoded0 = [Swift.String]()
            for string0 in phrasesContainer {
                if let string0 = string0 {
                    phrasesDecoded0?.append(string0)
                }
            }
        }
        phrases = phrasesDecoded0
        let vocabularyFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFileUri)
        vocabularyFileUri = vocabularyFileUriDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension UpdateVocabularyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVocabularyOutputBody = try responseDecoder.decode(responseBody: data)
            self.languageCode = output.languageCode
            self.lastModifiedTime = output.lastModifiedTime
            self.vocabularyName = output.vocabularyName
            self.vocabularyState = output.vocabularyState
        } else {
            self.languageCode = nil
            self.lastModifiedTime = nil
            self.vocabularyName = nil
            self.vocabularyState = nil
        }
    }
}

public struct UpdateVocabularyOutput: Swift.Equatable {
    /// The language code you selected for your custom vocabulary.
    public var languageCode: TranscribeClientTypes.LanguageCode?
    /// The date and time the specified custom vocabulary was last updated. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the updated custom vocabulary.
    public var vocabularyName: Swift.String?
    /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
    public var vocabularyState: TranscribeClientTypes.VocabularyState?

    public init(
        languageCode: TranscribeClientTypes.LanguageCode? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        vocabularyName: Swift.String? = nil,
        vocabularyState: TranscribeClientTypes.VocabularyState? = nil
    )
    {
        self.languageCode = languageCode
        self.lastModifiedTime = lastModifiedTime
        self.vocabularyName = vocabularyName
        self.vocabularyState = vocabularyState
    }
}

struct UpdateVocabularyOutputBody: Swift.Equatable {
    let vocabularyName: Swift.String?
    let languageCode: TranscribeClientTypes.LanguageCode?
    let lastModifiedTime: ClientRuntime.Date?
    let vocabularyState: TranscribeClientTypes.VocabularyState?
}

extension UpdateVocabularyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
    }
}

enum UpdateVocabularyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TranscribeClientTypes.VocabularyFilterInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyFilterName = "VocabularyFilterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides information about a custom vocabulary filter, including the language of the filter, when it was last modified, and its name.
    public struct VocabularyFilterInfo: Swift.Equatable {
        /// The language code that represents the language of the entries in your vocabulary filter. Each custom vocabulary filter must contain terms in only one language. A custom vocabulary filter can only be used to transcribe files in the same language as the filter. For example, if you create a custom vocabulary filter using US English (en-US), you can only apply this filter to files that contain English audio. For a list of supported languages and their associated language codes, refer to the [Supported languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) table.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The date and time the specified custom vocabulary filter was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A unique name, chosen by you, for your custom vocabulary filter. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var vocabularyFilterName: Swift.String?

        public init(
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            vocabularyFilterName: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.vocabularyFilterName = vocabularyFilterName
        }
    }

}

extension TranscribeClientTypes {
    public enum VocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VocabularyFilterMethod(rawValue: rawValue) ?? VocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeClientTypes.VocabularyInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case lastModifiedTime = "LastModifiedTime"
        case vocabularyName = "VocabularyName"
        case vocabularyState = "VocabularyState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
        if let vocabularyState = self.vocabularyState {
            try encodeContainer.encode(vocabularyState.rawValue, forKey: .vocabularyState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let vocabularyStateDecoded = try containerValues.decodeIfPresent(TranscribeClientTypes.VocabularyState.self, forKey: .vocabularyState)
        vocabularyState = vocabularyStateDecoded
    }
}

extension TranscribeClientTypes {
    /// Provides information about a custom vocabulary, including the language of the custom vocabulary, when it was last modified, its name, and the processing state.
    public struct VocabularyInfo: Swift.Equatable {
        /// The language code used to create your custom vocabulary. Each custom vocabulary must contain terms in only one language. A custom vocabulary can only be used to transcribe files in the same language as the custom vocabulary. For example, if you create a custom vocabulary using US English (en-US), you can only apply this custom vocabulary to files that contain English audio.
        public var languageCode: TranscribeClientTypes.LanguageCode?
        /// The date and time the specified custom vocabulary was last modified. Timestamps are in the format YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC. For example, 2022-05-04T12:32:58.761000-07:00 represents 12:32 PM UTC-7 on May 4, 2022.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A unique name, chosen by you, for your custom vocabulary. This name is case sensitive, cannot contain spaces, and must be unique within an Amazon Web Services account.
        public var vocabularyName: Swift.String?
        /// The processing state of your custom vocabulary. If the state is READY, you can use the custom vocabulary in a StartTranscriptionJob request.
        public var vocabularyState: TranscribeClientTypes.VocabularyState?

        public init(
            languageCode: TranscribeClientTypes.LanguageCode? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyState: TranscribeClientTypes.VocabularyState? = nil
        )
        {
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.vocabularyName = vocabularyName
            self.vocabularyState = vocabularyState
        }
    }

}

extension TranscribeClientTypes {
    public enum VocabularyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyState] {
            return [
                .failed,
                .pending,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VocabularyState(rawValue: rawValue) ?? VocabularyState.sdkUnknown(rawValue)
        }
    }
}
