//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension CloudHSMV2ClientTypes {

    public enum BackupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createInProgress
        case deleted
        case pendingDeletion
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupState] {
            return [
                .createInProgress,
                .deleted,
                .pendingDeletion,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudHSMV2ClientTypes {

    public enum ClusterMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fips
        case nonFips
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterMode] {
            return [
                .fips,
                .nonFips
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fips: return "FIPS"
            case .nonFips: return "NON_FIPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains a tag. A tag is a key-value pair.
    public struct Tag {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudHSMV2ClientTypes {
    /// Contains information about a backup of an CloudHSM cluster. All backup objects contain the BackupId, BackupState, ClusterId, and CreateTimestamp parameters. Backups that were copied into a destination region additionally contain the CopyTimestamp, SourceBackup, SourceCluster, and SourceRegion parameters. A backup that is pending deletion will include the DeleteTimestamp parameter.
    public struct Backup {
        /// The Amazon Resource Name (ARN) of the backup.
        public var backupArn: Swift.String?
        /// The identifier (ID) of the backup.
        /// This member is required.
        public var backupId: Swift.String?
        /// The state of the backup.
        public var backupState: CloudHSMV2ClientTypes.BackupState?
        /// The identifier (ID) of the cluster that was backed up.
        public var clusterId: Swift.String?
        /// The date and time when the backup was copied from a source backup.
        public var copyTimestamp: Foundation.Date?
        /// The date and time when the backup was created.
        public var createTimestamp: Foundation.Date?
        /// The date and time when the backup will be permanently deleted.
        public var deleteTimestamp: Foundation.Date?
        /// The HSM type used to create the backup.
        public var hsmType: Swift.String?
        /// The mode of the cluster that was backed up.
        public var mode: CloudHSMV2ClientTypes.ClusterMode?
        /// Specifies whether the service should exempt a backup from the retention policy for the cluster. True exempts a backup from the retention policy. False means the service applies the backup retention policy defined at the cluster.
        public var neverExpires: Swift.Bool?
        /// The identifier (ID) of the source backup from which the new backup was copied.
        public var sourceBackup: Swift.String?
        /// The identifier (ID) of the cluster containing the source backup from which the new backup was copied.
        public var sourceCluster: Swift.String?
        /// The AWS Region that contains the source backup from which the new backup was copied.
        public var sourceRegion: Swift.String?
        /// The list of tags for the backup.
        public var tagList: [CloudHSMV2ClientTypes.Tag]?

        public init(
            backupArn: Swift.String? = nil,
            backupId: Swift.String? = nil,
            backupState: CloudHSMV2ClientTypes.BackupState? = nil,
            clusterId: Swift.String? = nil,
            copyTimestamp: Foundation.Date? = nil,
            createTimestamp: Foundation.Date? = nil,
            deleteTimestamp: Foundation.Date? = nil,
            hsmType: Swift.String? = nil,
            mode: CloudHSMV2ClientTypes.ClusterMode? = nil,
            neverExpires: Swift.Bool? = nil,
            sourceBackup: Swift.String? = nil,
            sourceCluster: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            tagList: [CloudHSMV2ClientTypes.Tag]? = nil
        )
        {
            self.backupArn = backupArn
            self.backupId = backupId
            self.backupState = backupState
            self.clusterId = clusterId
            self.copyTimestamp = copyTimestamp
            self.createTimestamp = createTimestamp
            self.deleteTimestamp = deleteTimestamp
            self.hsmType = hsmType
            self.mode = mode
            self.neverExpires = neverExpires
            self.sourceBackup = sourceBackup
            self.sourceCluster = sourceCluster
            self.sourceRegion = sourceRegion
            self.tagList = tagList
        }
    }

}

extension CloudHSMV2ClientTypes {

    public enum BackupPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupPolicy] {
            return [
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudHSMV2ClientTypes {

    public enum BackupRetentionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupRetentionType] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudHSMV2ClientTypes {
    /// A policy that defines the number of days to retain backups.
    public struct BackupRetentionPolicy {
        /// The type of backup retention policy. For the DAYS type, the value is the number of days to retain backups.
        public var type: CloudHSMV2ClientTypes.BackupRetentionType?
        /// Use a value between 7 - 379.
        public var value: Swift.String?

        public init(
            type: CloudHSMV2ClientTypes.BackupRetentionType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

/// The request was rejected because the requester does not have permission to perform the requested operation.
public struct CloudHsmAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because of an CloudHSM internal failure. The request can be retried.
public struct CloudHsmInternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmInternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because it is not a valid request.
public struct CloudHsmInvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmInvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because it refers to a resource that cannot be found.
public struct CloudHsmResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because an error occurred.
public struct CloudHsmServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because of a tagging failure. Verify the tag conditions in all applicable policies, and then retry the request.
public struct CloudHsmTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmTagException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CopyBackupToRegionInput {
    /// The ID of the backup that will be copied to the destination region.
    /// This member is required.
    public var backupId: Swift.String?
    /// The AWS region that will contain your copied CloudHSM cluster backup.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// Tags to apply to the destination backup during creation. If you specify tags, only these tags will be applied to the destination backup. If you do not specify tags, the service copies tags from the source backup to the destination backup.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        backupId: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.backupId = backupId
        self.destinationRegion = destinationRegion
        self.tagList = tagList
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about the backup that will be copied and created by the [CopyBackupToRegion] operation.
    public struct DestinationBackup {
        /// The date and time when both the source backup was created.
        public var createTimestamp: Foundation.Date?
        /// The identifier (ID) of the source backup from which the new backup was copied.
        public var sourceBackup: Swift.String?
        /// The identifier (ID) of the cluster containing the source backup from which the new backup was copied.
        public var sourceCluster: Swift.String?
        /// The AWS region that contains the source backup from which the new backup was copied.
        public var sourceRegion: Swift.String?

        public init(
            createTimestamp: Foundation.Date? = nil,
            sourceBackup: Swift.String? = nil,
            sourceCluster: Swift.String? = nil,
            sourceRegion: Swift.String? = nil
        )
        {
            self.createTimestamp = createTimestamp
            self.sourceBackup = sourceBackup
            self.sourceCluster = sourceCluster
            self.sourceRegion = sourceRegion
        }
    }

}

public struct CopyBackupToRegionOutput {
    /// Information on the backup that will be copied to the destination region, including CreateTimestamp, SourceBackup, SourceCluster, and Source Region. CreateTimestamp of the destination backup will be the same as that of the source backup. You will need to use the sourceBackupID returned in this operation to use the [DescribeBackups] operation on the backup that will be copied to the destination region.
    public var destinationBackup: CloudHSMV2ClientTypes.DestinationBackup?

    public init(
        destinationBackup: CloudHSMV2ClientTypes.DestinationBackup? = nil
    )
    {
        self.destinationBackup = destinationBackup
    }
}

public struct CreateClusterInput {
    /// A policy that defines how the service retains backups.
    public var backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
    /// The type of HSM to use in the cluster. The allowed values are hsm1.medium and hsm2m.medium.
    /// This member is required.
    public var hsmType: Swift.String?
    /// The mode to use in the cluster. The allowed values are FIPS and NON_FIPS.
    public var mode: CloudHSMV2ClientTypes.ClusterMode?
    /// The identifier (ID) or the Amazon Resource Name (ARN) of the cluster backup to restore. Use this value to restore the cluster from a backup instead of creating a new cluster. To find the backup ID or ARN, use [DescribeBackups]. If using a backup in another account, the full ARN must be supplied.
    public var sourceBackupId: Swift.String?
    /// The identifiers (IDs) of the subnets where you are creating the cluster. You must specify at least one subnet. If you specify multiple subnets, they must meet the following criteria:
    ///
    /// * All subnets must be in the same virtual private cloud (VPC).
    ///
    /// * You can specify only one subnet per Availability Zone.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Tags to apply to the CloudHSM cluster during creation.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy? = nil,
        hsmType: Swift.String? = nil,
        mode: CloudHSMV2ClientTypes.ClusterMode? = nil,
        sourceBackupId: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.backupRetentionPolicy = backupRetentionPolicy
        self.hsmType = hsmType
        self.mode = mode
        self.sourceBackupId = sourceBackupId
        self.subnetIds = subnetIds
        self.tagList = tagList
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains one or more certificates or a certificate signing request (CSR).
    public struct Certificates {
        /// The HSM hardware certificate issued (signed) by CloudHSM.
        public var awsHardwareCertificate: Swift.String?
        /// The cluster certificate issued (signed) by the issuing certificate authority (CA) of the cluster's owner.
        public var clusterCertificate: Swift.String?
        /// The cluster's certificate signing request (CSR). The CSR exists only when the cluster's state is UNINITIALIZED.
        public var clusterCsr: Swift.String?
        /// The HSM certificate issued (signed) by the HSM hardware.
        public var hsmCertificate: Swift.String?
        /// The HSM hardware certificate issued (signed) by the hardware manufacturer.
        public var manufacturerHardwareCertificate: Swift.String?

        public init(
            awsHardwareCertificate: Swift.String? = nil,
            clusterCertificate: Swift.String? = nil,
            clusterCsr: Swift.String? = nil,
            hsmCertificate: Swift.String? = nil,
            manufacturerHardwareCertificate: Swift.String? = nil
        )
        {
            self.awsHardwareCertificate = awsHardwareCertificate
            self.clusterCertificate = clusterCertificate
            self.clusterCsr = clusterCsr
            self.hsmCertificate = hsmCertificate
            self.manufacturerHardwareCertificate = manufacturerHardwareCertificate
        }
    }

}

extension CloudHSMV2ClientTypes {

    public enum HsmState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createInProgress
        case degraded
        case deleted
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [HsmState] {
            return [
                .active,
                .createInProgress,
                .degraded,
                .deleted,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .degraded: return "DEGRADED"
            case .deleted: return "DELETED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about a hardware security module (HSM) in an CloudHSM cluster.
    public struct Hsm {
        /// The Availability Zone that contains the HSM.
        public var availabilityZone: Swift.String?
        /// The identifier (ID) of the cluster that contains the HSM.
        public var clusterId: Swift.String?
        /// The identifier (ID) of the HSM's elastic network interface (ENI).
        public var eniId: Swift.String?
        /// The IP address of the HSM's elastic network interface (ENI).
        public var eniIp: Swift.String?
        /// The HSM's identifier (ID).
        /// This member is required.
        public var hsmId: Swift.String?
        /// The HSM's state.
        public var state: CloudHSMV2ClientTypes.HsmState?
        /// A description of the HSM's state.
        public var stateMessage: Swift.String?
        /// The subnet that contains the HSM's elastic network interface (ENI).
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            eniId: Swift.String? = nil,
            eniIp: Swift.String? = nil,
            hsmId: Swift.String? = nil,
            state: CloudHSMV2ClientTypes.HsmState? = nil,
            stateMessage: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.clusterId = clusterId
            self.eniId = eniId
            self.eniIp = eniIp
            self.hsmId = hsmId
            self.state = state
            self.stateMessage = stateMessage
            self.subnetId = subnetId
        }
    }

}

extension CloudHSMV2ClientTypes {

    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createInProgress
        case degraded
        case deleted
        case deleteInProgress
        case initialized
        case initializeInProgress
        case uninitialized
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .active,
                .createInProgress,
                .degraded,
                .deleted,
                .deleteInProgress,
                .initialized,
                .initializeInProgress,
                .uninitialized,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .degraded: return "DEGRADED"
            case .deleted: return "DELETED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .initialized: return "INITIALIZED"
            case .initializeInProgress: return "INITIALIZE_IN_PROGRESS"
            case .uninitialized: return "UNINITIALIZED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about an CloudHSM cluster.
    public struct Cluster {
        /// The cluster's backup policy.
        public var backupPolicy: CloudHSMV2ClientTypes.BackupPolicy?
        /// A policy that defines how the service retains backups.
        public var backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
        /// Contains one or more certificates or a certificate signing request (CSR).
        public var certificates: CloudHSMV2ClientTypes.Certificates?
        /// The cluster's identifier (ID).
        public var clusterId: Swift.String?
        /// The date and time when the cluster was created.
        public var createTimestamp: Foundation.Date?
        /// The type of HSM that the cluster contains.
        public var hsmType: Swift.String?
        /// Contains information about the HSMs in the cluster.
        public var hsms: [CloudHSMV2ClientTypes.Hsm]?
        /// The mode of the cluster.
        public var mode: CloudHSMV2ClientTypes.ClusterMode?
        /// The default password for the cluster's Pre-Crypto Officer (PRECO) user.
        public var preCoPassword: Swift.String?
        /// The identifier (ID) of the cluster's security group.
        public var securityGroup: Swift.String?
        /// The identifier (ID) of the backup used to create the cluster. This value exists only when the cluster was created from a backup.
        public var sourceBackupId: Swift.String?
        /// The cluster's state.
        public var state: CloudHSMV2ClientTypes.ClusterState?
        /// A description of the cluster's state.
        public var stateMessage: Swift.String?
        /// A map from availability zone to the cluster’s subnet in that availability zone.
        public var subnetMapping: [Swift.String: Swift.String]?
        /// The list of tags for the cluster.
        public var tagList: [CloudHSMV2ClientTypes.Tag]?
        /// The identifier (ID) of the virtual private cloud (VPC) that contains the cluster.
        public var vpcId: Swift.String?

        public init(
            backupPolicy: CloudHSMV2ClientTypes.BackupPolicy? = nil,
            backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy? = nil,
            certificates: CloudHSMV2ClientTypes.Certificates? = nil,
            clusterId: Swift.String? = nil,
            createTimestamp: Foundation.Date? = nil,
            hsmType: Swift.String? = nil,
            hsms: [CloudHSMV2ClientTypes.Hsm]? = nil,
            mode: CloudHSMV2ClientTypes.ClusterMode? = nil,
            preCoPassword: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            sourceBackupId: Swift.String? = nil,
            state: CloudHSMV2ClientTypes.ClusterState? = nil,
            stateMessage: Swift.String? = nil,
            subnetMapping: [Swift.String: Swift.String]? = nil,
            tagList: [CloudHSMV2ClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.backupPolicy = backupPolicy
            self.backupRetentionPolicy = backupRetentionPolicy
            self.certificates = certificates
            self.clusterId = clusterId
            self.createTimestamp = createTimestamp
            self.hsmType = hsmType
            self.hsms = hsms
            self.mode = mode
            self.preCoPassword = preCoPassword
            self.securityGroup = securityGroup
            self.sourceBackupId = sourceBackupId
            self.state = state
            self.stateMessage = stateMessage
            self.subnetMapping = subnetMapping
            self.tagList = tagList
            self.vpcId = vpcId
        }
    }

}

public struct CreateClusterOutput {
    /// Information about the cluster that was created.
    public var cluster: CloudHSMV2ClientTypes.Cluster?

    public init(
        cluster: CloudHSMV2ClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

public struct CreateHsmInput {
    /// The Availability Zone where you are creating the HSM. To find the cluster's Availability Zones, use [DescribeClusters].
    /// This member is required.
    public var availabilityZone: Swift.String?
    /// The identifier (ID) of the HSM's cluster. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?
    /// The HSM's IP address. If you specify an IP address, use an available address from the subnet that maps to the Availability Zone where you are creating the HSM. If you don't specify an IP address, one is chosen for you from that subnet.
    public var ipAddress: Swift.String?

    public init(
        availabilityZone: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        ipAddress: Swift.String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.clusterId = clusterId
        self.ipAddress = ipAddress
    }
}

public struct CreateHsmOutput {
    /// Information about the HSM that was created.
    public var hsm: CloudHSMV2ClientTypes.Hsm?

    public init(
        hsm: CloudHSMV2ClientTypes.Hsm? = nil
    )
    {
        self.hsm = hsm
    }
}

public struct DeleteBackupInput {
    /// The ID of the backup to be deleted. To find the ID of a backup, use the [DescribeBackups] operation.
    /// This member is required.
    public var backupId: Swift.String?

    public init(
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

public struct DeleteBackupOutput {
    /// Information on the Backup object deleted.
    public var backup: CloudHSMV2ClientTypes.Backup?

    public init(
        backup: CloudHSMV2ClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

public struct DeleteClusterInput {
    /// The identifier (ID) of the cluster that you are deleting. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

public struct DeleteClusterOutput {
    /// Information about the cluster that was deleted.
    public var cluster: CloudHSMV2ClientTypes.Cluster?

    public init(
        cluster: CloudHSMV2ClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

public struct DeleteHsmInput {
    /// The identifier (ID) of the cluster that contains the HSM that you are deleting.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The identifier (ID) of the elastic network interface (ENI) of the HSM that you are deleting.
    public var eniId: Swift.String?
    /// The IP address of the elastic network interface (ENI) of the HSM that you are deleting.
    public var eniIp: Swift.String?
    /// The identifier (ID) of the HSM that you are deleting.
    public var hsmId: Swift.String?

    public init(
        clusterId: Swift.String? = nil,
        eniId: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        hsmId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmId = hsmId
    }
}

public struct DeleteHsmOutput {
    /// The identifier (ID) of the HSM that was deleted.
    public var hsmId: Swift.String?

    public init(
        hsmId: Swift.String? = nil
    )
    {
        self.hsmId = hsmId
    }
}

public struct DeleteResourcePolicyInput {
    /// Amazon Resource Name (ARN) of the resource from which the policy will be removed.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput {
    /// The policy previously attached to the resource.
    public var policy: Swift.String?
    /// Amazon Resource Name (ARN) of the resource from which the policy was deleted.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct DescribeBackupsInput {
    /// One or more filters to limit the items returned in the response. Use the backupIds filter to return only the specified backups. Specify backups by their backup identifier (ID). Use the sourceBackupIds filter to return only the backups created from a source backup. The sourceBackupID of a source backup is returned by the [CopyBackupToRegion] operation. Use the clusterIds filter to return only the backups for the specified clusters. Specify clusters by their cluster identifier (ID). Use the states filter to return only backups that match the specified state. Use the neverExpires filter to return backups filtered by the value in the neverExpires parameter. True returns all backups exempt from the backup retention policy. False returns all backups with a backup retention policy defined at the cluster.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of backups to return in the response. When there are more backups than the number you specify, the response contains a NextToken value.
    public var maxResults: Swift.Int?
    /// The NextToken value that you received in the previous response. Use this value to get more backups.
    public var nextToken: Swift.String?
    /// Describe backups that are shared with you. By default when using this option, the command returns backups that have been shared using a standard Resource Access Manager resource share. In order for a backup that was shared using the PutResourcePolicy command to be returned, the share must be promoted to a standard resource share using the RAM [PromoteResourceShareCreatedFromPolicy](https://docs.aws.amazon.com/cli/latest/reference/ram/promote-resource-share-created-from-policy.html) API operation. For more information about sharing backups, see [ Working with shared backups](https://docs.aws.amazon.com/cloudhsm/latest/userguide/sharing.html) in the CloudHSM User Guide.
    public var shared: Swift.Bool?
    /// Designates whether or not to sort the return backups by ascending chronological order of generation.
    public var sortAscending: Swift.Bool?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        shared: Swift.Bool? = nil,
        sortAscending: Swift.Bool? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shared = shared
        self.sortAscending = sortAscending
    }
}

public struct DescribeBackupsOutput {
    /// A list of backups.
    public var backups: [CloudHSMV2ClientTypes.Backup]?
    /// An opaque string that indicates that the response contains only a subset of backups. Use this value in a subsequent DescribeBackups request to get more backups.
    public var nextToken: Swift.String?

    public init(
        backups: [CloudHSMV2ClientTypes.Backup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

public struct DescribeClustersInput {
    /// One or more filters to limit the items returned in the response. Use the clusterIds filter to return only the specified clusters. Specify clusters by their cluster identifier (ID). Use the vpcIds filter to return only the clusters in the specified virtual private clouds (VPCs). Specify VPCs by their VPC identifier (ID). Use the states filter to return only clusters that match the specified state.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of clusters to return in the response. When there are more clusters than the number you specify, the response contains a NextToken value.
    public var maxResults: Swift.Int?
    /// The NextToken value that you received in the previous response. Use this value to get more clusters.
    public var nextToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeClustersOutput {
    /// A list of clusters.
    public var clusters: [CloudHSMV2ClientTypes.Cluster]?
    /// An opaque string that indicates that the response contains only a subset of clusters. Use this value in a subsequent DescribeClusters request to get more clusters.
    public var nextToken: Swift.String?

    public init(
        clusters: [CloudHSMV2ClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

public struct GetResourcePolicyInput {
    /// Amazon Resource Name (ARN) of the resource to which a policy is attached.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput {
    /// The policy attached to a resource.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

public struct InitializeClusterInput {
    /// The identifier (ID) of the cluster that you are claiming. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?
    /// The cluster certificate issued (signed) by your issuing certificate authority (CA). The certificate must be in PEM format and can contain a maximum of 5000 characters.
    /// This member is required.
    public var signedCert: Swift.String?
    /// The issuing certificate of the issuing certificate authority (CA) that issued (signed) the cluster certificate. You must use a self-signed certificate. The certificate used to sign the HSM CSR must be directly available, and thus must be the root certificate. The certificate must be in PEM format and can contain a maximum of 5000 characters.
    /// This member is required.
    public var trustAnchor: Swift.String?

    public init(
        clusterId: Swift.String? = nil,
        signedCert: Swift.String? = nil,
        trustAnchor: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.signedCert = signedCert
        self.trustAnchor = trustAnchor
    }
}

public struct InitializeClusterOutput {
    /// The cluster's state.
    public var state: CloudHSMV2ClientTypes.ClusterState?
    /// A description of the cluster's state.
    public var stateMessage: Swift.String?

    public init(
        state: CloudHSMV2ClientTypes.ClusterState? = nil,
        stateMessage: Swift.String? = nil
    )
    {
        self.state = state
        self.stateMessage = stateMessage
    }
}

public struct ListTagsInput {
    /// The maximum number of tags to return in the response. When there are more tags than the number you specify, the response contains a NextToken value.
    public var maxResults: Swift.Int?
    /// The NextToken value that you received in the previous response. Use this value to get more tags.
    public var nextToken: Swift.String?
    /// The cluster identifier (ID) for the cluster whose tags you are getting. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

public struct ListTagsOutput {
    /// An opaque string that indicates that the response contains only a subset of tags. Use this value in a subsequent ListTags request to get more tags.
    public var nextToken: Swift.String?
    /// A list of tags.
    /// This member is required.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tagList = tagList
    }
}

public struct ModifyBackupAttributesInput {
    /// The identifier (ID) of the backup to modify. To find the ID of a backup, use the [DescribeBackups] operation.
    /// This member is required.
    public var backupId: Swift.String?
    /// Specifies whether the service should exempt a backup from the retention policy for the cluster. True exempts a backup from the retention policy. False means the service applies the backup retention policy defined at the cluster.
    /// This member is required.
    public var neverExpires: Swift.Bool?

    public init(
        backupId: Swift.String? = nil,
        neverExpires: Swift.Bool? = nil
    )
    {
        self.backupId = backupId
        self.neverExpires = neverExpires
    }
}

public struct ModifyBackupAttributesOutput {
    /// Contains information about a backup of an CloudHSM cluster. All backup objects contain the BackupId, BackupState, ClusterId, and CreateTimestamp parameters. Backups that were copied into a destination region additionally contain the CopyTimestamp, SourceBackup, SourceCluster, and SourceRegion parameters. A backup that is pending deletion will include the DeleteTimestamp parameter.
    public var backup: CloudHSMV2ClientTypes.Backup?

    public init(
        backup: CloudHSMV2ClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

public struct ModifyClusterInput {
    /// A policy that defines how the service retains backups.
    /// This member is required.
    public var backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
    /// The identifier (ID) of the cluster that you want to modify. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy? = nil,
        clusterId: Swift.String? = nil
    )
    {
        self.backupRetentionPolicy = backupRetentionPolicy
        self.clusterId = clusterId
    }
}

public struct ModifyClusterOutput {
    /// Contains information about an CloudHSM cluster.
    public var cluster: CloudHSMV2ClientTypes.Cluster?

    public init(
        cluster: CloudHSMV2ClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

public struct PutResourcePolicyInput {
    /// The policy you want to associate with a resource. For an example policy, see [ Working with shared backups](https://docs.aws.amazon.com/cloudhsm/latest/userguide/sharing.html) in the CloudHSM User Guide
    public var policy: Swift.String?
    /// Amazon Resource Name (ARN) of the resource to which you want to attach a policy.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput {
    /// The policy attached to a resource.
    public var policy: Swift.String?
    /// Amazon Resource Name (ARN) of the resource to which a policy is attached.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct RestoreBackupInput {
    /// The ID of the backup to be restored. To find the ID of a backup, use the [DescribeBackups] operation.
    /// This member is required.
    public var backupId: Swift.String?

    public init(
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

public struct RestoreBackupOutput {
    /// Information on the Backup object created.
    public var backup: CloudHSMV2ClientTypes.Backup?

    public init(
        backup: CloudHSMV2ClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

public struct TagResourceInput {
    /// The cluster identifier (ID) for the cluster that you are tagging. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var resourceId: Swift.String?
    /// A list of one or more tags.
    /// This member is required.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagList = tagList
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The cluster identifier (ID) for the cluster whose tags you are removing. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var resourceId: Swift.String?
    /// A list of one or more tag keys for the tags that you are removing. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeyList = tagKeyList
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension CopyBackupToRegionInput {

    static func urlPathProvider(_ value: CopyBackupToRegionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateClusterInput {

    static func urlPathProvider(_ value: CreateClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateHsmInput {

    static func urlPathProvider(_ value: CreateHsmInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBackupInput {

    static func urlPathProvider(_ value: DeleteBackupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteClusterInput {

    static func urlPathProvider(_ value: DeleteClusterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteHsmInput {

    static func urlPathProvider(_ value: DeleteHsmInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBackupsInput {

    static func urlPathProvider(_ value: DescribeBackupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeClustersInput {

    static func urlPathProvider(_ value: DescribeClustersInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension InitializeClusterInput {

    static func urlPathProvider(_ value: InitializeClusterInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyBackupAttributesInput {

    static func urlPathProvider(_ value: ModifyBackupAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyClusterInput {

    static func urlPathProvider(_ value: ModifyClusterInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreBackupInput {

    static func urlPathProvider(_ value: RestoreBackupInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CopyBackupToRegionInput {

    static func write(value: CopyBackupToRegionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
        try writer["DestinationRegion"].write(value.destinationRegion)
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: CloudHSMV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateClusterInput {

    static func write(value: CreateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupRetentionPolicy"].write(value.backupRetentionPolicy, with: CloudHSMV2ClientTypes.BackupRetentionPolicy.write(value:to:))
        try writer["HsmType"].write(value.hsmType)
        try writer["Mode"].write(value.mode)
        try writer["SourceBackupId"].write(value.sourceBackupId)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: CloudHSMV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateHsmInput {

    static func write(value: CreateHsmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["ClusterId"].write(value.clusterId)
        try writer["IpAddress"].write(value.ipAddress)
    }
}

extension DeleteBackupInput {

    static func write(value: DeleteBackupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
    }
}

extension DeleteClusterInput {

    static func write(value: DeleteClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
    }
}

extension DeleteHsmInput {

    static func write(value: DeleteHsmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
        try writer["EniId"].write(value.eniId)
        try writer["EniIp"].write(value.eniIp)
        try writer["HsmId"].write(value.hsmId)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DescribeBackupsInput {

    static func write(value: DescribeBackupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Shared"].write(value.shared)
        try writer["SortAscending"].write(value.sortAscending)
    }
}

extension DescribeClustersInput {

    static func write(value: DescribeClustersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension InitializeClusterInput {

    static func write(value: InitializeClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
        try writer["SignedCert"].write(value.signedCert)
        try writer["TrustAnchor"].write(value.trustAnchor)
    }
}

extension ListTagsInput {

    static func write(value: ListTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension ModifyBackupAttributesInput {

    static func write(value: ModifyBackupAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
        try writer["NeverExpires"].write(value.neverExpires)
    }
}

extension ModifyClusterInput {

    static func write(value: ModifyClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupRetentionPolicy"].write(value.backupRetentionPolicy, with: CloudHSMV2ClientTypes.BackupRetentionPolicy.write(value:to:))
        try writer["ClusterId"].write(value.clusterId)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension RestoreBackupInput {

    static func write(value: RestoreBackupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupId"].write(value.backupId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: CloudHSMV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["TagKeyList"].writeList(value.tagKeyList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CopyBackupToRegionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyBackupToRegionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopyBackupToRegionOutput()
        value.destinationBackup = try reader["DestinationBackup"].readIfPresent(with: CloudHSMV2ClientTypes.DestinationBackup.read(from:))
        return value
    }
}

extension CreateClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: CloudHSMV2ClientTypes.Cluster.read(from:))
        return value
    }
}

extension CreateHsmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateHsmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateHsmOutput()
        value.hsm = try reader["Hsm"].readIfPresent(with: CloudHSMV2ClientTypes.Hsm.read(from:))
        return value
    }
}

extension DeleteBackupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBackupOutput()
        value.backup = try reader["Backup"].readIfPresent(with: CloudHSMV2ClientTypes.Backup.read(from:))
        return value
    }
}

extension DeleteClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: CloudHSMV2ClientTypes.Cluster.read(from:))
        return value
    }
}

extension DeleteHsmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteHsmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteHsmOutput()
        value.hsmId = try reader["HsmId"].readIfPresent()
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension DescribeBackupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBackupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBackupsOutput()
        value.backups = try reader["Backups"].readListIfPresent(memberReadingClosure: CloudHSMV2ClientTypes.Backup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClustersOutput()
        value.clusters = try reader["Clusters"].readListIfPresent(memberReadingClosure: CloudHSMV2ClientTypes.Cluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension InitializeClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InitializeClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InitializeClusterOutput()
        value.state = try reader["State"].readIfPresent()
        value.stateMessage = try reader["StateMessage"].readIfPresent()
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: CloudHSMV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ModifyBackupAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyBackupAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyBackupAttributesOutput()
        value.backup = try reader["Backup"].readIfPresent(with: CloudHSMV2ClientTypes.Backup.read(from:))
        return value
    }
}

extension ModifyClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: CloudHSMV2ClientTypes.Cluster.read(from:))
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension RestoreBackupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreBackupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreBackupOutput()
        value.backup = try reader["Backup"].readIfPresent(with: CloudHSMV2ClientTypes.Backup.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CopyBackupToRegionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateHsmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteHsmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBackupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InitializeClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyBackupAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreBackupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudHsmAccessDeniedException": return try CloudHsmAccessDeniedException.makeError(baseError: baseError)
            case "CloudHsmInternalFailureException": return try CloudHsmInternalFailureException.makeError(baseError: baseError)
            case "CloudHsmInvalidRequestException": return try CloudHsmInvalidRequestException.makeError(baseError: baseError)
            case "CloudHsmResourceNotFoundException": return try CloudHsmResourceNotFoundException.makeError(baseError: baseError)
            case "CloudHsmServiceException": return try CloudHsmServiceException.makeError(baseError: baseError)
            case "CloudHsmTagException": return try CloudHsmTagException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CloudHsmAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudHsmAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = CloudHsmAccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudHsmInvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudHsmInvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = CloudHsmInvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudHsmResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudHsmResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = CloudHsmResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudHsmTagException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudHsmTagException {
        let reader = baseError.errorBodyReader
        var value = CloudHsmTagException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudHsmInternalFailureException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudHsmInternalFailureException {
        let reader = baseError.errorBodyReader
        var value = CloudHsmInternalFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudHsmServiceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudHsmServiceException {
        let reader = baseError.errorBodyReader
        var value = CloudHsmServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudHSMV2ClientTypes.DestinationBackup {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.DestinationBackup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.DestinationBackup()
        value.createTimestamp = try reader["CreateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceRegion = try reader["SourceRegion"].readIfPresent()
        value.sourceBackup = try reader["SourceBackup"].readIfPresent()
        value.sourceCluster = try reader["SourceCluster"].readIfPresent()
        return value
    }
}

extension CloudHSMV2ClientTypes.Cluster {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.Cluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.Cluster()
        value.backupPolicy = try reader["BackupPolicy"].readIfPresent()
        value.backupRetentionPolicy = try reader["BackupRetentionPolicy"].readIfPresent(with: CloudHSMV2ClientTypes.BackupRetentionPolicy.read(from:))
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.createTimestamp = try reader["CreateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hsms = try reader["Hsms"].readListIfPresent(memberReadingClosure: CloudHSMV2ClientTypes.Hsm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.hsmType = try reader["HsmType"].readIfPresent()
        value.preCoPassword = try reader["PreCoPassword"].readIfPresent()
        value.securityGroup = try reader["SecurityGroup"].readIfPresent()
        value.sourceBackupId = try reader["SourceBackupId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.stateMessage = try reader["StateMessage"].readIfPresent()
        value.subnetMapping = try reader["SubnetMapping"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.certificates = try reader["Certificates"].readIfPresent(with: CloudHSMV2ClientTypes.Certificates.read(from:))
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: CloudHSMV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mode = try reader["Mode"].readIfPresent()
        return value
    }
}

extension CloudHSMV2ClientTypes.Tag {

    static func write(value: CloudHSMV2ClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension CloudHSMV2ClientTypes.Certificates {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.Certificates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.Certificates()
        value.clusterCsr = try reader["ClusterCsr"].readIfPresent()
        value.hsmCertificate = try reader["HsmCertificate"].readIfPresent()
        value.awsHardwareCertificate = try reader["AwsHardwareCertificate"].readIfPresent()
        value.manufacturerHardwareCertificate = try reader["ManufacturerHardwareCertificate"].readIfPresent()
        value.clusterCertificate = try reader["ClusterCertificate"].readIfPresent()
        return value
    }
}

extension CloudHSMV2ClientTypes.Hsm {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.Hsm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.Hsm()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.eniId = try reader["EniId"].readIfPresent()
        value.eniIp = try reader["EniIp"].readIfPresent()
        value.hsmId = try reader["HsmId"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent()
        value.stateMessage = try reader["StateMessage"].readIfPresent()
        return value
    }
}

extension CloudHSMV2ClientTypes.BackupRetentionPolicy {

    static func write(value: CloudHSMV2ClientTypes.BackupRetentionPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.BackupRetentionPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.BackupRetentionPolicy()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension CloudHSMV2ClientTypes.Backup {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudHSMV2ClientTypes.Backup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudHSMV2ClientTypes.Backup()
        value.backupId = try reader["BackupId"].readIfPresent() ?? ""
        value.backupArn = try reader["BackupArn"].readIfPresent()
        value.backupState = try reader["BackupState"].readIfPresent()
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.createTimestamp = try reader["CreateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.copyTimestamp = try reader["CopyTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.neverExpires = try reader["NeverExpires"].readIfPresent()
        value.sourceRegion = try reader["SourceRegion"].readIfPresent()
        value.sourceBackup = try reader["SourceBackup"].readIfPresent()
        value.sourceCluster = try reader["SourceCluster"].readIfPresent()
        value.deleteTimestamp = try reader["DeleteTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: CloudHSMV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.hsmType = try reader["HsmType"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        return value
    }
}

public enum CloudHSMV2ClientTypes {}
