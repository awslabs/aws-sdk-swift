// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CloudHSMV2ClientTypes.Backup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case backupState = "BackupState"
        case clusterId = "ClusterId"
        case copyTimestamp = "CopyTimestamp"
        case createTimestamp = "CreateTimestamp"
        case deleteTimestamp = "DeleteTimestamp"
        case neverExpires = "NeverExpires"
        case sourceBackup = "SourceBackup"
        case sourceCluster = "SourceCluster"
        case sourceRegion = "SourceRegion"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupState = self.backupState {
            try encodeContainer.encode(backupState.rawValue, forKey: .backupState)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let copyTimestamp = self.copyTimestamp {
            try encodeContainer.encodeTimestamp(copyTimestamp, format: .epochSeconds, forKey: .copyTimestamp)
        }
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
        if let deleteTimestamp = self.deleteTimestamp {
            try encodeContainer.encodeTimestamp(deleteTimestamp, format: .epochSeconds, forKey: .deleteTimestamp)
        }
        if let neverExpires = self.neverExpires {
            try encodeContainer.encode(neverExpires, forKey: .neverExpires)
        }
        if let sourceBackup = self.sourceBackup {
            try encodeContainer.encode(sourceBackup, forKey: .sourceBackup)
        }
        if let sourceCluster = self.sourceCluster {
            try encodeContainer.encode(sourceCluster, forKey: .sourceCluster)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let backupStateDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.BackupState.self, forKey: .backupState)
        backupState = backupStateDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let copyTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .copyTimestamp)
        copyTimestamp = copyTimestampDecoded
        let neverExpiresDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .neverExpires)
        neverExpires = neverExpiresDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceBackupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackup)
        sourceBackup = sourceBackupDecoded
        let sourceClusterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCluster)
        sourceCluster = sourceClusterDecoded
        let deleteTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deleteTimestamp)
        deleteTimestamp = deleteTimestampDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMV2ClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMV2ClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about a backup of an AWS CloudHSM cluster. All backup objects contain the BackupId, BackupState, ClusterId, and CreateTimestamp parameters. Backups that were copied into a destination region additionally contain the CopyTimestamp, SourceBackup, SourceCluster, and SourceRegion parameters. A backup that is pending deletion will include the DeleteTimestamp parameter.
    public struct Backup: Swift.Equatable {
        /// The identifier (ID) of the backup.
        /// This member is required.
        public var backupId: Swift.String?
        /// The state of the backup.
        public var backupState: CloudHSMV2ClientTypes.BackupState?
        /// The identifier (ID) of the cluster that was backed up.
        public var clusterId: Swift.String?
        /// The date and time when the backup was copied from a source backup.
        public var copyTimestamp: ClientRuntime.Date?
        /// The date and time when the backup was created.
        public var createTimestamp: ClientRuntime.Date?
        /// The date and time when the backup will be permanently deleted.
        public var deleteTimestamp: ClientRuntime.Date?
        /// Specifies whether the service should exempt a backup from the retention policy for the cluster. True exempts a backup from the retention policy. False means the service applies the backup retention policy defined at the cluster.
        public var neverExpires: Swift.Bool?
        /// The identifier (ID) of the source backup from which the new backup was copied.
        public var sourceBackup: Swift.String?
        /// The identifier (ID) of the cluster containing the source backup from which the new backup was copied.
        public var sourceCluster: Swift.String?
        /// The AWS Region that contains the source backup from which the new backup was copied.
        public var sourceRegion: Swift.String?
        /// The list of tags for the backup.
        public var tagList: [CloudHSMV2ClientTypes.Tag]?

        public init(
            backupId: Swift.String? = nil,
            backupState: CloudHSMV2ClientTypes.BackupState? = nil,
            clusterId: Swift.String? = nil,
            copyTimestamp: ClientRuntime.Date? = nil,
            createTimestamp: ClientRuntime.Date? = nil,
            deleteTimestamp: ClientRuntime.Date? = nil,
            neverExpires: Swift.Bool? = nil,
            sourceBackup: Swift.String? = nil,
            sourceCluster: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            tagList: [CloudHSMV2ClientTypes.Tag]? = nil
        )
        {
            self.backupId = backupId
            self.backupState = backupState
            self.clusterId = clusterId
            self.copyTimestamp = copyTimestamp
            self.createTimestamp = createTimestamp
            self.deleteTimestamp = deleteTimestamp
            self.neverExpires = neverExpires
            self.sourceBackup = sourceBackup
            self.sourceCluster = sourceCluster
            self.sourceRegion = sourceRegion
            self.tagList = tagList
        }
    }

}

extension CloudHSMV2ClientTypes {
    public enum BackupPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupPolicy] {
            return [
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupPolicy(rawValue: rawValue) ?? BackupPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudHSMV2ClientTypes.BackupRetentionPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.BackupRetentionType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudHSMV2ClientTypes {
    /// A policy that defines the number of days to retain backups.
    public struct BackupRetentionPolicy: Swift.Equatable {
        /// The type of backup retention policy. For the DAYS type, the value is the number of days to retain backups.
        public var type: CloudHSMV2ClientTypes.BackupRetentionType?
        /// Use a value between 7 - 379.
        public var value: Swift.String?

        public init(
            type: CloudHSMV2ClientTypes.BackupRetentionType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension CloudHSMV2ClientTypes {
    public enum BackupRetentionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupRetentionType] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupRetentionType(rawValue: rawValue) ?? BackupRetentionType.sdkUnknown(rawValue)
        }
    }
}

extension CloudHSMV2ClientTypes {
    public enum BackupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createInProgress
        case deleted
        case pendingDeletion
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupState] {
            return [
                .createInProgress,
                .deleted,
                .pendingDeletion,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupState(rawValue: rawValue) ?? BackupState.sdkUnknown(rawValue)
        }
    }
}

extension CloudHSMV2ClientTypes.Certificates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsHardwareCertificate = "AwsHardwareCertificate"
        case clusterCertificate = "ClusterCertificate"
        case clusterCsr = "ClusterCsr"
        case hsmCertificate = "HsmCertificate"
        case manufacturerHardwareCertificate = "ManufacturerHardwareCertificate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsHardwareCertificate = self.awsHardwareCertificate {
            try encodeContainer.encode(awsHardwareCertificate, forKey: .awsHardwareCertificate)
        }
        if let clusterCertificate = self.clusterCertificate {
            try encodeContainer.encode(clusterCertificate, forKey: .clusterCertificate)
        }
        if let clusterCsr = self.clusterCsr {
            try encodeContainer.encode(clusterCsr, forKey: .clusterCsr)
        }
        if let hsmCertificate = self.hsmCertificate {
            try encodeContainer.encode(hsmCertificate, forKey: .hsmCertificate)
        }
        if let manufacturerHardwareCertificate = self.manufacturerHardwareCertificate {
            try encodeContainer.encode(manufacturerHardwareCertificate, forKey: .manufacturerHardwareCertificate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterCsrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCsr)
        clusterCsr = clusterCsrDecoded
        let hsmCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmCertificate)
        hsmCertificate = hsmCertificateDecoded
        let awsHardwareCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsHardwareCertificate)
        awsHardwareCertificate = awsHardwareCertificateDecoded
        let manufacturerHardwareCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturerHardwareCertificate)
        manufacturerHardwareCertificate = manufacturerHardwareCertificateDecoded
        let clusterCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCertificate)
        clusterCertificate = clusterCertificateDecoded
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains one or more certificates or a certificate signing request (CSR).
    public struct Certificates: Swift.Equatable {
        /// The HSM hardware certificate issued (signed) by AWS CloudHSM.
        public var awsHardwareCertificate: Swift.String?
        /// The cluster certificate issued (signed) by the issuing certificate authority (CA) of the cluster's owner.
        public var clusterCertificate: Swift.String?
        /// The cluster's certificate signing request (CSR). The CSR exists only when the cluster's state is UNINITIALIZED.
        public var clusterCsr: Swift.String?
        /// The HSM certificate issued (signed) by the HSM hardware.
        public var hsmCertificate: Swift.String?
        /// The HSM hardware certificate issued (signed) by the hardware manufacturer.
        public var manufacturerHardwareCertificate: Swift.String?

        public init(
            awsHardwareCertificate: Swift.String? = nil,
            clusterCertificate: Swift.String? = nil,
            clusterCsr: Swift.String? = nil,
            hsmCertificate: Swift.String? = nil,
            manufacturerHardwareCertificate: Swift.String? = nil
        )
        {
            self.awsHardwareCertificate = awsHardwareCertificate
            self.clusterCertificate = clusterCertificate
            self.clusterCsr = clusterCsr
            self.hsmCertificate = hsmCertificate
            self.manufacturerHardwareCertificate = manufacturerHardwareCertificate
        }
    }

}

extension CloudHsmAccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the requester does not have permission to perform the requested operation.
public struct CloudHsmAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmAccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudHsmAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudHsmAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmInternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmInternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because of an AWS CloudHSM internal failure. The request can be retried.
public struct CloudHsmInternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmInternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudHsmInternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudHsmInternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmInvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmInvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it is not a valid request.
public struct CloudHsmInvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmInvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudHsmInvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudHsmInvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it refers to a resource that cannot be found.
public struct CloudHsmResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudHsmResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudHsmResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because an error occurred.
public struct CloudHsmServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmServiceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudHsmServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudHsmServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHsmTagException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudHsmTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because of a tagging failure. Verify the tag conditions in all applicable policies, and then retry the request.
public struct CloudHsmTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudHsmTagException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudHsmTagExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudHsmTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudHSMV2ClientTypes.Cluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case certificates = "Certificates"
        case clusterId = "ClusterId"
        case createTimestamp = "CreateTimestamp"
        case hsmType = "HsmType"
        case hsms = "Hsms"
        case preCoPassword = "PreCoPassword"
        case securityGroup = "SecurityGroup"
        case sourceBackupId = "SourceBackupId"
        case state = "State"
        case stateMessage = "StateMessage"
        case subnetMapping = "SubnetMapping"
        case tagList = "TagList"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPolicy = self.backupPolicy {
            try encodeContainer.encode(backupPolicy.rawValue, forKey: .backupPolicy)
        }
        if let backupRetentionPolicy = self.backupRetentionPolicy {
            try encodeContainer.encode(backupRetentionPolicy, forKey: .backupRetentionPolicy)
        }
        if let certificates = self.certificates {
            try encodeContainer.encode(certificates, forKey: .certificates)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
        if let hsmType = self.hsmType {
            try encodeContainer.encode(hsmType, forKey: .hsmType)
        }
        if let hsms = hsms {
            var hsmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hsms)
            for hsm0 in hsms {
                try hsmsContainer.encode(hsm0)
            }
        }
        if let preCoPassword = self.preCoPassword {
            try encodeContainer.encode(preCoPassword, forKey: .preCoPassword)
        }
        if let securityGroup = self.securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let sourceBackupId = self.sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateMessage = self.stateMessage {
            try encodeContainer.encode(stateMessage, forKey: .stateMessage)
        }
        if let subnetMapping = subnetMapping {
            var subnetMappingContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .subnetMapping)
            for (dictKey0, externalSubnetMapping0) in subnetMapping {
                try subnetMappingContainer.encode(externalSubnetMapping0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
        let backupRetentionPolicyDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.BackupRetentionPolicy.self, forKey: .backupRetentionPolicy)
        backupRetentionPolicy = backupRetentionPolicyDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let hsmsContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Hsm?].self, forKey: .hsms)
        var hsmsDecoded0:[CloudHSMV2ClientTypes.Hsm]? = nil
        if let hsmsContainer = hsmsContainer {
            hsmsDecoded0 = [CloudHSMV2ClientTypes.Hsm]()
            for structure0 in hsmsContainer {
                if let structure0 = structure0 {
                    hsmsDecoded0?.append(structure0)
                }
            }
        }
        hsms = hsmsDecoded0
        let hsmTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let preCoPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preCoPassword)
        preCoPassword = preCoPasswordDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMessage)
        stateMessage = stateMessageDecoded
        let subnetMappingContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .subnetMapping)
        var subnetMappingDecoded0: [Swift.String:Swift.String]? = nil
        if let subnetMappingContainer = subnetMappingContainer {
            subnetMappingDecoded0 = [Swift.String:Swift.String]()
            for (key0, subnetid0) in subnetMappingContainer {
                if let subnetid0 = subnetid0 {
                    subnetMappingDecoded0?[key0] = subnetid0
                }
            }
        }
        subnetMapping = subnetMappingDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let certificatesDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Certificates.self, forKey: .certificates)
        certificates = certificatesDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMV2ClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMV2ClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about an AWS CloudHSM cluster.
    public struct Cluster: Swift.Equatable {
        /// The cluster's backup policy.
        public var backupPolicy: CloudHSMV2ClientTypes.BackupPolicy?
        /// A policy that defines how the service retains backups.
        public var backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
        /// Contains one or more certificates or a certificate signing request (CSR).
        public var certificates: CloudHSMV2ClientTypes.Certificates?
        /// The cluster's identifier (ID).
        public var clusterId: Swift.String?
        /// The date and time when the cluster was created.
        public var createTimestamp: ClientRuntime.Date?
        /// The type of HSM that the cluster contains.
        public var hsmType: Swift.String?
        /// Contains information about the HSMs in the cluster.
        public var hsms: [CloudHSMV2ClientTypes.Hsm]?
        /// The default password for the cluster's Pre-Crypto Officer (PRECO) user.
        public var preCoPassword: Swift.String?
        /// The identifier (ID) of the cluster's security group.
        public var securityGroup: Swift.String?
        /// The identifier (ID) of the backup used to create the cluster. This value exists only when the cluster was created from a backup.
        public var sourceBackupId: Swift.String?
        /// The cluster's state.
        public var state: CloudHSMV2ClientTypes.ClusterState?
        /// A description of the cluster's state.
        public var stateMessage: Swift.String?
        /// A map from availability zone to the clusterâ€™s subnet in that availability zone.
        public var subnetMapping: [Swift.String:Swift.String]?
        /// The list of tags for the cluster.
        public var tagList: [CloudHSMV2ClientTypes.Tag]?
        /// The identifier (ID) of the virtual private cloud (VPC) that contains the cluster.
        public var vpcId: Swift.String?

        public init(
            backupPolicy: CloudHSMV2ClientTypes.BackupPolicy? = nil,
            backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy? = nil,
            certificates: CloudHSMV2ClientTypes.Certificates? = nil,
            clusterId: Swift.String? = nil,
            createTimestamp: ClientRuntime.Date? = nil,
            hsmType: Swift.String? = nil,
            hsms: [CloudHSMV2ClientTypes.Hsm]? = nil,
            preCoPassword: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            sourceBackupId: Swift.String? = nil,
            state: CloudHSMV2ClientTypes.ClusterState? = nil,
            stateMessage: Swift.String? = nil,
            subnetMapping: [Swift.String:Swift.String]? = nil,
            tagList: [CloudHSMV2ClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.backupPolicy = backupPolicy
            self.backupRetentionPolicy = backupRetentionPolicy
            self.certificates = certificates
            self.clusterId = clusterId
            self.createTimestamp = createTimestamp
            self.hsmType = hsmType
            self.hsms = hsms
            self.preCoPassword = preCoPassword
            self.securityGroup = securityGroup
            self.sourceBackupId = sourceBackupId
            self.state = state
            self.stateMessage = stateMessage
            self.subnetMapping = subnetMapping
            self.tagList = tagList
            self.vpcId = vpcId
        }
    }

}

extension CloudHSMV2ClientTypes {
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createInProgress
        case degraded
        case deleted
        case deleteInProgress
        case initialized
        case initializeInProgress
        case uninitialized
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .active,
                .createInProgress,
                .degraded,
                .deleted,
                .deleteInProgress,
                .initialized,
                .initializeInProgress,
                .uninitialized,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .degraded: return "DEGRADED"
            case .deleted: return "DELETED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .initialized: return "INITIALIZED"
            case .initializeInProgress: return "INITIALIZE_IN_PROGRESS"
            case .uninitialized: return "UNINITIALIZED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
        }
    }
}

extension CopyBackupToRegionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case destinationRegion = "DestinationRegion"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension CopyBackupToRegionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyBackupToRegionInput: Swift.Equatable {
    /// The ID of the backup that will be copied to the destination region.
    /// This member is required.
    public var backupId: Swift.String?
    /// The AWS region that will contain your copied CloudHSM cluster backup.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// Tags to apply to the destination backup during creation. If you specify tags, only these tags will be applied to the destination backup. If you do not specify tags, the service copies tags from the source backup to the destination backup.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        backupId: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.backupId = backupId
        self.destinationRegion = destinationRegion
        self.tagList = tagList
    }
}

struct CopyBackupToRegionInputBody: Swift.Equatable {
    let destinationRegion: Swift.String?
    let backupId: Swift.String?
    let tagList: [CloudHSMV2ClientTypes.Tag]?
}

extension CopyBackupToRegionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case destinationRegion = "DestinationRegion"
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMV2ClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMV2ClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension CopyBackupToRegionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyBackupToRegionOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationBackup = output.destinationBackup
        } else {
            self.destinationBackup = nil
        }
    }
}

public struct CopyBackupToRegionOutput: Swift.Equatable {
    /// Information on the backup that will be copied to the destination region, including CreateTimestamp, SourceBackup, SourceCluster, and Source Region. CreateTimestamp of the destination backup will be the same as that of the source backup. You will need to use the sourceBackupID returned in this operation to use the [DescribeBackups] operation on the backup that will be copied to the destination region.
    public var destinationBackup: CloudHSMV2ClientTypes.DestinationBackup?

    public init(
        destinationBackup: CloudHSMV2ClientTypes.DestinationBackup? = nil
    )
    {
        self.destinationBackup = destinationBackup
    }
}

struct CopyBackupToRegionOutputBody: Swift.Equatable {
    let destinationBackup: CloudHSMV2ClientTypes.DestinationBackup?
}

extension CopyBackupToRegionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackup = "DestinationBackup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationBackupDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.DestinationBackup.self, forKey: .destinationBackup)
        destinationBackup = destinationBackupDecoded
    }
}

enum CopyBackupToRegionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case hsmType = "HsmType"
        case sourceBackupId = "SourceBackupId"
        case subnetIds = "SubnetIds"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionPolicy = self.backupRetentionPolicy {
            try encodeContainer.encode(backupRetentionPolicy, forKey: .backupRetentionPolicy)
        }
        if let hsmType = self.hsmType {
            try encodeContainer.encode(hsmType, forKey: .hsmType)
        }
        if let sourceBackupId = self.sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// A policy that defines how the service retains backups.
    public var backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
    /// The type of HSM to use in the cluster. Currently the only allowed value is hsm1.medium.
    /// This member is required.
    public var hsmType: Swift.String?
    /// The identifier (ID) of the cluster backup to restore. Use this value to restore the cluster from a backup instead of creating a new cluster. To find the backup ID, use [DescribeBackups].
    public var sourceBackupId: Swift.String?
    /// The identifiers (IDs) of the subnets where you are creating the cluster. You must specify at least one subnet. If you specify multiple subnets, they must meet the following criteria:
    ///
    /// * All subnets must be in the same virtual private cloud (VPC).
    ///
    /// * You can specify only one subnet per Availability Zone.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Tags to apply to the CloudHSM cluster during creation.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy? = nil,
        hsmType: Swift.String? = nil,
        sourceBackupId: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.backupRetentionPolicy = backupRetentionPolicy
        self.hsmType = hsmType
        self.sourceBackupId = sourceBackupId
        self.subnetIds = subnetIds
        self.tagList = tagList
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
    let hsmType: Swift.String?
    let sourceBackupId: Swift.String?
    let subnetIds: [Swift.String]?
    let tagList: [CloudHSMV2ClientTypes.Tag]?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case hsmType = "HsmType"
        case sourceBackupId = "SourceBackupId"
        case subnetIds = "SubnetIds"
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupRetentionPolicyDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.BackupRetentionPolicy.self, forKey: .backupRetentionPolicy)
        backupRetentionPolicy = backupRetentionPolicyDecoded
        let hsmTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMV2ClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMV2ClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension CreateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutput: Swift.Equatable {
    /// Information about the cluster that was created.
    public var cluster: CloudHSMV2ClientTypes.Cluster?

    public init(
        cluster: CloudHSMV2ClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputBody: Swift.Equatable {
    let cluster: CloudHSMV2ClientTypes.Cluster?
}

extension CreateClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum CreateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clusterId = "ClusterId"
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }
}

extension CreateHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateHsmInput: Swift.Equatable {
    /// The Availability Zone where you are creating the HSM. To find the cluster's Availability Zones, use [DescribeClusters].
    /// This member is required.
    public var availabilityZone: Swift.String?
    /// The identifier (ID) of the HSM's cluster. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?
    /// The HSM's IP address. If you specify an IP address, use an available address from the subnet that maps to the Availability Zone where you are creating the HSM. If you don't specify an IP address, one is chosen for you from that subnet.
    public var ipAddress: Swift.String?

    public init(
        availabilityZone: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        ipAddress: Swift.String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.clusterId = clusterId
        self.ipAddress = ipAddress
    }
}

struct CreateHsmInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let availabilityZone: Swift.String?
    let ipAddress: Swift.String?
}

extension CreateHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clusterId = "ClusterId"
        case ipAddress = "IpAddress"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension CreateHsmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateHsmOutputBody = try responseDecoder.decode(responseBody: data)
            self.hsm = output.hsm
        } else {
            self.hsm = nil
        }
    }
}

public struct CreateHsmOutput: Swift.Equatable {
    /// Information about the HSM that was created.
    public var hsm: CloudHSMV2ClientTypes.Hsm?

    public init(
        hsm: CloudHSMV2ClientTypes.Hsm? = nil
    )
    {
        self.hsm = hsm
    }
}

struct CreateHsmOutputBody: Swift.Equatable {
    let hsm: CloudHSMV2ClientTypes.Hsm?
}

extension CreateHsmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsm = "Hsm"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Hsm.self, forKey: .hsm)
        hsm = hsmDecoded
    }
}

enum CreateHsmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

extension DeleteBackupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBackupInput: Swift.Equatable {
    /// The ID of the backup to be deleted. To find the ID of a backup, use the [DescribeBackups] operation.
    /// This member is required.
    public var backupId: Swift.String?

    public init(
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct DeleteBackupInputBody: Swift.Equatable {
    let backupId: Swift.String?
}

extension DeleteBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension DeleteBackupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackupOutputBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct DeleteBackupOutput: Swift.Equatable {
    /// Information on the Backup object deleted.
    public var backup: CloudHSMV2ClientTypes.Backup?

    public init(
        backup: CloudHSMV2ClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct DeleteBackupOutputBody: Swift.Equatable {
    let backup: CloudHSMV2ClientTypes.Backup?
}

extension DeleteBackupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

enum DeleteBackupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

extension DeleteClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The identifier (ID) of the cluster that you are deleting. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
}

extension DeleteClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension DeleteClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutput: Swift.Equatable {
    /// Information about the cluster that was deleted.
    public var cluster: CloudHSMV2ClientTypes.Cluster?

    public init(
        cluster: CloudHSMV2ClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputBody: Swift.Equatable {
    let cluster: CloudHSMV2ClientTypes.Cluster?
}

extension DeleteClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum DeleteClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHsmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmId = "HsmId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let eniId = self.eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniIp = self.eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let hsmId = self.hsmId {
            try encodeContainer.encode(hsmId, forKey: .hsmId)
        }
    }
}

extension DeleteHsmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteHsmInput: Swift.Equatable {
    /// The identifier (ID) of the cluster that contains the HSM that you are deleting.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The identifier (ID) of the elastic network interface (ENI) of the HSM that you are deleting.
    public var eniId: Swift.String?
    /// The IP address of the elastic network interface (ENI) of the HSM that you are deleting.
    public var eniIp: Swift.String?
    /// The identifier (ID) of the HSM that you are deleting.
    public var hsmId: Swift.String?

    public init(
        clusterId: Swift.String? = nil,
        eniId: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        hsmId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmId = hsmId
    }
}

struct DeleteHsmInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let hsmId: Swift.String?
    let eniId: Swift.String?
    let eniIp: Swift.String?
}

extension DeleteHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmId = "HsmId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let hsmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmId)
        hsmId = hsmIdDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
    }
}

extension DeleteHsmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteHsmOutputBody = try responseDecoder.decode(responseBody: data)
            self.hsmId = output.hsmId
        } else {
            self.hsmId = nil
        }
    }
}

public struct DeleteHsmOutput: Swift.Equatable {
    /// The identifier (ID) of the HSM that was deleted.
    public var hsmId: Swift.String?

    public init(
        hsmId: Swift.String? = nil
    )
    {
        self.hsmId = hsmId
    }
}

struct DeleteHsmOutputBody: Swift.Equatable {
    let hsmId: Swift.String?
}

extension DeleteHsmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmId = "HsmId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmId)
        hsmId = hsmIdDecoded
    }
}

enum DeleteHsmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBackupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortAscending = "SortAscending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, filters0) in filters {
                var filters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in filters0 {
                    try filters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortAscending = self.sortAscending {
            try encodeContainer.encode(sortAscending, forKey: .sortAscending)
        }
    }
}

extension DescribeBackupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBackupsInput: Swift.Equatable {
    /// One or more filters to limit the items returned in the response. Use the backupIds filter to return only the specified backups. Specify backups by their backup identifier (ID). Use the sourceBackupIds filter to return only the backups created from a source backup. The sourceBackupID of a source backup is returned by the [CopyBackupToRegion] operation. Use the clusterIds filter to return only the backups for the specified clusters. Specify clusters by their cluster identifier (ID). Use the states filter to return only backups that match the specified state. Use the neverExpires filter to return backups filtered by the value in the neverExpires parameter. True returns all backups exempt from the backup retention policy. False returns all backups with a backup retention policy defined at the cluster.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of backups to return in the response. When there are more backups than the number you specify, the response contains a NextToken value.
    public var maxResults: Swift.Int?
    /// The NextToken value that you received in the previous response. Use this value to get more backups.
    public var nextToken: Swift.String?
    /// Designates whether or not to sort the return backups by ascending chronological order of generation.
    public var sortAscending: Swift.Bool?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortAscending: Swift.Bool? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortAscending = sortAscending
    }
}

struct DescribeBackupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [Swift.String:[Swift.String]]?
    let sortAscending: Swift.Bool?
}

extension DescribeBackupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortAscending = "SortAscending"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, strings0) in filtersContainer {
                var strings0Decoded0: [Swift.String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [Swift.String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = strings0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortAscendingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortAscending)
        sortAscending = sortAscendingDecoded
    }
}

extension DescribeBackupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBackupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBackupsOutput: Swift.Equatable {
    /// A list of backups.
    public var backups: [CloudHSMV2ClientTypes.Backup]?
    /// An opaque string that indicates that the response contains only a subset of backups. Use this value in a subsequent DescribeBackups request to get more backups.
    public var nextToken: Swift.String?

    public init(
        backups: [CloudHSMV2ClientTypes.Backup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputBody: Swift.Equatable {
    let backups: [CloudHSMV2ClientTypes.Backup]?
    let nextToken: Swift.String?
}

extension DescribeBackupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Backup?].self, forKey: .backups)
        var backupsDecoded0:[CloudHSMV2ClientTypes.Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [CloudHSMV2ClientTypes.Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBackupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClustersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, filters0) in filters {
                var filters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in filters0 {
                    try filters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClustersInput: Swift.Equatable {
    /// One or more filters to limit the items returned in the response. Use the clusterIds filter to return only the specified clusters. Specify clusters by their cluster identifier (ID). Use the vpcIds filter to return only the clusters in the specified virtual private clouds (VPCs). Specify VPCs by their VPC identifier (ID). Use the states filter to return only clusters that match the specified state.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of clusters to return in the response. When there are more clusters than the number you specify, the response contains a NextToken value.
    public var maxResults: Swift.Int?
    /// The NextToken value that you received in the previous response. Use this value to get more clusters.
    public var nextToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeClustersInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, strings0) in filtersContainer {
                var strings0Decoded0: [Swift.String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [Swift.String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = strings0Decoded0
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutput: Swift.Equatable {
    /// A list of clusters.
    public var clusters: [CloudHSMV2ClientTypes.Cluster]?
    /// An opaque string that indicates that the response contains only a subset of clusters. Use this value in a subsequent DescribeClusters request to get more clusters.
    public var nextToken: Swift.String?

    public init(
        clusters: [CloudHSMV2ClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputBody: Swift.Equatable {
    let clusters: [CloudHSMV2ClientTypes.Cluster]?
    let nextToken: Swift.String?
}

extension DescribeClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clustersContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[CloudHSMV2ClientTypes.Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [CloudHSMV2ClientTypes.Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudHSMV2ClientTypes.DestinationBackup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTimestamp = "CreateTimestamp"
        case sourceBackup = "SourceBackup"
        case sourceCluster = "SourceCluster"
        case sourceRegion = "SourceRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
        if let sourceBackup = self.sourceBackup {
            try encodeContainer.encode(sourceBackup, forKey: .sourceBackup)
        }
        if let sourceCluster = self.sourceCluster {
            try encodeContainer.encode(sourceCluster, forKey: .sourceCluster)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceBackupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackup)
        sourceBackup = sourceBackupDecoded
        let sourceClusterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCluster)
        sourceCluster = sourceClusterDecoded
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about the backup that will be copied and created by the [CopyBackupToRegion] operation.
    public struct DestinationBackup: Swift.Equatable {
        /// The date and time when both the source backup was created.
        public var createTimestamp: ClientRuntime.Date?
        /// The identifier (ID) of the source backup from which the new backup was copied.
        public var sourceBackup: Swift.String?
        /// The identifier (ID) of the cluster containing the source backup from which the new backup was copied.
        public var sourceCluster: Swift.String?
        /// The AWS region that contains the source backup from which the new backup was copied.
        public var sourceRegion: Swift.String?

        public init(
            createTimestamp: ClientRuntime.Date? = nil,
            sourceBackup: Swift.String? = nil,
            sourceCluster: Swift.String? = nil,
            sourceRegion: Swift.String? = nil
        )
        {
            self.createTimestamp = createTimestamp
            self.sourceBackup = sourceBackup
            self.sourceCluster = sourceCluster
            self.sourceRegion = sourceRegion
        }
    }

}

extension CloudHSMV2ClientTypes.Hsm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clusterId = "ClusterId"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmId = "HsmId"
        case state = "State"
        case stateMessage = "StateMessage"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let eniId = self.eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniIp = self.eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let hsmId = self.hsmId {
            try encodeContainer.encode(hsmId, forKey: .hsmId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateMessage = self.stateMessage {
            try encodeContainer.encode(stateMessage, forKey: .stateMessage)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let hsmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmId)
        hsmId = hsmIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.HsmState.self, forKey: .state)
        state = stateDecoded
        let stateMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMessage)
        stateMessage = stateMessageDecoded
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains information about a hardware security module (HSM) in an AWS CloudHSM cluster.
    public struct Hsm: Swift.Equatable {
        /// The Availability Zone that contains the HSM.
        public var availabilityZone: Swift.String?
        /// The identifier (ID) of the cluster that contains the HSM.
        public var clusterId: Swift.String?
        /// The identifier (ID) of the HSM's elastic network interface (ENI).
        public var eniId: Swift.String?
        /// The IP address of the HSM's elastic network interface (ENI).
        public var eniIp: Swift.String?
        /// The HSM's identifier (ID).
        /// This member is required.
        public var hsmId: Swift.String?
        /// The HSM's state.
        public var state: CloudHSMV2ClientTypes.HsmState?
        /// A description of the HSM's state.
        public var stateMessage: Swift.String?
        /// The subnet that contains the HSM's elastic network interface (ENI).
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            eniId: Swift.String? = nil,
            eniIp: Swift.String? = nil,
            hsmId: Swift.String? = nil,
            state: CloudHSMV2ClientTypes.HsmState? = nil,
            stateMessage: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.clusterId = clusterId
            self.eniId = eniId
            self.eniIp = eniIp
            self.hsmId = hsmId
            self.state = state
            self.stateMessage = stateMessage
            self.subnetId = subnetId
        }
    }

}

extension CloudHSMV2ClientTypes {
    public enum HsmState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createInProgress
        case degraded
        case deleted
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [HsmState] {
            return [
                .active,
                .createInProgress,
                .degraded,
                .deleted,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .degraded: return "DEGRADED"
            case .deleted: return "DELETED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HsmState(rawValue: rawValue) ?? HsmState.sdkUnknown(rawValue)
        }
    }
}

extension InitializeClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case signedCert = "SignedCert"
        case trustAnchor = "TrustAnchor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let signedCert = self.signedCert {
            try encodeContainer.encode(signedCert, forKey: .signedCert)
        }
        if let trustAnchor = self.trustAnchor {
            try encodeContainer.encode(trustAnchor, forKey: .trustAnchor)
        }
    }
}

extension InitializeClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InitializeClusterInput: Swift.Equatable {
    /// The identifier (ID) of the cluster that you are claiming. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?
    /// The cluster certificate issued (signed) by your issuing certificate authority (CA). The certificate must be in PEM format and can contain a maximum of 5000 characters.
    /// This member is required.
    public var signedCert: Swift.String?
    /// The issuing certificate of the issuing certificate authority (CA) that issued (signed) the cluster certificate. You must use a self-signed certificate. The certificate used to sign the HSM CSR must be directly available, and thus must be the root certificate. The certificate must be in PEM format and can contain a maximum of 5000 characters.
    /// This member is required.
    public var trustAnchor: Swift.String?

    public init(
        clusterId: Swift.String? = nil,
        signedCert: Swift.String? = nil,
        trustAnchor: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.signedCert = signedCert
        self.trustAnchor = trustAnchor
    }
}

struct InitializeClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let signedCert: Swift.String?
    let trustAnchor: Swift.String?
}

extension InitializeClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case signedCert = "SignedCert"
        case trustAnchor = "TrustAnchor"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let signedCertDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedCert)
        signedCert = signedCertDecoded
        let trustAnchorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

extension InitializeClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InitializeClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.stateMessage = output.stateMessage
        } else {
            self.state = nil
            self.stateMessage = nil
        }
    }
}

public struct InitializeClusterOutput: Swift.Equatable {
    /// The cluster's state.
    public var state: CloudHSMV2ClientTypes.ClusterState?
    /// A description of the cluster's state.
    public var stateMessage: Swift.String?

    public init(
        state: CloudHSMV2ClientTypes.ClusterState? = nil,
        stateMessage: Swift.String? = nil
    )
    {
        self.state = state
        self.stateMessage = stateMessage
    }
}

struct InitializeClusterOutputBody: Swift.Equatable {
    let state: CloudHSMV2ClientTypes.ClusterState?
    let stateMessage: Swift.String?
}

extension InitializeClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
        case stateMessage = "StateMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMessage)
        stateMessage = stateMessageDecoded
    }
}

enum InitializeClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The maximum number of tags to return in the response. When there are more tags than the number you specify, the response contains a NextToken value.
    public var maxResults: Swift.Int?
    /// The NextToken value that you received in the previous response. Use this value to get more tags.
    public var nextToken: Swift.String?
    /// The cluster identifier (ID) for the cluster whose tags you are getting. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tagList = output.tagList
        } else {
            self.nextToken = nil
            self.tagList = nil
        }
    }
}

public struct ListTagsOutput: Swift.Equatable {
    /// An opaque string that indicates that the response contains only a subset of tags. Use this value in a subsequent ListTags request to get more tags.
    public var nextToken: Swift.String?
    /// A list of tags.
    /// This member is required.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tagList = tagList
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let tagList: [CloudHSMV2ClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMV2ClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMV2ClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyBackupAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case neverExpires = "NeverExpires"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let neverExpires = self.neverExpires {
            try encodeContainer.encode(neverExpires, forKey: .neverExpires)
        }
    }
}

extension ModifyBackupAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyBackupAttributesInput: Swift.Equatable {
    /// The identifier (ID) of the backup to modify. To find the ID of a backup, use the [DescribeBackups] operation.
    /// This member is required.
    public var backupId: Swift.String?
    /// Specifies whether the service should exempt a backup from the retention policy for the cluster. True exempts a backup from the retention policy. False means the service applies the backup retention policy defined at the cluster.
    /// This member is required.
    public var neverExpires: Swift.Bool?

    public init(
        backupId: Swift.String? = nil,
        neverExpires: Swift.Bool? = nil
    )
    {
        self.backupId = backupId
        self.neverExpires = neverExpires
    }
}

struct ModifyBackupAttributesInputBody: Swift.Equatable {
    let backupId: Swift.String?
    let neverExpires: Swift.Bool?
}

extension ModifyBackupAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case neverExpires = "NeverExpires"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let neverExpiresDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .neverExpires)
        neverExpires = neverExpiresDecoded
    }
}

extension ModifyBackupAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyBackupAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct ModifyBackupAttributesOutput: Swift.Equatable {
    /// Contains information about a backup of an AWS CloudHSM cluster. All backup objects contain the BackupId, BackupState, ClusterId, and CreateTimestamp parameters. Backups that were copied into a destination region additionally contain the CopyTimestamp, SourceBackup, SourceCluster, and SourceRegion parameters. A backup that is pending deletion will include the DeleteTimestamp parameter.
    public var backup: CloudHSMV2ClientTypes.Backup?

    public init(
        backup: CloudHSMV2ClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct ModifyBackupAttributesOutputBody: Swift.Equatable {
    let backup: CloudHSMV2ClientTypes.Backup?
}

extension ModifyBackupAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

enum ModifyBackupAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionPolicy = self.backupRetentionPolicy {
            try encodeContainer.encode(backupRetentionPolicy, forKey: .backupRetentionPolicy)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

extension ModifyClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyClusterInput: Swift.Equatable {
    /// A policy that defines how the service retains backups.
    /// This member is required.
    public var backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
    /// The identifier (ID) of the cluster that you want to modify. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy? = nil,
        clusterId: Swift.String? = nil
    )
    {
        self.backupRetentionPolicy = backupRetentionPolicy
        self.clusterId = clusterId
    }
}

struct ModifyClusterInputBody: Swift.Equatable {
    let backupRetentionPolicy: CloudHSMV2ClientTypes.BackupRetentionPolicy?
    let clusterId: Swift.String?
}

extension ModifyClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionPolicy = "BackupRetentionPolicy"
        case clusterId = "ClusterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupRetentionPolicyDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.BackupRetentionPolicy.self, forKey: .backupRetentionPolicy)
        backupRetentionPolicy = backupRetentionPolicyDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension ModifyClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct ModifyClusterOutput: Swift.Equatable {
    /// Contains information about an AWS CloudHSM cluster.
    public var cluster: CloudHSMV2ClientTypes.Cluster?

    public init(
        cluster: CloudHSMV2ClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct ModifyClusterOutputBody: Swift.Equatable {
    let cluster: CloudHSMV2ClientTypes.Cluster?
}

extension ModifyClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum ModifyClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreBackupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

extension RestoreBackupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreBackupInput: Swift.Equatable {
    /// The ID of the backup to be restored. To find the ID of a backup, use the [DescribeBackups] operation.
    /// This member is required.
    public var backupId: Swift.String?

    public init(
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct RestoreBackupInputBody: Swift.Equatable {
    let backupId: Swift.String?
}

extension RestoreBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension RestoreBackupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreBackupOutputBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct RestoreBackupOutput: Swift.Equatable {
    /// Information on the Backup object created.
    public var backup: CloudHSMV2ClientTypes.Backup?

    public init(
        backup: CloudHSMV2ClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct RestoreBackupOutputBody: Swift.Equatable {
    let backup: CloudHSMV2ClientTypes.Backup?
}

extension RestoreBackupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(CloudHSMV2ClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

enum RestoreBackupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudHSMV2ClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudHSMV2ClientTypes {
    /// Contains a tag. A tag is a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The cluster identifier (ID) for the cluster that you are tagging. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var resourceId: Swift.String?
    /// A list of one or more tags.
    /// This member is required.
    public var tagList: [CloudHSMV2ClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tagList: [CloudHSMV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagList = tagList
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagList: [CloudHSMV2ClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHSMV2ClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHSMV2ClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHSMV2ClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The cluster identifier (ID) for the cluster whose tags you are removing. To find the cluster ID, use [DescribeClusters].
    /// This member is required.
    public var resourceId: Swift.String?
    /// A list of one or more tag keys for the tags that you are removing. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeyList = "TagKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudHsmAccessDeniedException": return try await CloudHsmAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInternalFailureException": return try await CloudHsmInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmInvalidRequestException": return try await CloudHsmInvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmResourceNotFoundException": return try await CloudHsmResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmServiceException": return try await CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudHsmTagException": return try await CloudHsmTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
