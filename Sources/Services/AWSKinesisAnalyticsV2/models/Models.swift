// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddApplicationCloudWatchLoggingOptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOption = self.cloudWatchLoggingOption {
            try encodeContainer.encode(cloudWatchLoggingOption, forKey: .cloudWatchLoggingOption)
        }
        if let conditionalToken = self.conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

extension AddApplicationCloudWatchLoggingOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationCloudWatchLoggingOptionInput: Swift.Equatable {
    /// The Kinesis Data Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN).
    /// This member is required.
    public var cloudWatchLoggingOption: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The version ID of the Kinesis Data Analytics application. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOption: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOption = cloudWatchLoggingOption
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct AddApplicationCloudWatchLoggingOptionInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let cloudWatchLoggingOption: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption?
    let conditionalToken: Swift.String?
}

extension AddApplicationCloudWatchLoggingOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption.self, forKey: .cloudWatchLoggingOption)
        cloudWatchLoggingOption = cloudWatchLoggingOptionDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationCloudWatchLoggingOptionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationCloudWatchLoggingOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddApplicationCloudWatchLoggingOptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = output.cloudWatchLoggingOptionDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.cloudWatchLoggingOptionDescriptions = nil
        }
    }
}

public struct AddApplicationCloudWatchLoggingOptionOutputResponse: Swift.Equatable {
    /// The application's ARN.
    public var applicationARN: Swift.String?
    /// The new version ID of the Kinesis Data Analytics application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
    public var applicationVersionId: Swift.Int?
    /// The descriptions of the current CloudWatch logging options for the Kinesis Data Analytics application.
    public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
    }
}

struct AddApplicationCloudWatchLoggingOptionOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?
}

extension AddApplicationCloudWatchLoggingOptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
    }
}

extension AddApplicationInputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
    }
}

extension AddApplicationInputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationInputInput: Swift.Equatable {
    /// The name of your existing application to which you want to add the streaming source.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current version of your application. You must provide the ApplicationVersionID or the ConditionalToken.You can use the [DescribeApplication] operation to find the current application version.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The [Input] to add.
    /// This member is required.
    public var input: KinesisAnalyticsV2ClientTypes.Input?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        input: KinesisAnalyticsV2ClientTypes.Input? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.input = input
    }
}

struct AddApplicationInputInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let input: KinesisAnalyticsV2ClientTypes.Input?
}

extension AddApplicationInputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension AddApplicationInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationInputOutputError: Swift.Error, Swift.Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddApplicationInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.inputDescriptions = output.inputDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.inputDescriptions = nil
        }
    }
}

public struct AddApplicationInputOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// Provides the current application version.
    public var applicationVersionId: Swift.Int?
    /// Describes the application input configuration.
    public var inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.inputDescriptions = inputDescriptions
    }
}

struct AddApplicationInputOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]?
}

extension AddApplicationInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case inputDescriptions = "InputDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let inputDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.InputDescription?].self, forKey: .inputDescriptions)
        var inputDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.InputDescription]? = nil
        if let inputDescriptionsContainer = inputDescriptionsContainer {
            inputDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.InputDescription]()
            for structure0 in inputDescriptionsContainer {
                if let structure0 = structure0 {
                    inputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        inputDescriptions = inputDescriptionsDecoded0
    }
}

extension AddApplicationInputProcessingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputProcessingConfiguration = self.inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
    }
}

extension AddApplicationInputProcessingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationInputProcessingConfigurationInput: Swift.Equatable {
    /// The name of the application to which you want to add the input processing configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version of the application to which you want to add the input processing configuration. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration to add the input processing configuration to. You can get a list of the input IDs for an application using the [DescribeApplication] operation.
    /// This member is required.
    public var inputId: Swift.String?
    /// The [InputProcessingConfiguration] to add to the application.
    /// This member is required.
    public var inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil,
        inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
        self.inputProcessingConfiguration = inputProcessingConfiguration
    }
}

struct AddApplicationInputProcessingConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let inputId: Swift.String?
    let inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?
}

extension AddApplicationInputProcessingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension AddApplicationInputProcessingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputProcessingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationInputProcessingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputProcessingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddApplicationInputProcessingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.inputId = output.inputId
            self.inputProcessingConfigurationDescription = output.inputProcessingConfigurationDescription
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.inputId = nil
            self.inputProcessingConfigurationDescription = nil
        }
    }
}

public struct AddApplicationInputProcessingConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// Provides the current application version.
    public var applicationVersionId: Swift.Int?
    /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input configuration that you add to your application.
    public var inputId: Swift.String?
    /// The description of the preprocessor that executes on records in this input before the application's code is run.
    public var inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil,
        inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.inputId = inputId
        self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
    }
}

struct AddApplicationInputProcessingConfigurationOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let inputId: Swift.String?
    let inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription?
}

extension AddApplicationInputProcessingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputProcessingConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription.self, forKey: .inputProcessingConfigurationDescription)
        inputProcessingConfigurationDescription = inputProcessingConfigurationDescriptionDecoded
    }
}

extension AddApplicationOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let output = self.output {
            try encodeContainer.encode(output, forKey: .output)
        }
    }
}

extension AddApplicationOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationOutputInput: Swift.Equatable {
    /// The name of the application to which you want to add the output configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version of the application to which you want to add the output configuration. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// An array of objects, each describing one output configuration. In the output configuration, you specify the name of an in-application stream, a destination (that is, a Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and record the formation to use when writing to the destination.
    /// This member is required.
    public var output: KinesisAnalyticsV2ClientTypes.Output?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        output: KinesisAnalyticsV2ClientTypes.Output? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.output = output
    }
}

struct AddApplicationOutputInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let output: KinesisAnalyticsV2ClientTypes.Output?
}

extension AddApplicationOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.Output.self, forKey: .output)
        output = outputDecoded
    }
}

extension AddApplicationOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationOutputOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddApplicationOutputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.outputDescriptions = output.outputDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.outputDescriptions = nil
        }
    }
}

public struct AddApplicationOutputOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
    public var applicationVersionId: Swift.Int?
    /// Describes the application output configuration. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
    public var outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.outputDescriptions = outputDescriptions
    }
}

struct AddApplicationOutputOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]?
}

extension AddApplicationOutputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case outputDescriptions = "OutputDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let outputDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.OutputDescription?].self, forKey: .outputDescriptions)
        var outputDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.OutputDescription]? = nil
        if let outputDescriptionsContainer = outputDescriptionsContainer {
            outputDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.OutputDescription]()
            for structure0 in outputDescriptionsContainer {
                if let structure0 = structure0 {
                    outputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        outputDescriptions = outputDescriptionsDecoded0
    }
}

extension AddApplicationReferenceDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceDataSource = self.referenceDataSource {
            try encodeContainer.encode(referenceDataSource, forKey: .referenceDataSource)
        }
    }
}

extension AddApplicationReferenceDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationReferenceDataSourceInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version of the application for which you are adding the reference data source. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting in-application table that is created.
    /// This member is required.
    public var referenceDataSource: KinesisAnalyticsV2ClientTypes.ReferenceDataSource?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceDataSource: KinesisAnalyticsV2ClientTypes.ReferenceDataSource? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceDataSource = referenceDataSource
    }
}

struct AddApplicationReferenceDataSourceInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let referenceDataSource: KinesisAnalyticsV2ClientTypes.ReferenceDataSource?
}

extension AddApplicationReferenceDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceDataSourceDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ReferenceDataSource.self, forKey: .referenceDataSource)
        referenceDataSource = referenceDataSourceDecoded
    }
}

extension AddApplicationReferenceDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationReferenceDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationReferenceDataSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationReferenceDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddApplicationReferenceDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.referenceDataSourceDescriptions = output.referenceDataSourceDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.referenceDataSourceDescriptions = nil
        }
    }
}

public struct AddApplicationReferenceDataSourceOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
    public var applicationVersionId: Swift.Int?
    /// Describes reference data sources configured for the application.
    public var referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
    }
}

struct AddApplicationReferenceDataSourceOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]?
}

extension AddApplicationReferenceDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let referenceDataSourceDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription?].self, forKey: .referenceDataSourceDescriptions)
        var referenceDataSourceDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]? = nil
        if let referenceDataSourceDescriptionsContainer = referenceDataSourceDescriptionsContainer {
            referenceDataSourceDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]()
            for structure0 in referenceDataSourceDescriptionsContainer {
                if let structure0 = structure0 {
                    referenceDataSourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceDescriptions = referenceDataSourceDescriptionsDecoded0
    }
}

extension AddApplicationVpcConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let conditionalToken = self.conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

extension AddApplicationVpcConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationVpcConfigurationInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// A value you use to implement strong concurrency for application updates. You must provide the ApplicationVersionID or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The version of the application to which you want to add the VPC configuration. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?
    /// Description of the VPC to add to the application.
    /// This member is required.
    public var vpcConfiguration: KinesisAnalyticsV2ClientTypes.VpcConfiguration?

    public init (
        applicationName: Swift.String? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        vpcConfiguration: KinesisAnalyticsV2ClientTypes.VpcConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.vpcConfiguration = vpcConfiguration
    }
}

struct AddApplicationVpcConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let vpcConfiguration: KinesisAnalyticsV2ClientTypes.VpcConfiguration?
    let conditionalToken: Swift.String?
}

extension AddApplicationVpcConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension AddApplicationVpcConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationVpcConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationVpcConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationVpcConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddApplicationVpcConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.vpcConfigurationDescription = output.vpcConfigurationDescription
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.vpcConfigurationDescription = nil
        }
    }
}

public struct AddApplicationVpcConfigurationOutputResponse: Swift.Equatable {
    /// The ARN of the application.
    public var applicationARN: Swift.String?
    /// Provides the current application version. Kinesis Data Analytics updates the ApplicationVersionId each time you update the application.
    public var applicationVersionId: Swift.Int?
    /// The parameters of the new VPC configuration.
    public var vpcConfigurationDescription: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        vpcConfigurationDescription: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.vpcConfigurationDescription = vpcConfigurationDescription
    }
}

struct AddApplicationVpcConfigurationOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let vpcConfigurationDescription: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription?
}

extension AddApplicationVpcConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case vpcConfigurationDescription = "VpcConfigurationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let vpcConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription.self, forKey: .vpcConfigurationDescription)
        vpcConfigurationDescription = vpcConfigurationDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeContent = "CodeContent"
        case codeContentType = "CodeContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeContent = self.codeContent {
            try encodeContainer.encode(codeContent, forKey: .codeContent)
        }
        if let codeContentType = self.codeContentType {
            try encodeContainer.encode(codeContentType.rawValue, forKey: .codeContentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeContentDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CodeContent.self, forKey: .codeContent)
        codeContent = codeContentDecoded
        let codeContentTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CodeContentType.self, forKey: .codeContentType)
        codeContentType = codeContentTypeDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes code configuration for an application.
    public struct ApplicationCodeConfiguration: Swift.Equatable {
        /// The location and type of the application code.
        public var codeContent: KinesisAnalyticsV2ClientTypes.CodeContent?
        /// Specifies whether the code content is in text or zip format.
        /// This member is required.
        public var codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType?

        public init (
            codeContent: KinesisAnalyticsV2ClientTypes.CodeContent? = nil,
            codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType? = nil
        )
        {
            self.codeContent = codeContent
            self.codeContentType = codeContentType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeContentDescription = "CodeContentDescription"
        case codeContentType = "CodeContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeContentDescription = self.codeContentDescription {
            try encodeContainer.encode(codeContentDescription, forKey: .codeContentDescription)
        }
        if let codeContentType = self.codeContentType {
            try encodeContainer.encode(codeContentType.rawValue, forKey: .codeContentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeContentTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CodeContentType.self, forKey: .codeContentType)
        codeContentType = codeContentTypeDecoded
        let codeContentDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CodeContentDescription.self, forKey: .codeContentDescription)
        codeContentDescription = codeContentDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes code configuration for an application.
    public struct ApplicationCodeConfigurationDescription: Swift.Equatable {
        /// Describes details about the location and format of the application code.
        public var codeContentDescription: KinesisAnalyticsV2ClientTypes.CodeContentDescription?
        /// Specifies whether the code content is in text or zip format.
        /// This member is required.
        public var codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType?

        public init (
            codeContentDescription: KinesisAnalyticsV2ClientTypes.CodeContentDescription? = nil,
            codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType? = nil
        )
        {
            self.codeContentDescription = codeContentDescription
            self.codeContentType = codeContentType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeContentTypeUpdate = "CodeContentTypeUpdate"
        case codeContentUpdate = "CodeContentUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeContentTypeUpdate = self.codeContentTypeUpdate {
            try encodeContainer.encode(codeContentTypeUpdate.rawValue, forKey: .codeContentTypeUpdate)
        }
        if let codeContentUpdate = self.codeContentUpdate {
            try encodeContainer.encode(codeContentUpdate, forKey: .codeContentUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeContentTypeUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CodeContentType.self, forKey: .codeContentTypeUpdate)
        codeContentTypeUpdate = codeContentTypeUpdateDecoded
        let codeContentUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CodeContentUpdate.self, forKey: .codeContentUpdate)
        codeContentUpdate = codeContentUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes code configuration updates for an application. This is supported for a Flink-based Kinesis Data Analytics application or a SQL-based Kinesis Data Analytics application.
    public struct ApplicationCodeConfigurationUpdate: Swift.Equatable {
        /// Describes updates to the code content type.
        public var codeContentTypeUpdate: KinesisAnalyticsV2ClientTypes.CodeContentType?
        /// Describes updates to the code content of an application.
        public var codeContentUpdate: KinesisAnalyticsV2ClientTypes.CodeContentUpdate?

        public init (
            codeContentTypeUpdate: KinesisAnalyticsV2ClientTypes.CodeContentType? = nil,
            codeContentUpdate: KinesisAnalyticsV2ClientTypes.CodeContentUpdate? = nil
        )
        {
            self.codeContentTypeUpdate = codeContentTypeUpdate
            self.codeContentUpdate = codeContentUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCodeConfiguration = "ApplicationCodeConfiguration"
        case applicationSnapshotConfiguration = "ApplicationSnapshotConfiguration"
        case environmentProperties = "EnvironmentProperties"
        case flinkApplicationConfiguration = "FlinkApplicationConfiguration"
        case sqlApplicationConfiguration = "SqlApplicationConfiguration"
        case vpcConfigurations = "VpcConfigurations"
        case zeppelinApplicationConfiguration = "ZeppelinApplicationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeConfiguration = self.applicationCodeConfiguration {
            try encodeContainer.encode(applicationCodeConfiguration, forKey: .applicationCodeConfiguration)
        }
        if let applicationSnapshotConfiguration = self.applicationSnapshotConfiguration {
            try encodeContainer.encode(applicationSnapshotConfiguration, forKey: .applicationSnapshotConfiguration)
        }
        if let environmentProperties = self.environmentProperties {
            try encodeContainer.encode(environmentProperties, forKey: .environmentProperties)
        }
        if let flinkApplicationConfiguration = self.flinkApplicationConfiguration {
            try encodeContainer.encode(flinkApplicationConfiguration, forKey: .flinkApplicationConfiguration)
        }
        if let sqlApplicationConfiguration = self.sqlApplicationConfiguration {
            try encodeContainer.encode(sqlApplicationConfiguration, forKey: .sqlApplicationConfiguration)
        }
        if let vpcConfigurations = vpcConfigurations {
            var vpcConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigurations)
            for vpcconfiguration0 in vpcConfigurations {
                try vpcConfigurationsContainer.encode(vpcconfiguration0)
            }
        }
        if let zeppelinApplicationConfiguration = self.zeppelinApplicationConfiguration {
            try encodeContainer.encode(zeppelinApplicationConfiguration, forKey: .zeppelinApplicationConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlApplicationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration.self, forKey: .sqlApplicationConfiguration)
        sqlApplicationConfiguration = sqlApplicationConfigurationDecoded
        let flinkApplicationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration.self, forKey: .flinkApplicationConfiguration)
        flinkApplicationConfiguration = flinkApplicationConfigurationDecoded
        let environmentPropertiesDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.EnvironmentProperties.self, forKey: .environmentProperties)
        environmentProperties = environmentPropertiesDecoded
        let applicationCodeConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration.self, forKey: .applicationCodeConfiguration)
        applicationCodeConfiguration = applicationCodeConfigurationDecoded
        let applicationSnapshotConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration.self, forKey: .applicationSnapshotConfiguration)
        applicationSnapshotConfiguration = applicationSnapshotConfigurationDecoded
        let vpcConfigurationsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.VpcConfiguration?].self, forKey: .vpcConfigurations)
        var vpcConfigurationsDecoded0:[KinesisAnalyticsV2ClientTypes.VpcConfiguration]? = nil
        if let vpcConfigurationsContainer = vpcConfigurationsContainer {
            vpcConfigurationsDecoded0 = [KinesisAnalyticsV2ClientTypes.VpcConfiguration]()
            for structure0 in vpcConfigurationsContainer {
                if let structure0 = structure0 {
                    vpcConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigurations = vpcConfigurationsDecoded0
        let zeppelinApplicationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration.self, forKey: .zeppelinApplicationConfiguration)
        zeppelinApplicationConfiguration = zeppelinApplicationConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies the creation parameters for a Kinesis Data Analytics application.
    public struct ApplicationConfiguration: Swift.Equatable {
        /// The code location and type parameters for a Flink-based Kinesis Data Analytics application.
        public var applicationCodeConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration?
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public var applicationSnapshotConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration?
        /// Describes execution properties for a Flink-based Kinesis Data Analytics application.
        public var environmentProperties: KinesisAnalyticsV2ClientTypes.EnvironmentProperties?
        /// The creation and update parameters for a Flink-based Kinesis Data Analytics application.
        public var flinkApplicationConfiguration: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration?
        /// The creation and update parameters for a SQL-based Kinesis Data Analytics application.
        public var sqlApplicationConfiguration: KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration?
        /// The array of descriptions of VPC configurations available to the application.
        public var vpcConfigurations: [KinesisAnalyticsV2ClientTypes.VpcConfiguration]?
        /// The configuration parameters for a Kinesis Data Analytics Studio notebook.
        public var zeppelinApplicationConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration?

        public init (
            applicationCodeConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration? = nil,
            applicationSnapshotConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration? = nil,
            environmentProperties: KinesisAnalyticsV2ClientTypes.EnvironmentProperties? = nil,
            flinkApplicationConfiguration: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration? = nil,
            sqlApplicationConfiguration: KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration? = nil,
            vpcConfigurations: [KinesisAnalyticsV2ClientTypes.VpcConfiguration]? = nil,
            zeppelinApplicationConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration? = nil
        )
        {
            self.applicationCodeConfiguration = applicationCodeConfiguration
            self.applicationSnapshotConfiguration = applicationSnapshotConfiguration
            self.environmentProperties = environmentProperties
            self.flinkApplicationConfiguration = flinkApplicationConfiguration
            self.sqlApplicationConfiguration = sqlApplicationConfiguration
            self.vpcConfigurations = vpcConfigurations
            self.zeppelinApplicationConfiguration = zeppelinApplicationConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCodeConfigurationDescription = "ApplicationCodeConfigurationDescription"
        case applicationSnapshotConfigurationDescription = "ApplicationSnapshotConfigurationDescription"
        case environmentPropertyDescriptions = "EnvironmentPropertyDescriptions"
        case flinkApplicationConfigurationDescription = "FlinkApplicationConfigurationDescription"
        case runConfigurationDescription = "RunConfigurationDescription"
        case sqlApplicationConfigurationDescription = "SqlApplicationConfigurationDescription"
        case vpcConfigurationDescriptions = "VpcConfigurationDescriptions"
        case zeppelinApplicationConfigurationDescription = "ZeppelinApplicationConfigurationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeConfigurationDescription = self.applicationCodeConfigurationDescription {
            try encodeContainer.encode(applicationCodeConfigurationDescription, forKey: .applicationCodeConfigurationDescription)
        }
        if let applicationSnapshotConfigurationDescription = self.applicationSnapshotConfigurationDescription {
            try encodeContainer.encode(applicationSnapshotConfigurationDescription, forKey: .applicationSnapshotConfigurationDescription)
        }
        if let environmentPropertyDescriptions = self.environmentPropertyDescriptions {
            try encodeContainer.encode(environmentPropertyDescriptions, forKey: .environmentPropertyDescriptions)
        }
        if let flinkApplicationConfigurationDescription = self.flinkApplicationConfigurationDescription {
            try encodeContainer.encode(flinkApplicationConfigurationDescription, forKey: .flinkApplicationConfigurationDescription)
        }
        if let runConfigurationDescription = self.runConfigurationDescription {
            try encodeContainer.encode(runConfigurationDescription, forKey: .runConfigurationDescription)
        }
        if let sqlApplicationConfigurationDescription = self.sqlApplicationConfigurationDescription {
            try encodeContainer.encode(sqlApplicationConfigurationDescription, forKey: .sqlApplicationConfigurationDescription)
        }
        if let vpcConfigurationDescriptions = vpcConfigurationDescriptions {
            var vpcConfigurationDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigurationDescriptions)
            for vpcconfigurationdescription0 in vpcConfigurationDescriptions {
                try vpcConfigurationDescriptionsContainer.encode(vpcconfigurationdescription0)
            }
        }
        if let zeppelinApplicationConfigurationDescription = self.zeppelinApplicationConfigurationDescription {
            try encodeContainer.encode(zeppelinApplicationConfigurationDescription, forKey: .zeppelinApplicationConfigurationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription.self, forKey: .sqlApplicationConfigurationDescription)
        sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescriptionDecoded
        let applicationCodeConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription.self, forKey: .applicationCodeConfigurationDescription)
        applicationCodeConfigurationDescription = applicationCodeConfigurationDescriptionDecoded
        let runConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RunConfigurationDescription.self, forKey: .runConfigurationDescription)
        runConfigurationDescription = runConfigurationDescriptionDecoded
        let flinkApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription.self, forKey: .flinkApplicationConfigurationDescription)
        flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescriptionDecoded
        let environmentPropertyDescriptionsDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions.self, forKey: .environmentPropertyDescriptions)
        environmentPropertyDescriptions = environmentPropertyDescriptionsDecoded
        let applicationSnapshotConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription.self, forKey: .applicationSnapshotConfigurationDescription)
        applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescriptionDecoded
        let vpcConfigurationDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription?].self, forKey: .vpcConfigurationDescriptions)
        var vpcConfigurationDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription]? = nil
        if let vpcConfigurationDescriptionsContainer = vpcConfigurationDescriptionsContainer {
            vpcConfigurationDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription]()
            for structure0 in vpcConfigurationDescriptionsContainer {
                if let structure0 = structure0 {
                    vpcConfigurationDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigurationDescriptions = vpcConfigurationDescriptionsDecoded0
        let zeppelinApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription.self, forKey: .zeppelinApplicationConfigurationDescription)
        zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes details about the application code and starting parameters for a Kinesis Data Analytics application.
    public struct ApplicationConfigurationDescription: Swift.Equatable {
        /// The details about the application code for a Flink-based Kinesis Data Analytics application.
        public var applicationCodeConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription?
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public var applicationSnapshotConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription?
        /// Describes execution properties for a Flink-based Kinesis Data Analytics application.
        public var environmentPropertyDescriptions: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions?
        /// The details about a Flink-based Kinesis Data Analytics application.
        public var flinkApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription?
        /// The details about the starting properties for a Kinesis Data Analytics application.
        public var runConfigurationDescription: KinesisAnalyticsV2ClientTypes.RunConfigurationDescription?
        /// The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
        public var sqlApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription?
        /// The array of descriptions of VPC configurations available to the application.
        public var vpcConfigurationDescriptions: [KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription]?
        /// The configuration parameters for a Kinesis Data Analytics Studio notebook.
        public var zeppelinApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription?

        public init (
            applicationCodeConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription? = nil,
            applicationSnapshotConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription? = nil,
            environmentPropertyDescriptions: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions? = nil,
            flinkApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription? = nil,
            runConfigurationDescription: KinesisAnalyticsV2ClientTypes.RunConfigurationDescription? = nil,
            sqlApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription? = nil,
            vpcConfigurationDescriptions: [KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription]? = nil,
            zeppelinApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription? = nil
        )
        {
            self.applicationCodeConfigurationDescription = applicationCodeConfigurationDescription
            self.applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescription
            self.environmentPropertyDescriptions = environmentPropertyDescriptions
            self.flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescription
            self.runConfigurationDescription = runConfigurationDescription
            self.sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescription
            self.vpcConfigurationDescriptions = vpcConfigurationDescriptions
            self.zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCodeConfigurationUpdate = "ApplicationCodeConfigurationUpdate"
        case applicationSnapshotConfigurationUpdate = "ApplicationSnapshotConfigurationUpdate"
        case environmentPropertyUpdates = "EnvironmentPropertyUpdates"
        case flinkApplicationConfigurationUpdate = "FlinkApplicationConfigurationUpdate"
        case sqlApplicationConfigurationUpdate = "SqlApplicationConfigurationUpdate"
        case vpcConfigurationUpdates = "VpcConfigurationUpdates"
        case zeppelinApplicationConfigurationUpdate = "ZeppelinApplicationConfigurationUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeConfigurationUpdate = self.applicationCodeConfigurationUpdate {
            try encodeContainer.encode(applicationCodeConfigurationUpdate, forKey: .applicationCodeConfigurationUpdate)
        }
        if let applicationSnapshotConfigurationUpdate = self.applicationSnapshotConfigurationUpdate {
            try encodeContainer.encode(applicationSnapshotConfigurationUpdate, forKey: .applicationSnapshotConfigurationUpdate)
        }
        if let environmentPropertyUpdates = self.environmentPropertyUpdates {
            try encodeContainer.encode(environmentPropertyUpdates, forKey: .environmentPropertyUpdates)
        }
        if let flinkApplicationConfigurationUpdate = self.flinkApplicationConfigurationUpdate {
            try encodeContainer.encode(flinkApplicationConfigurationUpdate, forKey: .flinkApplicationConfigurationUpdate)
        }
        if let sqlApplicationConfigurationUpdate = self.sqlApplicationConfigurationUpdate {
            try encodeContainer.encode(sqlApplicationConfigurationUpdate, forKey: .sqlApplicationConfigurationUpdate)
        }
        if let vpcConfigurationUpdates = vpcConfigurationUpdates {
            var vpcConfigurationUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigurationUpdates)
            for vpcconfigurationupdate0 in vpcConfigurationUpdates {
                try vpcConfigurationUpdatesContainer.encode(vpcconfigurationupdate0)
            }
        }
        if let zeppelinApplicationConfigurationUpdate = self.zeppelinApplicationConfigurationUpdate {
            try encodeContainer.encode(zeppelinApplicationConfigurationUpdate, forKey: .zeppelinApplicationConfigurationUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate.self, forKey: .sqlApplicationConfigurationUpdate)
        sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdateDecoded
        let applicationCodeConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate.self, forKey: .applicationCodeConfigurationUpdate)
        applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdateDecoded
        let flinkApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate.self, forKey: .flinkApplicationConfigurationUpdate)
        flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdateDecoded
        let environmentPropertyUpdatesDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates.self, forKey: .environmentPropertyUpdates)
        environmentPropertyUpdates = environmentPropertyUpdatesDecoded
        let applicationSnapshotConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate.self, forKey: .applicationSnapshotConfigurationUpdate)
        applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdateDecoded
        let vpcConfigurationUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate?].self, forKey: .vpcConfigurationUpdates)
        var vpcConfigurationUpdatesDecoded0:[KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate]? = nil
        if let vpcConfigurationUpdatesContainer = vpcConfigurationUpdatesContainer {
            vpcConfigurationUpdatesDecoded0 = [KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate]()
            for structure0 in vpcConfigurationUpdatesContainer {
                if let structure0 = structure0 {
                    vpcConfigurationUpdatesDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigurationUpdates = vpcConfigurationUpdatesDecoded0
        let zeppelinApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate.self, forKey: .zeppelinApplicationConfigurationUpdate)
        zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to an application's configuration.
    public struct ApplicationConfigurationUpdate: Swift.Equatable {
        /// Describes updates to an application's code configuration.
        public var applicationCodeConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate?
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public var applicationSnapshotConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate?
        /// Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.
        public var environmentPropertyUpdates: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates?
        /// Describes updates to a Flink-based Kinesis Data Analytics application's configuration.
        public var flinkApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate?
        /// Describes updates to a SQL-based Kinesis Data Analytics application's configuration.
        public var sqlApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate?
        /// Updates to the array of descriptions of VPC configurations available to the application.
        public var vpcConfigurationUpdates: [KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate]?
        /// Updates to the configuration of a Kinesis Data Analytics Studio notebook.
        public var zeppelinApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate?

        public init (
            applicationCodeConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate? = nil,
            applicationSnapshotConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate? = nil,
            environmentPropertyUpdates: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates? = nil,
            flinkApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate? = nil,
            sqlApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate? = nil,
            vpcConfigurationUpdates: [KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate]? = nil,
            zeppelinApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate? = nil
        )
        {
            self.applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdate
            self.applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdate
            self.environmentPropertyUpdates = environmentPropertyUpdates
            self.flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdate
            self.sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate
            self.vpcConfigurationUpdates = vpcConfigurationUpdates
            self.zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationConfigurationDescription = "ApplicationConfigurationDescription"
        case applicationDescription = "ApplicationDescription"
        case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
        case applicationVersionRolledBackFrom = "ApplicationVersionRolledBackFrom"
        case applicationVersionRolledBackTo = "ApplicationVersionRolledBackTo"
        case applicationVersionUpdatedFrom = "ApplicationVersionUpdatedFrom"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
        case conditionalToken = "ConditionalToken"
        case createTimestamp = "CreateTimestamp"
        case lastUpdateTimestamp = "LastUpdateTimestamp"
        case runtimeEnvironment = "RuntimeEnvironment"
        case serviceExecutionRole = "ServiceExecutionRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = self.applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationConfigurationDescription = self.applicationConfigurationDescription {
            try encodeContainer.encode(applicationConfigurationDescription, forKey: .applicationConfigurationDescription)
        }
        if let applicationDescription = self.applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationMaintenanceConfigurationDescription = self.applicationMaintenanceConfigurationDescription {
            try encodeContainer.encode(applicationMaintenanceConfigurationDescription, forKey: .applicationMaintenanceConfigurationDescription)
        }
        if let applicationMode = self.applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = self.applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let applicationVersionRolledBackFrom = self.applicationVersionRolledBackFrom {
            try encodeContainer.encode(applicationVersionRolledBackFrom, forKey: .applicationVersionRolledBackFrom)
        }
        if let applicationVersionRolledBackTo = self.applicationVersionRolledBackTo {
            try encodeContainer.encode(applicationVersionRolledBackTo, forKey: .applicationVersionRolledBackTo)
        }
        if let applicationVersionUpdatedFrom = self.applicationVersionUpdatedFrom {
            try encodeContainer.encode(applicationVersionUpdatedFrom, forKey: .applicationVersionUpdatedFrom)
        }
        if let cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions {
            var cloudWatchLoggingOptionDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionDescriptions)
            for cloudwatchloggingoptiondescription0 in cloudWatchLoggingOptionDescriptions {
                try cloudWatchLoggingOptionDescriptionsContainer.encode(cloudwatchloggingoptiondescription0)
            }
        }
        if let conditionalToken = self.conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
        if let lastUpdateTimestamp = self.lastUpdateTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdateTimestamp, format: .epochSeconds, forKey: .lastUpdateTimestamp)
        }
        if let runtimeEnvironment = self.runtimeEnvironment {
            try encodeContainer.encode(runtimeEnvironment.rawValue, forKey: .runtimeEnvironment)
        }
        if let serviceExecutionRole = self.serviceExecutionRole {
            try encodeContainer.encode(serviceExecutionRole, forKey: .serviceExecutionRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let runtimeEnvironmentDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RuntimeEnvironment.self, forKey: .runtimeEnvironment)
        runtimeEnvironment = runtimeEnvironmentDecoded
        let serviceExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRole)
        serviceExecutionRole = serviceExecutionRoleDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let lastUpdateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTimestamp)
        lastUpdateTimestamp = lastUpdateTimestampDecoded
        let applicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription.self, forKey: .applicationConfigurationDescription)
        applicationConfigurationDescription = applicationConfigurationDescriptionDecoded
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
        let applicationMaintenanceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription.self, forKey: .applicationMaintenanceConfigurationDescription)
        applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescriptionDecoded
        let applicationVersionUpdatedFromDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionUpdatedFrom)
        applicationVersionUpdatedFrom = applicationVersionUpdatedFromDecoded
        let applicationVersionRolledBackFromDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionRolledBackFrom)
        applicationVersionRolledBackFrom = applicationVersionRolledBackFromDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
        let applicationVersionRolledBackToDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionRolledBackTo)
        applicationVersionRolledBackTo = applicationVersionRolledBackToDecoded
        let applicationModeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configurations.
    public struct ApplicationDetail: Swift.Equatable {
        /// The ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// Describes details about the application code and starting parameters for a Kinesis Data Analytics application.
        public var applicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription?
        /// The description of the application.
        public var applicationDescription: Swift.String?
        /// The details of the maintenance configuration for the application.
        public var applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription?
        /// To create a Kinesis Data Analytics Studio notebook, you must set the mode to INTERACTIVE. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
        public var applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
        /// The name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// The status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus?
        /// Provides the current application version. Kinesis Data Analytics updates the ApplicationVersionId each time you update the application.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// If you reverted the application using [RollbackApplication], the application version when RollbackApplication was called.
        public var applicationVersionRolledBackFrom: Swift.Int?
        /// The version to which you want to roll back the application.
        public var applicationVersionRolledBackTo: Swift.Int?
        /// The previous application version before the latest application update. [RollbackApplication] reverts the application to this version.
        public var applicationVersionUpdatedFrom: Swift.Int?
        /// Describes the application Amazon CloudWatch logging options.
        public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?
        /// A value you use to implement strong concurrency for application updates.
        public var conditionalToken: Swift.String?
        /// The current timestamp when the application was created.
        public var createTimestamp: ClientRuntime.Date?
        /// The current timestamp when the application was last updated.
        public var lastUpdateTimestamp: ClientRuntime.Date?
        /// The runtime environment for the application.
        /// This member is required.
        public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
        /// Specifies the IAM role that the application uses to access external resources.
        public var serviceExecutionRole: Swift.String?

        public init (
            applicationARN: Swift.String? = nil,
            applicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription? = nil,
            applicationDescription: Swift.String? = nil,
            applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription? = nil,
            applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil,
            applicationVersionRolledBackFrom: Swift.Int? = nil,
            applicationVersionRolledBackTo: Swift.Int? = nil,
            applicationVersionUpdatedFrom: Swift.Int? = nil,
            cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil,
            conditionalToken: Swift.String? = nil,
            createTimestamp: ClientRuntime.Date? = nil,
            lastUpdateTimestamp: ClientRuntime.Date? = nil,
            runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil,
            serviceExecutionRole: Swift.String? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationConfigurationDescription = applicationConfigurationDescription
            self.applicationDescription = applicationDescription
            self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.applicationVersionRolledBackFrom = applicationVersionRolledBackFrom
            self.applicationVersionRolledBackTo = applicationVersionRolledBackTo
            self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.conditionalToken = conditionalToken
            self.createTimestamp = createTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.runtimeEnvironment = runtimeEnvironment
            self.serviceExecutionRole = serviceExecutionRole
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMaintenanceWindowEndTime = "ApplicationMaintenanceWindowEndTime"
        case applicationMaintenanceWindowStartTime = "ApplicationMaintenanceWindowStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMaintenanceWindowEndTime = self.applicationMaintenanceWindowEndTime {
            try encodeContainer.encode(applicationMaintenanceWindowEndTime, forKey: .applicationMaintenanceWindowEndTime)
        }
        if let applicationMaintenanceWindowStartTime = self.applicationMaintenanceWindowStartTime {
            try encodeContainer.encode(applicationMaintenanceWindowStartTime, forKey: .applicationMaintenanceWindowStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationMaintenanceWindowStartTime)
        applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTimeDecoded
        let applicationMaintenanceWindowEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationMaintenanceWindowEndTime)
        applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTimeDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The details of the maintenance configuration for the application.
    public struct ApplicationMaintenanceConfigurationDescription: Swift.Equatable {
        /// The end time for the maintenance window.
        /// This member is required.
        public var applicationMaintenanceWindowEndTime: Swift.String?
        /// The start time for the maintenance window.
        /// This member is required.
        public var applicationMaintenanceWindowStartTime: Swift.String?

        public init (
            applicationMaintenanceWindowEndTime: Swift.String? = nil,
            applicationMaintenanceWindowStartTime: Swift.String? = nil
        )
        {
            self.applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTime
            self.applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTime
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMaintenanceWindowStartTimeUpdate = "ApplicationMaintenanceWindowStartTimeUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMaintenanceWindowStartTimeUpdate = self.applicationMaintenanceWindowStartTimeUpdate {
            try encodeContainer.encode(applicationMaintenanceWindowStartTimeUpdate, forKey: .applicationMaintenanceWindowStartTimeUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationMaintenanceWindowStartTimeUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationMaintenanceWindowStartTimeUpdate)
        applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the updated maintenance configuration for the application.
    public struct ApplicationMaintenanceConfigurationUpdate: Swift.Equatable {
        /// The updated start time for the maintenance window.
        /// This member is required.
        public var applicationMaintenanceWindowStartTimeUpdate: Swift.String?

        public init (
            applicationMaintenanceWindowStartTimeUpdate: Swift.String? = nil
        )
        {
            self.applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum ApplicationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interactive
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationMode] {
            return [
                .interactive,
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationMode(rawValue: rawValue) ?? ApplicationMode.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationRestoreType = "ApplicationRestoreType"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreType = self.applicationRestoreType {
            try encodeContainer.encode(applicationRestoreType.rawValue, forKey: .applicationRestoreType)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationRestoreTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationRestoreType.self, forKey: .applicationRestoreType)
        applicationRestoreType = applicationRestoreTypeDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies the method and snapshot to use when restarting an application using previously saved application state.
    public struct ApplicationRestoreConfiguration: Swift.Equatable {
        /// Specifies how the application should be restored.
        /// This member is required.
        public var applicationRestoreType: KinesisAnalyticsV2ClientTypes.ApplicationRestoreType?
        /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the ApplicationRestoreType.
        public var snapshotName: Swift.String?

        public init (
            applicationRestoreType: KinesisAnalyticsV2ClientTypes.ApplicationRestoreType? = nil,
            snapshotName: Swift.String? = nil
        )
        {
            self.applicationRestoreType = applicationRestoreType
            self.snapshotName = snapshotName
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum ApplicationRestoreType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restoreFromCustomSnapshot
        case restoreFromLatestSnapshot
        case skipRestoreFromSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationRestoreType] {
            return [
                .restoreFromCustomSnapshot,
                .restoreFromLatestSnapshot,
                .skipRestoreFromSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restoreFromCustomSnapshot: return "RESTORE_FROM_CUSTOM_SNAPSHOT"
            case .restoreFromLatestSnapshot: return "RESTORE_FROM_LATEST_SNAPSHOT"
            case .skipRestoreFromSnapshot: return "SKIP_RESTORE_FROM_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationRestoreType(rawValue: rawValue) ?? ApplicationRestoreType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotsEnabled = "SnapshotsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotsEnabled = self.snapshotsEnabled {
            try encodeContainer.encode(snapshotsEnabled, forKey: .snapshotsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .snapshotsEnabled)
        snapshotsEnabled = snapshotsEnabledDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
    public struct ApplicationSnapshotConfiguration: Swift.Equatable {
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        /// This member is required.
        public var snapshotsEnabled: Swift.Bool?

        public init (
            snapshotsEnabled: Swift.Bool? = nil
        )
        {
            self.snapshotsEnabled = snapshotsEnabled
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotsEnabled = "SnapshotsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotsEnabled = self.snapshotsEnabled {
            try encodeContainer.encode(snapshotsEnabled, forKey: .snapshotsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .snapshotsEnabled)
        snapshotsEnabled = snapshotsEnabledDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
    public struct ApplicationSnapshotConfigurationDescription: Swift.Equatable {
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        /// This member is required.
        public var snapshotsEnabled: Swift.Bool?

        public init (
            snapshotsEnabled: Swift.Bool? = nil
        )
        {
            self.snapshotsEnabled = snapshotsEnabled
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotsEnabledUpdate = "SnapshotsEnabledUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotsEnabledUpdate = self.snapshotsEnabledUpdate {
            try encodeContainer.encode(snapshotsEnabledUpdate, forKey: .snapshotsEnabledUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsEnabledUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .snapshotsEnabledUpdate)
        snapshotsEnabledUpdate = snapshotsEnabledUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
    public struct ApplicationSnapshotConfigurationUpdate: Swift.Equatable {
        /// Describes updates to whether snapshots are enabled for an application.
        /// This member is required.
        public var snapshotsEnabledUpdate: Swift.Bool?

        public init (
            snapshotsEnabledUpdate: Swift.Bool? = nil
        )
        {
            self.snapshotsEnabledUpdate = snapshotsEnabledUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoscaling
        case deleting
        case forceStopping
        case maintenance
        case ready
        case rolledBack
        case rollingBack
        case running
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .autoscaling,
                .deleting,
                .forceStopping,
                .maintenance,
                .ready,
                .rolledBack,
                .rollingBack,
                .running,
                .starting,
                .stopping,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoscaling: return "AUTOSCALING"
            case .deleting: return "DELETING"
            case .forceStopping: return "FORCE_STOPPING"
            case .maintenance: return "MAINTENANCE"
            case .ready: return "READY"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
        case runtimeEnvironment = "RuntimeEnvironment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = self.applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationMode = self.applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = self.applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let runtimeEnvironment = self.runtimeEnvironment {
            try encodeContainer.encode(runtimeEnvironment.rawValue, forKey: .runtimeEnvironment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let runtimeEnvironmentDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RuntimeEnvironment.self, forKey: .runtimeEnvironment)
        runtimeEnvironment = runtimeEnvironmentDecoded
        let applicationModeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.
    public struct ApplicationSummary: Swift.Equatable {
        /// The ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// For a Kinesis Data Analytics for Apache Flink application, the mode is STREAMING. For a Kinesis Data Analytics Studio notebook, it is INTERACTIVE.
        public var applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
        /// The name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// The status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus?
        /// Provides the current application version.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// The runtime environment for the application.
        /// This member is required.
        public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?

        public init (
            applicationARN: Swift.String? = nil,
            applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil,
            runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.runtimeEnvironment = runtimeEnvironment
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = self.applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The summary of the application version.
    public struct ApplicationVersionSummary: Swift.Equatable {
        /// The status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus?
        /// The ID of the application version. Kinesis Data Analytics updates the ApplicationVersionId each time you update the application.
        /// This member is required.
        public var applicationVersionId: Swift.Int?

        public init (
            applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil
        )
        {
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum ArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyJar
        case udf
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactType] {
            return [
                .dependencyJar,
                .udf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyJar: return "DEPENDENCY_JAR"
            case .udf: return "UDF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactType(rawValue: rawValue) ?? ArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.CSVMappingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordColumnDelimiter = "RecordColumnDelimiter"
        case recordRowDelimiter = "RecordRowDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnDelimiter = self.recordColumnDelimiter {
            try encodeContainer.encode(recordColumnDelimiter, forKey: .recordColumnDelimiter)
        }
        if let recordRowDelimiter = self.recordRowDelimiter {
            try encodeContainer.encode(recordRowDelimiter, forKey: .recordRowDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordRowDelimiter)
        recordRowDelimiter = recordRowDelimiterDecoded
        let recordColumnDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordColumnDelimiter)
        recordColumnDelimiter = recordColumnDelimiterDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter: "name1", "address1"
    ///     "name2", "address2"
    public struct CSVMappingParameters: Swift.Equatable {
        /// The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
        /// This member is required.
        public var recordColumnDelimiter: Swift.String?
        /// The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
        /// This member is required.
        public var recordRowDelimiter: Swift.String?

        public init (
            recordColumnDelimiter: Swift.String? = nil,
            recordRowDelimiter: Swift.String? = nil
        )
        {
            self.recordColumnDelimiter = recordColumnDelimiter
            self.recordRowDelimiter = recordRowDelimiter
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CatalogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glueDataCatalogConfiguration = "GlueDataCatalogConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalogConfiguration = self.glueDataCatalogConfiguration {
            try encodeContainer.encode(glueDataCatalogConfiguration, forKey: .glueDataCatalogConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration.self, forKey: .glueDataCatalogConfiguration)
        glueDataCatalogConfiguration = glueDataCatalogConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
    public struct CatalogConfiguration: Swift.Equatable {
        /// The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
        /// This member is required.
        public var glueDataCatalogConfiguration: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration?

        public init (
            glueDataCatalogConfiguration: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration? = nil
        )
        {
            self.glueDataCatalogConfiguration = glueDataCatalogConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glueDataCatalogConfigurationDescription = "GlueDataCatalogConfigurationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalogConfigurationDescription = self.glueDataCatalogConfigurationDescription {
            try encodeContainer.encode(glueDataCatalogConfigurationDescription, forKey: .glueDataCatalogConfigurationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription.self, forKey: .glueDataCatalogConfigurationDescription)
        glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
    public struct CatalogConfigurationDescription: Swift.Equatable {
        /// The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
        /// This member is required.
        public var glueDataCatalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription?

        public init (
            glueDataCatalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription? = nil
        )
        {
            self.glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glueDataCatalogConfigurationUpdate = "GlueDataCatalogConfigurationUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalogConfigurationUpdate = self.glueDataCatalogConfigurationUpdate {
            try encodeContainer.encode(glueDataCatalogConfigurationUpdate, forKey: .glueDataCatalogConfigurationUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate.self, forKey: .glueDataCatalogConfigurationUpdate)
        glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
    public struct CatalogConfigurationUpdate: Swift.Equatable {
        /// Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
        /// This member is required.
        public var glueDataCatalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate?

        public init (
            glueDataCatalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate? = nil
        )
        {
            self.glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CheckpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointInterval = "CheckpointInterval"
        case checkpointingEnabled = "CheckpointingEnabled"
        case configurationType = "ConfigurationType"
        case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointInterval = self.checkpointInterval {
            try encodeContainer.encode(checkpointInterval, forKey: .checkpointInterval)
        }
        if let checkpointingEnabled = self.checkpointingEnabled {
            try encodeContainer.encode(checkpointingEnabled, forKey: .checkpointingEnabled)
        }
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let minPauseBetweenCheckpoints = self.minPauseBetweenCheckpoints {
            try encodeContainer.encode(minPauseBetweenCheckpoints, forKey: .minPauseBetweenCheckpoints)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let checkpointingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .checkpointingEnabled)
        checkpointingEnabled = checkpointingEnabledDecoded
        let checkpointIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .checkpointInterval)
        checkpointInterval = checkpointIntervalDecoded
        let minPauseBetweenCheckpointsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minPauseBetweenCheckpoints)
        minPauseBetweenCheckpoints = minPauseBetweenCheckpointsDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see [ Checkpoints for Fault Tolerance](https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance) in the [Apache Flink Documentation](https://ci.apache.org/projects/flink/flink-docs-release-1.8/).
    public struct CheckpointConfiguration: Swift.Equatable {
        /// Describes the interval in milliseconds between checkpoint operations. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value using this API or in application code.
        public var checkpointInterval: Swift.Int?
        /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to another value using this API or in application code.
        public var checkpointingEnabled: Swift.Bool?
        /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters. If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:
        ///
        /// * CheckpointingEnabled: true
        ///
        /// * CheckpointInterval: 60000
        ///
        /// * MinPauseBetweenCheckpoints: 5000
        /// This member is required.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see [ Tuning Checkpointing](https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing) in the [Apache Flink Documentation](https://ci.apache.org/projects/flink/flink-docs-release-1.8/). If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or in application code.
        public var minPauseBetweenCheckpoints: Swift.Int?

        public init (
            checkpointInterval: Swift.Int? = nil,
            checkpointingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            minPauseBetweenCheckpoints: Swift.Int? = nil
        )
        {
            self.checkpointInterval = checkpointInterval
            self.checkpointingEnabled = checkpointingEnabled
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointInterval = "CheckpointInterval"
        case checkpointingEnabled = "CheckpointingEnabled"
        case configurationType = "ConfigurationType"
        case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointInterval = self.checkpointInterval {
            try encodeContainer.encode(checkpointInterval, forKey: .checkpointInterval)
        }
        if let checkpointingEnabled = self.checkpointingEnabled {
            try encodeContainer.encode(checkpointingEnabled, forKey: .checkpointingEnabled)
        }
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let minPauseBetweenCheckpoints = self.minPauseBetweenCheckpoints {
            try encodeContainer.encode(minPauseBetweenCheckpoints, forKey: .minPauseBetweenCheckpoints)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let checkpointingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .checkpointingEnabled)
        checkpointingEnabled = checkpointingEnabledDecoded
        let checkpointIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .checkpointInterval)
        checkpointInterval = checkpointIntervalDecoded
        let minPauseBetweenCheckpointsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minPauseBetweenCheckpoints)
        minPauseBetweenCheckpoints = minPauseBetweenCheckpointsDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes checkpointing parameters for a Flink-based Kinesis Data Analytics application.
    public struct CheckpointConfigurationDescription: Swift.Equatable {
        /// Describes the interval in milliseconds between checkpoint operations. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value using this API or in application code.
        public var checkpointInterval: Swift.Int?
        /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to another value using this API or in application code.
        public var checkpointingEnabled: Swift.Bool?
        /// Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics. If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:
        ///
        /// * CheckpointingEnabled: true
        ///
        /// * CheckpointInterval: 60000
        ///
        /// * MinPauseBetweenCheckpoints: 5000
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or in application code.
        public var minPauseBetweenCheckpoints: Swift.Int?

        public init (
            checkpointInterval: Swift.Int? = nil,
            checkpointingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            minPauseBetweenCheckpoints: Swift.Int? = nil
        )
        {
            self.checkpointInterval = checkpointInterval
            self.checkpointingEnabled = checkpointingEnabled
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointIntervalUpdate = "CheckpointIntervalUpdate"
        case checkpointingEnabledUpdate = "CheckpointingEnabledUpdate"
        case configurationTypeUpdate = "ConfigurationTypeUpdate"
        case minPauseBetweenCheckpointsUpdate = "MinPauseBetweenCheckpointsUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointIntervalUpdate = self.checkpointIntervalUpdate {
            try encodeContainer.encode(checkpointIntervalUpdate, forKey: .checkpointIntervalUpdate)
        }
        if let checkpointingEnabledUpdate = self.checkpointingEnabledUpdate {
            try encodeContainer.encode(checkpointingEnabledUpdate, forKey: .checkpointingEnabledUpdate)
        }
        if let configurationTypeUpdate = self.configurationTypeUpdate {
            try encodeContainer.encode(configurationTypeUpdate.rawValue, forKey: .configurationTypeUpdate)
        }
        if let minPauseBetweenCheckpointsUpdate = self.minPauseBetweenCheckpointsUpdate {
            try encodeContainer.encode(minPauseBetweenCheckpointsUpdate, forKey: .minPauseBetweenCheckpointsUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationTypeUpdate)
        configurationTypeUpdate = configurationTypeUpdateDecoded
        let checkpointingEnabledUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .checkpointingEnabledUpdate)
        checkpointingEnabledUpdate = checkpointingEnabledUpdateDecoded
        let checkpointIntervalUpdateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .checkpointIntervalUpdate)
        checkpointIntervalUpdate = checkpointIntervalUpdateDecoded
        let minPauseBetweenCheckpointsUpdateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minPauseBetweenCheckpointsUpdate)
        minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the checkpointing parameters for a Flink-based Kinesis Data Analytics application.
    public struct CheckpointConfigurationUpdate: Swift.Equatable {
        /// Describes updates to the interval in milliseconds between checkpoint operations. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value using this API or in application code.
        public var checkpointIntervalUpdate: Swift.Int?
        /// Describes updates to whether checkpointing is enabled for an application. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to another value using this API or in application code.
        public var checkpointingEnabledUpdate: Swift.Bool?
        /// Describes updates to whether the application uses the default checkpointing behavior of Kinesis Data Analytics. You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters. If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:
        ///
        /// * CheckpointingEnabled: true
        ///
        /// * CheckpointInterval: 60000
        ///
        /// * MinPauseBetweenCheckpoints: 5000
        public var configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or in application code.
        public var minPauseBetweenCheckpointsUpdate: Swift.Int?

        public init (
            checkpointIntervalUpdate: Swift.Int? = nil,
            checkpointingEnabledUpdate: Swift.Bool? = nil,
            configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            minPauseBetweenCheckpointsUpdate: Swift.Int? = nil
        )
        {
            self.checkpointIntervalUpdate = checkpointIntervalUpdate
            self.checkpointingEnabledUpdate = checkpointingEnabledUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logStreamARN = "LogStreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logStreamARN = self.logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logStreamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
    public struct CloudWatchLoggingOption: Swift.Equatable {
        /// The ARN of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?

        public init (
            logStreamARN: Swift.String? = nil
        )
        {
            self.logStreamARN = logStreamARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARN = "LogStreamARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = self.cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARN = self.logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the Amazon CloudWatch logging option.
    public struct CloudWatchLoggingOptionDescription: Swift.Equatable {
        /// The ID of the CloudWatch logging option description.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?
        /// The IAM ARN of the role to use to send application messages. Provided for backward compatibility. Applications created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARNUpdate = "LogStreamARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = self.cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARNUpdate = self.logStreamARNUpdate {
            try encodeContainer.encode(logStreamARNUpdate, forKey: .logStreamARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamARNUpdate)
        logStreamARNUpdate = logStreamARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the Amazon CloudWatch logging option updates.
    public struct CloudWatchLoggingOptionUpdate: Swift.Equatable {
        /// The ID of the CloudWatch logging option to update
        /// This member is required.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        public var logStreamARNUpdate: Swift.String?

        public init (
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARNUpdate: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARNUpdate = logStreamARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CodeContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ContentLocation = "S3ContentLocation"
        case textContent = "TextContent"
        case zipFileContent = "ZipFileContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocation = self.s3ContentLocation {
            try encodeContainer.encode(s3ContentLocation, forKey: .s3ContentLocation)
        }
        if let textContent = self.textContent {
            try encodeContainer.encode(textContent, forKey: .textContent)
        }
        if let zipFileContent = self.zipFileContent {
            try encodeContainer.encode(zipFileContent.base64EncodedString(), forKey: .zipFileContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textContent)
        textContent = textContentDecoded
        let zipFileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFileContent)
        zipFileContent = zipFileContentDecoded
        let s3ContentLocationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentLocation.self, forKey: .s3ContentLocation)
        s3ContentLocation = s3ContentLocationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies either the application code, or the location of the application code, for a Flink-based Kinesis Data Analytics application.
    public struct CodeContent: Swift.Equatable {
        /// Information about the Amazon S3 bucket that contains the application code.
        public var s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation?
        /// The text-format code for a Flink-based Kinesis Data Analytics application.
        public var textContent: Swift.String?
        /// The zip-format code for a Flink-based Kinesis Data Analytics application.
        public var zipFileContent: ClientRuntime.Data?

        public init (
            s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation? = nil,
            textContent: Swift.String? = nil,
            zipFileContent: ClientRuntime.Data? = nil
        )
        {
            self.s3ContentLocation = s3ContentLocation
            self.textContent = textContent
            self.zipFileContent = zipFileContent
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CodeContentDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeMD5 = "CodeMD5"
        case codeSize = "CodeSize"
        case s3ApplicationCodeLocationDescription = "S3ApplicationCodeLocationDescription"
        case textContent = "TextContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeMD5 = self.codeMD5 {
            try encodeContainer.encode(codeMD5, forKey: .codeMD5)
        }
        if let codeSize = self.codeSize {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let s3ApplicationCodeLocationDescription = self.s3ApplicationCodeLocationDescription {
            try encodeContainer.encode(s3ApplicationCodeLocationDescription, forKey: .s3ApplicationCodeLocationDescription)
        }
        if let textContent = self.textContent {
            try encodeContainer.encode(textContent, forKey: .textContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textContent)
        textContent = textContentDecoded
        let codeMD5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeMD5)
        codeMD5 = codeMD5Decoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let s3ApplicationCodeLocationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription.self, forKey: .s3ApplicationCodeLocationDescription)
        s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes details about the code of a Kinesis Data Analytics application.
    public struct CodeContentDescription: Swift.Equatable {
        /// The checksum that can be used to validate zip-format code.
        public var codeMD5: Swift.String?
        /// The size in bytes of the application code. Can be used to validate zip-format code.
        public var codeSize: Swift.Int?
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application code stored in Amazon S3.
        public var s3ApplicationCodeLocationDescription: KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription?
        /// The text-format code
        public var textContent: Swift.String?

        public init (
            codeMD5: Swift.String? = nil,
            codeSize: Swift.Int? = nil,
            s3ApplicationCodeLocationDescription: KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription? = nil,
            textContent: Swift.String? = nil
        )
        {
            self.codeMD5 = codeMD5
            self.codeSize = codeSize
            self.s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescription
            self.textContent = textContent
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum CodeContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case zipfile
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeContentType] {
            return [
                .plaintext,
                .zipfile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .zipfile: return "ZIPFILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeContentType(rawValue: rawValue) ?? CodeContentType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.CodeContentUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ContentLocationUpdate = "S3ContentLocationUpdate"
        case textContentUpdate = "TextContentUpdate"
        case zipFileContentUpdate = "ZipFileContentUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocationUpdate = self.s3ContentLocationUpdate {
            try encodeContainer.encode(s3ContentLocationUpdate, forKey: .s3ContentLocationUpdate)
        }
        if let textContentUpdate = self.textContentUpdate {
            try encodeContainer.encode(textContentUpdate, forKey: .textContentUpdate)
        }
        if let zipFileContentUpdate = self.zipFileContentUpdate {
            try encodeContainer.encode(zipFileContentUpdate.base64EncodedString(), forKey: .zipFileContentUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textContentUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textContentUpdate)
        textContentUpdate = textContentUpdateDecoded
        let zipFileContentUpdateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFileContentUpdate)
        zipFileContentUpdate = zipFileContentUpdateDecoded
        let s3ContentLocationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate.self, forKey: .s3ContentLocationUpdate)
        s3ContentLocationUpdate = s3ContentLocationUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes an update to the code of an application. Not supported for Apache Zeppelin.
    public struct CodeContentUpdate: Swift.Equatable {
        /// Describes an update to the location of code for an application.
        public var s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate?
        /// Describes an update to the text code for an application.
        public var textContentUpdate: Swift.String?
        /// Describes an update to the zipped code for an application.
        public var zipFileContentUpdate: ClientRuntime.Data?

        public init (
            s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate? = nil,
            textContentUpdate: Swift.String? = nil,
            zipFileContentUpdate: ClientRuntime.Data? = nil
        )
        {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
            self.textContentUpdate = textContentUpdate
            self.zipFileContentUpdate = zipFileContentUpdate
        }
    }

}

extension CodeValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CodeValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user-provided application code (query) is not valid. This can be a simple syntax error.
public struct CodeValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CodeValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CodeValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown as a result of concurrent modifications to an application. This error can be the result of attempting to modify an application without using the current application ID.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    public enum ConfigurationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationType] {
            return [
                .custom,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationType(rawValue: rawValue) ?? ConfigurationType.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration = "ApplicationConfiguration"
        case applicationDescription = "ApplicationDescription"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case runtimeEnvironment = "RuntimeEnvironment"
        case serviceExecutionRole = "ServiceExecutionRole"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = self.applicationConfiguration {
            try encodeContainer.encode(applicationConfiguration, forKey: .applicationConfiguration)
        }
        if let applicationDescription = self.applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationMode = self.applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptions = cloudWatchLoggingOptions {
            var cloudWatchLoggingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptions)
            for cloudwatchloggingoption0 in cloudWatchLoggingOptions {
                try cloudWatchLoggingOptionsContainer.encode(cloudwatchloggingoption0)
            }
        }
        if let runtimeEnvironment = self.runtimeEnvironment {
            try encodeContainer.encode(runtimeEnvironment.rawValue, forKey: .runtimeEnvironment)
        }
        if let serviceExecutionRole = self.serviceExecutionRole {
            try encodeContainer.encode(serviceExecutionRole, forKey: .serviceExecutionRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Use this parameter to configure the application.
    public var applicationConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration?
    /// A summary description of the application.
    public var applicationDescription: Swift.String?
    /// Use the STREAMING mode to create a Kinesis Data Analytics For Flink application. To create a Kinesis Data Analytics Studio notebook, use the INTERACTIVE mode.
    public var applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
    /// The name of your application (for example, sample-app).
    /// This member is required.
    public var applicationName: Swift.String?
    /// Use this parameter to configure an Amazon CloudWatch log stream to monitor application configuration errors.
    public var cloudWatchLoggingOptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]?
    /// The runtime environment for the application.
    /// This member is required.
    public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
    /// The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
    /// This member is required.
    public var serviceExecutionRole: Swift.String?
    /// A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html).
    public var tags: [KinesisAnalyticsV2ClientTypes.Tag]?

    public init (
        applicationConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration? = nil,
        applicationDescription: Swift.String? = nil,
        applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode? = nil,
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]? = nil,
        runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil,
        serviceExecutionRole: Swift.String? = nil,
        tags: [KinesisAnalyticsV2ClientTypes.Tag]? = nil
    )
    {
        self.applicationConfiguration = applicationConfiguration
        self.applicationDescription = applicationDescription
        self.applicationMode = applicationMode
        self.applicationName = applicationName
        self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
        self.runtimeEnvironment = runtimeEnvironment
        self.serviceExecutionRole = serviceExecutionRole
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let applicationDescription: Swift.String?
    let runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
    let serviceExecutionRole: Swift.String?
    let applicationConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration?
    let cloudWatchLoggingOptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]?
    let tags: [KinesisAnalyticsV2ClientTypes.Tag]?
    let applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration = "ApplicationConfiguration"
        case applicationDescription = "ApplicationDescription"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case runtimeEnvironment = "RuntimeEnvironment"
        case serviceExecutionRole = "ServiceExecutionRole"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let runtimeEnvironmentDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RuntimeEnvironment.self, forKey: .runtimeEnvironment)
        runtimeEnvironment = runtimeEnvironmentDecoded
        let serviceExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRole)
        serviceExecutionRole = serviceExecutionRoleDecoded
        let applicationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationConfiguration.self, forKey: .applicationConfiguration)
        applicationConfiguration = applicationConfigurationDecoded
        let cloudWatchLoggingOptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption?].self, forKey: .cloudWatchLoggingOptions)
        var cloudWatchLoggingOptionsDecoded0:[KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]? = nil
        if let cloudWatchLoggingOptionsContainer = cloudWatchLoggingOptionsContainer {
            cloudWatchLoggingOptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]()
            for structure0 in cloudWatchLoggingOptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptions = cloudWatchLoggingOptionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisAnalyticsV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisAnalyticsV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let applicationModeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case tooManyTagsException(TooManyTagsException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// In response to your CreateApplication request, Kinesis Data Analytics returns a response with details of the application it created.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init (
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension CreateApplicationPresignedUrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
        case urlType = "UrlType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let sessionExpirationDurationInSeconds = self.sessionExpirationDurationInSeconds {
            try encodeContainer.encode(sessionExpirationDurationInSeconds, forKey: .sessionExpirationDurationInSeconds)
        }
        if let urlType = self.urlType {
            try encodeContainer.encode(urlType.rawValue, forKey: .urlType)
        }
    }
}

extension CreateApplicationPresignedUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationPresignedUrlInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The duration in seconds for which the returned URL will be valid.
    public var sessionExpirationDurationInSeconds: Swift.Int?
    /// The type of the extension for which to create and return a URL. Currently, the only valid extension URL type is FLINK_DASHBOARD_URL.
    /// This member is required.
    public var urlType: KinesisAnalyticsV2ClientTypes.UrlType?

    public init (
        applicationName: Swift.String? = nil,
        sessionExpirationDurationInSeconds: Swift.Int? = nil,
        urlType: KinesisAnalyticsV2ClientTypes.UrlType? = nil
    )
    {
        self.applicationName = applicationName
        self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
        self.urlType = urlType
    }
}

struct CreateApplicationPresignedUrlInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let urlType: KinesisAnalyticsV2ClientTypes.UrlType?
    let sessionExpirationDurationInSeconds: Swift.Int?
}

extension CreateApplicationPresignedUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
        case urlType = "UrlType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let urlTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.UrlType.self, forKey: .urlType)
        urlType = urlTypeDecoded
        let sessionExpirationDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionExpirationDurationInSeconds)
        sessionExpirationDurationInSeconds = sessionExpirationDurationInSecondsDecoded
    }
}

extension CreateApplicationPresignedUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationPresignedUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationPresignedUrlOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationPresignedUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationPresignedUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizedUrl = output.authorizedUrl
        } else {
            self.authorizedUrl = nil
        }
    }
}

public struct CreateApplicationPresignedUrlOutputResponse: Swift.Equatable {
    /// The URL of the extension.
    public var authorizedUrl: Swift.String?

    public init (
        authorizedUrl: Swift.String? = nil
    )
    {
        self.authorizedUrl = authorizedUrl
    }
}

struct CreateApplicationPresignedUrlOutputResponseBody: Swift.Equatable {
    let authorizedUrl: Swift.String?
}

extension CreateApplicationPresignedUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedUrl = "AuthorizedUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedUrl)
        authorizedUrl = authorizedUrlDecoded
    }
}

extension CreateApplicationSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension CreateApplicationSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationSnapshotInput: Swift.Equatable {
    /// The name of an existing application
    /// This member is required.
    public var applicationName: Swift.String?
    /// An identifier for the application snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotName = snapshotName
    }
}

struct CreateApplicationSnapshotInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let snapshotName: Swift.String?
}

extension CreateApplicationSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension CreateApplicationSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationSnapshotOutputError: Swift.Error, Swift.Equatable {
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateApplicationSnapshotOutputResponse: Swift.Equatable {

    public init () { }
}

extension KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactType = "ArtifactType"
        case mavenReference = "MavenReference"
        case s3ContentLocation = "S3ContentLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactType = self.artifactType {
            try encodeContainer.encode(artifactType.rawValue, forKey: .artifactType)
        }
        if let mavenReference = self.mavenReference {
            try encodeContainer.encode(mavenReference, forKey: .mavenReference)
        }
        if let s3ContentLocation = self.s3ContentLocation {
            try encodeContainer.encode(s3ContentLocation, forKey: .s3ContentLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ArtifactType.self, forKey: .artifactType)
        artifactType = artifactTypeDecoded
        let s3ContentLocationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentLocation.self, forKey: .s3ContentLocation)
        s3ContentLocation = s3ContentLocationDecoded
        let mavenReferenceDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MavenReference.self, forKey: .mavenReference)
        mavenReference = mavenReferenceDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies dependency JARs, as well as JAR files that contain user-defined functions (UDF).
    public struct CustomArtifactConfiguration: Swift.Equatable {
        /// UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        /// This member is required.
        public var artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType?
        /// The parameters required to fully specify a Maven reference.
        public var mavenReference: KinesisAnalyticsV2ClientTypes.MavenReference?
        /// For a Kinesis Data Analytics application provides a description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        public var s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation?

        public init (
            artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType? = nil,
            mavenReference: KinesisAnalyticsV2ClientTypes.MavenReference? = nil,
            s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation? = nil
        )
        {
            self.artifactType = artifactType
            self.mavenReference = mavenReference
            self.s3ContentLocation = s3ContentLocation
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactType = "ArtifactType"
        case mavenReferenceDescription = "MavenReferenceDescription"
        case s3ContentLocationDescription = "S3ContentLocationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactType = self.artifactType {
            try encodeContainer.encode(artifactType.rawValue, forKey: .artifactType)
        }
        if let mavenReferenceDescription = self.mavenReferenceDescription {
            try encodeContainer.encode(mavenReferenceDescription, forKey: .mavenReferenceDescription)
        }
        if let s3ContentLocationDescription = self.s3ContentLocationDescription {
            try encodeContainer.encode(s3ContentLocationDescription, forKey: .s3ContentLocationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ArtifactType.self, forKey: .artifactType)
        artifactType = artifactTypeDecoded
        let s3ContentLocationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentLocation.self, forKey: .s3ContentLocationDescription)
        s3ContentLocationDescription = s3ContentLocationDescriptionDecoded
        let mavenReferenceDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MavenReference.self, forKey: .mavenReferenceDescription)
        mavenReferenceDescription = mavenReferenceDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies a dependency JAR or a JAR of user-defined functions.
    public struct CustomArtifactConfigurationDescription: Swift.Equatable {
        /// UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        public var artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType?
        /// The parameters that are required to specify a Maven dependency.
        public var mavenReferenceDescription: KinesisAnalyticsV2ClientTypes.MavenReference?
        /// For a Kinesis Data Analytics application provides a description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        public var s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentLocation?

        public init (
            artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType? = nil,
            mavenReferenceDescription: KinesisAnalyticsV2ClientTypes.MavenReference? = nil,
            s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentLocation? = nil
        )
        {
            self.artifactType = artifactType
            self.mavenReferenceDescription = mavenReferenceDescription
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }
    }

}

extension DeleteApplicationCloudWatchLoggingOptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptionId = self.cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let conditionalToken = self.conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionInput: Swift.Equatable {
    /// The application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The CloudWatchLoggingOptionId of the Amazon CloudWatch logging option to delete. You can get the CloudWatchLoggingOptionId by using the [DescribeApplication] operation.
    /// This member is required.
    public var cloudWatchLoggingOptionId: Swift.String?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The version ID of the application. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptionId: Swift.String? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct DeleteApplicationCloudWatchLoggingOptionInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let cloudWatchLoggingOptionId: Swift.String?
    let conditionalToken: Swift.String?
}

extension DeleteApplicationCloudWatchLoggingOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationCloudWatchLoggingOptionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteApplicationCloudWatchLoggingOptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = output.cloudWatchLoggingOptionDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.cloudWatchLoggingOptionDescriptions = nil
        }
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionOutputResponse: Swift.Equatable {
    /// The application's Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The version ID of the application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
    public var applicationVersionId: Swift.Int?
    /// The descriptions of the remaining CloudWatch logging options for the application.
    public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
    }
}

struct DeleteApplicationCloudWatchLoggingOptionOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
    let cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The name of the application to delete.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Use the DescribeApplication operation to get this value.
    /// This member is required.
    public var createTimestamp: ClientRuntime.Date?

    public init (
        applicationName: Swift.String? = nil,
        createTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.applicationName = applicationName
        self.createTimestamp = createTimestamp
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let createTimestamp: ClientRuntime.Date?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
    }
}

extension DeleteApplicationInputProcessingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
    }
}

extension DeleteApplicationInputProcessingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInputProcessingConfigurationInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The application version. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration from which to delete the input processing configuration. You can get a list of the input IDs for an application by using the [DescribeApplication] operation.
    /// This member is required.
    public var inputId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
    }
}

struct DeleteApplicationInputProcessingConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let inputId: Swift.String?
}

extension DeleteApplicationInputProcessingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationInputProcessingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationInputProcessingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteApplicationInputProcessingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationInputProcessingConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// The current application version ID.
    public var applicationVersionId: Swift.Int?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationInputProcessingConfigurationOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
}

extension DeleteApplicationInputProcessingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let outputId = self.outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }
}

extension DeleteApplicationOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationOutputInput: Swift.Equatable {
    /// The application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The application version. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the configuration to delete. Each output configuration that is added to the application (either when the application is created or later) using the [AddApplicationOutput] operation has a unique ID. You need to provide the ID to uniquely identify the output configuration that you want to delete from the application configuration. You can use the [DescribeApplication] operation to get the specific OutputId.
    /// This member is required.
    public var outputId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        outputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.outputId = outputId
    }
}

struct DeleteApplicationOutputInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let outputId: Swift.String?
}

extension DeleteApplicationOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputId)
        outputId = outputIdDecoded
    }
}

extension DeleteApplicationOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationOutputOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteApplicationOutputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationOutputOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The current application version ID.
    public var applicationVersionId: Swift.Int?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationOutputOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
}

extension DeleteApplicationOutputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteApplicationReferenceDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }
}

extension DeleteApplicationReferenceDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationReferenceDataSourceInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current application version. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the reference data source. When you add a reference data source to your application using the [AddApplicationReferenceDataSource], Kinesis Data Analytics assigns an ID. You can use the [DescribeApplication] operation to get the reference ID.
    /// This member is required.
    public var referenceId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceId = referenceId
    }
}

struct DeleteApplicationReferenceDataSourceInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let referenceId: Swift.String?
}

extension DeleteApplicationReferenceDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension DeleteApplicationReferenceDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationReferenceDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationReferenceDataSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationReferenceDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteApplicationReferenceDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationReferenceDataSourceOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The updated version ID of the application.
    public var applicationVersionId: Swift.Int?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationReferenceDataSourceOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
}

extension DeleteApplicationReferenceDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DeleteApplicationSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let snapshotCreationTimestamp = self.snapshotCreationTimestamp {
            try encodeContainer.encodeTimestamp(snapshotCreationTimestamp, format: .epochSeconds, forKey: .snapshotCreationTimestamp)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension DeleteApplicationSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationSnapshotInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The creation timestamp of the application snapshot to delete. You can retrieve this value using or .
    /// This member is required.
    public var snapshotCreationTimestamp: ClientRuntime.Date?
    /// The identifier for the snapshot delete.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        snapshotCreationTimestamp: ClientRuntime.Date? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotCreationTimestamp = snapshotCreationTimestamp
        self.snapshotName = snapshotName
    }
}

struct DeleteApplicationSnapshotInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let snapshotName: Swift.String?
    let snapshotCreationTimestamp: ClientRuntime.Date?
}

extension DeleteApplicationSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
        case snapshotName = "SnapshotName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotCreationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreationTimestamp)
        snapshotCreationTimestamp = snapshotCreationTimestampDecoded
    }
}

extension DeleteApplicationSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationSnapshotOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationSnapshotOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteApplicationVpcConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfigurationId = "VpcConfigurationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let conditionalToken = self.conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let vpcConfigurationId = self.vpcConfigurationId {
            try encodeContainer.encode(vpcConfigurationId, forKey: .vpcConfigurationId)
        }
    }
}

extension DeleteApplicationVpcConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationVpcConfigurationInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the VPC configuration to delete.
    /// This member is required.
    public var vpcConfigurationId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        vpcConfigurationId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.vpcConfigurationId = vpcConfigurationId
    }
}

struct DeleteApplicationVpcConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let vpcConfigurationId: Swift.String?
    let conditionalToken: Swift.String?
}

extension DeleteApplicationVpcConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfigurationId = "VpcConfigurationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let vpcConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConfigurationId)
        vpcConfigurationId = vpcConfigurationIdDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension DeleteApplicationVpcConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationVpcConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationVpcConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationVpcConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteApplicationVpcConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationVpcConfigurationOutputResponse: Swift.Equatable {
    /// The ARN of the Kinesis Data Analytics application.
    public var applicationARN: Swift.String?
    /// The updated version ID of the application.
    public var applicationVersionId: Swift.Int?

    public init (
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationVpcConfigurationOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationVersionId: Swift.Int?
}

extension DeleteApplicationVpcConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ContentLocation = "S3ContentLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocation = self.s3ContentLocation {
            try encodeContainer.encode(s3ContentLocation, forKey: .s3ContentLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ContentLocationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation.self, forKey: .s3ContentLocation)
        s3ContentLocation = s3ContentLocationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
    public struct DeployAsApplicationConfiguration: Swift.Equatable {
        /// The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        /// This member is required.
        public var s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation?

        public init (
            s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation? = nil
        )
        {
            self.s3ContentLocation = s3ContentLocation
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ContentLocationDescription = "S3ContentLocationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocationDescription = self.s3ContentLocationDescription {
            try encodeContainer.encode(s3ContentLocationDescription, forKey: .s3ContentLocationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ContentLocationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription.self, forKey: .s3ContentLocationDescription)
        s3ContentLocationDescription = s3ContentLocationDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.
    public struct DeployAsApplicationConfigurationDescription: Swift.Equatable {
        /// The location that holds the data required to specify an Amazon Data Analytics application.
        /// This member is required.
        public var s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription?

        public init (
            s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription? = nil
        )
        {
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ContentLocationUpdate = "S3ContentLocationUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocationUpdate = self.s3ContentLocationUpdate {
            try encodeContainer.encode(s3ContentLocationUpdate, forKey: .s3ContentLocationUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ContentLocationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate.self, forKey: .s3ContentLocationUpdate)
        s3ContentLocationUpdate = s3ContentLocationUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.
    public struct DeployAsApplicationConfigurationUpdate: Swift.Equatable {
        /// Updates to the location that holds the data required to specify an Amazon Data Analytics application.
        public var s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate?

        public init (
            s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate? = nil
        )
        {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
        }
    }

}

extension DescribeApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case includeAdditionalDetails = "IncludeAdditionalDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let includeAdditionalDetails = self.includeAdditionalDetails {
            try encodeContainer.encode(includeAdditionalDetails, forKey: .includeAdditionalDetails)
        }
    }
}

extension DescribeApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.
    public var includeAdditionalDetails: Swift.Bool?

    public init (
        applicationName: Swift.String? = nil,
        includeAdditionalDetails: Swift.Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.includeAdditionalDetails = includeAdditionalDetails
    }
}

struct DescribeApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let includeAdditionalDetails: Swift.Bool?
}

extension DescribeApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case includeAdditionalDetails = "IncludeAdditionalDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let includeAdditionalDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAdditionalDetails)
        includeAdditionalDetails = includeAdditionalDetailsDecoded
    }
}

extension DescribeApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct DescribeApplicationOutputResponse: Swift.Equatable {
    /// Provides a description of the application, such as the application's Amazon Resource Name (ARN), status, and latest version.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init (
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct DescribeApplicationOutputResponseBody: Swift.Equatable {
    let applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
}

extension DescribeApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension DescribeApplicationSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension DescribeApplicationSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationSnapshotInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The identifier of an application snapshot. You can retrieve this value using .
    /// This member is required.
    public var snapshotName: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotName = snapshotName
    }
}

struct DescribeApplicationSnapshotInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let snapshotName: Swift.String?
}

extension DescribeApplicationSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension DescribeApplicationSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationSnapshotOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshotDetails = output.snapshotDetails
        } else {
            self.snapshotDetails = nil
        }
    }
}

public struct DescribeApplicationSnapshotOutputResponse: Swift.Equatable {
    /// An object containing information about the application snapshot.
    /// This member is required.
    public var snapshotDetails: KinesisAnalyticsV2ClientTypes.SnapshotDetails?

    public init (
        snapshotDetails: KinesisAnalyticsV2ClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshotDetails = snapshotDetails
    }
}

struct DescribeApplicationSnapshotOutputResponseBody: Swift.Equatable {
    let snapshotDetails: KinesisAnalyticsV2ClientTypes.SnapshotDetails?
}

extension DescribeApplicationSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDetails = "SnapshotDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDetailsDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SnapshotDetails.self, forKey: .snapshotDetails)
        snapshotDetails = snapshotDetailsDecoded
    }
}

extension DescribeApplicationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case applicationVersionId = "ApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationVersionId = self.applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
    }
}

extension DescribeApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationVersionInput: Swift.Equatable {
    /// The name of the application for which you want to get the version description.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The ID of the application version for which you want to get the description.
    /// This member is required.
    public var applicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationVersionId = applicationVersionId
    }
}

struct DescribeApplicationVersionInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let applicationVersionId: Swift.Int?
}

extension DescribeApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DescribeApplicationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationVersionDetail = output.applicationVersionDetail
        } else {
            self.applicationVersionDetail = nil
        }
    }
}

public struct DescribeApplicationVersionOutputResponse: Swift.Equatable {
    /// Describes the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configurations.
    public var applicationVersionDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init (
        applicationVersionDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationVersionDetail = applicationVersionDetail
    }
}

struct DescribeApplicationVersionOutputResponseBody: Swift.Equatable {
    let applicationVersionDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
}

extension DescribeApplicationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersionDetail = "ApplicationVersionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionDetailDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationDetail.self, forKey: .applicationVersionDetail)
        applicationVersionDetail = applicationVersionDetailDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes.DestinationSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordFormatType = self.recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the data format when records are written to the destination in a SQL-based Kinesis Data Analytics application.
    public struct DestinationSchema: Swift.Equatable {
        /// Specifies the format of the records on the output stream.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType?

        public init (
            recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType? = nil
        )
        {
            self.recordFormatType = recordFormatType
        }
    }

}

extension DiscoverInputSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case s3Configuration = "S3Configuration"
        case serviceExecutionRole = "ServiceExecutionRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputProcessingConfiguration = self.inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputStartingPositionConfiguration = self.inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let serviceExecutionRole = self.serviceExecutionRole {
            try encodeContainer.encode(serviceExecutionRole, forKey: .serviceExecutionRole)
        }
    }
}

extension DiscoverInputSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DiscoverInputSchemaInput: Swift.Equatable {
    /// The [InputProcessingConfiguration] to use to preprocess the records before discovering the schema of the records.
    public var inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?
    /// The point at which you want Kinesis Data Analytics to start reading records from the specified streaming source discovery purposes.
    public var inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?
    /// The Amazon Resource Name (ARN) of the streaming source.
    public var resourceARN: Swift.String?
    /// Specify this parameter to discover a schema from data in an Amazon S3 object.
    public var s3Configuration: KinesisAnalyticsV2ClientTypes.S3Configuration?
    /// The ARN of the role that is used to access the streaming source.
    /// This member is required.
    public var serviceExecutionRole: Swift.String?

    public init (
        inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration? = nil,
        inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration? = nil,
        resourceARN: Swift.String? = nil,
        s3Configuration: KinesisAnalyticsV2ClientTypes.S3Configuration? = nil,
        serviceExecutionRole: Swift.String? = nil
    )
    {
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.resourceARN = resourceARN
        self.s3Configuration = s3Configuration
        self.serviceExecutionRole = serviceExecutionRole
    }
}

struct DiscoverInputSchemaInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let serviceExecutionRole: Swift.String?
    let inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?
    let s3Configuration: KinesisAnalyticsV2ClientTypes.S3Configuration?
    let inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?
}

extension DiscoverInputSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case s3Configuration = "S3Configuration"
        case serviceExecutionRole = "ServiceExecutionRole"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let serviceExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRole)
        serviceExecutionRole = serviceExecutionRoleDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension DiscoverInputSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInputSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceProvisionedThroughputExceededException" : self = .resourceProvisionedThroughputExceededException(try ResourceProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnableToDetectSchemaException" : self = .unableToDetectSchemaException(try UnableToDetectSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DiscoverInputSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceProvisionedThroughputExceededException(ResourceProvisionedThroughputExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unableToDetectSchemaException(UnableToDetectSchemaException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInputSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DiscoverInputSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputSchema = output.inputSchema
            self.parsedInputRecords = output.parsedInputRecords
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.inputSchema = nil
            self.parsedInputRecords = nil
            self.processedInputRecords = nil
            self.rawInputRecords = nil
        }
    }
}

public struct DiscoverInputSchemaOutputResponse: Swift.Equatable {
    /// The schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.
    public var inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
    /// An array of elements, where each element corresponds to a row in a stream record (a stream record can have more than one row).
    public var parsedInputRecords: [[Swift.String]]?
    /// The stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
    public var processedInputRecords: [Swift.String]?
    /// The raw stream data that was sampled to infer the schema.
    public var rawInputRecords: [Swift.String]?

    public init (
        inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
        parsedInputRecords: [[Swift.String]]? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.inputSchema = inputSchema
        self.parsedInputRecords = parsedInputRecords
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct DiscoverInputSchemaOutputResponseBody: Swift.Equatable {
    let inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
    let parsedInputRecords: [[Swift.String]]?
    let processedInputRecords: [Swift.String]?
    let rawInputRecords: [Swift.String]?
}

extension DiscoverInputSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSchema = "InputSchema"
        case parsedInputRecords = "ParsedInputRecords"
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let parsedInputRecordsContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .parsedInputRecords)
        var parsedInputRecordsDecoded0:[[Swift.String]]? = nil
        if let parsedInputRecordsContainer = parsedInputRecordsContainer {
            parsedInputRecordsDecoded0 = [[Swift.String]]()
            for list0 in parsedInputRecordsContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parsedInputRecordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parsedInputRecords = parsedInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[Swift.String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [Swift.String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[Swift.String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [Swift.String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes.EnvironmentProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyGroups = "PropertyGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyGroups)
            for propertygroup0 in propertyGroups {
                try propertyGroupsContainer.encode(propertygroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.PropertyGroup?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0:[KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [KinesisAnalyticsV2ClientTypes.PropertyGroup]()
            for structure0 in propertyGroupsContainer {
                if let structure0 = structure0 {
                    propertyGroupsDecoded0?.append(structure0)
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes execution properties for a Flink-based Kinesis Data Analytics application.
    public struct EnvironmentProperties: Swift.Equatable {
        /// Describes the execution property groups.
        /// This member is required.
        public var propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]?

        public init (
            propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        )
        {
            self.propertyGroups = propertyGroups
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyGroupDescriptions = "PropertyGroupDescriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroupDescriptions = propertyGroupDescriptions {
            var propertyGroupDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyGroupDescriptions)
            for propertygroup0 in propertyGroupDescriptions {
                try propertyGroupDescriptionsContainer.encode(propertygroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.PropertyGroup?].self, forKey: .propertyGroupDescriptions)
        var propertyGroupDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        if let propertyGroupDescriptionsContainer = propertyGroupDescriptionsContainer {
            propertyGroupDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.PropertyGroup]()
            for structure0 in propertyGroupDescriptionsContainer {
                if let structure0 = structure0 {
                    propertyGroupDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        propertyGroupDescriptions = propertyGroupDescriptionsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the execution properties for an Apache Flink runtime.
    public struct EnvironmentPropertyDescriptions: Swift.Equatable {
        /// Describes the execution property groups.
        public var propertyGroupDescriptions: [KinesisAnalyticsV2ClientTypes.PropertyGroup]?

        public init (
            propertyGroupDescriptions: [KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        )
        {
            self.propertyGroupDescriptions = propertyGroupDescriptions
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyGroups = "PropertyGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyGroups)
            for propertygroup0 in propertyGroups {
                try propertyGroupsContainer.encode(propertygroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.PropertyGroup?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0:[KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [KinesisAnalyticsV2ClientTypes.PropertyGroup]()
            for structure0 in propertyGroupsContainer {
                if let structure0 = structure0 {
                    propertyGroupsDecoded0?.append(structure0)
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the execution property groups for a Flink-based Kinesis Data Analytics application or a Studio notebook.
    public struct EnvironmentPropertyUpdates: Swift.Equatable {
        /// Describes updates to the execution property groups.
        /// This member is required.
        public var propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]?

        public init (
            propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        )
        {
            self.propertyGroups = propertyGroups
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointConfiguration = "CheckpointConfiguration"
        case monitoringConfiguration = "MonitoringConfiguration"
        case parallelismConfiguration = "ParallelismConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointConfiguration = self.checkpointConfiguration {
            try encodeContainer.encode(checkpointConfiguration, forKey: .checkpointConfiguration)
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
        if let parallelismConfiguration = self.parallelismConfiguration {
            try encodeContainer.encode(parallelismConfiguration, forKey: .parallelismConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkpointConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CheckpointConfiguration.self, forKey: .checkpointConfiguration)
        checkpointConfiguration = checkpointConfigurationDecoded
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
        let parallelismConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ParallelismConfiguration.self, forKey: .parallelismConfiguration)
        parallelismConfiguration = parallelismConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.
    public struct FlinkApplicationConfiguration: Swift.Equatable {
        /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see [ Checkpoints for Fault Tolerance](https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance) in the [Apache Flink Documentation](https://ci.apache.org/projects/flink/flink-docs-release-1.8/).
        public var checkpointConfiguration: KinesisAnalyticsV2ClientTypes.CheckpointConfiguration?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public var monitoringConfiguration: KinesisAnalyticsV2ClientTypes.MonitoringConfiguration?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public var parallelismConfiguration: KinesisAnalyticsV2ClientTypes.ParallelismConfiguration?

        public init (
            checkpointConfiguration: KinesisAnalyticsV2ClientTypes.CheckpointConfiguration? = nil,
            monitoringConfiguration: KinesisAnalyticsV2ClientTypes.MonitoringConfiguration? = nil,
            parallelismConfiguration: KinesisAnalyticsV2ClientTypes.ParallelismConfiguration? = nil
        )
        {
            self.checkpointConfiguration = checkpointConfiguration
            self.monitoringConfiguration = monitoringConfiguration
            self.parallelismConfiguration = parallelismConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointConfigurationDescription = "CheckpointConfigurationDescription"
        case jobPlanDescription = "JobPlanDescription"
        case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
        case parallelismConfigurationDescription = "ParallelismConfigurationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointConfigurationDescription = self.checkpointConfigurationDescription {
            try encodeContainer.encode(checkpointConfigurationDescription, forKey: .checkpointConfigurationDescription)
        }
        if let jobPlanDescription = self.jobPlanDescription {
            try encodeContainer.encode(jobPlanDescription, forKey: .jobPlanDescription)
        }
        if let monitoringConfigurationDescription = self.monitoringConfigurationDescription {
            try encodeContainer.encode(monitoringConfigurationDescription, forKey: .monitoringConfigurationDescription)
        }
        if let parallelismConfigurationDescription = self.parallelismConfigurationDescription {
            try encodeContainer.encode(parallelismConfigurationDescription, forKey: .parallelismConfigurationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkpointConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription.self, forKey: .checkpointConfigurationDescription)
        checkpointConfigurationDescription = checkpointConfigurationDescriptionDecoded
        let monitoringConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription.self, forKey: .monitoringConfigurationDescription)
        monitoringConfigurationDescription = monitoringConfigurationDescriptionDecoded
        let parallelismConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription.self, forKey: .parallelismConfigurationDescription)
        parallelismConfigurationDescription = parallelismConfigurationDescriptionDecoded
        let jobPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobPlanDescription)
        jobPlanDescription = jobPlanDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for a Flink-based Kinesis Data Analytics application.
    public struct FlinkApplicationConfigurationDescription: Swift.Equatable {
        /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance.
        public var checkpointConfigurationDescription: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription?
        /// The job plan for an application. For more information about the job plan, see [Jobs and Scheduling](https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html) in the [Apache Flink Documentation](https://ci.apache.org/projects/flink/flink-docs-release-1.8/). To retrieve the job plan for the application, use the [DescribeApplicationRequest$IncludeAdditionalDetails] parameter of the [DescribeApplication] operation.
        public var jobPlanDescription: Swift.String?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public var monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public var parallelismConfigurationDescription: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription?

        public init (
            checkpointConfigurationDescription: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription? = nil,
            jobPlanDescription: Swift.String? = nil,
            monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription? = nil,
            parallelismConfigurationDescription: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription? = nil
        )
        {
            self.checkpointConfigurationDescription = checkpointConfigurationDescription
            self.jobPlanDescription = jobPlanDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
            self.parallelismConfigurationDescription = parallelismConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointConfigurationUpdate = "CheckpointConfigurationUpdate"
        case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
        case parallelismConfigurationUpdate = "ParallelismConfigurationUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointConfigurationUpdate = self.checkpointConfigurationUpdate {
            try encodeContainer.encode(checkpointConfigurationUpdate, forKey: .checkpointConfigurationUpdate)
        }
        if let monitoringConfigurationUpdate = self.monitoringConfigurationUpdate {
            try encodeContainer.encode(monitoringConfigurationUpdate, forKey: .monitoringConfigurationUpdate)
        }
        if let parallelismConfigurationUpdate = self.parallelismConfigurationUpdate {
            try encodeContainer.encode(parallelismConfigurationUpdate, forKey: .parallelismConfigurationUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkpointConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate.self, forKey: .checkpointConfigurationUpdate)
        checkpointConfigurationUpdate = checkpointConfigurationUpdateDecoded
        let monitoringConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate.self, forKey: .monitoringConfigurationUpdate)
        monitoringConfigurationUpdate = monitoringConfigurationUpdateDecoded
        let parallelismConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate.self, forKey: .parallelismConfigurationUpdate)
        parallelismConfigurationUpdate = parallelismConfigurationUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the configuration parameters for a Flink-based Kinesis Data Analytics application.
    public struct FlinkApplicationConfigurationUpdate: Swift.Equatable {
        /// Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance.
        public var checkpointConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate?
        /// Describes updates to the configuration parameters for Amazon CloudWatch logging for an application.
        public var monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate?
        /// Describes updates to the parameters for how an application executes multiple tasks simultaneously.
        public var parallelismConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate?

        public init (
            checkpointConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate? = nil,
            monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate? = nil,
            parallelismConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate? = nil
        )
        {
            self.checkpointConfigurationUpdate = checkpointConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
            self.parallelismConfigurationUpdate = parallelismConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowNonRestoredState = "AllowNonRestoredState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowNonRestoredState = self.allowNonRestoredState {
            try encodeContainer.encode(allowNonRestoredState, forKey: .allowNonRestoredState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowNonRestoredStateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowNonRestoredState)
        allowNonRestoredState = allowNonRestoredStateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
    public struct FlinkRunConfiguration: Swift.Equatable {
        /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. This will happen if the program is updated between snapshots to remove stateful parameters, and state data in the snapshot no longer corresponds to valid application data. For more information, see [ Allowing Non-Restored State](https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state) in the [Apache Flink documentation](https://ci.apache.org/projects/flink/flink-docs-release-1.8/). This value defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
        public var allowNonRestoredState: Swift.Bool?

        public init (
            allowNonRestoredState: Swift.Bool? = nil
        )
        {
            self.allowNonRestoredState = allowNonRestoredState
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseARN = "DatabaseARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseARN = self.databaseARN {
            try encodeContainer.encode(databaseARN, forKey: .databaseARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseARN)
        databaseARN = databaseARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
    public struct GlueDataCatalogConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the database.
        /// This member is required.
        public var databaseARN: Swift.String?

        public init (
            databaseARN: Swift.String? = nil
        )
        {
            self.databaseARN = databaseARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseARN = "DatabaseARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseARN = self.databaseARN {
            try encodeContainer.encode(databaseARN, forKey: .databaseARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseARN)
        databaseARN = databaseARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
    public struct GlueDataCatalogConfigurationDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the database.
        /// This member is required.
        public var databaseARN: Swift.String?

        public init (
            databaseARN: Swift.String? = nil
        )
        {
            self.databaseARN = databaseARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseARNUpdate = "DatabaseARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseARNUpdate = self.databaseARNUpdate {
            try encodeContainer.encode(databaseARNUpdate, forKey: .databaseARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseARNUpdate)
        databaseARNUpdate = databaseARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration of the Glue Data Catalog that you use for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
    public struct GlueDataCatalogConfigurationUpdate: Swift.Equatable {
        /// The updated Amazon Resource Name (ARN) of the database.
        /// This member is required.
        public var databaseARNUpdate: Swift.String?

        public init (
            databaseARNUpdate: Swift.String? = nil
        )
        {
            self.databaseARNUpdate = databaseARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.Input: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputParallelism = "InputParallelism"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputSchema = "InputSchema"
        case kinesisFirehoseInput = "KinesisFirehoseInput"
        case kinesisStreamsInput = "KinesisStreamsInput"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputParallelism = self.inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfiguration = self.inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputSchema = self.inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let kinesisFirehoseInput = self.kinesisFirehoseInput {
            try encodeContainer.encode(kinesisFirehoseInput, forKey: .kinesisFirehoseInput)
        }
        if let kinesisStreamsInput = self.kinesisStreamsInput {
            try encodeContainer.encode(kinesisStreamsInput, forKey: .kinesisStreamsInput)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
        let kinesisStreamsInputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisStreamsInput.self, forKey: .kinesisStreamsInput)
        kinesisStreamsInput = kinesisStreamsInputDecoded
        let kinesisFirehoseInputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput.self, forKey: .kinesisFirehoseInput)
        kinesisFirehoseInput = kinesisFirehoseInputDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
    public struct Input: Swift.Equatable {
        /// Describes the number of in-application streams to create.
        public var inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism?
        /// The [InputProcessingConfiguration] for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is [InputLambdaProcessor].
        public var inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created. Also used to describe the format of the reference data source.
        /// This member is required.
        public var inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
        public var kinesisFirehoseInput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput?
        /// If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
        public var kinesisStreamsInput: KinesisAnalyticsV2ClientTypes.KinesisStreamsInput?
        /// The name prefix to use when creating an in-application stream. Suppose that you specify a prefix "MyInApplicationStream." Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on.
        /// This member is required.
        public var namePrefix: Swift.String?

        public init (
            inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism? = nil,
            inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration? = nil,
            inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            kinesisFirehoseInput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput? = nil,
            kinesisStreamsInput: KinesisAnalyticsV2ClientTypes.KinesisStreamsInput? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inputParallelism = inputParallelism
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputSchema = inputSchema
            self.kinesisFirehoseInput = kinesisFirehoseInput
            self.kinesisStreamsInput = kinesisStreamsInput
            self.namePrefix = namePrefix
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inAppStreamNames = "InAppStreamNames"
        case inputId = "InputId"
        case inputParallelism = "InputParallelism"
        case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
        case inputSchema = "InputSchema"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case kinesisFirehoseInputDescription = "KinesisFirehoseInputDescription"
        case kinesisStreamsInputDescription = "KinesisStreamsInputDescription"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inAppStreamNames = inAppStreamNames {
            var inAppStreamNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inAppStreamNames)
            for inappstreamname0 in inAppStreamNames {
                try inAppStreamNamesContainer.encode(inappstreamname0)
            }
        }
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelism = self.inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfigurationDescription = self.inputProcessingConfigurationDescription {
            try encodeContainer.encode(inputProcessingConfigurationDescription, forKey: .inputProcessingConfigurationDescription)
        }
        if let inputSchema = self.inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let inputStartingPositionConfiguration = self.inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let kinesisFirehoseInputDescription = self.kinesisFirehoseInputDescription {
            try encodeContainer.encode(kinesisFirehoseInputDescription, forKey: .kinesisFirehoseInputDescription)
        }
        if let kinesisStreamsInputDescription = self.kinesisStreamsInputDescription {
            try encodeContainer.encode(kinesisStreamsInputDescription, forKey: .kinesisStreamsInputDescription)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inAppStreamNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inAppStreamNames)
        var inAppStreamNamesDecoded0:[Swift.String]? = nil
        if let inAppStreamNamesContainer = inAppStreamNamesContainer {
            inAppStreamNamesDecoded0 = [Swift.String]()
            for string0 in inAppStreamNamesContainer {
                if let string0 = string0 {
                    inAppStreamNamesDecoded0?.append(string0)
                }
            }
        }
        inAppStreamNames = inAppStreamNamesDecoded0
        let inputProcessingConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription.self, forKey: .inputProcessingConfigurationDescription)
        inputProcessingConfigurationDescription = inputProcessingConfigurationDescriptionDecoded
        let kinesisStreamsInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription.self, forKey: .kinesisStreamsInputDescription)
        kinesisStreamsInputDescription = kinesisStreamsInputDescriptionDecoded
        let kinesisFirehoseInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription.self, forKey: .kinesisFirehoseInputDescription)
        kinesisFirehoseInputDescription = kinesisFirehoseInputDescriptionDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the application input configuration for a SQL-based Kinesis Data Analytics application.
    public struct InputDescription: Swift.Equatable {
        /// Returns the in-application stream names that are mapped to the stream source.
        public var inAppStreamNames: [Swift.String]?
        /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input configuration that you add to your application.
        public var inputId: Swift.String?
        /// Describes the configured parallelism (number of in-application streams mapped to the streaming source).
        public var inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public var inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
        public var inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// The point at which the application is configured to read from the input stream.
        public var inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?
        /// If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN.
        public var kinesisFirehoseInputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription?
        /// If a Kinesis data stream is configured as a streaming source, provides the Kinesis data stream's Amazon Resource Name (ARN).
        public var kinesisStreamsInputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription?
        /// The in-application name prefix.
        public var namePrefix: Swift.String?

        public init (
            inAppStreamNames: [Swift.String]? = nil,
            inputId: Swift.String? = nil,
            inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism? = nil,
            inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription? = nil,
            inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration? = nil,
            kinesisFirehoseInputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription? = nil,
            kinesisStreamsInputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inAppStreamNames = inAppStreamNames
            self.inputId = inputId
            self.inputParallelism = inputParallelism
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
            self.inputSchema = inputSchema
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
            self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
            self.namePrefix = namePrefix
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputLambdaProcessor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
    public struct InputLambdaProcessor: Swift.Equatable {
        /// The ARN of the Amazon Lambda function that operates on records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, an object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream.
    public struct InputLambdaProcessorDescription: Swift.Equatable {
        /// The ARN of the Amazon Lambda function that is used to preprocess the records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that is used to access the Amazon Lambda function. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, represents an update to the [InputLambdaProcessor] that is used to preprocess the records in the stream.
    public struct InputLambdaProcessorUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess the records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputParallelism: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
    public struct InputParallelism: Swift.Equatable {
        /// The number of in-application streams to create.
        public var count: Swift.Int?

        public init (
            count: Swift.Int? = nil
        )
        {
            self.count = count
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputParallelismUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countUpdate = "CountUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countUpdate = self.countUpdate {
            try encodeContainer.encode(countUpdate, forKey: .countUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countUpdateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countUpdate)
        countUpdate = countUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides updates to the parallelism count.
    public struct InputParallelismUpdate: Swift.Equatable {
        /// The number of in-application streams to create for the specified streaming source.
        /// This member is required.
        public var countUpdate: Swift.Int?

        public init (
            countUpdate: Swift.Int? = nil
        )
        {
            self.countUpdate = countUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLambdaProcessor = "InputLambdaProcessor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessor = self.inputLambdaProcessor {
            try encodeContainer.encode(inputLambdaProcessor, forKey: .inputLambdaProcessor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputLambdaProcessor.self, forKey: .inputLambdaProcessor)
        inputLambdaProcessor = inputLambdaProcessorDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is [Amazon Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfiguration: Swift.Equatable {
        /// The [InputLambdaProcessor] that is used to preprocess the records in the stream before being processed by your application code.
        /// This member is required.
        public var inputLambdaProcessor: KinesisAnalyticsV2ClientTypes.InputLambdaProcessor?

        public init (
            inputLambdaProcessor: KinesisAnalyticsV2ClientTypes.InputLambdaProcessor? = nil
        )
        {
            self.inputLambdaProcessor = inputLambdaProcessor
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLambdaProcessorDescription = "InputLambdaProcessorDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorDescription = self.inputLambdaProcessorDescription {
            try encodeContainer.encode(inputLambdaProcessorDescription, forKey: .inputLambdaProcessorDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription.self, forKey: .inputLambdaProcessorDescription)
        inputLambdaProcessorDescription = inputLambdaProcessorDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides the configuration information about an input processor. Currently, the only input processor available is [Amazon Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfigurationDescription: Swift.Equatable {
        /// Provides configuration information about the associated [InputLambdaProcessorDescription]
        public var inputLambdaProcessorDescription: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription?

        public init (
            inputLambdaProcessorDescription: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription? = nil
        )
        {
            self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLambdaProcessorUpdate = "InputLambdaProcessorUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorUpdate = self.inputLambdaProcessorUpdate {
            try encodeContainer.encode(inputLambdaProcessorUpdate, forKey: .inputLambdaProcessorUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate.self, forKey: .inputLambdaProcessorUpdate)
        inputLambdaProcessorUpdate = inputLambdaProcessorUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes updates to an [InputProcessingConfiguration].
    public struct InputProcessingConfigurationUpdate: Swift.Equatable {
        /// Provides update information for an [InputLambdaProcessor].
        /// This member is required.
        public var inputLambdaProcessorUpdate: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate?

        public init (
            inputLambdaProcessorUpdate: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate? = nil
        )
        {
            self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputSchemaUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordColumnUpdates = "RecordColumnUpdates"
        case recordEncodingUpdate = "RecordEncodingUpdate"
        case recordFormatUpdate = "RecordFormatUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnUpdates = recordColumnUpdates {
            var recordColumnUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumnUpdates)
            for recordcolumn0 in recordColumnUpdates {
                try recordColumnUpdatesContainer.encode(recordcolumn0)
            }
        }
        if let recordEncodingUpdate = self.recordEncodingUpdate {
            try encodeContainer.encode(recordEncodingUpdate, forKey: .recordEncodingUpdate)
        }
        if let recordFormatUpdate = self.recordFormatUpdate {
            try encodeContainer.encode(recordFormatUpdate, forKey: .recordFormatUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RecordFormat.self, forKey: .recordFormatUpdate)
        recordFormatUpdate = recordFormatUpdateDecoded
        let recordEncodingUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordEncodingUpdate)
        recordEncodingUpdate = recordEncodingUpdateDecoded
        let recordColumnUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.RecordColumn?].self, forKey: .recordColumnUpdates)
        var recordColumnUpdatesDecoded0:[KinesisAnalyticsV2ClientTypes.RecordColumn]? = nil
        if let recordColumnUpdatesContainer = recordColumnUpdatesContainer {
            recordColumnUpdatesDecoded0 = [KinesisAnalyticsV2ClientTypes.RecordColumn]()
            for structure0 in recordColumnUpdatesContainer {
                if let structure0 = structure0 {
                    recordColumnUpdatesDecoded0?.append(structure0)
                }
            }
        }
        recordColumnUpdates = recordColumnUpdatesDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates for an SQL-based Kinesis Data Analytics application's input schema.
    public struct InputSchemaUpdate: Swift.Equatable {
        /// A list of RecordColumn objects. Each object describes the mapping of the streaming source element to the corresponding column in the in-application stream.
        public var recordColumnUpdates: [KinesisAnalyticsV2ClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source; for example, UTF-8.
        public var recordEncodingUpdate: Swift.String?
        /// Specifies the format of the records on the streaming source.
        public var recordFormatUpdate: KinesisAnalyticsV2ClientTypes.RecordFormat?

        public init (
            recordColumnUpdates: [KinesisAnalyticsV2ClientTypes.RecordColumn]? = nil,
            recordEncodingUpdate: Swift.String? = nil,
            recordFormatUpdate: KinesisAnalyticsV2ClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumnUpdates = recordColumnUpdates
            self.recordEncodingUpdate = recordEncodingUpdate
            self.recordFormatUpdate = recordFormatUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum InputStartingPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastStoppedPoint
        case now
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStartingPosition] {
            return [
                .lastStoppedPoint,
                .now,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastStoppedPoint: return "LAST_STOPPED_POINT"
            case .now: return "NOW"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputStartingPosition(rawValue: rawValue) ?? InputStartingPosition.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStartingPosition = "InputStartingPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStartingPosition = self.inputStartingPosition {
            try encodeContainer.encode(inputStartingPosition.rawValue, forKey: .inputStartingPosition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStartingPositionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputStartingPosition.self, forKey: .inputStartingPosition)
        inputStartingPosition = inputStartingPositionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the point at which the application reads from the streaming source.
    public struct InputStartingPositionConfiguration: Swift.Equatable {
        /// The starting position on the stream.
        ///
        /// * NOW - Start reading just after the most recent record in the stream, and start at the request timestamp that the customer issued.
        ///
        /// * TRIM_HORIZON - Start reading at the last untrimmed record in the stream, which is the oldest record available in the stream. This option is not available for an Amazon Kinesis Data Firehose delivery stream.
        ///
        /// * LAST_STOPPED_POINT - Resume reading from where the application last stopped reading.
        public var inputStartingPosition: KinesisAnalyticsV2ClientTypes.InputStartingPosition?

        public init (
            inputStartingPosition: KinesisAnalyticsV2ClientTypes.InputStartingPosition? = nil
        )
        {
            self.inputStartingPosition = inputStartingPosition
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.InputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputId = "InputId"
        case inputParallelismUpdate = "InputParallelismUpdate"
        case inputProcessingConfigurationUpdate = "InputProcessingConfigurationUpdate"
        case inputSchemaUpdate = "InputSchemaUpdate"
        case kinesisFirehoseInputUpdate = "KinesisFirehoseInputUpdate"
        case kinesisStreamsInputUpdate = "KinesisStreamsInputUpdate"
        case namePrefixUpdate = "NamePrefixUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelismUpdate = self.inputParallelismUpdate {
            try encodeContainer.encode(inputParallelismUpdate, forKey: .inputParallelismUpdate)
        }
        if let inputProcessingConfigurationUpdate = self.inputProcessingConfigurationUpdate {
            try encodeContainer.encode(inputProcessingConfigurationUpdate, forKey: .inputProcessingConfigurationUpdate)
        }
        if let inputSchemaUpdate = self.inputSchemaUpdate {
            try encodeContainer.encode(inputSchemaUpdate, forKey: .inputSchemaUpdate)
        }
        if let kinesisFirehoseInputUpdate = self.kinesisFirehoseInputUpdate {
            try encodeContainer.encode(kinesisFirehoseInputUpdate, forKey: .kinesisFirehoseInputUpdate)
        }
        if let kinesisStreamsInputUpdate = self.kinesisStreamsInputUpdate {
            try encodeContainer.encode(kinesisStreamsInputUpdate, forKey: .kinesisStreamsInputUpdate)
        }
        if let namePrefixUpdate = self.namePrefixUpdate {
            try encodeContainer.encode(namePrefixUpdate, forKey: .namePrefixUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefixUpdate)
        namePrefixUpdate = namePrefixUpdateDecoded
        let inputProcessingConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate.self, forKey: .inputProcessingConfigurationUpdate)
        inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdateDecoded
        let kinesisStreamsInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate.self, forKey: .kinesisStreamsInputUpdate)
        kinesisStreamsInputUpdate = kinesisStreamsInputUpdateDecoded
        let kinesisFirehoseInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate.self, forKey: .kinesisFirehoseInputUpdate)
        kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdateDecoded
        let inputSchemaUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputSchemaUpdate.self, forKey: .inputSchemaUpdate)
        inputSchemaUpdate = inputSchemaUpdateDecoded
        let inputParallelismUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputParallelismUpdate.self, forKey: .inputParallelismUpdate)
        inputParallelismUpdate = inputParallelismUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes updates to a specific input configuration (identified by the InputId of an application).
    public struct InputUpdate: Swift.Equatable {
        /// The input ID of the application input to be updated.
        /// This member is required.
        public var inputId: Swift.String?
        /// Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).
        public var inputParallelismUpdate: KinesisAnalyticsV2ClientTypes.InputParallelismUpdate?
        /// Describes updates to an [InputProcessingConfiguration].
        public var inputProcessingConfigurationUpdate: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate?
        /// Describes the data format on the streaming source, and how record elements on the streaming source map to columns of the in-application stream that is created.
        public var inputSchemaUpdate: KinesisAnalyticsV2ClientTypes.InputSchemaUpdate?
        /// If a Kinesis Data Firehose delivery stream is the streaming source to be updated, provides an updated stream ARN.
        public var kinesisFirehoseInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate?
        /// If a Kinesis data stream is the streaming source to be updated, provides an updated stream Amazon Resource Name (ARN).
        public var kinesisStreamsInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate?
        /// The name prefix for in-application streams that Kinesis Data Analytics creates for the specific streaming source.
        public var namePrefixUpdate: Swift.String?

        public init (
            inputId: Swift.String? = nil,
            inputParallelismUpdate: KinesisAnalyticsV2ClientTypes.InputParallelismUpdate? = nil,
            inputProcessingConfigurationUpdate: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate? = nil,
            inputSchemaUpdate: KinesisAnalyticsV2ClientTypes.InputSchemaUpdate? = nil,
            kinesisFirehoseInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate? = nil,
            kinesisStreamsInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate? = nil,
            namePrefixUpdate: Swift.String? = nil
        )
        {
            self.inputId = inputId
            self.inputParallelismUpdate = inputParallelismUpdate
            self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
            self.inputSchemaUpdate = inputSchemaUpdate
            self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
            self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
            self.namePrefixUpdate = namePrefixUpdate
        }
    }

}

extension InvalidApplicationConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApplicationConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user-provided application configuration is not valid.
public struct InvalidApplicationConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApplicationConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApplicationConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified input parameter value is not valid.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request JSON is not valid for the operation.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes.JSONMappingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordRowPath = "RecordRowPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordRowPath = self.recordRowPath {
            try encodeContainer.encode(recordRowPath, forKey: .recordRowPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordRowPath)
        recordRowPath = recordRowPathDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
    public struct JSONMappingParameters: Swift.Equatable {
        /// The path to the top-level parent that contains the records.
        /// This member is required.
        public var recordRowPath: Swift.String?

        public init (
            recordRowPath: Swift.String? = nil
        )
        {
            self.recordRowPath = recordRowPath
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN).
    public struct KinesisFirehoseInput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the Amazon Kinesis Data Firehose delivery stream that is configured as the streaming source in the application input configuration.
    public struct KinesisFirehoseInputDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, when updating application input configuration, provides information about a Kinesis Data Firehose delivery stream as the streaming source.
    public struct KinesisFirehoseInputUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the input delivery stream to read.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, when configuring application output, identifies a Kinesis Data Firehose delivery stream as the destination. You provide the stream Amazon Resource Name (ARN) of the delivery stream.
    public struct KinesisFirehoseOutput: Swift.Equatable {
        /// The ARN of the destination delivery stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application's output, describes the Kinesis Data Firehose delivery stream that is configured as its destination.
    public struct KinesisFirehoseOutputDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, when updating an output configuration using the [UpdateApplication] operation, provides information about a Kinesis Data Firehose delivery stream that is configured as the destination.
    public struct KinesisFirehoseOutputUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream to write to.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Identifies a Kinesis data stream as the streaming source. You provide the stream's Amazon Resource Name (ARN).
    public struct KinesisStreamsInput: Swift.Equatable {
        /// The ARN of the input Kinesis data stream to read.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the Kinesis data stream that is configured as the streaming source in the application input configuration.
    public struct KinesisStreamsInputDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update the input configuration for a SQL-based Kinesis Data Analytics application, provides information about a Kinesis stream as the streaming source.
    public struct KinesisStreamsInputUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the input Kinesis data stream to read.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure a SQL-based Kinesis Data Analytics application's output, identifies a Kinesis data stream as the destination. You provide the stream Amazon Resource Name (ARN).
    public struct KinesisStreamsOutput: Swift.Equatable {
        /// The ARN of the destination Kinesis data stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For an SQL-based Kinesis Data Analytics application's output, describes the Kinesis data stream that is configured as its destination.
    public struct KinesisStreamsOutputDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update a SQL-based Kinesis Data Analytics application's output configuration using the [UpdateApplication] operation, provides information about a Kinesis data stream that is configured as the destination.
    public struct KinesisStreamsOutputUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the output.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.LambdaOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure a SQL-based Kinesis Data Analytics application's output, identifies an Amazon Lambda function as the destination. You provide the function Amazon Resource Name (ARN) of the Lambda function.
    public struct LambdaOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination Lambda function to write to. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.LambdaOutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application's output, describes the Amazon Lambda function that is configured as its destination.
    public struct LambdaOutputDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination Lambda function.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination function. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update an SQL-based Kinesis Data Analytics application's output configuration using the [UpdateApplication] operation, provides information about an Amazon Lambda function that is configured as the destination.
    public struct LambdaOutputUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination Amazon Lambda function. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of allowed resources has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationSnapshotsInput: Swift.Equatable {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The maximum number of application snapshots to list.
    public var limit: Swift.Int?
    /// Use this parameter if you receive a NextToken response in a previous request that indicates that there is more output available. Set it to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListApplicationSnapshotsInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshotSummaries = output.snapshotSummaries
        } else {
            self.nextToken = nil
            self.snapshotSummaries = nil
        }
    }
}

public struct ListApplicationSnapshotsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A collection of objects containing information about the application snapshots.
    public var snapshotSummaries: [KinesisAnalyticsV2ClientTypes.SnapshotDetails]?

    public init (
        nextToken: Swift.String? = nil,
        snapshotSummaries: [KinesisAnalyticsV2ClientTypes.SnapshotDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshotSummaries = snapshotSummaries
    }
}

struct ListApplicationSnapshotsOutputResponseBody: Swift.Equatable {
    let snapshotSummaries: [KinesisAnalyticsV2ClientTypes.SnapshotDetails]?
    let nextToken: Swift.String?
}

extension ListApplicationSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case snapshotSummaries = "SnapshotSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotSummariesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.SnapshotDetails?].self, forKey: .snapshotSummaries)
        var snapshotSummariesDecoded0:[KinesisAnalyticsV2ClientTypes.SnapshotDetails]? = nil
        if let snapshotSummariesContainer = snapshotSummariesContainer {
            snapshotSummariesDecoded0 = [KinesisAnalyticsV2ClientTypes.SnapshotDetails]()
            for structure0 in snapshotSummariesContainer {
                if let structure0 = structure0 {
                    snapshotSummariesDecoded0?.append(structure0)
                }
            }
        }
        snapshotSummaries = snapshotSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationVersionsInput: Swift.Equatable {
    /// The name of the application for which you want to list all versions.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The maximum number of versions to list in this invocation of the operation.
    public var limit: Swift.Int?
    /// If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationVersionSummaries = output.applicationVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.applicationVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationVersionsOutputResponse: Swift.Equatable {
    /// A list of the application versions and the associated configuration summaries. The list includes application versions that were rolled back. To get the complete description of a specific application version, invoke the [DescribeApplicationVersion] operation.
    public var applicationVersionSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]?
    /// The pagination token for the next set of results, or null if there are no additional results. To retrieve the next set of items, pass this token into a subsequent invocation of this operation. For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init (
        applicationVersionSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationVersionSummaries = applicationVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsOutputResponseBody: Swift.Equatable {
    let applicationVersionSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersionSummaries = "ApplicationVersionSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionSummariesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary?].self, forKey: .applicationVersionSummaries)
        var applicationVersionSummariesDecoded0:[KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]? = nil
        if let applicationVersionSummariesContainer = applicationVersionSummariesContainer {
            applicationVersionSummariesDecoded0 = [KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]()
            for structure0 in applicationVersionSummariesContainer {
                if let structure0 = structure0 {
                    applicationVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationVersionSummaries = applicationVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of applications to list.
    public var limit: Swift.Int?
    /// If a previous command returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationSummaries = output.applicationSummaries
            self.nextToken = output.nextToken
        } else {
            self.applicationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// A list of ApplicationSummary objects.
    /// This member is required.
    public var applicationSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationSummary]?
    /// The pagination token for the next set of results, or null if there are no additional results. Pass this token into a subsequent command to retrieve the next set of items For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init (
        applicationSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let applicationSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSummaries = "ApplicationSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummariesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.ApplicationSummary?].self, forKey: .applicationSummaries)
        var applicationSummariesDecoded0:[KinesisAnalyticsV2ClientTypes.ApplicationSummary]? = nil
        if let applicationSummariesContainer = applicationSummariesContainer {
            applicationSummariesDecoded0 = [KinesisAnalyticsV2ClientTypes.ApplicationSummary]()
            for structure0 in applicationSummariesContainer {
                if let structure0 = structure0 {
                    applicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaries = applicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the application for which to retrieve tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The key-value tags assigned to the application.
    public var tags: [KinesisAnalyticsV2ClientTypes.Tag]?

    public init (
        tags: [KinesisAnalyticsV2ClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [KinesisAnalyticsV2ClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisAnalyticsV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisAnalyticsV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .error,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.MappingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvMappingParameters = "CSVMappingParameters"
        case jsonMappingParameters = "JSONMappingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvMappingParameters = self.csvMappingParameters {
            try encodeContainer.encode(csvMappingParameters, forKey: .csvMappingParameters)
        }
        if let jsonMappingParameters = self.jsonMappingParameters {
            try encodeContainer.encode(jsonMappingParameters, forKey: .jsonMappingParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonMappingParametersDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.JSONMappingParameters.self, forKey: .jsonMappingParameters)
        jsonMappingParameters = jsonMappingParametersDecoded
        let csvMappingParametersDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CSVMappingParameters.self, forKey: .csvMappingParameters)
        csvMappingParameters = csvMappingParametersDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    public struct MappingParameters: Swift.Equatable {
        /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
        public var csvMappingParameters: KinesisAnalyticsV2ClientTypes.CSVMappingParameters?
        /// Provides additional mapping information when JSON is the record format on the streaming source.
        public var jsonMappingParameters: KinesisAnalyticsV2ClientTypes.JSONMappingParameters?

        public init (
            csvMappingParameters: KinesisAnalyticsV2ClientTypes.CSVMappingParameters? = nil,
            jsonMappingParameters: KinesisAnalyticsV2ClientTypes.JSONMappingParameters? = nil
        )
        {
            self.csvMappingParameters = csvMappingParameters
            self.jsonMappingParameters = jsonMappingParameters
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.MavenReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactId = "ArtifactId"
        case groupId = "GroupId"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactId = self.artifactId {
            try encodeContainer.encode(artifactId, forKey: .artifactId)
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let artifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactId)
        artifactId = artifactIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.
    public struct MavenReference: Swift.Equatable {
        /// The artifact ID of the Maven reference.
        /// This member is required.
        public var artifactId: Swift.String?
        /// The group ID of the Maven reference.
        /// This member is required.
        public var groupId: Swift.String?
        /// The version of the Maven reference.
        /// This member is required.
        public var version: Swift.String?

        public init (
            artifactId: Swift.String? = nil,
            groupId: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.artifactId = artifactId
            self.groupId = groupId
            self.version = version
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum MetricsLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case `operator`
        case parallelism
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsLevel] {
            return [
                .application,
                .operator,
                .parallelism,
                .task,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .operator: return "OPERATOR"
            case .parallelism: return "PARALLELISM"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricsLevel(rawValue: rawValue) ?? MetricsLevel.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationType = "ConfigurationType"
        case logLevel = "LogLevel"
        case metricsLevel = "MetricsLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let metricsLevel = self.metricsLevel {
            try encodeContainer.encode(metricsLevel.rawValue, forKey: .metricsLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let metricsLevelDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MetricsLevel.self, forKey: .metricsLevel)
        metricsLevel = metricsLevelDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for Amazon CloudWatch logging for an application. For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html).
    public struct MonitoringConfiguration: Swift.Equatable {
        /// Describes whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        /// This member is required.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public var metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel?

        public init (
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil,
            metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel? = nil
        )
        {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationType = "ConfigurationType"
        case logLevel = "LogLevel"
        case metricsLevel = "MetricsLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let metricsLevel = self.metricsLevel {
            try encodeContainer.encode(metricsLevel.rawValue, forKey: .metricsLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let metricsLevelDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MetricsLevel.self, forKey: .metricsLevel)
        metricsLevel = metricsLevelDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for CloudWatch logging for an application.
    public struct MonitoringConfigurationDescription: Swift.Equatable {
        /// Describes whether to use the default CloudWatch logging configuration for an application.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application.
        public var metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel?

        public init (
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil,
            metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel? = nil
        )
        {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationTypeUpdate = "ConfigurationTypeUpdate"
        case logLevelUpdate = "LogLevelUpdate"
        case metricsLevelUpdate = "MetricsLevelUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationTypeUpdate = self.configurationTypeUpdate {
            try encodeContainer.encode(configurationTypeUpdate.rawValue, forKey: .configurationTypeUpdate)
        }
        if let logLevelUpdate = self.logLevelUpdate {
            try encodeContainer.encode(logLevelUpdate.rawValue, forKey: .logLevelUpdate)
        }
        if let metricsLevelUpdate = self.metricsLevelUpdate {
            try encodeContainer.encode(metricsLevelUpdate.rawValue, forKey: .metricsLevelUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationTypeUpdate)
        configurationTypeUpdate = configurationTypeUpdateDecoded
        let metricsLevelUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MetricsLevel.self, forKey: .metricsLevelUpdate)
        metricsLevelUpdate = metricsLevelUpdateDecoded
        let logLevelUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LogLevel.self, forKey: .logLevelUpdate)
        logLevelUpdate = logLevelUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to configuration parameters for Amazon CloudWatch logging for an application.
    public struct MonitoringConfigurationUpdate: Swift.Equatable {
        /// Describes updates to whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        public var configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes updates to the verbosity of the CloudWatch Logs for an application.
        public var logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel?
        /// Describes updates to the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public var metricsLevelUpdate: KinesisAnalyticsV2ClientTypes.MetricsLevel?

        public init (
            configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel? = nil,
            metricsLevelUpdate: KinesisAnalyticsV2ClientTypes.MetricsLevel? = nil
        )
        {
            self.configurationTypeUpdate = configurationTypeUpdate
            self.logLevelUpdate = logLevelUpdate
            self.metricsLevelUpdate = metricsLevelUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutput = "KinesisFirehoseOutput"
        case kinesisStreamsOutput = "KinesisStreamsOutput"
        case lambdaOutput = "LambdaOutput"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = self.destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutput = self.kinesisFirehoseOutput {
            try encodeContainer.encode(kinesisFirehoseOutput, forKey: .kinesisFirehoseOutput)
        }
        if let kinesisStreamsOutput = self.kinesisStreamsOutput {
            try encodeContainer.encode(kinesisStreamsOutput, forKey: .kinesisStreamsOutput)
        }
        if let lambdaOutput = self.lambdaOutput {
            try encodeContainer.encode(lambdaOutput, forKey: .lambdaOutput)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput.self, forKey: .kinesisStreamsOutput)
        kinesisStreamsOutput = kinesisStreamsOutputDecoded
        let kinesisFirehoseOutputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput.self, forKey: .kinesisFirehoseOutput)
        kinesisFirehoseOutput = kinesisFirehoseOutputDecoded
        let lambdaOutputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LambdaOutput.self, forKey: .lambdaOutput)
        lambdaOutput = lambdaOutputDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written. The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
    public struct Output: Swift.Equatable {
        /// Describes the data format when records are written to the destination.
        /// This member is required.
        public var destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema?
        /// Identifies a Kinesis Data Firehose delivery stream as the destination.
        public var kinesisFirehoseOutput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput?
        /// Identifies a Kinesis data stream as the destination.
        public var kinesisStreamsOutput: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput?
        /// Identifies an Amazon Lambda function as the destination.
        public var lambdaOutput: KinesisAnalyticsV2ClientTypes.LambdaOutput?
        /// The name of the in-application stream.
        /// This member is required.
        public var name: Swift.String?

        public init (
            destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput? = nil,
            kinesisStreamsOutput: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput? = nil,
            lambdaOutput: KinesisAnalyticsV2ClientTypes.LambdaOutput? = nil,
            name: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutput = kinesisFirehoseOutput
            self.kinesisStreamsOutput = kinesisStreamsOutput
            self.lambdaOutput = lambdaOutput
            self.name = name
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.OutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutputDescription = "KinesisFirehoseOutputDescription"
        case kinesisStreamsOutputDescription = "KinesisStreamsOutputDescription"
        case lambdaOutputDescription = "LambdaOutputDescription"
        case name = "Name"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = self.destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutputDescription = self.kinesisFirehoseOutputDescription {
            try encodeContainer.encode(kinesisFirehoseOutputDescription, forKey: .kinesisFirehoseOutputDescription)
        }
        if let kinesisStreamsOutputDescription = self.kinesisStreamsOutputDescription {
            try encodeContainer.encode(kinesisStreamsOutputDescription, forKey: .kinesisStreamsOutputDescription)
        }
        if let lambdaOutputDescription = self.lambdaOutputDescription {
            try encodeContainer.encode(lambdaOutputDescription, forKey: .lambdaOutputDescription)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputId = self.outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription.self, forKey: .kinesisStreamsOutputDescription)
        kinesisStreamsOutputDescription = kinesisStreamsOutputDescriptionDecoded
        let kinesisFirehoseOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription.self, forKey: .kinesisFirehoseOutputDescription)
        kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescriptionDecoded
        let lambdaOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LambdaOutputDescription.self, forKey: .lambdaOutputDescription)
        lambdaOutputDescription = lambdaOutputDescriptionDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the application output configuration, which includes the in-application stream name and the destination where the stream data is written. The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
    public struct OutputDescription: Swift.Equatable {
        /// The data format used for writing data to the destination.
        public var destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema?
        /// Describes the Kinesis Data Firehose delivery stream that is configured as the destination where output is written.
        public var kinesisFirehoseOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription?
        /// Describes the Kinesis data stream that is configured as the destination where output is written.
        public var kinesisStreamsOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription?
        /// Describes the Lambda function that is configured as the destination where output is written.
        public var lambdaOutputDescription: KinesisAnalyticsV2ClientTypes.LambdaOutputDescription?
        /// The name of the in-application stream that is configured as output.
        public var name: Swift.String?
        /// A unique identifier for the output configuration.
        public var outputId: Swift.String?

        public init (
            destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription? = nil,
            kinesisStreamsOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription? = nil,
            lambdaOutputDescription: KinesisAnalyticsV2ClientTypes.LambdaOutputDescription? = nil,
            name: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
            self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
            self.lambdaOutputDescription = lambdaOutputDescription
            self.name = name
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.OutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSchemaUpdate = "DestinationSchemaUpdate"
        case kinesisFirehoseOutputUpdate = "KinesisFirehoseOutputUpdate"
        case kinesisStreamsOutputUpdate = "KinesisStreamsOutputUpdate"
        case lambdaOutputUpdate = "LambdaOutputUpdate"
        case nameUpdate = "NameUpdate"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchemaUpdate = self.destinationSchemaUpdate {
            try encodeContainer.encode(destinationSchemaUpdate, forKey: .destinationSchemaUpdate)
        }
        if let kinesisFirehoseOutputUpdate = self.kinesisFirehoseOutputUpdate {
            try encodeContainer.encode(kinesisFirehoseOutputUpdate, forKey: .kinesisFirehoseOutputUpdate)
        }
        if let kinesisStreamsOutputUpdate = self.kinesisStreamsOutputUpdate {
            try encodeContainer.encode(kinesisStreamsOutputUpdate, forKey: .kinesisStreamsOutputUpdate)
        }
        if let lambdaOutputUpdate = self.lambdaOutputUpdate {
            try encodeContainer.encode(lambdaOutputUpdate, forKey: .lambdaOutputUpdate)
        }
        if let nameUpdate = self.nameUpdate {
            try encodeContainer.encode(nameUpdate, forKey: .nameUpdate)
        }
        if let outputId = self.outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameUpdate)
        nameUpdate = nameUpdateDecoded
        let kinesisStreamsOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate.self, forKey: .kinesisStreamsOutputUpdate)
        kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdateDecoded
        let kinesisFirehoseOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate.self, forKey: .kinesisFirehoseOutputUpdate)
        kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdateDecoded
        let lambdaOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate.self, forKey: .lambdaOutputUpdate)
        lambdaOutputUpdate = lambdaOutputUpdateDecoded
        let destinationSchemaUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.DestinationSchema.self, forKey: .destinationSchemaUpdate)
        destinationSchemaUpdate = destinationSchemaUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes updates to the output configuration identified by the OutputId.
    public struct OutputUpdate: Swift.Equatable {
        /// Describes the data format when records are written to the destination.
        public var destinationSchemaUpdate: KinesisAnalyticsV2ClientTypes.DestinationSchema?
        /// Describes a Kinesis Data Firehose delivery stream as the destination for the output.
        public var kinesisFirehoseOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate?
        /// Describes a Kinesis data stream as the destination for the output.
        public var kinesisStreamsOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate?
        /// Describes an Amazon Lambda function as the destination for the output.
        public var lambdaOutputUpdate: KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate?
        /// If you want to specify a different in-application stream for this output configuration, use this field to specify the new in-application stream name.
        public var nameUpdate: Swift.String?
        /// Identifies the specific output configuration that you want to update.
        /// This member is required.
        public var outputId: Swift.String?

        public init (
            destinationSchemaUpdate: KinesisAnalyticsV2ClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate? = nil,
            kinesisStreamsOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate? = nil,
            lambdaOutputUpdate: KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate? = nil,
            nameUpdate: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchemaUpdate = destinationSchemaUpdate
            self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
            self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
            self.lambdaOutputUpdate = lambdaOutputUpdate
            self.nameUpdate = nameUpdate
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ParallelismConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingEnabled = "AutoScalingEnabled"
        case configurationType = "ConfigurationType"
        case parallelism = "Parallelism"
        case parallelismPerKPU = "ParallelismPerKPU"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingEnabled = self.autoScalingEnabled {
            try encodeContainer.encode(autoScalingEnabled, forKey: .autoScalingEnabled)
        }
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let parallelism = self.parallelism {
            try encodeContainer.encode(parallelism, forKey: .parallelism)
        }
        if let parallelismPerKPU = self.parallelismPerKPU {
            try encodeContainer.encode(parallelismPerKPU, forKey: .parallelismPerKPU)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let parallelismDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelism)
        parallelism = parallelismDecoded
        let parallelismPerKPUDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelismPerKPU)
        parallelismPerKPU = parallelismPerKPUDecoded
        let autoScalingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoScalingEnabled)
        autoScalingEnabled = autoScalingEnabledDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously. For more information about parallelism, see [Parallel Execution](https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/parallel.html) in the [Apache Flink Documentation](https://ci.apache.org/projects/flink/flink-docs-release-1.8/).
    public struct ParallelismConfiguration: Swift.Equatable {
        /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
        public var autoScalingEnabled: Swift.Bool?
        /// Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        /// This member is required.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If AutoScalingEnabled is set to True, Kinesis Data Analytics increases the CurrentParallelism value in response to application load. The service can increase the CurrentParallelism value up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public var parallelism: Swift.Int?
        /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application. For more information about KPUs, see [Amazon Kinesis Data Analytics Pricing](http://aws.amazon.com/kinesis/data-analytics/pricing/).
        public var parallelismPerKPU: Swift.Int?

        public init (
            autoScalingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            parallelism: Swift.Int? = nil,
            parallelismPerKPU: Swift.Int? = nil
        )
        {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingEnabled = "AutoScalingEnabled"
        case configurationType = "ConfigurationType"
        case currentParallelism = "CurrentParallelism"
        case parallelism = "Parallelism"
        case parallelismPerKPU = "ParallelismPerKPU"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingEnabled = self.autoScalingEnabled {
            try encodeContainer.encode(autoScalingEnabled, forKey: .autoScalingEnabled)
        }
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let currentParallelism = self.currentParallelism {
            try encodeContainer.encode(currentParallelism, forKey: .currentParallelism)
        }
        if let parallelism = self.parallelism {
            try encodeContainer.encode(parallelism, forKey: .parallelism)
        }
        if let parallelismPerKPU = self.parallelismPerKPU {
            try encodeContainer.encode(parallelismPerKPU, forKey: .parallelismPerKPU)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let parallelismDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelism)
        parallelism = parallelismDecoded
        let parallelismPerKPUDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelismPerKPU)
        parallelismPerKPU = parallelismPerKPUDecoded
        let currentParallelismDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentParallelism)
        currentParallelism = currentParallelismDecoded
        let autoScalingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoScalingEnabled)
        autoScalingEnabled = autoScalingEnabledDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously.
    public struct ParallelismConfigurationDescription: Swift.Equatable {
        /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
        public var autoScalingEnabled: Swift.Bool?
        /// Describes whether the application uses the default parallelism for the Kinesis Data Analytics service.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If AutoScalingEnabled is set to True, Kinesis Data Analytics can increase this value in response to application load. The service can increase this value up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public var currentParallelism: Swift.Int?
        /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If AutoScalingEnabled is set to True, then Kinesis Data Analytics can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public var parallelism: Swift.Int?
        /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
        public var parallelismPerKPU: Swift.Int?

        public init (
            autoScalingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            currentParallelism: Swift.Int? = nil,
            parallelism: Swift.Int? = nil,
            parallelismPerKPU: Swift.Int? = nil
        )
        {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.currentParallelism = currentParallelism
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingEnabledUpdate = "AutoScalingEnabledUpdate"
        case configurationTypeUpdate = "ConfigurationTypeUpdate"
        case parallelismPerKPUUpdate = "ParallelismPerKPUUpdate"
        case parallelismUpdate = "ParallelismUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingEnabledUpdate = self.autoScalingEnabledUpdate {
            try encodeContainer.encode(autoScalingEnabledUpdate, forKey: .autoScalingEnabledUpdate)
        }
        if let configurationTypeUpdate = self.configurationTypeUpdate {
            try encodeContainer.encode(configurationTypeUpdate.rawValue, forKey: .configurationTypeUpdate)
        }
        if let parallelismPerKPUUpdate = self.parallelismPerKPUUpdate {
            try encodeContainer.encode(parallelismPerKPUUpdate, forKey: .parallelismPerKPUUpdate)
        }
        if let parallelismUpdate = self.parallelismUpdate {
            try encodeContainer.encode(parallelismUpdate, forKey: .parallelismUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ConfigurationType.self, forKey: .configurationTypeUpdate)
        configurationTypeUpdate = configurationTypeUpdateDecoded
        let parallelismUpdateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelismUpdate)
        parallelismUpdate = parallelismUpdateDecoded
        let parallelismPerKPUUpdateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelismPerKPUUpdate)
        parallelismPerKPUUpdate = parallelismPerKPUUpdateDecoded
        let autoScalingEnabledUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoScalingEnabledUpdate)
        autoScalingEnabledUpdate = autoScalingEnabledUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to parameters for how an application executes multiple tasks simultaneously.
    public struct ParallelismConfigurationUpdate: Swift.Equatable {
        /// Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.
        public var autoScalingEnabledUpdate: Swift.Bool?
        /// Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        public var configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.
        public var parallelismPerKPUUpdate: Swift.Int?
        /// Describes updates to the initial number of parallel tasks an application can perform. If AutoScalingEnabled is set to True, then Kinesis Data Analytics can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will reduce CurrentParallelism down to the Parallelism setting.
        public var parallelismUpdate: Swift.Int?

        public init (
            autoScalingEnabledUpdate: Swift.Bool? = nil,
            configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            parallelismPerKPUUpdate: Swift.Int? = nil,
            parallelismUpdate: Swift.Int? = nil
        )
        {
            self.autoScalingEnabledUpdate = autoScalingEnabledUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.parallelismPerKPUUpdate = parallelismPerKPUUpdate
            self.parallelismUpdate = parallelismUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.PropertyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyGroupId = "PropertyGroupId"
        case propertyMap = "PropertyMap"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroupId = self.propertyGroupId {
            try encodeContainer.encode(propertyGroupId, forKey: .propertyGroupId)
        }
        if let propertyMap = propertyMap {
            var propertyMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyMap)
            for (dictKey0, propertyMap0) in propertyMap {
                try propertyMapContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyGroupId)
        propertyGroupId = propertyGroupIdDecoded
        let propertyMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .propertyMap)
        var propertyMapDecoded0: [Swift.String:Swift.String]? = nil
        if let propertyMapContainer = propertyMapContainer {
            propertyMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, propertyvalue0) in propertyMapContainer {
                if let propertyvalue0 = propertyvalue0 {
                    propertyMapDecoded0?[key0] = propertyvalue0
                }
            }
        }
        propertyMap = propertyMapDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Property key-value pairs passed into an application.
    public struct PropertyGroup: Swift.Equatable {
        /// Describes the key of an application execution property key-value pair.
        /// This member is required.
        public var propertyGroupId: Swift.String?
        /// Describes the value of an application execution property key-value pair.
        /// This member is required.
        public var propertyMap: [Swift.String:Swift.String]?

        public init (
            propertyGroupId: Swift.String? = nil,
            propertyMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.propertyGroupId = propertyGroupId
            self.propertyMap = propertyMap
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.RecordColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapping = "Mapping"
        case name = "Name"
        case sqlType = "SqlType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mapping = self.mapping {
            try encodeContainer.encode(mapping, forKey: .mapping)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlType = self.sqlType {
            try encodeContainer.encode(sqlType, forKey: .sqlType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mappingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapping)
        mapping = mappingDecoded
        let sqlTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlType)
        sqlType = sqlTypeDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream. Also used to describe the format of the reference data source.
    public struct RecordColumn: Swift.Equatable {
        /// A reference to the data element in the streaming input or the reference data source.
        public var mapping: Swift.String?
        /// The name of the column that is created in the in-application input stream or reference table.
        /// This member is required.
        public var name: Swift.String?
        /// The type of column created in the in-application input stream or reference table.
        /// This member is required.
        public var sqlType: Swift.String?

        public init (
            mapping: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlType: Swift.String? = nil
        )
        {
            self.mapping = mapping
            self.name = name
            self.sqlType = sqlType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.RecordFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappingParameters = "MappingParameters"
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mappingParameters = self.mappingParameters {
            try encodeContainer.encode(mappingParameters, forKey: .mappingParameters)
        }
        if let recordFormatType = self.recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
        let mappingParametersDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.MappingParameters.self, forKey: .mappingParameters)
        mappingParameters = mappingParametersDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
    public struct RecordFormat: Swift.Equatable {
        /// When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        public var mappingParameters: KinesisAnalyticsV2ClientTypes.MappingParameters?
        /// The type of record format.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType?

        public init (
            mappingParameters: KinesisAnalyticsV2ClientTypes.MappingParameters? = nil,
            recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType? = nil
        )
        {
            self.mappingParameters = mappingParameters
            self.recordFormatType = recordFormatType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum RecordFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordFormatType] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordFormatType(rawValue: rawValue) ?? RecordFormatType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.ReferenceDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSource = "S3ReferenceDataSource"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceSchema = self.referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSource = self.s3ReferenceDataSource {
            try encodeContainer.encode(s3ReferenceDataSource, forKey: .s3ReferenceDataSource)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource.self, forKey: .s3ReferenceDataSource)
        s3ReferenceDataSource = s3ReferenceDataSourceDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
    public struct ReferenceDataSource: Swift.Equatable {
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        /// This member is required.
        public var referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// Identifies the S3 bucket and object that contains the reference data. A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication] operation to trigger reloading of data into your application.
        public var s3ReferenceDataSource: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource?
        /// The name of the in-application table to create.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            s3ReferenceDataSource: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSource = s3ReferenceDataSource
            self.tableName = tableName
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSourceDescription = "S3ReferenceDataSourceDescription"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchema = self.referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSourceDescription = self.s3ReferenceDataSourceDescription {
            try encodeContainer.encode(s3ReferenceDataSourceDescription, forKey: .s3ReferenceDataSourceDescription)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription.self, forKey: .s3ReferenceDataSourceDescription)
        s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescriptionDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the reference data source configured for an application.
    public struct ReferenceDataSourceDescription: Swift.Equatable {
        /// The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns when you add the reference data source to your application using the [CreateApplication] or [UpdateApplication] operation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// Provides the Amazon S3 bucket name, the object key name that contains the reference data.
        /// This member is required.
        public var s3ReferenceDataSourceDescription: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription?
        /// The in-application table name created by the specific reference data source configuration.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            referenceId: Swift.String? = nil,
            referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceDescription: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
            self.tableName = tableName
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchemaUpdate = "ReferenceSchemaUpdate"
        case s3ReferenceDataSourceUpdate = "S3ReferenceDataSourceUpdate"
        case tableNameUpdate = "TableNameUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchemaUpdate = self.referenceSchemaUpdate {
            try encodeContainer.encode(referenceSchemaUpdate, forKey: .referenceSchemaUpdate)
        }
        if let s3ReferenceDataSourceUpdate = self.s3ReferenceDataSourceUpdate {
            try encodeContainer.encode(s3ReferenceDataSourceUpdate, forKey: .s3ReferenceDataSourceUpdate)
        }
        if let tableNameUpdate = self.tableNameUpdate {
            try encodeContainer.encode(tableNameUpdate, forKey: .tableNameUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableNameUpdate)
        tableNameUpdate = tableNameUpdateDecoded
        let s3ReferenceDataSourceUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate.self, forKey: .s3ReferenceDataSourceUpdate)
        s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdateDecoded
        let referenceSchemaUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SourceSchema.self, forKey: .referenceSchemaUpdate)
        referenceSchemaUpdate = referenceSchemaUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update a reference data source configuration for a SQL-based Kinesis Data Analytics application, this object provides all the updated values (such as the source bucket name and object key name), the in-application table name that is created, and updated mapping information that maps the data in the Amazon S3 object to the in-application reference table that is created.
    public struct ReferenceDataSourceUpdate: Swift.Equatable {
        /// The ID of the reference data source that is being updated. You can use the [DescribeApplication] operation to get this value.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchemaUpdate: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
        public var s3ReferenceDataSourceUpdate: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate?
        /// The in-application table name that is created by this update.
        public var tableNameUpdate: Swift.String?

        public init (
            referenceId: Swift.String? = nil,
            referenceSchemaUpdate: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceUpdate: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate? = nil,
            tableNameUpdate: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchemaUpdate = referenceSchemaUpdate
            self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
            self.tableNameUpdate = tableNameUpdate
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The application is not available for this operation.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Specified application can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceProvisionedThroughputExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Discovery failed to get a record from the streaming source because of the Kinesis Streams ProvisionedThroughputExceededException. For more information, see [GetRecords](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html) in the Amazon Kinesis Streams API Reference.
public struct ResourceProvisionedThroughputExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceProvisionedThroughputExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceProvisionedThroughputExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RollbackApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

extension RollbackApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RollbackApplicationInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current application version ID. You can retrieve the application version ID using [DescribeApplication].
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct RollbackApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
}

extension RollbackApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
    }
}

extension RollbackApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RollbackApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RollbackApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RollbackApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RollbackApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct RollbackApplicationOutputResponse: Swift.Equatable {
    /// Describes the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configurations.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init (
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct RollbackApplicationOutputResponseBody: Swift.Equatable {
    let applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
}

extension RollbackApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes.RunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
        case flinkRunConfiguration = "FlinkRunConfiguration"
        case sqlRunConfigurations = "SqlRunConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreConfiguration = self.applicationRestoreConfiguration {
            try encodeContainer.encode(applicationRestoreConfiguration, forKey: .applicationRestoreConfiguration)
        }
        if let flinkRunConfiguration = self.flinkRunConfiguration {
            try encodeContainer.encode(flinkRunConfiguration, forKey: .flinkRunConfiguration)
        }
        if let sqlRunConfigurations = sqlRunConfigurations {
            var sqlRunConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sqlRunConfigurations)
            for sqlrunconfiguration0 in sqlRunConfigurations {
                try sqlRunConfigurationsContainer.encode(sqlrunconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flinkRunConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration.self, forKey: .flinkRunConfiguration)
        flinkRunConfiguration = flinkRunConfigurationDecoded
        let sqlRunConfigurationsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.SqlRunConfiguration?].self, forKey: .sqlRunConfigurations)
        var sqlRunConfigurationsDecoded0:[KinesisAnalyticsV2ClientTypes.SqlRunConfiguration]? = nil
        if let sqlRunConfigurationsContainer = sqlRunConfigurationsContainer {
            sqlRunConfigurationsDecoded0 = [KinesisAnalyticsV2ClientTypes.SqlRunConfiguration]()
            for structure0 in sqlRunConfigurationsContainer {
                if let structure0 = structure0 {
                    sqlRunConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sqlRunConfigurations = sqlRunConfigurationsDecoded0
        let applicationRestoreConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration.self, forKey: .applicationRestoreConfiguration)
        applicationRestoreConfiguration = applicationRestoreConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting parameters for an Kinesis Data Analytics application.
    public struct RunConfiguration: Swift.Equatable {
        /// Describes the restore behavior of a restarting application.
        public var applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
        public var flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?
        /// Describes the starting parameters for a SQL-based Kinesis Data Analytics application application.
        public var sqlRunConfigurations: [KinesisAnalyticsV2ClientTypes.SqlRunConfiguration]?

        public init (
            applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration? = nil,
            flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration? = nil,
            sqlRunConfigurations: [KinesisAnalyticsV2ClientTypes.SqlRunConfiguration]? = nil
        )
        {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
            self.sqlRunConfigurations = sqlRunConfigurations
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.RunConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationRestoreConfigurationDescription = "ApplicationRestoreConfigurationDescription"
        case flinkRunConfigurationDescription = "FlinkRunConfigurationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreConfigurationDescription = self.applicationRestoreConfigurationDescription {
            try encodeContainer.encode(applicationRestoreConfigurationDescription, forKey: .applicationRestoreConfigurationDescription)
        }
        if let flinkRunConfigurationDescription = self.flinkRunConfigurationDescription {
            try encodeContainer.encode(flinkRunConfigurationDescription, forKey: .flinkRunConfigurationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationRestoreConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration.self, forKey: .applicationRestoreConfigurationDescription)
        applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescriptionDecoded
        let flinkRunConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration.self, forKey: .flinkRunConfigurationDescription)
        flinkRunConfigurationDescription = flinkRunConfigurationDescriptionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting properties for a Kinesis Data Analytics application.
    public struct RunConfigurationDescription: Swift.Equatable {
        /// Describes the restore behavior of a restarting application.
        public var applicationRestoreConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
        public var flinkRunConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?

        public init (
            applicationRestoreConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration? = nil,
            flinkRunConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration? = nil
        )
        {
            self.applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescription
            self.flinkRunConfigurationDescription = flinkRunConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
        case flinkRunConfiguration = "FlinkRunConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreConfiguration = self.applicationRestoreConfiguration {
            try encodeContainer.encode(applicationRestoreConfiguration, forKey: .applicationRestoreConfiguration)
        }
        if let flinkRunConfiguration = self.flinkRunConfiguration {
            try encodeContainer.encode(flinkRunConfiguration, forKey: .flinkRunConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flinkRunConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration.self, forKey: .flinkRunConfiguration)
        flinkRunConfiguration = flinkRunConfigurationDecoded
        let applicationRestoreConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration.self, forKey: .applicationRestoreConfiguration)
        applicationRestoreConfiguration = applicationRestoreConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the updates to the starting parameters for a Kinesis Data Analytics application.
    public struct RunConfigurationUpdate: Swift.Equatable {
        /// Describes updates to the restore behavior of a restarting application.
        public var applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
        public var flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?

        public init (
            applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration? = nil,
            flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration? = nil
        )
        {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum RuntimeEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case flink111
        case flink113
        case flink115
        case flink16
        case flink18
        case sql10
        case zeppelinFlink10
        case zeppelinFlink20
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeEnvironment] {
            return [
                .flink111,
                .flink113,
                .flink115,
                .flink16,
                .flink18,
                .sql10,
                .zeppelinFlink10,
                .zeppelinFlink20,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .flink111: return "FLINK-1_11"
            case .flink113: return "FLINK-1_13"
            case .flink115: return "FLINK-1_15"
            case .flink16: return "FLINK-1_6"
            case .flink18: return "FLINK-1_8"
            case .sql10: return "SQL-1_0"
            case .zeppelinFlink10: return "ZEPPELIN-FLINK-1_0"
            case .zeppelinFlink20: return "ZEPPELIN-FLINK-2_0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuntimeEnvironment(rawValue: rawValue) ?? RuntimeEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case objectVersion = "ObjectVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let objectVersion = self.objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the location of an application's code stored in an S3 bucket.
    public struct S3ApplicationCodeLocationDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The file key for the object containing the application code.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The version of the object containing the application code.
        public var objectVersion: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides a description of an Amazon S3 data source, including the Amazon Resource Name (ARN) of the S3 bucket and the name of the Amazon S3 object that contains the data.
    public struct S3Configuration: Swift.Equatable {
        /// The ARN of the S3 bucket that contains the data.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The name of the object that contains the data.
        /// This member is required.
        public var fileKey: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath = "BasePath"
        case bucketARN = "BucketARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = self.basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The S3 bucket that holds the application information.
    public struct S3ContentBaseLocation: Swift.Equatable {
        /// The base path for the S3 bucket.
        public var basePath: Swift.String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?

        public init (
            basePath: Swift.String? = nil,
            bucketARN: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath = "BasePath"
        case bucketARN = "BucketARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = self.basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The description of the S3 base location that holds the application.
    public struct S3ContentBaseLocationDescription: Swift.Equatable {
        /// The base path for the S3 bucket.
        public var basePath: Swift.String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?

        public init (
            basePath: Swift.String? = nil,
            bucketARN: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePathUpdate = "BasePathUpdate"
        case bucketARNUpdate = "BucketARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePathUpdate = self.basePathUpdate {
            try encodeContainer.encode(basePathUpdate, forKey: .basePathUpdate)
        }
        if let bucketARNUpdate = self.bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let basePathUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePathUpdate)
        basePathUpdate = basePathUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The information required to update the S3 base location that holds the application.
    public struct S3ContentBaseLocationUpdate: Swift.Equatable {
        /// The updated S3 bucket path.
        public var basePathUpdate: Swift.String?
        /// The updated Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARNUpdate: Swift.String?

        public init (
            basePathUpdate: Swift.String? = nil,
            bucketARNUpdate: Swift.String? = nil
        )
        {
            self.basePathUpdate = basePathUpdate
            self.bucketARNUpdate = bucketARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ContentLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case objectVersion = "ObjectVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let objectVersion = self.objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a Kinesis Data Analytics application provides a description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
    public struct S3ContentLocation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The file key for the object containing the application code.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The version of the object containing the application code.
        public var objectVersion: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARNUpdate = "BucketARNUpdate"
        case fileKeyUpdate = "FileKeyUpdate"
        case objectVersionUpdate = "ObjectVersionUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARNUpdate = self.bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
        if let fileKeyUpdate = self.fileKeyUpdate {
            try encodeContainer.encode(fileKeyUpdate, forKey: .fileKeyUpdate)
        }
        if let objectVersionUpdate = self.objectVersionUpdate {
            try encodeContainer.encode(objectVersionUpdate, forKey: .objectVersionUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let fileKeyUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKeyUpdate)
        fileKeyUpdate = fileKeyUpdateDecoded
        let objectVersionUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersionUpdate)
        objectVersionUpdate = objectVersionUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes an update for the Amazon S3 code content location for an application.
    public struct S3ContentLocationUpdate: Swift.Equatable {
        /// The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public var bucketARNUpdate: Swift.String?
        /// The new file key for the object containing the application code.
        public var fileKeyUpdate: Swift.String?
        /// The new version of the object containing the application code.
        public var objectVersionUpdate: Swift.String?

        public init (
            bucketARNUpdate: Swift.String? = nil,
            fileKeyUpdate: Swift.String? = nil,
            objectVersionUpdate: Swift.String? = nil
        )
        {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
            self.objectVersionUpdate = objectVersionUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, identifies the Amazon S3 bucket and object that contains the reference data. A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication] operation to trigger reloading of data into your application.
    public struct S3ReferenceDataSource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARN: Swift.String?
        /// The object key name containing the reference data.
        public var fileKey: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case referenceRoleARN = "ReferenceRoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let referenceRoleARN = self.referenceRoleARN {
            try encodeContainer.encode(referenceRoleARN, forKey: .referenceRoleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let referenceRoleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceRoleARN)
        referenceRoleARN = referenceRoleARNDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides the bucket name and object key name that stores the reference data.
    public struct S3ReferenceDataSourceDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// Amazon S3 object key name.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var referenceRoleARN: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            referenceRoleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARNUpdate = "BucketARNUpdate"
        case fileKeyUpdate = "FileKeyUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARNUpdate = self.bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
        if let fileKeyUpdate = self.fileKeyUpdate {
            try encodeContainer.encode(fileKeyUpdate, forKey: .fileKeyUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let fileKeyUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKeyUpdate)
        fileKeyUpdate = fileKeyUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the Amazon S3 bucket name and object key name for an in-application reference table.
    public struct S3ReferenceDataSourceUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARNUpdate: Swift.String?
        /// The object key name.
        public var fileKeyUpdate: Swift.String?

        public init (
            bucketARNUpdate: Swift.String? = nil,
            fileKeyUpdate: Swift.String? = nil
        )
        {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service cannot complete the request.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes.SnapshotDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersionId = "ApplicationVersionId"
        case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
        case snapshotName = "SnapshotName"
        case snapshotStatus = "SnapshotStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationVersionId = self.applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let snapshotCreationTimestamp = self.snapshotCreationTimestamp {
            try encodeContainer.encodeTimestamp(snapshotCreationTimestamp, format: .epochSeconds, forKey: .snapshotCreationTimestamp)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let snapshotStatus = self.snapshotStatus {
            try encodeContainer.encode(snapshotStatus.rawValue, forKey: .snapshotStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotStatusDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.SnapshotStatus.self, forKey: .snapshotStatus)
        snapshotStatus = snapshotStatusDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let snapshotCreationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreationTimestamp)
        snapshotCreationTimestamp = snapshotCreationTimestampDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides details about a snapshot of application state.
    public struct SnapshotDetails: Swift.Equatable {
        /// The current application version ID when the snapshot was created.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// The timestamp of the application snapshot.
        public var snapshotCreationTimestamp: ClientRuntime.Date?
        /// The identifier for the application snapshot.
        /// This member is required.
        public var snapshotName: Swift.String?
        /// The status of the application snapshot.
        /// This member is required.
        public var snapshotStatus: KinesisAnalyticsV2ClientTypes.SnapshotStatus?

        public init (
            applicationVersionId: Swift.Int? = nil,
            snapshotCreationTimestamp: ClientRuntime.Date? = nil,
            snapshotName: Swift.String? = nil,
            snapshotStatus: KinesisAnalyticsV2ClientTypes.SnapshotStatus? = nil
        )
        {
            self.applicationVersionId = applicationVersionId
            self.snapshotCreationTimestamp = snapshotCreationTimestamp
            self.snapshotName = snapshotName
            self.snapshotStatus = snapshotStatus
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.SourceSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordColumns = "RecordColumns"
        case recordEncoding = "RecordEncoding"
        case recordFormat = "RecordFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumns = recordColumns {
            var recordColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumns)
            for recordcolumn0 in recordColumns {
                try recordColumnsContainer.encode(recordcolumn0)
            }
        }
        if let recordEncoding = self.recordEncoding {
            try encodeContainer.encode(recordEncoding, forKey: .recordEncoding)
        }
        if let recordFormat = self.recordFormat {
            try encodeContainer.encode(recordFormat, forKey: .recordFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RecordFormat.self, forKey: .recordFormat)
        recordFormat = recordFormatDecoded
        let recordEncodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordEncoding)
        recordEncoding = recordEncodingDecoded
        let recordColumnsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.RecordColumn?].self, forKey: .recordColumns)
        var recordColumnsDecoded0:[KinesisAnalyticsV2ClientTypes.RecordColumn]? = nil
        if let recordColumnsContainer = recordColumnsContainer {
            recordColumnsDecoded0 = [KinesisAnalyticsV2ClientTypes.RecordColumn]()
            for structure0 in recordColumnsContainer {
                if let structure0 = structure0 {
                    recordColumnsDecoded0?.append(structure0)
                }
            }
        }
        recordColumns = recordColumnsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    public struct SourceSchema: Swift.Equatable {
        /// A list of RecordColumn objects.
        /// This member is required.
        public var recordColumns: [KinesisAnalyticsV2ClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public var recordEncoding: Swift.String?
        /// Specifies the format of the records on the streaming source.
        /// This member is required.
        public var recordFormat: KinesisAnalyticsV2ClientTypes.RecordFormat?

        public init (
            recordColumns: [KinesisAnalyticsV2ClientTypes.RecordColumn]? = nil,
            recordEncoding: Swift.String? = nil,
            recordFormat: KinesisAnalyticsV2ClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumns = recordColumns
            self.recordEncoding = recordEncoding
            self.recordFormat = recordFormat
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputs = "Inputs"
        case outputs = "Outputs"
        case referenceDataSources = "ReferenceDataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for input0 in inputs {
                try inputsContainer.encode(input0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let referenceDataSources = referenceDataSources {
            var referenceDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSources)
            for referencedatasource0 in referenceDataSources {
                try referenceDataSourcesContainer.encode(referencedatasource0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.Input?].self, forKey: .inputs)
        var inputsDecoded0:[KinesisAnalyticsV2ClientTypes.Input]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [KinesisAnalyticsV2ClientTypes.Input]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[KinesisAnalyticsV2ClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [KinesisAnalyticsV2ClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let referenceDataSourcesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.ReferenceDataSource?].self, forKey: .referenceDataSources)
        var referenceDataSourcesDecoded0:[KinesisAnalyticsV2ClientTypes.ReferenceDataSource]? = nil
        if let referenceDataSourcesContainer = referenceDataSourcesContainer {
            referenceDataSourcesDecoded0 = [KinesisAnalyticsV2ClientTypes.ReferenceDataSource]()
            for structure0 in referenceDataSourcesContainer {
                if let structure0 = structure0 {
                    referenceDataSourcesDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSources = referenceDataSourcesDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
    public struct SqlApplicationConfiguration: Swift.Equatable {
        /// The array of [Input] objects describing the input streams used by the application.
        public var inputs: [KinesisAnalyticsV2ClientTypes.Input]?
        /// The array of [Output] objects describing the destination streams used by the application.
        public var outputs: [KinesisAnalyticsV2ClientTypes.Output]?
        /// The array of [ReferenceDataSource] objects describing the reference data sources used by the application.
        public var referenceDataSources: [KinesisAnalyticsV2ClientTypes.ReferenceDataSource]?

        public init (
            inputs: [KinesisAnalyticsV2ClientTypes.Input]? = nil,
            outputs: [KinesisAnalyticsV2ClientTypes.Output]? = nil,
            referenceDataSources: [KinesisAnalyticsV2ClientTypes.ReferenceDataSource]? = nil
        )
        {
            self.inputs = inputs
            self.outputs = outputs
            self.referenceDataSources = referenceDataSources
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDescriptions = "InputDescriptions"
        case outputDescriptions = "OutputDescriptions"
        case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDescriptions = inputDescriptions {
            var inputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputDescriptions)
            for inputdescription0 in inputDescriptions {
                try inputDescriptionsContainer.encode(inputdescription0)
            }
        }
        if let outputDescriptions = outputDescriptions {
            var outputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputDescriptions)
            for outputdescription0 in outputDescriptions {
                try outputDescriptionsContainer.encode(outputdescription0)
            }
        }
        if let referenceDataSourceDescriptions = referenceDataSourceDescriptions {
            var referenceDataSourceDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceDescriptions)
            for referencedatasourcedescription0 in referenceDataSourceDescriptions {
                try referenceDataSourceDescriptionsContainer.encode(referencedatasourcedescription0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.InputDescription?].self, forKey: .inputDescriptions)
        var inputDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.InputDescription]? = nil
        if let inputDescriptionsContainer = inputDescriptionsContainer {
            inputDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.InputDescription]()
            for structure0 in inputDescriptionsContainer {
                if let structure0 = structure0 {
                    inputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        inputDescriptions = inputDescriptionsDecoded0
        let outputDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.OutputDescription?].self, forKey: .outputDescriptions)
        var outputDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.OutputDescription]? = nil
        if let outputDescriptionsContainer = outputDescriptionsContainer {
            outputDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.OutputDescription]()
            for structure0 in outputDescriptionsContainer {
                if let structure0 = structure0 {
                    outputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        outputDescriptions = outputDescriptionsDecoded0
        let referenceDataSourceDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription?].self, forKey: .referenceDataSourceDescriptions)
        var referenceDataSourceDescriptionsDecoded0:[KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]? = nil
        if let referenceDataSourceDescriptionsContainer = referenceDataSourceDescriptionsContainer {
            referenceDataSourceDescriptionsDecoded0 = [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]()
            for structure0 in referenceDataSourceDescriptionsContainer {
                if let structure0 = structure0 {
                    referenceDataSourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceDescriptions = referenceDataSourceDescriptionsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
    public struct SqlApplicationConfigurationDescription: Swift.Equatable {
        /// The array of [InputDescription] objects describing the input streams used by the application.
        public var inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]?
        /// The array of [OutputDescription] objects describing the destination streams used by the application.
        public var outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]?
        /// The array of [ReferenceDataSourceDescription] objects describing the reference data sources used by the application.
        public var referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]?

        public init (
            inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]? = nil,
            outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]? = nil,
            referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]? = nil
        )
        {
            self.inputDescriptions = inputDescriptions
            self.outputDescriptions = outputDescriptions
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputUpdates = "InputUpdates"
        case outputUpdates = "OutputUpdates"
        case referenceDataSourceUpdates = "ReferenceDataSourceUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputUpdates = inputUpdates {
            var inputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputUpdates)
            for inputupdate0 in inputUpdates {
                try inputUpdatesContainer.encode(inputupdate0)
            }
        }
        if let outputUpdates = outputUpdates {
            var outputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputUpdates)
            for outputupdate0 in outputUpdates {
                try outputUpdatesContainer.encode(outputupdate0)
            }
        }
        if let referenceDataSourceUpdates = referenceDataSourceUpdates {
            var referenceDataSourceUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceUpdates)
            for referencedatasourceupdate0 in referenceDataSourceUpdates {
                try referenceDataSourceUpdatesContainer.encode(referencedatasourceupdate0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.InputUpdate?].self, forKey: .inputUpdates)
        var inputUpdatesDecoded0:[KinesisAnalyticsV2ClientTypes.InputUpdate]? = nil
        if let inputUpdatesContainer = inputUpdatesContainer {
            inputUpdatesDecoded0 = [KinesisAnalyticsV2ClientTypes.InputUpdate]()
            for structure0 in inputUpdatesContainer {
                if let structure0 = structure0 {
                    inputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        inputUpdates = inputUpdatesDecoded0
        let outputUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.OutputUpdate?].self, forKey: .outputUpdates)
        var outputUpdatesDecoded0:[KinesisAnalyticsV2ClientTypes.OutputUpdate]? = nil
        if let outputUpdatesContainer = outputUpdatesContainer {
            outputUpdatesDecoded0 = [KinesisAnalyticsV2ClientTypes.OutputUpdate]()
            for structure0 in outputUpdatesContainer {
                if let structure0 = structure0 {
                    outputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        outputUpdates = outputUpdatesDecoded0
        let referenceDataSourceUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate?].self, forKey: .referenceDataSourceUpdates)
        var referenceDataSourceUpdatesDecoded0:[KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate]? = nil
        if let referenceDataSourceUpdatesContainer = referenceDataSourceUpdatesContainer {
            referenceDataSourceUpdatesDecoded0 = [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate]()
            for structure0 in referenceDataSourceUpdatesContainer {
                if let structure0 = structure0 {
                    referenceDataSourceUpdatesDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceUpdates = referenceDataSourceUpdatesDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the input streams, destination streams, and reference data sources for a SQL-based Kinesis Data Analytics application.
    public struct SqlApplicationConfigurationUpdate: Swift.Equatable {
        /// The array of [InputUpdate] objects describing the new input streams used by the application.
        public var inputUpdates: [KinesisAnalyticsV2ClientTypes.InputUpdate]?
        /// The array of [OutputUpdate] objects describing the new destination streams used by the application.
        public var outputUpdates: [KinesisAnalyticsV2ClientTypes.OutputUpdate]?
        /// The array of [ReferenceDataSourceUpdate] objects describing the new reference data sources used by the application.
        public var referenceDataSourceUpdates: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate]?

        public init (
            inputUpdates: [KinesisAnalyticsV2ClientTypes.InputUpdate]? = nil,
            outputUpdates: [KinesisAnalyticsV2ClientTypes.OutputUpdate]? = nil,
            referenceDataSourceUpdates: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate]? = nil
        )
        {
            self.inputUpdates = inputUpdates
            self.outputUpdates = outputUpdates
            self.referenceDataSourceUpdates = referenceDataSourceUpdates
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.SqlRunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputId = "InputId"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputStartingPositionConfiguration = self.inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting parameters for a SQL-based Kinesis Data Analytics application.
    public struct SqlRunConfiguration: Swift.Equatable {
        /// The input source ID. You can get this ID by calling the [DescribeApplication] operation.
        /// This member is required.
        public var inputId: Swift.String?
        /// The point at which you want the application to start processing records from the streaming source.
        /// This member is required.
        public var inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?

        public init (
            inputId: Swift.String? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration? = nil
        )
        {
            self.inputId = inputId
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        }
    }

}

extension StartApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case runConfiguration = "RunConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let runConfiguration = self.runConfiguration {
            try encodeContainer.encode(runConfiguration, forKey: .runConfiguration)
        }
    }
}

extension StartApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartApplicationInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
    public var runConfiguration: KinesisAnalyticsV2ClientTypes.RunConfiguration?

    public init (
        applicationName: Swift.String? = nil,
        runConfiguration: KinesisAnalyticsV2ClientTypes.RunConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.runConfiguration = runConfiguration
    }
}

struct StartApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let runConfiguration: KinesisAnalyticsV2ClientTypes.RunConfiguration?
}

extension StartApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case runConfiguration = "RunConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let runConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RunConfiguration.self, forKey: .runConfiguration)
        runConfiguration = runConfigurationDecoded
    }
}

extension StartApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartApplicationOutputError: Swift.Error, Swift.Equatable {
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case force = "Force"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
    }
}

extension StopApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopApplicationInput: Swift.Equatable {
    /// The name of the running application to stop.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Set to true to force the application to stop. If you set Force to true, Kinesis Data Analytics stops the application without taking a snapshot. Force-stopping your application may lead to data loss or duplication. To prevent data loss or duplicate processing of data during application restarts, we recommend you to take frequent snapshots of your application. You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application. The application must be in the STARTING, UPDATING, STOPPING, AUTOSCALING, or RUNNING status.
    public var force: Swift.Bool?

    public init (
        applicationName: Swift.String? = nil,
        force: Swift.Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.force = force
    }
}

struct StopApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let force: Swift.Bool?
}

extension StopApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case force = "Force"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension StopApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension KinesisAnalyticsV2ClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// A key-value pair (the value is optional) that you can define and assign to Amazon resources. If you specify a tag that already exists, the tag value is replaced with the value that you specify in the request. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html).
    public struct Tag: Swift.Equatable {
        /// The key of the key-value tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value tag. The value is optional.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the application to assign the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value tags to assign to the application.
    /// This member is required.
    public var tags: [KinesisAnalyticsV2ClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [KinesisAnalyticsV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [KinesisAnalyticsV2ClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisAnalyticsV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisAnalyticsV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Application created with too many tags, or too many tags added to an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnableToDetectSchemaException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnableToDetectSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.message = nil
            self.processedInputRecords = nil
            self.rawInputRecords = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The data format is not valid. Kinesis Data Analytics cannot detect the schema for the given streaming source.
public struct UnableToDetectSchemaException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
    public var processedInputRecords: [Swift.String]?
    /// Raw stream data that was sampled to infer the schema.
    public var rawInputRecords: [Swift.String]?

    public init (
        message: Swift.String? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.message = message
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct UnableToDetectSchemaExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let rawInputRecords: [Swift.String]?
    let processedInputRecords: [Swift.String]?
}

extension UnableToDetectSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[Swift.String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [Swift.String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[Swift.String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [Swift.String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
    }
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because a specified parameter is not supported or a specified resource is not valid for this operation.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the Kinesis Data Analytics application from which to remove the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of keys of tags to remove from the specified application.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationUpdate = "ApplicationConfigurationUpdate"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case runConfigurationUpdate = "RunConfigurationUpdate"
        case serviceExecutionRoleUpdate = "ServiceExecutionRoleUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationUpdate = self.applicationConfigurationUpdate {
            try encodeContainer.encode(applicationConfigurationUpdate, forKey: .applicationConfigurationUpdate)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates {
            var cloudWatchLoggingOptionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionUpdates)
            for cloudwatchloggingoptionupdate0 in cloudWatchLoggingOptionUpdates {
                try cloudWatchLoggingOptionUpdatesContainer.encode(cloudwatchloggingoptionupdate0)
            }
        }
        if let conditionalToken = self.conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let runConfigurationUpdate = self.runConfigurationUpdate {
            try encodeContainer.encode(runConfigurationUpdate, forKey: .runConfigurationUpdate)
        }
        if let serviceExecutionRoleUpdate = self.serviceExecutionRoleUpdate {
            try encodeContainer.encode(serviceExecutionRoleUpdate, forKey: .serviceExecutionRoleUpdate)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Describes application configuration updates.
    public var applicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate?
    /// The name of the application to update.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Describes application Amazon CloudWatch logging option updates. You can only update existing CloudWatch logging options with this action. To add a new CloudWatch logging option, use [AddApplicationCloudWatchLoggingOption].
    public var cloudWatchLoggingOptionUpdates: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?
    /// Describes updates to the application's starting parameters.
    public var runConfigurationUpdate: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate?
    /// Describes updates to the service execution role.
    public var serviceExecutionRoleUpdate: Swift.String?

    public init (
        applicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate? = nil,
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptionUpdates: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        runConfigurationUpdate: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate? = nil,
        serviceExecutionRoleUpdate: Swift.String? = nil
    )
    {
        self.applicationConfigurationUpdate = applicationConfigurationUpdate
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.runConfigurationUpdate = runConfigurationUpdate
        self.serviceExecutionRoleUpdate = serviceExecutionRoleUpdate
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let applicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate?
    let serviceExecutionRoleUpdate: Swift.String?
    let runConfigurationUpdate: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate?
    let cloudWatchLoggingOptionUpdates: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]?
    let conditionalToken: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationUpdate = "ApplicationConfigurationUpdate"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case runConfigurationUpdate = "RunConfigurationUpdate"
        case serviceExecutionRoleUpdate = "ServiceExecutionRoleUpdate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let applicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate.self, forKey: .applicationConfigurationUpdate)
        applicationConfigurationUpdate = applicationConfigurationUpdateDecoded
        let serviceExecutionRoleUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRoleUpdate)
        serviceExecutionRoleUpdate = serviceExecutionRoleUpdateDecoded
        let runConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate.self, forKey: .runConfigurationUpdate)
        runConfigurationUpdate = runConfigurationUpdateDecoded
        let cloudWatchLoggingOptionUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate?].self, forKey: .cloudWatchLoggingOptionUpdates)
        var cloudWatchLoggingOptionUpdatesDecoded0:[KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]? = nil
        if let cloudWatchLoggingOptionUpdatesContainer = cloudWatchLoggingOptionUpdatesContainer {
            cloudWatchLoggingOptionUpdatesDecoded0 = [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]()
            for structure0 in cloudWatchLoggingOptionUpdatesContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdatesDecoded0
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension UpdateApplicationMaintenanceConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMaintenanceConfigurationUpdate = "ApplicationMaintenanceConfigurationUpdate"
        case applicationName = "ApplicationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMaintenanceConfigurationUpdate = self.applicationMaintenanceConfigurationUpdate {
            try encodeContainer.encode(applicationMaintenanceConfigurationUpdate, forKey: .applicationMaintenanceConfigurationUpdate)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
    }
}

extension UpdateApplicationMaintenanceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationMaintenanceConfigurationInput: Swift.Equatable {
    /// Describes the application maintenance configuration update.
    /// This member is required.
    public var applicationMaintenanceConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate?
    /// The name of the application for which you want to update the maintenance configuration.
    /// This member is required.
    public var applicationName: Swift.String?

    public init (
        applicationMaintenanceConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate? = nil,
        applicationName: Swift.String? = nil
    )
    {
        self.applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdate
        self.applicationName = applicationName
    }
}

struct UpdateApplicationMaintenanceConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let applicationMaintenanceConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate?
}

extension UpdateApplicationMaintenanceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMaintenanceConfigurationUpdate = "ApplicationMaintenanceConfigurationUpdate"
        case applicationName = "ApplicationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationMaintenanceConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate.self, forKey: .applicationMaintenanceConfigurationUpdate)
        applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdateDecoded
    }
}

extension UpdateApplicationMaintenanceConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationMaintenanceConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationMaintenanceConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationMaintenanceConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApplicationMaintenanceConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationARN = output.applicationARN
            self.applicationMaintenanceConfigurationDescription = output.applicationMaintenanceConfigurationDescription
        } else {
            self.applicationARN = nil
            self.applicationMaintenanceConfigurationDescription = nil
        }
    }
}

public struct UpdateApplicationMaintenanceConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// The application maintenance configuration description after the update.
    public var applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription?

    public init (
        applicationARN: Swift.String? = nil,
        applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
    }
}

struct UpdateApplicationMaintenanceConfigurationOutputResponseBody: Swift.Equatable {
    let applicationARN: Swift.String?
    let applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription?
}

extension UpdateApplicationMaintenanceConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationMaintenanceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription.self, forKey: .applicationMaintenanceConfigurationDescription)
        applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescriptionDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// Describes application updates.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init (
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    let applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    public enum UrlType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case flinkDashboardUrl
        case zeppelinUiUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [UrlType] {
            return [
                .flinkDashboardUrl,
                .zeppelinUiUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .flinkDashboardUrl: return "FLINK_DASHBOARD_URL"
            case .zeppelinUiUrl: return "ZEPPELIN_UI_URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UrlType(rawValue: rawValue) ?? UrlType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsV2ClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the parameters of a VPC used by the application.
    public struct VpcConfiguration: Swift.Equatable {
        /// The array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcConfigurationId = "VpcConfigurationId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcConfigurationId = self.vpcConfigurationId {
            try encodeContainer.encode(vpcConfigurationId, forKey: .vpcConfigurationId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConfigurationId)
        vpcConfigurationId = vpcConfigurationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the parameters of a VPC used by the application.
    public struct VpcConfigurationDescription: Swift.Equatable {
        /// The array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC configuration.
        /// This member is required.
        public var vpcConfigurationId: Swift.String?
        /// The ID of the associated VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcConfigurationId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConfigurationId = vpcConfigurationId
            self.vpcId = vpcId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIdUpdates = "SecurityGroupIdUpdates"
        case subnetIdUpdates = "SubnetIdUpdates"
        case vpcConfigurationId = "VpcConfigurationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdUpdates = securityGroupIdUpdates {
            var securityGroupIdUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdUpdates)
            for securitygroupid0 in securityGroupIdUpdates {
                try securityGroupIdUpdatesContainer.encode(securitygroupid0)
            }
        }
        if let subnetIdUpdates = subnetIdUpdates {
            var subnetIdUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIdUpdates)
            for subnetid0 in subnetIdUpdates {
                try subnetIdUpdatesContainer.encode(subnetid0)
            }
        }
        if let vpcConfigurationId = self.vpcConfigurationId {
            try encodeContainer.encode(vpcConfigurationId, forKey: .vpcConfigurationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConfigurationId)
        vpcConfigurationId = vpcConfigurationIdDecoded
        let subnetIdUpdatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIdUpdates)
        var subnetIdUpdatesDecoded0:[Swift.String]? = nil
        if let subnetIdUpdatesContainer = subnetIdUpdatesContainer {
            subnetIdUpdatesDecoded0 = [Swift.String]()
            for string0 in subnetIdUpdatesContainer {
                if let string0 = string0 {
                    subnetIdUpdatesDecoded0?.append(string0)
                }
            }
        }
        subnetIdUpdates = subnetIdUpdatesDecoded0
        let securityGroupIdUpdatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIdUpdates)
        var securityGroupIdUpdatesDecoded0:[Swift.String]? = nil
        if let securityGroupIdUpdatesContainer = securityGroupIdUpdatesContainer {
            securityGroupIdUpdatesDecoded0 = [Swift.String]()
            for string0 in securityGroupIdUpdatesContainer {
                if let string0 = string0 {
                    securityGroupIdUpdatesDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdUpdates = securityGroupIdUpdatesDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the VPC configuration used by the application.
    public struct VpcConfigurationUpdate: Swift.Equatable {
        /// Describes updates to the array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
        public var securityGroupIdUpdates: [Swift.String]?
        /// Describes updates to the array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
        public var subnetIdUpdates: [Swift.String]?
        /// Describes an update to the ID of the VPC configuration.
        /// This member is required.
        public var vpcConfigurationId: Swift.String?

        public init (
            securityGroupIdUpdates: [Swift.String]? = nil,
            subnetIdUpdates: [Swift.String]? = nil,
            vpcConfigurationId: Swift.String? = nil
        )
        {
            self.securityGroupIdUpdates = securityGroupIdUpdates
            self.subnetIdUpdates = subnetIdUpdates
            self.vpcConfigurationId = vpcConfigurationId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogConfiguration = "CatalogConfiguration"
        case customArtifactsConfiguration = "CustomArtifactsConfiguration"
        case deployAsApplicationConfiguration = "DeployAsApplicationConfiguration"
        case monitoringConfiguration = "MonitoringConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogConfiguration = self.catalogConfiguration {
            try encodeContainer.encode(catalogConfiguration, forKey: .catalogConfiguration)
        }
        if let customArtifactsConfiguration = customArtifactsConfiguration {
            var customArtifactsConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customArtifactsConfiguration)
            for customartifactconfiguration0 in customArtifactsConfiguration {
                try customArtifactsConfigurationContainer.encode(customartifactconfiguration0)
            }
        }
        if let deployAsApplicationConfiguration = self.deployAsApplicationConfiguration {
            try encodeContainer.encode(deployAsApplicationConfiguration, forKey: .deployAsApplicationConfiguration)
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
        let catalogConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CatalogConfiguration.self, forKey: .catalogConfiguration)
        catalogConfiguration = catalogConfigurationDecoded
        let deployAsApplicationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration.self, forKey: .deployAsApplicationConfiguration)
        deployAsApplicationConfiguration = deployAsApplicationConfigurationDecoded
        let customArtifactsConfigurationContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration?].self, forKey: .customArtifactsConfiguration)
        var customArtifactsConfigurationDecoded0:[KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]? = nil
        if let customArtifactsConfigurationContainer = customArtifactsConfigurationContainer {
            customArtifactsConfigurationDecoded0 = [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]()
            for structure0 in customArtifactsConfigurationContainer {
                if let structure0 = structure0 {
                    customArtifactsConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customArtifactsConfiguration = customArtifactsConfigurationDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of a Kinesis Data Analytics Studio notebook.
    public struct ZeppelinApplicationConfiguration: Swift.Equatable {
        /// The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
        public var catalogConfiguration: KinesisAnalyticsV2ClientTypes.CatalogConfiguration?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public var customArtifactsConfiguration: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]?
        /// The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
        public var deployAsApplicationConfiguration: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration?
        /// The monitoring configuration of a Kinesis Data Analytics Studio notebook.
        public var monitoringConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration?

        public init (
            catalogConfiguration: KinesisAnalyticsV2ClientTypes.CatalogConfiguration? = nil,
            customArtifactsConfiguration: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]? = nil,
            deployAsApplicationConfiguration: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration? = nil,
            monitoringConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration? = nil
        )
        {
            self.catalogConfiguration = catalogConfiguration
            self.customArtifactsConfiguration = customArtifactsConfiguration
            self.deployAsApplicationConfiguration = deployAsApplicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogConfigurationDescription = "CatalogConfigurationDescription"
        case customArtifactsConfigurationDescription = "CustomArtifactsConfigurationDescription"
        case deployAsApplicationConfigurationDescription = "DeployAsApplicationConfigurationDescription"
        case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogConfigurationDescription = self.catalogConfigurationDescription {
            try encodeContainer.encode(catalogConfigurationDescription, forKey: .catalogConfigurationDescription)
        }
        if let customArtifactsConfigurationDescription = customArtifactsConfigurationDescription {
            var customArtifactsConfigurationDescriptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customArtifactsConfigurationDescription)
            for customartifactconfigurationdescription0 in customArtifactsConfigurationDescription {
                try customArtifactsConfigurationDescriptionContainer.encode(customartifactconfigurationdescription0)
            }
        }
        if let deployAsApplicationConfigurationDescription = self.deployAsApplicationConfigurationDescription {
            try encodeContainer.encode(deployAsApplicationConfigurationDescription, forKey: .deployAsApplicationConfigurationDescription)
        }
        if let monitoringConfigurationDescription = self.monitoringConfigurationDescription {
            try encodeContainer.encode(monitoringConfigurationDescription, forKey: .monitoringConfigurationDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription.self, forKey: .monitoringConfigurationDescription)
        monitoringConfigurationDescription = monitoringConfigurationDescriptionDecoded
        let catalogConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription.self, forKey: .catalogConfigurationDescription)
        catalogConfigurationDescription = catalogConfigurationDescriptionDecoded
        let deployAsApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription.self, forKey: .deployAsApplicationConfigurationDescription)
        deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescriptionDecoded
        let customArtifactsConfigurationDescriptionContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription?].self, forKey: .customArtifactsConfigurationDescription)
        var customArtifactsConfigurationDescriptionDecoded0:[KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription]? = nil
        if let customArtifactsConfigurationDescriptionContainer = customArtifactsConfigurationDescriptionContainer {
            customArtifactsConfigurationDescriptionDecoded0 = [KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription]()
            for structure0 in customArtifactsConfigurationDescriptionContainer {
                if let structure0 = structure0 {
                    customArtifactsConfigurationDescriptionDecoded0?.append(structure0)
                }
            }
        }
        customArtifactsConfigurationDescription = customArtifactsConfigurationDescriptionDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of a Kinesis Data Analytics Studio notebook.
    public struct ZeppelinApplicationConfigurationDescription: Swift.Equatable {
        /// The Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.
        public var catalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public var customArtifactsConfigurationDescription: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription]?
        /// The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
        public var deployAsApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription?
        /// The monitoring configuration of a Kinesis Data Analytics Studio notebook.
        /// This member is required.
        public var monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription?

        public init (
            catalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription? = nil,
            customArtifactsConfigurationDescription: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription]? = nil,
            deployAsApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription? = nil,
            monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription? = nil
        )
        {
            self.catalogConfigurationDescription = catalogConfigurationDescription
            self.customArtifactsConfigurationDescription = customArtifactsConfigurationDescription
            self.deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogConfigurationUpdate = "CatalogConfigurationUpdate"
        case customArtifactsConfigurationUpdate = "CustomArtifactsConfigurationUpdate"
        case deployAsApplicationConfigurationUpdate = "DeployAsApplicationConfigurationUpdate"
        case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogConfigurationUpdate = self.catalogConfigurationUpdate {
            try encodeContainer.encode(catalogConfigurationUpdate, forKey: .catalogConfigurationUpdate)
        }
        if let customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate {
            var customArtifactsConfigurationUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customArtifactsConfigurationUpdate)
            for customartifactconfiguration0 in customArtifactsConfigurationUpdate {
                try customArtifactsConfigurationUpdateContainer.encode(customartifactconfiguration0)
            }
        }
        if let deployAsApplicationConfigurationUpdate = self.deployAsApplicationConfigurationUpdate {
            try encodeContainer.encode(deployAsApplicationConfigurationUpdate, forKey: .deployAsApplicationConfigurationUpdate)
        }
        if let monitoringConfigurationUpdate = self.monitoringConfigurationUpdate {
            try encodeContainer.encode(monitoringConfigurationUpdate, forKey: .monitoringConfigurationUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate.self, forKey: .monitoringConfigurationUpdate)
        monitoringConfigurationUpdate = monitoringConfigurationUpdateDecoded
        let catalogConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate.self, forKey: .catalogConfigurationUpdate)
        catalogConfigurationUpdate = catalogConfigurationUpdateDecoded
        let deployAsApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate.self, forKey: .deployAsApplicationConfigurationUpdate)
        deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdateDecoded
        let customArtifactsConfigurationUpdateContainer = try containerValues.decodeIfPresent([KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration?].self, forKey: .customArtifactsConfigurationUpdate)
        var customArtifactsConfigurationUpdateDecoded0:[KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]? = nil
        if let customArtifactsConfigurationUpdateContainer = customArtifactsConfigurationUpdateContainer {
            customArtifactsConfigurationUpdateDecoded0 = [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]()
            for structure0 in customArtifactsConfigurationUpdateContainer {
                if let structure0 = structure0 {
                    customArtifactsConfigurationUpdateDecoded0?.append(structure0)
                }
            }
        }
        customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdateDecoded0
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration of Kinesis Data Analytics Studio notebook.
    public struct ZeppelinApplicationConfigurationUpdate: Swift.Equatable {
        /// Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.
        public var catalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate?
        /// Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).
        public var customArtifactsConfigurationUpdate: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]?
        /// Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.
        public var deployAsApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate?
        /// Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.
        public var monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate?

        public init (
            catalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate? = nil,
            customArtifactsConfigurationUpdate: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]? = nil,
            deployAsApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate? = nil,
            monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate? = nil
        )
        {
            self.catalogConfigurationUpdate = catalogConfigurationUpdate
            self.customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate
            self.deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook. For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html).
    public struct ZeppelinMonitoringConfiguration: Swift.Equatable {
        /// The verbosity of the CloudWatch Logs for an application.
        /// This member is required.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?

        public init (
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil
        )
        {
            self.logLevel = logLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The monitoring configuration for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.
    public struct ZeppelinMonitoringConfigurationDescription: Swift.Equatable {
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?

        public init (
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil
        )
        {
            self.logLevel = logLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevelUpdate = "LogLevelUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevelUpdate = self.logLevelUpdate {
            try encodeContainer.encode(logLevelUpdate.rawValue, forKey: .logLevelUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsV2ClientTypes.LogLevel.self, forKey: .logLevelUpdate)
        logLevelUpdate = logLevelUpdateDecoded
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the monitoring configuration for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.
    public struct ZeppelinMonitoringConfigurationUpdate: Swift.Equatable {
        /// Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.
        /// This member is required.
        public var logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel?

        public init (
            logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel? = nil
        )
        {
            self.logLevelUpdate = logLevelUpdate
        }
    }

}
