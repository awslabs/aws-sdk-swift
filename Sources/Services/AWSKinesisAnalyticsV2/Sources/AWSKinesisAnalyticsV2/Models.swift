//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Exception thrown as a result of concurrent modifications to an application. This error can be the result of attempting to modify an application without using the current application ID.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The user-provided application configuration is not valid.
public struct InvalidApplicationConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApplicationConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified input parameter value is not valid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request JSON is not valid for the operation.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The application is not available for this operation.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Specified application can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
    public struct CloudWatchLoggingOption {
        /// The ARN of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?

        public init(
            logStreamARN: Swift.String? = nil
        )
        {
            self.logStreamARN = logStreamARN
        }
    }

}

public struct AddApplicationCloudWatchLoggingOptionInput {
    /// The Kinesis Data Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN).
    /// This member is required.
    public var cloudWatchLoggingOption: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The version ID of the SQL-based Kinesis Data Analytics application. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOption: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOption = cloudWatchLoggingOption
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the Amazon CloudWatch logging option.
    public struct CloudWatchLoggingOptionDescription {
        /// The ID of the CloudWatch logging option description.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?
        /// The IAM ARN of the role to use to send application messages. Provided for backward compatibility. Applications created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }
    }

}

public struct AddApplicationCloudWatchLoggingOptionOutput {
    /// The application's ARN.
    public var applicationARN: Swift.String?
    /// The new version ID of the SQL-based Kinesis Data Analytics application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
    public var applicationVersionId: Swift.Int?
    /// The descriptions of the current CloudWatch logging options for the SQL-based Kinesis Data Analytics application.
    public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?
    /// Operation ID for tracking AddApplicationCloudWatchLoggingOption request
    public var operationId: Swift.String?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
        self.operationId = operationId
    }
}

/// The user-provided application code (query) is not valid. This can be a simple syntax error.
public struct CodeValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
    public struct InputParallelism {
        /// The number of in-application streams to create.
        public var count: Swift.Int?

        public init(
            count: Swift.Int? = nil
        )
        {
            self.count = count
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
    public struct InputLambdaProcessor {
        /// The ARN of the Amazon Lambda function that operates on records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is [Amazon Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfiguration {
        /// The [InputLambdaProcessor] that is used to preprocess the records in the stream before being processed by your application code.
        /// This member is required.
        public var inputLambdaProcessor: KinesisAnalyticsV2ClientTypes.InputLambdaProcessor?

        public init(
            inputLambdaProcessor: KinesisAnalyticsV2ClientTypes.InputLambdaProcessor? = nil
        )
        {
            self.inputLambdaProcessor = inputLambdaProcessor
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream. Also used to describe the format of the reference data source.
    public struct RecordColumn {
        /// A reference to the data element in the streaming input or the reference data source.
        public var mapping: Swift.String?
        /// The name of the column that is created in the in-application input stream or reference table.
        /// This member is required.
        public var name: Swift.String?
        /// The type of column created in the in-application input stream or reference table.
        /// This member is required.
        public var sqlType: Swift.String?

        public init(
            mapping: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlType: Swift.String? = nil
        )
        {
            self.mapping = mapping
            self.name = name
            self.sqlType = sqlType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter: "name1", "address1"
    ///     "name2", "address2"
    public struct CSVMappingParameters {
        /// The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
        /// This member is required.
        public var recordColumnDelimiter: Swift.String?
        /// The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
        /// This member is required.
        public var recordRowDelimiter: Swift.String?

        public init(
            recordColumnDelimiter: Swift.String? = nil,
            recordRowDelimiter: Swift.String? = nil
        )
        {
            self.recordColumnDelimiter = recordColumnDelimiter
            self.recordRowDelimiter = recordRowDelimiter
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
    public struct JSONMappingParameters {
        /// The path to the top-level parent that contains the records.
        /// This member is required.
        public var recordRowPath: Swift.String?

        public init(
            recordRowPath: Swift.String? = nil
        )
        {
            self.recordRowPath = recordRowPath
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    public struct MappingParameters {
        /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
        public var csvMappingParameters: KinesisAnalyticsV2ClientTypes.CSVMappingParameters?
        /// Provides additional mapping information when JSON is the record format on the streaming source.
        public var jsonMappingParameters: KinesisAnalyticsV2ClientTypes.JSONMappingParameters?

        public init(
            csvMappingParameters: KinesisAnalyticsV2ClientTypes.CSVMappingParameters? = nil,
            jsonMappingParameters: KinesisAnalyticsV2ClientTypes.JSONMappingParameters? = nil
        )
        {
            self.csvMappingParameters = csvMappingParameters
            self.jsonMappingParameters = jsonMappingParameters
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum RecordFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordFormatType] {
            return [
                .csv,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
    public struct RecordFormat {
        /// When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        public var mappingParameters: KinesisAnalyticsV2ClientTypes.MappingParameters?
        /// The type of record format.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType?

        public init(
            mappingParameters: KinesisAnalyticsV2ClientTypes.MappingParameters? = nil,
            recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType? = nil
        )
        {
            self.mappingParameters = mappingParameters
            self.recordFormatType = recordFormatType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    public struct SourceSchema {
        /// A list of RecordColumn objects.
        /// This member is required.
        public var recordColumns: [KinesisAnalyticsV2ClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public var recordEncoding: Swift.String?
        /// Specifies the format of the records on the streaming source.
        /// This member is required.
        public var recordFormat: KinesisAnalyticsV2ClientTypes.RecordFormat?

        public init(
            recordColumns: [KinesisAnalyticsV2ClientTypes.RecordColumn]? = nil,
            recordEncoding: Swift.String? = nil,
            recordFormat: KinesisAnalyticsV2ClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumns = recordColumns
            self.recordEncoding = recordEncoding
            self.recordFormat = recordFormat
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN).
    public struct KinesisFirehoseInput {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Identifies a Kinesis data stream as the streaming source. You provide the stream's Amazon Resource Name (ARN).
    public struct KinesisStreamsInput {
        /// The ARN of the input Kinesis data stream to read.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
    public struct Input {
        /// Describes the number of in-application streams to create.
        public var inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism?
        /// The [InputProcessingConfiguration] for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is [InputLambdaProcessor].
        public var inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created. Also used to describe the format of the reference data source.
        /// This member is required.
        public var inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
        public var kinesisFirehoseInput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput?
        /// If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
        public var kinesisStreamsInput: KinesisAnalyticsV2ClientTypes.KinesisStreamsInput?
        /// The name prefix to use when creating an in-application stream. Suppose that you specify a prefix "MyInApplicationStream." Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on.
        /// This member is required.
        public var namePrefix: Swift.String?

        public init(
            inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism? = nil,
            inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration? = nil,
            inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            kinesisFirehoseInput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput? = nil,
            kinesisStreamsInput: KinesisAnalyticsV2ClientTypes.KinesisStreamsInput? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inputParallelism = inputParallelism
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputSchema = inputSchema
            self.kinesisFirehoseInput = kinesisFirehoseInput
            self.kinesisStreamsInput = kinesisStreamsInput
            self.namePrefix = namePrefix
        }
    }

}

public struct AddApplicationInputInput {
    /// The name of your existing application to which you want to add the streaming source.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current version of your application. You must provide the ApplicationVersionID or the ConditionalToken.You can use the [DescribeApplication] operation to find the current application version.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The [Input] to add.
    /// This member is required.
    public var input: KinesisAnalyticsV2ClientTypes.Input?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        input: KinesisAnalyticsV2ClientTypes.Input? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.input = input
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, an object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream.
    public struct InputLambdaProcessorDescription {
        /// The ARN of the Amazon Lambda function that is used to preprocess the records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that is used to access the Amazon Lambda function. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides the configuration information about an input processor. Currently, the only input processor available is [Amazon Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfigurationDescription {
        /// Provides configuration information about the associated [InputLambdaProcessorDescription]
        public var inputLambdaProcessorDescription: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription?

        public init(
            inputLambdaProcessorDescription: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription? = nil
        )
        {
            self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum InputStartingPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lastStoppedPoint
        case now
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStartingPosition] {
            return [
                .lastStoppedPoint,
                .now,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lastStoppedPoint: return "LAST_STOPPED_POINT"
            case .now: return "NOW"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the point at which the application reads from the streaming source.
    public struct InputStartingPositionConfiguration {
        /// The starting position on the stream.
        ///
        /// * NOW - Start reading just after the most recent record in the stream, and start at the request timestamp that the customer issued.
        ///
        /// * TRIM_HORIZON - Start reading at the last untrimmed record in the stream, which is the oldest record available in the stream. This option is not available for an Amazon Kinesis Data Firehose delivery stream.
        ///
        /// * LAST_STOPPED_POINT - Resume reading from where the application last stopped reading.
        public var inputStartingPosition: KinesisAnalyticsV2ClientTypes.InputStartingPosition?

        public init(
            inputStartingPosition: KinesisAnalyticsV2ClientTypes.InputStartingPosition? = nil
        )
        {
            self.inputStartingPosition = inputStartingPosition
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the Amazon Kinesis Data Firehose delivery stream that is configured as the streaming source in the application input configuration.
    public struct KinesisFirehoseInputDescription {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the Kinesis data stream that is configured as the streaming source in the application input configuration.
    public struct KinesisStreamsInputDescription {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the application input configuration for a SQL-based Kinesis Data Analytics application.
    public struct InputDescription {
        /// Returns the in-application stream names that are mapped to the stream source.
        public var inAppStreamNames: [Swift.String]?
        /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input configuration that you add to your application.
        public var inputId: Swift.String?
        /// Describes the configured parallelism (number of in-application streams mapped to the streaming source).
        public var inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public var inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
        public var inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// The point at which the application is configured to read from the input stream.
        public var inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?
        /// If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN.
        public var kinesisFirehoseInputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription?
        /// If a Kinesis data stream is configured as a streaming source, provides the Kinesis data stream's Amazon Resource Name (ARN).
        public var kinesisStreamsInputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription?
        /// The in-application name prefix.
        public var namePrefix: Swift.String?

        public init(
            inAppStreamNames: [Swift.String]? = nil,
            inputId: Swift.String? = nil,
            inputParallelism: KinesisAnalyticsV2ClientTypes.InputParallelism? = nil,
            inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription? = nil,
            inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration? = nil,
            kinesisFirehoseInputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription? = nil,
            kinesisStreamsInputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inAppStreamNames = inAppStreamNames
            self.inputId = inputId
            self.inputParallelism = inputParallelism
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
            self.inputSchema = inputSchema
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
            self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
            self.namePrefix = namePrefix
        }
    }

}

public struct AddApplicationInputOutput {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// Provides the current application version.
    public var applicationVersionId: Swift.Int?
    /// Describes the application input configuration.
    public var inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.inputDescriptions = inputDescriptions
    }
}

public struct AddApplicationInputProcessingConfigurationInput {
    /// The name of the application to which you want to add the input processing configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version of the application to which you want to add the input processing configuration. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration to add the input processing configuration to. You can get a list of the input IDs for an application using the [DescribeApplication] operation.
    /// This member is required.
    public var inputId: Swift.String?
    /// The [InputProcessingConfiguration] to add to the application.
    /// This member is required.
    public var inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil,
        inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
        self.inputProcessingConfiguration = inputProcessingConfiguration
    }
}

public struct AddApplicationInputProcessingConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// Provides the current application version.
    public var applicationVersionId: Swift.Int?
    /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input configuration that you add to your application.
    public var inputId: Swift.String?
    /// The description of the preprocessor that executes on records in this input before the application's code is run.
    public var inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil,
        inputProcessingConfigurationDescription: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.inputId = inputId
        self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the data format when records are written to the destination in a SQL-based Kinesis Data Analytics application.
    public struct DestinationSchema {
        /// Specifies the format of the records on the output stream.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType?

        public init(
            recordFormatType: KinesisAnalyticsV2ClientTypes.RecordFormatType? = nil
        )
        {
            self.recordFormatType = recordFormatType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, when configuring application output, identifies a Kinesis Data Firehose delivery stream as the destination. You provide the stream Amazon Resource Name (ARN) of the delivery stream.
    public struct KinesisFirehoseOutput {
        /// The ARN of the destination delivery stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure a SQL-based Kinesis Data Analytics application's output, identifies a Kinesis data stream as the destination. You provide the stream Amazon Resource Name (ARN).
    public struct KinesisStreamsOutput {
        /// The ARN of the destination Kinesis data stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you configure a SQL-based Kinesis Data Analytics application's output, identifies an Amazon Lambda function as the destination. You provide the function Amazon Resource Name (ARN) of the Lambda function.
    public struct LambdaOutput {
        /// The Amazon Resource Name (ARN) of the destination Lambda function to write to. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written. The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
    public struct Output {
        /// Describes the data format when records are written to the destination.
        /// This member is required.
        public var destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema?
        /// Identifies a Kinesis Data Firehose delivery stream as the destination.
        public var kinesisFirehoseOutput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput?
        /// Identifies a Kinesis data stream as the destination.
        public var kinesisStreamsOutput: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput?
        /// Identifies an Amazon Lambda function as the destination.
        public var lambdaOutput: KinesisAnalyticsV2ClientTypes.LambdaOutput?
        /// The name of the in-application stream.
        /// This member is required.
        public var name: Swift.String?

        public init(
            destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutput: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput? = nil,
            kinesisStreamsOutput: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput? = nil,
            lambdaOutput: KinesisAnalyticsV2ClientTypes.LambdaOutput? = nil,
            name: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutput = kinesisFirehoseOutput
            self.kinesisStreamsOutput = kinesisStreamsOutput
            self.lambdaOutput = lambdaOutput
            self.name = name
        }
    }

}

public struct AddApplicationOutputInput {
    /// The name of the application to which you want to add the output configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version of the application to which you want to add the output configuration. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// An array of objects, each describing one output configuration. In the output configuration, you specify the name of an in-application stream, a destination (that is, a Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and record the formation to use when writing to the destination.
    /// This member is required.
    public var output: KinesisAnalyticsV2ClientTypes.Output?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        output: KinesisAnalyticsV2ClientTypes.Output? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.output = output
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application's output, describes the Kinesis Data Firehose delivery stream that is configured as its destination.
    public struct KinesisFirehoseOutputDescription {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For an SQL-based Kinesis Data Analytics application's output, describes the Kinesis data stream that is configured as its destination.
    public struct KinesisStreamsOutputDescription {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application's output, describes the Amazon Lambda function that is configured as its destination.
    public struct LambdaOutputDescription {
        /// The Amazon Resource Name (ARN) of the destination Lambda function.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination function. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the application output configuration, which includes the in-application stream name and the destination where the stream data is written. The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
    public struct OutputDescription {
        /// The data format used for writing data to the destination.
        public var destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema?
        /// Describes the Kinesis Data Firehose delivery stream that is configured as the destination where output is written.
        public var kinesisFirehoseOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription?
        /// Describes the Kinesis data stream that is configured as the destination where output is written.
        public var kinesisStreamsOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription?
        /// Describes the Lambda function that is configured as the destination where output is written.
        public var lambdaOutputDescription: KinesisAnalyticsV2ClientTypes.LambdaOutputDescription?
        /// The name of the in-application stream that is configured as output.
        public var name: Swift.String?
        /// A unique identifier for the output configuration.
        public var outputId: Swift.String?

        public init(
            destinationSchema: KinesisAnalyticsV2ClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription? = nil,
            kinesisStreamsOutputDescription: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription? = nil,
            lambdaOutputDescription: KinesisAnalyticsV2ClientTypes.LambdaOutputDescription? = nil,
            name: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
            self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
            self.lambdaOutputDescription = lambdaOutputDescription
            self.name = name
            self.outputId = outputId
        }
    }

}

public struct AddApplicationOutputOutput {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
    public var applicationVersionId: Swift.Int?
    /// Describes the application output configuration. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
    public var outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.outputDescriptions = outputDescriptions
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, identifies the Amazon S3 bucket and object that contains the reference data. A SQL-based Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication] operation to trigger reloading of data into your application.
    public struct S3ReferenceDataSource {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARN: Swift.String?
        /// The object key name containing the reference data.
        public var fileKey: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
    public struct ReferenceDataSource {
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        /// This member is required.
        public var referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// Identifies the S3 bucket and object that contains the reference data. A SQL-based Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication] operation to trigger reloading of data into your application.
        public var s3ReferenceDataSource: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource?
        /// The name of the in-application table to create.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            s3ReferenceDataSource: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSource = s3ReferenceDataSource
            self.tableName = tableName
        }
    }

}

public struct AddApplicationReferenceDataSourceInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version of the application for which you are adding the reference data source. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting in-application table that is created.
    /// This member is required.
    public var referenceDataSource: KinesisAnalyticsV2ClientTypes.ReferenceDataSource?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceDataSource: KinesisAnalyticsV2ClientTypes.ReferenceDataSource? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceDataSource = referenceDataSource
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides the bucket name and object key name that stores the reference data.
    public struct S3ReferenceDataSourceDescription {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// Amazon S3 object key name.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table. Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public var referenceRoleARN: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            referenceRoleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the reference data source configured for an application.
    public struct ReferenceDataSourceDescription {
        /// The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns when you add the reference data source to your application using the [CreateApplication] or [UpdateApplication] operation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// Provides the Amazon S3 bucket name, the object key name that contains the reference data.
        /// This member is required.
        public var s3ReferenceDataSourceDescription: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription?
        /// The in-application table name created by the specific reference data source configuration.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            referenceId: Swift.String? = nil,
            referenceSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceDescription: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
            self.tableName = tableName
        }
    }

}

public struct AddApplicationReferenceDataSourceOutput {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
    public var applicationVersionId: Swift.Int?
    /// Describes reference data sources configured for the application.
    public var referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the parameters of a VPC used by the application.
    public struct VpcConfiguration {
        /// The array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

public struct AddApplicationVpcConfigurationInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// A value you use to implement strong concurrency for application updates. You must provide the ApplicationVersionID or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The version of the application to which you want to add the VPC configuration. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?
    /// Description of the VPC to add to the application.
    /// This member is required.
    public var vpcConfiguration: KinesisAnalyticsV2ClientTypes.VpcConfiguration?

    public init(
        applicationName: Swift.String? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        vpcConfiguration: KinesisAnalyticsV2ClientTypes.VpcConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.vpcConfiguration = vpcConfiguration
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the parameters of a VPC used by the application.
    public struct VpcConfigurationDescription {
        /// The array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC configuration.
        /// This member is required.
        public var vpcConfigurationId: Swift.String?
        /// The ID of the associated VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcConfigurationId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConfigurationId = vpcConfigurationId
            self.vpcId = vpcId
        }
    }

}

public struct AddApplicationVpcConfigurationOutput {
    /// The ARN of the application.
    public var applicationARN: Swift.String?
    /// Provides the current application version. Managed Service for Apache Flink updates the ApplicationVersionId each time you update the application.
    public var applicationVersionId: Swift.Int?
    /// Operation ID for tracking AddApplicationVpcConfiguration request
    public var operationId: Swift.String?
    /// The parameters of the new VPC configuration.
    public var vpcConfigurationDescription: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        operationId: Swift.String? = nil,
        vpcConfigurationDescription: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.operationId = operationId
        self.vpcConfigurationDescription = vpcConfigurationDescription
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a Managed Service for Apache Flink application provides a description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
    public struct S3ContentLocation {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The file key for the object containing the application code.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The version of the object containing the application code.
        public var objectVersion: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies either the application code, or the location of the application code, for a Managed Service for Apache Flink application.
    public struct CodeContent {
        /// Information about the Amazon S3 bucket that contains the application code.
        public var s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation?
        /// The text-format code for a Managed Service for Apache Flink application.
        public var textContent: Swift.String?
        /// The zip-format code for a Managed Service for Apache Flink application.
        public var zipFileContent: Foundation.Data?

        public init(
            s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation? = nil,
            textContent: Swift.String? = nil,
            zipFileContent: Foundation.Data? = nil
        )
        {
            self.s3ContentLocation = s3ContentLocation
            self.textContent = textContent
            self.zipFileContent = zipFileContent
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum CodeContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plaintext
        case zipfile
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeContentType] {
            return [
                .plaintext,
                .zipfile
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .zipfile: return "ZIPFILE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes code configuration for an application.
    public struct ApplicationCodeConfiguration {
        /// The location and type of the application code.
        public var codeContent: KinesisAnalyticsV2ClientTypes.CodeContent?
        /// Specifies whether the code content is in text or zip format.
        /// This member is required.
        public var codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType?

        public init(
            codeContent: KinesisAnalyticsV2ClientTypes.CodeContent? = nil,
            codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType? = nil
        )
        {
            self.codeContent = codeContent
            self.codeContentType = codeContentType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the location of an application's code stored in an S3 bucket.
    public struct S3ApplicationCodeLocationDescription {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The file key for the object containing the application code.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The version of the object containing the application code.
        public var objectVersion: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes details about the code of a Managed Service for Apache Flink application.
    public struct CodeContentDescription {
        /// The checksum that can be used to validate zip-format code.
        public var codeMD5: Swift.String?
        /// The size in bytes of the application code. Can be used to validate zip-format code.
        public var codeSize: Swift.Int?
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application code stored in Amazon S3.
        public var s3ApplicationCodeLocationDescription: KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription?
        /// The text-format code
        public var textContent: Swift.String?

        public init(
            codeMD5: Swift.String? = nil,
            codeSize: Swift.Int? = nil,
            s3ApplicationCodeLocationDescription: KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription? = nil,
            textContent: Swift.String? = nil
        )
        {
            self.codeMD5 = codeMD5
            self.codeSize = codeSize
            self.s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescription
            self.textContent = textContent
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes code configuration for an application.
    public struct ApplicationCodeConfigurationDescription {
        /// Describes details about the location and format of the application code.
        public var codeContentDescription: KinesisAnalyticsV2ClientTypes.CodeContentDescription?
        /// Specifies whether the code content is in text or zip format.
        /// This member is required.
        public var codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType?

        public init(
            codeContentDescription: KinesisAnalyticsV2ClientTypes.CodeContentDescription? = nil,
            codeContentType: KinesisAnalyticsV2ClientTypes.CodeContentType? = nil
        )
        {
            self.codeContentDescription = codeContentDescription
            self.codeContentType = codeContentType
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes an update for the Amazon S3 code content location for an application.
    public struct S3ContentLocationUpdate {
        /// The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public var bucketARNUpdate: Swift.String?
        /// The new file key for the object containing the application code.
        public var fileKeyUpdate: Swift.String?
        /// The new version of the object containing the application code.
        public var objectVersionUpdate: Swift.String?

        public init(
            bucketARNUpdate: Swift.String? = nil,
            fileKeyUpdate: Swift.String? = nil,
            objectVersionUpdate: Swift.String? = nil
        )
        {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
            self.objectVersionUpdate = objectVersionUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes an update to the code of an application. Not supported for Apache Zeppelin.
    public struct CodeContentUpdate {
        /// Describes an update to the location of code for an application.
        public var s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate?
        /// Describes an update to the text code for an application.
        public var textContentUpdate: Swift.String?
        /// Describes an update to the zipped code for an application.
        public var zipFileContentUpdate: Foundation.Data?

        public init(
            s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate? = nil,
            textContentUpdate: Swift.String? = nil,
            zipFileContentUpdate: Foundation.Data? = nil
        )
        {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
            self.textContentUpdate = textContentUpdate
            self.zipFileContentUpdate = zipFileContentUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes code configuration updates for an application. This is supported for a Managed Service for Apache Flink application or a SQL-based Kinesis Data Analytics application.
    public struct ApplicationCodeConfigurationUpdate {
        /// Describes updates to the code content type.
        public var codeContentTypeUpdate: KinesisAnalyticsV2ClientTypes.CodeContentType?
        /// Describes updates to the code content of an application.
        public var codeContentUpdate: KinesisAnalyticsV2ClientTypes.CodeContentUpdate?

        public init(
            codeContentTypeUpdate: KinesisAnalyticsV2ClientTypes.CodeContentType? = nil,
            codeContentUpdate: KinesisAnalyticsV2ClientTypes.CodeContentUpdate? = nil
        )
        {
            self.codeContentTypeUpdate = codeContentTypeUpdate
            self.codeContentUpdate = codeContentUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
    public struct ApplicationSnapshotConfiguration {
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        /// This member is required.
        public var snapshotsEnabled: Swift.Bool?

        public init(
            snapshotsEnabled: Swift.Bool? = nil
        )
        {
            self.snapshotsEnabled = snapshotsEnabled
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes system rollback configuration for a Managed Service for Apache Flink application
    public struct ApplicationSystemRollbackConfiguration {
        /// Describes whether system rollbacks are enabled for a Managed Service for Apache Flink application
        /// This member is required.
        public var rollbackEnabled: Swift.Bool?

        public init(
            rollbackEnabled: Swift.Bool? = nil
        )
        {
            self.rollbackEnabled = rollbackEnabled
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Property key-value pairs passed into an application.
    public struct PropertyGroup {
        /// Describes the key of an application execution property key-value pair.
        /// This member is required.
        public var propertyGroupId: Swift.String?
        /// Describes the value of an application execution property key-value pair.
        /// This member is required.
        public var propertyMap: [Swift.String: Swift.String]?

        public init(
            propertyGroupId: Swift.String? = nil,
            propertyMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.propertyGroupId = propertyGroupId
            self.propertyMap = propertyMap
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes execution properties for a Managed Service for Apache Flink application.
    public struct EnvironmentProperties {
        /// Describes the execution property groups.
        /// This member is required.
        public var propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]?

        public init(
            propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        )
        {
            self.propertyGroups = propertyGroups
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum ConfigurationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationType] {
            return [
                .custom,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see [ Checkpoints for Fault Tolerance](https://nightlies.apache.org/flink/flink-docs-release-1.19/docs/dev/datastream/fault-tolerance/checkpointing/#enabling-and-configuring-checkpointing) in the [Apache Flink Documentation](https://nightlies.apache.org/flink/flink-docs-release-1.19/).
    public struct CheckpointConfiguration {
        /// Describes the interval in milliseconds between checkpoint operations. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value using this API or in application code.
        public var checkpointInterval: Swift.Int?
        /// Describes whether checkpointing is enabled for a Managed Service for Apache Flink application. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to another value using this API or in application code.
        public var checkpointingEnabled: Swift.Bool?
        /// Describes whether the application uses Managed Service for Apache Flink' default checkpointing behavior. You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters. If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:
        ///
        /// * CheckpointingEnabled: true
        ///
        /// * CheckpointInterval: 60000
        ///
        /// * MinPauseBetweenCheckpoints: 5000
        /// This member is required.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see [ Tuning Checkpointing](https://nightlies.apache.org/flink/flink-docs-release-1.19/docs/ops/state/large_state_tuning/#tuning-checkpointing) in the [Apache Flink Documentation](https://nightlies.apache.org/flink/flink-docs-release-1.19/). If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or in application code.
        public var minPauseBetweenCheckpoints: Swift.Int?

        public init(
            checkpointInterval: Swift.Int? = nil,
            checkpointingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            minPauseBetweenCheckpoints: Swift.Int? = nil
        )
        {
            self.checkpointInterval = checkpointInterval
            self.checkpointingEnabled = checkpointingEnabled
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .error,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {

    public enum MetricsLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case `operator`
        case parallelism
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsLevel] {
            return [
                .application,
                .operator,
                .parallelism,
                .task
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .operator: return "OPERATOR"
            case .parallelism: return "PARALLELISM"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for Amazon CloudWatch logging for an application. For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html).
    public struct MonitoringConfiguration {
        /// Describes whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        /// This member is required.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public var metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel?

        public init(
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil,
            metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel? = nil
        )
        {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes parameters for how a Managed Service for Apache Flink application executes multiple tasks simultaneously. For more information about parallelism, see [Parallel Execution](https://nightlies.apache.org/flink/flink-docs-release-1.19/dev/parallel.html) in the [Apache Flink Documentation](https://nightlies.apache.org/flink/flink-docs-release-1.19/).
    public struct ParallelismConfiguration {
        /// Describes whether the Managed Service for Apache Flink service can increase the parallelism of the application in response to increased throughput.
        public var autoScalingEnabled: Swift.Bool?
        /// Describes whether the application uses the default parallelism for the Managed Service for Apache Flink service. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        /// This member is required.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the initial number of parallel tasks that a Managed Service for Apache Flink application can perform. If AutoScalingEnabled is set to True, Managed Service for Apache Flink increases the CurrentParallelism value in response to application load. The service can increase the CurrentParallelism value up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public var parallelism: Swift.Int?
        /// Describes the number of parallel tasks that a Managed Service for Apache Flink application can perform per Kinesis Processing Unit (KPU) used by the application. For more information about KPUs, see [Amazon Managed Service for Apache Flink Pricing](http://aws.amazon.com/kinesis/data-analytics/pricing/).
        public var parallelismPerKPU: Swift.Int?

        public init(
            autoScalingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            parallelism: Swift.Int? = nil,
            parallelismPerKPU: Swift.Int? = nil
        )
        {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for a Managed Service for Apache Flink application or a Studio notebook.
    public struct FlinkApplicationConfiguration {
        /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see [ Checkpoints for Fault Tolerance](https://nightlies.apache.org/flink/flink-docs-release-1.19/docs/dev/datastream/fault-tolerance/checkpointing/#enabling-and-configuring-checkpointing) in the [Apache Flink Documentation](https://nightlies.apache.org/flink/flink-docs-release-1.19/).
        public var checkpointConfiguration: KinesisAnalyticsV2ClientTypes.CheckpointConfiguration?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public var monitoringConfiguration: KinesisAnalyticsV2ClientTypes.MonitoringConfiguration?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public var parallelismConfiguration: KinesisAnalyticsV2ClientTypes.ParallelismConfiguration?

        public init(
            checkpointConfiguration: KinesisAnalyticsV2ClientTypes.CheckpointConfiguration? = nil,
            monitoringConfiguration: KinesisAnalyticsV2ClientTypes.MonitoringConfiguration? = nil,
            parallelismConfiguration: KinesisAnalyticsV2ClientTypes.ParallelismConfiguration? = nil
        )
        {
            self.checkpointConfiguration = checkpointConfiguration
            self.monitoringConfiguration = monitoringConfiguration
            self.parallelismConfiguration = parallelismConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
    public struct SqlApplicationConfiguration {
        /// The array of [Input] objects describing the input streams used by the application.
        public var inputs: [KinesisAnalyticsV2ClientTypes.Input]?
        /// The array of [Output] objects describing the destination streams used by the application.
        public var outputs: [KinesisAnalyticsV2ClientTypes.Output]?
        /// The array of [ReferenceDataSource] objects describing the reference data sources used by the application.
        public var referenceDataSources: [KinesisAnalyticsV2ClientTypes.ReferenceDataSource]?

        public init(
            inputs: [KinesisAnalyticsV2ClientTypes.Input]? = nil,
            outputs: [KinesisAnalyticsV2ClientTypes.Output]? = nil,
            referenceDataSources: [KinesisAnalyticsV2ClientTypes.ReferenceDataSource]? = nil
        )
        {
            self.inputs = inputs
            self.outputs = outputs
            self.referenceDataSources = referenceDataSources
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
    public struct GlueDataCatalogConfiguration {
        /// The Amazon Resource Name (ARN) of the database.
        /// This member is required.
        public var databaseARN: Swift.String?

        public init(
            databaseARN: Swift.String? = nil
        )
        {
            self.databaseARN = databaseARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
    public struct CatalogConfiguration {
        /// The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Managed Service for Apache Flink Studio notebook.
        /// This member is required.
        public var glueDataCatalogConfiguration: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration?

        public init(
            glueDataCatalogConfiguration: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration? = nil
        )
        {
            self.glueDataCatalogConfiguration = glueDataCatalogConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum ArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dependencyJar
        case udf
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactType] {
            return [
                .dependencyJar,
                .udf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dependencyJar: return "DEPENDENCY_JAR"
            case .udf: return "UDF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.
    public struct MavenReference {
        /// The artifact ID of the Maven reference.
        /// This member is required.
        public var artifactId: Swift.String?
        /// The group ID of the Maven reference.
        /// This member is required.
        public var groupId: Swift.String?
        /// The version of the Maven reference.
        /// This member is required.
        public var version: Swift.String?

        public init(
            artifactId: Swift.String? = nil,
            groupId: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.artifactId = artifactId
            self.groupId = groupId
            self.version = version
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies dependency JARs, as well as JAR files that contain user-defined functions (UDF).
    public struct CustomArtifactConfiguration {
        /// UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        /// This member is required.
        public var artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType?
        /// The parameters required to fully specify a Maven reference.
        public var mavenReference: KinesisAnalyticsV2ClientTypes.MavenReference?
        /// For a Managed Service for Apache Flink application provides a description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        public var s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation?

        public init(
            artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType? = nil,
            mavenReference: KinesisAnalyticsV2ClientTypes.MavenReference? = nil,
            s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentLocation? = nil
        )
        {
            self.artifactType = artifactType
            self.mavenReference = mavenReference
            self.s3ContentLocation = s3ContentLocation
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The S3 bucket that holds the application information.
    public struct S3ContentBaseLocation {
        /// The base path for the S3 bucket.
        public var basePath: Swift.String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?

        public init(
            basePath: Swift.String? = nil,
            bucketARN: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The information required to deploy a Managed Service for Apache Flink Studio notebook as an application with durable state.
    public struct DeployAsApplicationConfiguration {
        /// The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        /// This member is required.
        public var s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation?

        public init(
            s3ContentLocation: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation? = nil
        )
        {
            self.s3ContentLocation = s3ContentLocation
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for Amazon CloudWatch logging for a Managed Service for Apache Flink Studio notebook. For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html).
    public struct ZeppelinMonitoringConfiguration {
        /// The verbosity of the CloudWatch Logs for an application.
        /// This member is required.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?

        public init(
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil
        )
        {
            self.logLevel = logLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of a Managed Service for Apache Flink Studio notebook.
    public struct ZeppelinApplicationConfiguration {
        /// The Amazon Glue Data Catalog that you use in queries in a Managed Service for Apache Flink Studio notebook.
        public var catalogConfiguration: KinesisAnalyticsV2ClientTypes.CatalogConfiguration?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public var customArtifactsConfiguration: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]?
        /// The information required to deploy a Managed Service for Apache Flink Studio notebook as an application with durable state.
        public var deployAsApplicationConfiguration: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration?
        /// The monitoring configuration of a Managed Service for Apache Flink Studio notebook.
        public var monitoringConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration?

        public init(
            catalogConfiguration: KinesisAnalyticsV2ClientTypes.CatalogConfiguration? = nil,
            customArtifactsConfiguration: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]? = nil,
            deployAsApplicationConfiguration: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration? = nil,
            monitoringConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration? = nil
        )
        {
            self.catalogConfiguration = catalogConfiguration
            self.customArtifactsConfiguration = customArtifactsConfiguration
            self.deployAsApplicationConfiguration = deployAsApplicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies the creation parameters for a Managed Service for Apache Flink application.
    public struct ApplicationConfiguration {
        /// The code location and type parameters for a Managed Service for Apache Flink application.
        public var applicationCodeConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration?
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public var applicationSnapshotConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration?
        /// Describes system rollback configuration for a Managed Service for Apache Flink application
        public var applicationSystemRollbackConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfiguration?
        /// Describes execution properties for a Managed Service for Apache Flink application.
        public var environmentProperties: KinesisAnalyticsV2ClientTypes.EnvironmentProperties?
        /// The creation and update parameters for a Managed Service for Apache Flink application.
        public var flinkApplicationConfiguration: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration?
        /// The creation and update parameters for a SQL-based Kinesis Data Analytics application.
        public var sqlApplicationConfiguration: KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration?
        /// The array of descriptions of VPC configurations available to the application.
        public var vpcConfigurations: [KinesisAnalyticsV2ClientTypes.VpcConfiguration]?
        /// The configuration parameters for a Managed Service for Apache Flink Studio notebook.
        public var zeppelinApplicationConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration?

        public init(
            applicationCodeConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration? = nil,
            applicationSnapshotConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration? = nil,
            applicationSystemRollbackConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfiguration? = nil,
            environmentProperties: KinesisAnalyticsV2ClientTypes.EnvironmentProperties? = nil,
            flinkApplicationConfiguration: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration? = nil,
            sqlApplicationConfiguration: KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration? = nil,
            vpcConfigurations: [KinesisAnalyticsV2ClientTypes.VpcConfiguration]? = nil,
            zeppelinApplicationConfiguration: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration? = nil
        )
        {
            self.applicationCodeConfiguration = applicationCodeConfiguration
            self.applicationSnapshotConfiguration = applicationSnapshotConfiguration
            self.applicationSystemRollbackConfiguration = applicationSystemRollbackConfiguration
            self.environmentProperties = environmentProperties
            self.flinkApplicationConfiguration = flinkApplicationConfiguration
            self.sqlApplicationConfiguration = sqlApplicationConfiguration
            self.vpcConfigurations = vpcConfigurations
            self.zeppelinApplicationConfiguration = zeppelinApplicationConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
    public struct ApplicationSnapshotConfigurationDescription {
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        /// This member is required.
        public var snapshotsEnabled: Swift.Bool?

        public init(
            snapshotsEnabled: Swift.Bool? = nil
        )
        {
            self.snapshotsEnabled = snapshotsEnabled
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes system rollback configuration for a Managed Service for Apache Flink application
    public struct ApplicationSystemRollbackConfigurationDescription {
        /// Describes whether system rollbacks are enabled for a Managed Service for Apache Flink application
        /// This member is required.
        public var rollbackEnabled: Swift.Bool?

        public init(
            rollbackEnabled: Swift.Bool? = nil
        )
        {
            self.rollbackEnabled = rollbackEnabled
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the execution properties for an Apache Flink runtime.
    public struct EnvironmentPropertyDescriptions {
        /// Describes the execution property groups.
        public var propertyGroupDescriptions: [KinesisAnalyticsV2ClientTypes.PropertyGroup]?

        public init(
            propertyGroupDescriptions: [KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        )
        {
            self.propertyGroupDescriptions = propertyGroupDescriptions
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes checkpointing parameters for a Managed Service for Apache Flink application.
    public struct CheckpointConfigurationDescription {
        /// Describes the interval in milliseconds between checkpoint operations. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value using this API or in application code.
        public var checkpointInterval: Swift.Int?
        /// Describes whether checkpointing is enabled for a Managed Service for Apache Flink application. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to another value using this API or in application code.
        public var checkpointingEnabled: Swift.Bool?
        /// Describes whether the application uses the default checkpointing behavior in Managed Service for Apache Flink. If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:
        ///
        /// * CheckpointingEnabled: true
        ///
        /// * CheckpointInterval: 60000
        ///
        /// * MinPauseBetweenCheckpoints: 5000
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or in application code.
        public var minPauseBetweenCheckpoints: Swift.Int?

        public init(
            checkpointInterval: Swift.Int? = nil,
            checkpointingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            minPauseBetweenCheckpoints: Swift.Int? = nil
        )
        {
            self.checkpointInterval = checkpointInterval
            self.checkpointingEnabled = checkpointingEnabled
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for CloudWatch logging for an application.
    public struct MonitoringConfigurationDescription {
        /// Describes whether to use the default CloudWatch logging configuration for an application.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application.
        public var metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel?

        public init(
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil,
            metricsLevel: KinesisAnalyticsV2ClientTypes.MetricsLevel? = nil
        )
        {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes parameters for how a Managed Service for Apache Flink application executes multiple tasks simultaneously.
    public struct ParallelismConfigurationDescription {
        /// Describes whether the Managed Service for Apache Flink service can increase the parallelism of the application in response to increased throughput.
        public var autoScalingEnabled: Swift.Bool?
        /// Describes whether the application uses the default parallelism for the Managed Service for Apache Flink service.
        public var configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes the current number of parallel tasks that a Managed Service for Apache Flink application can perform. If AutoScalingEnabled is set to True, Managed Service for Apache Flink can increase this value in response to application load. The service can increase this value up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public var currentParallelism: Swift.Int?
        /// Describes the initial number of parallel tasks that a Managed Service for Apache Flink application can perform. If AutoScalingEnabled is set to True, then Managed Service for Apache Flink can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public var parallelism: Swift.Int?
        /// Describes the number of parallel tasks that a Managed Service for Apache Flink application can perform per Kinesis Processing Unit (KPU) used by the application.
        public var parallelismPerKPU: Swift.Int?

        public init(
            autoScalingEnabled: Swift.Bool? = nil,
            configurationType: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            currentParallelism: Swift.Int? = nil,
            parallelism: Swift.Int? = nil,
            parallelismPerKPU: Swift.Int? = nil
        )
        {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.currentParallelism = currentParallelism
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes configuration parameters for a Managed Service for Apache Flink application.
    public struct FlinkApplicationConfigurationDescription {
        /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance.
        public var checkpointConfigurationDescription: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription?
        /// The job plan for an application. For more information about the job plan, see [Jobs and Scheduling](https://nightlies.apache.org/flink/flink-docs-release-1.19/internals/job_scheduling.html) in the [Apache Flink Documentation](https://nightlies.apache.org/flink/flink-docs-release-1.19/). To retrieve the job plan for the application, use the [DescribeApplicationRequest$IncludeAdditionalDetails] parameter of the [DescribeApplication] operation.
        public var jobPlanDescription: Swift.String?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public var monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public var parallelismConfigurationDescription: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription?

        public init(
            checkpointConfigurationDescription: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription? = nil,
            jobPlanDescription: Swift.String? = nil,
            monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription? = nil,
            parallelismConfigurationDescription: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription? = nil
        )
        {
            self.checkpointConfigurationDescription = checkpointConfigurationDescription
            self.jobPlanDescription = jobPlanDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
            self.parallelismConfigurationDescription = parallelismConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum ApplicationRestoreType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case restoreFromCustomSnapshot
        case restoreFromLatestSnapshot
        case skipRestoreFromSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationRestoreType] {
            return [
                .restoreFromCustomSnapshot,
                .restoreFromLatestSnapshot,
                .skipRestoreFromSnapshot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .restoreFromCustomSnapshot: return "RESTORE_FROM_CUSTOM_SNAPSHOT"
            case .restoreFromLatestSnapshot: return "RESTORE_FROM_LATEST_SNAPSHOT"
            case .skipRestoreFromSnapshot: return "SKIP_RESTORE_FROM_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies the method and snapshot to use when restarting an application using previously saved application state.
    public struct ApplicationRestoreConfiguration {
        /// Specifies how the application should be restored.
        /// This member is required.
        public var applicationRestoreType: KinesisAnalyticsV2ClientTypes.ApplicationRestoreType?
        /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the ApplicationRestoreType.
        public var snapshotName: Swift.String?

        public init(
            applicationRestoreType: KinesisAnalyticsV2ClientTypes.ApplicationRestoreType? = nil,
            snapshotName: Swift.String? = nil
        )
        {
            self.applicationRestoreType = applicationRestoreType
            self.snapshotName = snapshotName
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting parameters for a Managed Service for Apache Flink application.
    public struct FlinkRunConfiguration {
        /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. This will happen if the program is updated between snapshots to remove stateful parameters, and state data in the snapshot no longer corresponds to valid application data. For more information, see [ Allowing Non-Restored State](https://nightlies.apache.org/flink/flink-docs-release-1.19/docs/ops/state/savepoints/#allowing-non-restored-state) in the [Apache Flink documentation](https://nightlies.apache.org/flink/flink-docs-release-1.19/). This value defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
        public var allowNonRestoredState: Swift.Bool?

        public init(
            allowNonRestoredState: Swift.Bool? = nil
        )
        {
            self.allowNonRestoredState = allowNonRestoredState
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting properties for a Managed Service for Apache Flink application.
    public struct RunConfigurationDescription {
        /// Describes the restore behavior of a restarting application.
        public var applicationRestoreConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Managed Service for Apache Flink application.
        public var flinkRunConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?

        public init(
            applicationRestoreConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration? = nil,
            flinkRunConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration? = nil
        )
        {
            self.applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescription
            self.flinkRunConfigurationDescription = flinkRunConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
    public struct SqlApplicationConfigurationDescription {
        /// The array of [InputDescription] objects describing the input streams used by the application.
        public var inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]?
        /// The array of [OutputDescription] objects describing the destination streams used by the application.
        public var outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]?
        /// The array of [ReferenceDataSourceDescription] objects describing the reference data sources used by the application.
        public var referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]?

        public init(
            inputDescriptions: [KinesisAnalyticsV2ClientTypes.InputDescription]? = nil,
            outputDescriptions: [KinesisAnalyticsV2ClientTypes.OutputDescription]? = nil,
            referenceDataSourceDescriptions: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription]? = nil
        )
        {
            self.inputDescriptions = inputDescriptions
            self.outputDescriptions = outputDescriptions
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
    public struct GlueDataCatalogConfigurationDescription {
        /// The Amazon Resource Name (ARN) of the database.
        /// This member is required.
        public var databaseARN: Swift.String?

        public init(
            databaseARN: Swift.String? = nil
        )
        {
            self.databaseARN = databaseARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Managed Service for Apache Flink Studio notebook.
    public struct CatalogConfigurationDescription {
        /// The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
        /// This member is required.
        public var glueDataCatalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription?

        public init(
            glueDataCatalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription? = nil
        )
        {
            self.glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Specifies a dependency JAR or a JAR of user-defined functions.
    public struct CustomArtifactConfigurationDescription {
        /// UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        public var artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType?
        /// The parameters that are required to specify a Maven dependency.
        public var mavenReferenceDescription: KinesisAnalyticsV2ClientTypes.MavenReference?
        /// For a Managed Service for Apache Flink application provides a description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        public var s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentLocation?

        public init(
            artifactType: KinesisAnalyticsV2ClientTypes.ArtifactType? = nil,
            mavenReferenceDescription: KinesisAnalyticsV2ClientTypes.MavenReference? = nil,
            s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentLocation? = nil
        )
        {
            self.artifactType = artifactType
            self.mavenReferenceDescription = mavenReferenceDescription
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The description of the S3 base location that holds the application.
    public struct S3ContentBaseLocationDescription {
        /// The base path for the S3 bucket.
        public var basePath: Swift.String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?

        public init(
            basePath: Swift.String? = nil,
            bucketARN: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.
    public struct DeployAsApplicationConfigurationDescription {
        /// The location that holds the data required to specify an Amazon Data Analytics application.
        /// This member is required.
        public var s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription?

        public init(
            s3ContentLocationDescription: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription? = nil
        )
        {
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The monitoring configuration for Apache Zeppelin within a Managed Service for Apache Flink Studio notebook.
    public struct ZeppelinMonitoringConfigurationDescription {
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public var logLevel: KinesisAnalyticsV2ClientTypes.LogLevel?

        public init(
            logLevel: KinesisAnalyticsV2ClientTypes.LogLevel? = nil
        )
        {
            self.logLevel = logLevel
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The configuration of a Managed Service for Apache Flink Studio notebook.
    public struct ZeppelinApplicationConfigurationDescription {
        /// The Amazon Glue Data Catalog that is associated with the Managed Service for Apache Flink Studio notebook.
        public var catalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public var customArtifactsConfigurationDescription: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription]?
        /// The parameters required to deploy a Managed Service for Apache Flink Studio notebook as an application with durable state.
        public var deployAsApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription?
        /// The monitoring configuration of a Managed Service for Apache Flink Studio notebook.
        /// This member is required.
        public var monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription?

        public init(
            catalogConfigurationDescription: KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription? = nil,
            customArtifactsConfigurationDescription: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription]? = nil,
            deployAsApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription? = nil,
            monitoringConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription? = nil
        )
        {
            self.catalogConfigurationDescription = catalogConfigurationDescription
            self.customArtifactsConfigurationDescription = customArtifactsConfigurationDescription
            self.deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes details about the application code and starting parameters for a Managed Service for Apache Flink application.
    public struct ApplicationConfigurationDescription {
        /// The details about the application code for a Managed Service for Apache Flink application.
        public var applicationCodeConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription?
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public var applicationSnapshotConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription?
        /// Describes system rollback configuration for a Managed Service for Apache Flink application
        public var applicationSystemRollbackConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationDescription?
        /// Describes execution properties for a Managed Service for Apache Flink application.
        public var environmentPropertyDescriptions: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions?
        /// The details about a Managed Service for Apache Flink application.
        public var flinkApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription?
        /// The details about the starting properties for a Managed Service for Apache Flink application.
        public var runConfigurationDescription: KinesisAnalyticsV2ClientTypes.RunConfigurationDescription?
        /// The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
        public var sqlApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription?
        /// The array of descriptions of VPC configurations available to the application.
        public var vpcConfigurationDescriptions: [KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription]?
        /// The configuration parameters for a Managed Service for Apache Flink Studio notebook.
        public var zeppelinApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription?

        public init(
            applicationCodeConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription? = nil,
            applicationSnapshotConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription? = nil,
            applicationSystemRollbackConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationDescription? = nil,
            environmentPropertyDescriptions: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions? = nil,
            flinkApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription? = nil,
            runConfigurationDescription: KinesisAnalyticsV2ClientTypes.RunConfigurationDescription? = nil,
            sqlApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription? = nil,
            vpcConfigurationDescriptions: [KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription]? = nil,
            zeppelinApplicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription? = nil
        )
        {
            self.applicationCodeConfigurationDescription = applicationCodeConfigurationDescription
            self.applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescription
            self.applicationSystemRollbackConfigurationDescription = applicationSystemRollbackConfigurationDescription
            self.environmentPropertyDescriptions = environmentPropertyDescriptions
            self.flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescription
            self.runConfigurationDescription = runConfigurationDescription
            self.sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescription
            self.vpcConfigurationDescriptions = vpcConfigurationDescriptions
            self.zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescription
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to whether snapshots are enabled for a Managed Service for Apache Flink application.
    public struct ApplicationSnapshotConfigurationUpdate {
        /// Describes updates to whether snapshots are enabled for an application.
        /// This member is required.
        public var snapshotsEnabledUpdate: Swift.Bool?

        public init(
            snapshotsEnabledUpdate: Swift.Bool? = nil
        )
        {
            self.snapshotsEnabledUpdate = snapshotsEnabledUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes system rollback configuration for a Managed Service for Apache Flink application
    public struct ApplicationSystemRollbackConfigurationUpdate {
        /// Describes whether system rollbacks are enabled for a Managed Service for Apache Flink application
        /// This member is required.
        public var rollbackEnabledUpdate: Swift.Bool?

        public init(
            rollbackEnabledUpdate: Swift.Bool? = nil
        )
        {
            self.rollbackEnabledUpdate = rollbackEnabledUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the execution property groups for a Managed Service for Apache Flink application or a Studio notebook.
    public struct EnvironmentPropertyUpdates {
        /// Describes updates to the execution property groups.
        /// This member is required.
        public var propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]?

        public init(
            propertyGroups: [KinesisAnalyticsV2ClientTypes.PropertyGroup]? = nil
        )
        {
            self.propertyGroups = propertyGroups
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the checkpointing parameters for a Managed Service for Apache Flink application.
    public struct CheckpointConfigurationUpdate {
        /// Describes updates to the interval in milliseconds between checkpoint operations. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value using this API or in application code.
        public var checkpointIntervalUpdate: Swift.Int?
        /// Describes updates to whether checkpointing is enabled for an application. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to another value using this API or in application code.
        public var checkpointingEnabledUpdate: Swift.Bool?
        /// Describes updates to whether the application uses the default checkpointing behavior of Managed Service for Apache Flink. You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters. If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:
        ///
        /// * CheckpointingEnabled: true
        ///
        /// * CheckpointInterval: 60000
        ///
        /// * MinPauseBetweenCheckpoints: 5000
        public var configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or in application code.
        public var minPauseBetweenCheckpointsUpdate: Swift.Int?

        public init(
            checkpointIntervalUpdate: Swift.Int? = nil,
            checkpointingEnabledUpdate: Swift.Bool? = nil,
            configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            minPauseBetweenCheckpointsUpdate: Swift.Int? = nil
        )
        {
            self.checkpointIntervalUpdate = checkpointIntervalUpdate
            self.checkpointingEnabledUpdate = checkpointingEnabledUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to configuration parameters for Amazon CloudWatch logging for an application.
    public struct MonitoringConfigurationUpdate {
        /// Describes updates to whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        public var configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes updates to the verbosity of the CloudWatch Logs for an application.
        public var logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel?
        /// Describes updates to the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public var metricsLevelUpdate: KinesisAnalyticsV2ClientTypes.MetricsLevel?

        public init(
            configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel? = nil,
            metricsLevelUpdate: KinesisAnalyticsV2ClientTypes.MetricsLevel? = nil
        )
        {
            self.configurationTypeUpdate = configurationTypeUpdate
            self.logLevelUpdate = logLevelUpdate
            self.metricsLevelUpdate = metricsLevelUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to parameters for how an application executes multiple tasks simultaneously.
    public struct ParallelismConfigurationUpdate {
        /// Describes updates to whether the Managed Service for Apache Flink service can increase the parallelism of a Managed Service for Apache Flink application in response to increased throughput.
        public var autoScalingEnabledUpdate: Swift.Bool?
        /// Describes updates to whether the application uses the default parallelism for the Managed Service for Apache Flink service, or if a custom parallelism is used. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        public var configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType?
        /// Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.
        public var parallelismPerKPUUpdate: Swift.Int?
        /// Describes updates to the initial number of parallel tasks an application can perform. If AutoScalingEnabled is set to True, then Managed Service for Apache Flink can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application. The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will reduce CurrentParallelism down to the Parallelism setting.
        public var parallelismUpdate: Swift.Int?

        public init(
            autoScalingEnabledUpdate: Swift.Bool? = nil,
            configurationTypeUpdate: KinesisAnalyticsV2ClientTypes.ConfigurationType? = nil,
            parallelismPerKPUUpdate: Swift.Int? = nil,
            parallelismUpdate: Swift.Int? = nil
        )
        {
            self.autoScalingEnabledUpdate = autoScalingEnabledUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.parallelismPerKPUUpdate = parallelismPerKPUUpdate
            self.parallelismUpdate = parallelismUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the configuration parameters for a Managed Service for Apache Flink application.
    public struct FlinkApplicationConfigurationUpdate {
        /// Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance.
        public var checkpointConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate?
        /// Describes updates to the configuration parameters for Amazon CloudWatch logging for an application.
        public var monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate?
        /// Describes updates to the parameters for how an application executes multiple tasks simultaneously.
        public var parallelismConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate?

        public init(
            checkpointConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate? = nil,
            monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate? = nil,
            parallelismConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate? = nil
        )
        {
            self.checkpointConfigurationUpdate = checkpointConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
            self.parallelismConfigurationUpdate = parallelismConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides updates to the parallelism count.
    public struct InputParallelismUpdate {
        /// The number of in-application streams to create for the specified streaming source.
        /// This member is required.
        public var countUpdate: Swift.Int?

        public init(
            countUpdate: Swift.Int? = nil
        )
        {
            self.countUpdate = countUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, represents an update to the [InputLambdaProcessor] that is used to preprocess the records in the stream.
    public struct InputLambdaProcessorUpdate {
        /// The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess the records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes updates to an [InputProcessingConfiguration].
    public struct InputProcessingConfigurationUpdate {
        /// Provides update information for an [InputLambdaProcessor].
        /// This member is required.
        public var inputLambdaProcessorUpdate: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate?

        public init(
            inputLambdaProcessorUpdate: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate? = nil
        )
        {
            self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates for an SQL-based Kinesis Data Analytics application's input schema.
    public struct InputSchemaUpdate {
        /// A list of RecordColumn objects. Each object describes the mapping of the streaming source element to the corresponding column in the in-application stream.
        public var recordColumnUpdates: [KinesisAnalyticsV2ClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source; for example, UTF-8.
        public var recordEncodingUpdate: Swift.String?
        /// Specifies the format of the records on the streaming source.
        public var recordFormatUpdate: KinesisAnalyticsV2ClientTypes.RecordFormat?

        public init(
            recordColumnUpdates: [KinesisAnalyticsV2ClientTypes.RecordColumn]? = nil,
            recordEncodingUpdate: Swift.String? = nil,
            recordFormatUpdate: KinesisAnalyticsV2ClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumnUpdates = recordColumnUpdates
            self.recordEncodingUpdate = recordEncodingUpdate
            self.recordFormatUpdate = recordFormatUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, when updating application input configuration, provides information about a Kinesis Data Firehose delivery stream as the streaming source.
    public struct KinesisFirehoseInputUpdate {
        /// The Amazon Resource Name (ARN) of the input delivery stream to read.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update the input configuration for a SQL-based Kinesis Data Analytics application, provides information about a Kinesis stream as the streaming source.
    public struct KinesisStreamsInputUpdate {
        /// The Amazon Resource Name (ARN) of the input Kinesis data stream to read.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes updates to a specific input configuration (identified by the InputId of an application).
    public struct InputUpdate {
        /// The input ID of the application input to be updated.
        /// This member is required.
        public var inputId: Swift.String?
        /// Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).
        public var inputParallelismUpdate: KinesisAnalyticsV2ClientTypes.InputParallelismUpdate?
        /// Describes updates to an [InputProcessingConfiguration].
        public var inputProcessingConfigurationUpdate: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate?
        /// Describes the data format on the streaming source, and how record elements on the streaming source map to columns of the in-application stream that is created.
        public var inputSchemaUpdate: KinesisAnalyticsV2ClientTypes.InputSchemaUpdate?
        /// If a Kinesis Data Firehose delivery stream is the streaming source to be updated, provides an updated stream ARN.
        public var kinesisFirehoseInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate?
        /// If a Kinesis data stream is the streaming source to be updated, provides an updated stream Amazon Resource Name (ARN).
        public var kinesisStreamsInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate?
        /// The name prefix for in-application streams that Kinesis Data Analytics creates for the specific streaming source.
        public var namePrefixUpdate: Swift.String?

        public init(
            inputId: Swift.String? = nil,
            inputParallelismUpdate: KinesisAnalyticsV2ClientTypes.InputParallelismUpdate? = nil,
            inputProcessingConfigurationUpdate: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate? = nil,
            inputSchemaUpdate: KinesisAnalyticsV2ClientTypes.InputSchemaUpdate? = nil,
            kinesisFirehoseInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate? = nil,
            kinesisStreamsInputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate? = nil,
            namePrefixUpdate: Swift.String? = nil
        )
        {
            self.inputId = inputId
            self.inputParallelismUpdate = inputParallelismUpdate
            self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
            self.inputSchemaUpdate = inputSchemaUpdate
            self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
            self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
            self.namePrefixUpdate = namePrefixUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, when updating an output configuration using the [UpdateApplication] operation, provides information about a Kinesis Data Firehose delivery stream that is configured as the destination.
    public struct KinesisFirehoseOutputUpdate {
        /// The Amazon Resource Name (ARN) of the delivery stream to write to.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update a SQL-based Kinesis Data Analytics application's output configuration using the [UpdateApplication] operation, provides information about a Kinesis data stream that is configured as the destination.
    public struct KinesisStreamsOutputUpdate {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the output.
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update an SQL-based Kinesis Data Analytics application's output configuration using the [UpdateApplication] operation, provides information about an Amazon Lambda function that is configured as the destination.
    public struct LambdaOutputUpdate {
        /// The Amazon Resource Name (ARN) of the destination Amazon Lambda function. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
        /// This member is required.
        public var resourceARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes updates to the output configuration identified by the OutputId.
    public struct OutputUpdate {
        /// Describes the data format when records are written to the destination.
        public var destinationSchemaUpdate: KinesisAnalyticsV2ClientTypes.DestinationSchema?
        /// Describes a Kinesis Data Firehose delivery stream as the destination for the output.
        public var kinesisFirehoseOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate?
        /// Describes a Kinesis data stream as the destination for the output.
        public var kinesisStreamsOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate?
        /// Describes an Amazon Lambda function as the destination for the output.
        public var lambdaOutputUpdate: KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate?
        /// If you want to specify a different in-application stream for this output configuration, use this field to specify the new in-application stream name.
        public var nameUpdate: Swift.String?
        /// Identifies the specific output configuration that you want to update.
        /// This member is required.
        public var outputId: Swift.String?

        public init(
            destinationSchemaUpdate: KinesisAnalyticsV2ClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate? = nil,
            kinesisStreamsOutputUpdate: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate? = nil,
            lambdaOutputUpdate: KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate? = nil,
            nameUpdate: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchemaUpdate = destinationSchemaUpdate
            self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
            self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
            self.lambdaOutputUpdate = lambdaOutputUpdate
            self.nameUpdate = nameUpdate
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, describes the Amazon S3 bucket name and object key name for an in-application reference table.
    public struct S3ReferenceDataSourceUpdate {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARNUpdate: Swift.String?
        /// The object key name.
        public var fileKeyUpdate: Swift.String?

        public init(
            bucketARNUpdate: Swift.String? = nil,
            fileKeyUpdate: Swift.String? = nil
        )
        {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// When you update a reference data source configuration for a SQL-based Kinesis Data Analytics application, this object provides all the updated values (such as the source bucket name and object key name), the in-application table name that is created, and updated mapping information that maps the data in the Amazon S3 object to the in-application reference table that is created.
    public struct ReferenceDataSourceUpdate {
        /// The ID of the reference data source that is being updated. You can use the [DescribeApplication] operation to get this value.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchemaUpdate: KinesisAnalyticsV2ClientTypes.SourceSchema?
        /// Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
        public var s3ReferenceDataSourceUpdate: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate?
        /// The in-application table name that is created by this update.
        public var tableNameUpdate: Swift.String?

        public init(
            referenceId: Swift.String? = nil,
            referenceSchemaUpdate: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceUpdate: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate? = nil,
            tableNameUpdate: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchemaUpdate = referenceSchemaUpdate
            self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
            self.tableNameUpdate = tableNameUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the input streams, destination streams, and reference data sources for a SQL-based Kinesis Data Analytics application.
    public struct SqlApplicationConfigurationUpdate {
        /// The array of [InputUpdate] objects describing the new input streams used by the application.
        public var inputUpdates: [KinesisAnalyticsV2ClientTypes.InputUpdate]?
        /// The array of [OutputUpdate] objects describing the new destination streams used by the application.
        public var outputUpdates: [KinesisAnalyticsV2ClientTypes.OutputUpdate]?
        /// The array of [ReferenceDataSourceUpdate] objects describing the new reference data sources used by the application.
        public var referenceDataSourceUpdates: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate]?

        public init(
            inputUpdates: [KinesisAnalyticsV2ClientTypes.InputUpdate]? = nil,
            outputUpdates: [KinesisAnalyticsV2ClientTypes.OutputUpdate]? = nil,
            referenceDataSourceUpdates: [KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate]? = nil
        )
        {
            self.inputUpdates = inputUpdates
            self.outputUpdates = outputUpdates
            self.referenceDataSourceUpdates = referenceDataSourceUpdates
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to the VPC configuration used by the application.
    public struct VpcConfigurationUpdate {
        /// Describes updates to the array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
        public var securityGroupIdUpdates: [Swift.String]?
        /// Describes updates to the array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
        public var subnetIdUpdates: [Swift.String]?
        /// Describes an update to the ID of the VPC configuration.
        /// This member is required.
        public var vpcConfigurationId: Swift.String?

        public init(
            securityGroupIdUpdates: [Swift.String]? = nil,
            subnetIdUpdates: [Swift.String]? = nil,
            vpcConfigurationId: Swift.String? = nil
        )
        {
            self.securityGroupIdUpdates = securityGroupIdUpdates
            self.subnetIdUpdates = subnetIdUpdates
            self.vpcConfigurationId = vpcConfigurationId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration of the Glue Data Catalog that you use for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
    public struct GlueDataCatalogConfigurationUpdate {
        /// The updated Amazon Resource Name (ARN) of the database.
        /// This member is required.
        public var databaseARNUpdate: Swift.String?

        public init(
            databaseARNUpdate: Swift.String? = nil
        )
        {
            self.databaseARNUpdate = databaseARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
    public struct CatalogConfigurationUpdate {
        /// Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
        /// This member is required.
        public var glueDataCatalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate?

        public init(
            glueDataCatalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate? = nil
        )
        {
            self.glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The information required to update the S3 base location that holds the application.
    public struct S3ContentBaseLocationUpdate {
        /// The updated S3 bucket path.
        public var basePathUpdate: Swift.String?
        /// The updated Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARNUpdate: Swift.String?

        public init(
            basePathUpdate: Swift.String? = nil,
            bucketARNUpdate: Swift.String? = nil
        )
        {
            self.basePathUpdate = basePathUpdate
            self.bucketARNUpdate = bucketARNUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.
    public struct DeployAsApplicationConfigurationUpdate {
        /// Updates to the location that holds the data required to specify an Amazon Data Analytics application.
        public var s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate?

        public init(
            s3ContentLocationUpdate: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate? = nil
        )
        {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the monitoring configuration for Apache Zeppelin within a Managed Service for Apache Flink Studio notebook.
    public struct ZeppelinMonitoringConfigurationUpdate {
        /// Updates to the logging level for Apache Zeppelin within a Managed Service for Apache Flink Studio notebook.
        /// This member is required.
        public var logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel?

        public init(
            logLevelUpdate: KinesisAnalyticsV2ClientTypes.LogLevel? = nil
        )
        {
            self.logLevelUpdate = logLevelUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Updates to the configuration of Managed Service for Apache Flink Studio notebook.
    public struct ZeppelinApplicationConfigurationUpdate {
        /// Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Managed Service for Apache Flink Studio notebook.
        public var catalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate?
        /// Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).
        public var customArtifactsConfigurationUpdate: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]?
        /// Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.
        public var deployAsApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate?
        /// Updates to the monitoring configuration of a Managed Service for Apache Flink Studio notebook.
        public var monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate?

        public init(
            catalogConfigurationUpdate: KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate? = nil,
            customArtifactsConfigurationUpdate: [KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration]? = nil,
            deployAsApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate? = nil,
            monitoringConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate? = nil
        )
        {
            self.catalogConfigurationUpdate = catalogConfigurationUpdate
            self.customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate
            self.deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes updates to an application's configuration.
    public struct ApplicationConfigurationUpdate {
        /// Describes updates to an application's code configuration.
        public var applicationCodeConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate?
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public var applicationSnapshotConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate?
        /// Describes system rollback configuration for a Managed Service for Apache Flink application
        public var applicationSystemRollbackConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationUpdate?
        /// Describes updates to the environment properties for a Managed Service for Apache Flink application.
        public var environmentPropertyUpdates: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates?
        /// Describes updates to a Managed Service for Apache Flink application's configuration.
        public var flinkApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate?
        /// Describes updates to a SQL-based Kinesis Data Analytics application's configuration.
        public var sqlApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate?
        /// Updates to the array of descriptions of VPC configurations available to the application.
        public var vpcConfigurationUpdates: [KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate]?
        /// Updates to the configuration of a Managed Service for Apache Flink Studio notebook.
        public var zeppelinApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate?

        public init(
            applicationCodeConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate? = nil,
            applicationSnapshotConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate? = nil,
            applicationSystemRollbackConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationUpdate? = nil,
            environmentPropertyUpdates: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates? = nil,
            flinkApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate? = nil,
            sqlApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate? = nil,
            vpcConfigurationUpdates: [KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate]? = nil,
            zeppelinApplicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate? = nil
        )
        {
            self.applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdate
            self.applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdate
            self.applicationSystemRollbackConfigurationUpdate = applicationSystemRollbackConfigurationUpdate
            self.environmentPropertyUpdates = environmentPropertyUpdates
            self.flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdate
            self.sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate
            self.vpcConfigurationUpdates = vpcConfigurationUpdates
            self.zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The details of the maintenance configuration for the application.
    public struct ApplicationMaintenanceConfigurationDescription {
        /// The end time for the maintenance window.
        /// This member is required.
        public var applicationMaintenanceWindowEndTime: Swift.String?
        /// The start time for the maintenance window.
        /// This member is required.
        public var applicationMaintenanceWindowStartTime: Swift.String?

        public init(
            applicationMaintenanceWindowEndTime: Swift.String? = nil,
            applicationMaintenanceWindowStartTime: Swift.String? = nil
        )
        {
            self.applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTime
            self.applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTime
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    public enum ApplicationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interactive
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationMode] {
            return [
                .interactive,
                .streaming
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {

    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoscaling
        case deleting
        case forceStopping
        case maintenance
        case ready
        case rolledBack
        case rollingBack
        case running
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .autoscaling,
                .deleting,
                .forceStopping,
                .maintenance,
                .ready,
                .rolledBack,
                .rollingBack,
                .running,
                .starting,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoscaling: return "AUTOSCALING"
            case .deleting: return "DELETING"
            case .forceStopping: return "FORCE_STOPPING"
            case .maintenance: return "MAINTENANCE"
            case .ready: return "READY"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {

    public enum RuntimeEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case flink111
        case flink113
        case flink115
        case flink118
        case flink119
        case flink120
        case flink16
        case flink18
        case sql10
        case zeppelinFlink10
        case zeppelinFlink20
        case zeppelinFlink30
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeEnvironment] {
            return [
                .flink111,
                .flink113,
                .flink115,
                .flink118,
                .flink119,
                .flink120,
                .flink16,
                .flink18,
                .sql10,
                .zeppelinFlink10,
                .zeppelinFlink20,
                .zeppelinFlink30
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .flink111: return "FLINK-1_11"
            case .flink113: return "FLINK-1_13"
            case .flink115: return "FLINK-1_15"
            case .flink118: return "FLINK-1_18"
            case .flink119: return "FLINK-1_19"
            case .flink120: return "FLINK-1_20"
            case .flink16: return "FLINK-1_6"
            case .flink18: return "FLINK-1_8"
            case .sql10: return "SQL-1_0"
            case .zeppelinFlink10: return "ZEPPELIN-FLINK-1_0"
            case .zeppelinFlink20: return "ZEPPELIN-FLINK-2_0"
            case .zeppelinFlink30: return "ZEPPELIN-FLINK-3_0"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configurations.
    public struct ApplicationDetail {
        /// The ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// Describes details about the application code and starting parameters for a Managed Service for Apache Flink application.
        public var applicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription?
        /// The description of the application.
        public var applicationDescription: Swift.String?
        /// The details of the maintenance configuration for the application.
        public var applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription?
        /// To create a Managed Service for Apache Flink Studio notebook, you must set the mode to INTERACTIVE. However, for a Managed Service for Apache Flink application, the mode is optional.
        public var applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
        /// The name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// The status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus?
        /// The current timestamp when the application version was created.
        public var applicationVersionCreateTimestamp: Foundation.Date?
        /// Provides the current application version. Managed Service for Apache Flink updates the ApplicationVersionId each time you update the application.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// If you reverted the application using [RollbackApplication], the application version when RollbackApplication was called.
        public var applicationVersionRolledBackFrom: Swift.Int?
        /// The version to which you want to roll back the application.
        public var applicationVersionRolledBackTo: Swift.Int?
        /// The previous application version before the latest application update. [RollbackApplication] reverts the application to this version.
        public var applicationVersionUpdatedFrom: Swift.Int?
        /// Describes the application Amazon CloudWatch logging options.
        public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?
        /// A value you use to implement strong concurrency for application updates.
        public var conditionalToken: Swift.String?
        /// The current timestamp when the application was created.
        public var createTimestamp: Foundation.Date?
        /// The current timestamp when the application was last updated.
        public var lastUpdateTimestamp: Foundation.Date?
        /// The runtime environment for the application.
        /// This member is required.
        public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
        /// Specifies the IAM role that the application uses to access external resources.
        public var serviceExecutionRole: Swift.String?

        public init(
            applicationARN: Swift.String? = nil,
            applicationConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription? = nil,
            applicationDescription: Swift.String? = nil,
            applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription? = nil,
            applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus? = nil,
            applicationVersionCreateTimestamp: Foundation.Date? = nil,
            applicationVersionId: Swift.Int? = nil,
            applicationVersionRolledBackFrom: Swift.Int? = nil,
            applicationVersionRolledBackTo: Swift.Int? = nil,
            applicationVersionUpdatedFrom: Swift.Int? = nil,
            cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil,
            conditionalToken: Swift.String? = nil,
            createTimestamp: Foundation.Date? = nil,
            lastUpdateTimestamp: Foundation.Date? = nil,
            runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil,
            serviceExecutionRole: Swift.String? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationConfigurationDescription = applicationConfigurationDescription
            self.applicationDescription = applicationDescription
            self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionCreateTimestamp = applicationVersionCreateTimestamp
            self.applicationVersionId = applicationVersionId
            self.applicationVersionRolledBackFrom = applicationVersionRolledBackFrom
            self.applicationVersionRolledBackTo = applicationVersionRolledBackTo
            self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.conditionalToken = conditionalToken
            self.createTimestamp = createTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.runtimeEnvironment = runtimeEnvironment
            self.serviceExecutionRole = serviceExecutionRole
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the updated maintenance configuration for the application.
    public struct ApplicationMaintenanceConfigurationUpdate {
        /// The updated start time for the maintenance window.
        /// This member is required.
        public var applicationMaintenanceWindowStartTimeUpdate: Swift.String?

        public init(
            applicationMaintenanceWindowStartTimeUpdate: Swift.String? = nil
        )
        {
            self.applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdate
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {

    /// Status of the operation performed on an application
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides a description of the operation, such as the type and status of operation
    public struct ApplicationOperationInfo {
        /// The timestamp at which the operation finished for the application
        public var endTime: Foundation.Date?
        /// Type of operation performed on an application
        public var operation: Swift.String?
        /// Identifier of the Operation
        public var operationId: Swift.String?
        /// Status of the operation performed on an application
        public var operationStatus: KinesisAnalyticsV2ClientTypes.OperationStatus?
        /// The timestamp at which the operation was created
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            operation: Swift.String? = nil,
            operationId: Swift.String? = nil,
            operationStatus: KinesisAnalyticsV2ClientTypes.OperationStatus? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.operation = operation
            self.operationId = operationId
            self.operationStatus = operationStatus
            self.startTime = startTime
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Contains information about the application version changes due to an operation
    public struct ApplicationVersionChangeDetails {
        /// The operation was performed on this version of the application
        /// This member is required.
        public var applicationVersionUpdatedFrom: Swift.Int?
        /// The operation execution resulted in the transition to the following version of the application
        /// This member is required.
        public var applicationVersionUpdatedTo: Swift.Int?

        public init(
            applicationVersionUpdatedFrom: Swift.Int? = nil,
            applicationVersionUpdatedTo: Swift.Int? = nil
        )
        {
            self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
            self.applicationVersionUpdatedTo = applicationVersionUpdatedTo
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides a description of the operation failure error
    public struct ErrorInfo {
        /// Error message resulting in failure of the operation
        public var errorString: Swift.String?

        public init(
            errorString: Swift.String? = nil
        )
        {
            self.errorString = errorString
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides a description of the operation failure
    public struct OperationFailureDetails {
        /// Provides a description of the operation failure error
        public var errorInfo: KinesisAnalyticsV2ClientTypes.ErrorInfo?
        /// Provides the operation ID of a system-rollback operation executed due to failure in the current operation
        public var rollbackOperationId: Swift.String?

        public init(
            errorInfo: KinesisAnalyticsV2ClientTypes.ErrorInfo? = nil,
            rollbackOperationId: Swift.String? = nil
        )
        {
            self.errorInfo = errorInfo
            self.rollbackOperationId = rollbackOperationId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides a description of the operation, such as the operation-type and status
    public struct ApplicationOperationInfoDetails {
        /// Contains information about the application version changes due to an operation
        public var applicationVersionChangeDetails: KinesisAnalyticsV2ClientTypes.ApplicationVersionChangeDetails?
        /// The timestamp at which the operation finished for the application
        /// This member is required.
        public var endTime: Foundation.Date?
        /// Type of operation performed on an application
        /// This member is required.
        public var operation: Swift.String?
        /// Provides a description of the operation failure
        public var operationFailureDetails: KinesisAnalyticsV2ClientTypes.OperationFailureDetails?
        /// Status of the operation performed on an application
        /// This member is required.
        public var operationStatus: KinesisAnalyticsV2ClientTypes.OperationStatus?
        /// The timestamp at which the operation was created
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            applicationVersionChangeDetails: KinesisAnalyticsV2ClientTypes.ApplicationVersionChangeDetails? = nil,
            endTime: Foundation.Date? = nil,
            operation: Swift.String? = nil,
            operationFailureDetails: KinesisAnalyticsV2ClientTypes.OperationFailureDetails? = nil,
            operationStatus: KinesisAnalyticsV2ClientTypes.OperationStatus? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.applicationVersionChangeDetails = applicationVersionChangeDetails
            self.endTime = endTime
            self.operation = operation
            self.operationFailureDetails = operationFailureDetails
            self.operationStatus = operationStatus
            self.startTime = startTime
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.
    public struct ApplicationSummary {
        /// The ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// For a Managed Service for Apache Flink application, the mode is STREAMING. For a Managed Service for Apache Flink Studio notebook, it is INTERACTIVE.
        public var applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
        /// The name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// The status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus?
        /// Provides the current application version.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// The runtime environment for the application.
        /// This member is required.
        public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?

        public init(
            applicationARN: Swift.String? = nil,
            applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil,
            runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.runtimeEnvironment = runtimeEnvironment
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// The summary of the application version.
    public struct ApplicationVersionSummary {
        /// The status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus?
        /// The ID of the application version. Managed Service for Apache Flink updates the ApplicationVersionId each time you update the application.
        /// This member is required.
        public var applicationVersionId: Swift.Int?

        public init(
            applicationStatus: KinesisAnalyticsV2ClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil
        )
        {
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the Amazon CloudWatch logging option updates.
    public struct CloudWatchLoggingOptionUpdate {
        /// The ID of the CloudWatch logging option to update
        /// This member is required.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        public var logStreamARNUpdate: Swift.String?

        public init(
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARNUpdate: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARNUpdate = logStreamARNUpdate
        }
    }

}

/// The number of allowed resources has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Application created with too many tags, or too many tags added to an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because a specified parameter is not supported or a specified resource is not valid for this operation.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// A key-value pair (the value is optional) that you can define and assign to Amazon resources. If you specify a tag that already exists, the tag value is replaced with the value that you specify in the request. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html).
    public struct Tag {
        /// The key of the key-value tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value tag. The value is optional.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateApplicationInput {
    /// Use this parameter to configure the application.
    public var applicationConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration?
    /// A summary description of the application.
    public var applicationDescription: Swift.String?
    /// Use the STREAMING mode to create a Managed Service for Apache Flink application. To create a Managed Service for Apache Flink Studio notebook, use the INTERACTIVE mode.
    public var applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode?
    /// The name of your application (for example, sample-app).
    /// This member is required.
    public var applicationName: Swift.String?
    /// Use this parameter to configure an Amazon CloudWatch log stream to monitor application configuration errors.
    public var cloudWatchLoggingOptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]?
    /// The runtime environment for the application.
    /// This member is required.
    public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
    /// The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
    /// This member is required.
    public var serviceExecutionRole: Swift.String?
    /// A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html).
    public var tags: [KinesisAnalyticsV2ClientTypes.Tag]?

    public init(
        applicationConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration? = nil,
        applicationDescription: Swift.String? = nil,
        applicationMode: KinesisAnalyticsV2ClientTypes.ApplicationMode? = nil,
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption]? = nil,
        runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil,
        serviceExecutionRole: Swift.String? = nil,
        tags: [KinesisAnalyticsV2ClientTypes.Tag]? = nil
    )
    {
        self.applicationConfiguration = applicationConfiguration
        self.applicationDescription = applicationDescription
        self.applicationMode = applicationMode
        self.applicationName = applicationName
        self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
        self.runtimeEnvironment = runtimeEnvironment
        self.serviceExecutionRole = serviceExecutionRole
        self.tags = tags
    }
}

public struct CreateApplicationOutput {
    /// In response to your CreateApplication request, Managed Service for Apache Flink returns a response with details of the application it created.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init(
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

extension KinesisAnalyticsV2ClientTypes {

    public enum UrlType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case flinkDashboardUrl
        case zeppelinUiUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [UrlType] {
            return [
                .flinkDashboardUrl,
                .zeppelinUiUrl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .flinkDashboardUrl: return "FLINK_DASHBOARD_URL"
            case .zeppelinUiUrl: return "ZEPPELIN_UI_URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateApplicationPresignedUrlInput {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The duration in seconds for which the returned URL will be valid.
    public var sessionExpirationDurationInSeconds: Swift.Int?
    /// The type of the extension for which to create and return a URL. Currently, the only valid extension URL type is FLINK_DASHBOARD_URL.
    /// This member is required.
    public var urlType: KinesisAnalyticsV2ClientTypes.UrlType?

    public init(
        applicationName: Swift.String? = nil,
        sessionExpirationDurationInSeconds: Swift.Int? = nil,
        urlType: KinesisAnalyticsV2ClientTypes.UrlType? = nil
    )
    {
        self.applicationName = applicationName
        self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
        self.urlType = urlType
    }
}

public struct CreateApplicationPresignedUrlOutput {
    /// The URL of the extension.
    public var authorizedUrl: Swift.String?

    public init(
        authorizedUrl: Swift.String? = nil
    )
    {
        self.authorizedUrl = authorizedUrl
    }
}

public struct CreateApplicationSnapshotInput {
    /// The name of an existing application
    /// This member is required.
    public var applicationName: Swift.String?
    /// An identifier for the application snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotName = snapshotName
    }
}

public struct CreateApplicationSnapshotOutput {

    public init() { }
}

public struct DeleteApplicationInput {
    /// The name of the application to delete.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Use the DescribeApplication operation to get this value.
    /// This member is required.
    public var createTimestamp: Foundation.Date?

    public init(
        applicationName: Swift.String? = nil,
        createTimestamp: Foundation.Date? = nil
    )
    {
        self.applicationName = applicationName
        self.createTimestamp = createTimestamp
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

public struct DeleteApplicationCloudWatchLoggingOptionInput {
    /// The application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The CloudWatchLoggingOptionId of the Amazon CloudWatch logging option to delete. You can get the CloudWatchLoggingOptionId by using the [DescribeApplication] operation.
    /// This member is required.
    public var cloudWatchLoggingOptionId: Swift.String?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The version ID of the application. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptionId: Swift.String? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionOutput {
    /// The application's Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The version ID of the application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
    public var applicationVersionId: Swift.Int?
    /// The descriptions of the remaining CloudWatch logging options for the application.
    public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]?
    /// Operation ID for tracking DeleteApplicationCloudWatchLoggingOption request
    public var operationId: Swift.String?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription]? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
        self.operationId = operationId
    }
}

public struct DeleteApplicationInputProcessingConfigurationInput {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The application version. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration from which to delete the input processing configuration. You can get a list of the input IDs for an application by using the [DescribeApplication] operation.
    /// This member is required.
    public var inputId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
    }
}

public struct DeleteApplicationInputProcessingConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// The current application version ID.
    public var applicationVersionId: Swift.Int?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

public struct DeleteApplicationOutputInput {
    /// The application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The application version. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the configuration to delete. Each output configuration that is added to the application (either when the application is created or later) using the [AddApplicationOutput] operation has a unique ID. You need to provide the ID to uniquely identify the output configuration that you want to delete from the application configuration. You can use the [DescribeApplication] operation to get the specific OutputId.
    /// This member is required.
    public var outputId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        outputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.outputId = outputId
    }
}

public struct DeleteApplicationOutputOutput {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The current application version ID.
    public var applicationVersionId: Swift.Int?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

public struct DeleteApplicationReferenceDataSourceInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current application version. You can use the [DescribeApplication] operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the reference data source. When you add a reference data source to your application using the [AddApplicationReferenceDataSource], Kinesis Data Analytics assigns an ID. You can use the [DescribeApplication] operation to get the reference ID.
    /// This member is required.
    public var referenceId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceId = referenceId
    }
}

public struct DeleteApplicationReferenceDataSourceOutput {
    /// The application Amazon Resource Name (ARN).
    public var applicationARN: Swift.String?
    /// The updated version ID of the application.
    public var applicationVersionId: Swift.Int?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

public struct DeleteApplicationSnapshotInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The creation timestamp of the application snapshot to delete. You can retrieve this value using or .
    /// This member is required.
    public var snapshotCreationTimestamp: Foundation.Date?
    /// The identifier for the snapshot delete.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        snapshotCreationTimestamp: Foundation.Date? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotCreationTimestamp = snapshotCreationTimestamp
        self.snapshotName = snapshotName
    }
}

public struct DeleteApplicationSnapshotOutput {

    public init() { }
}

public struct DeleteApplicationVpcConfigurationInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the VPC configuration to delete.
    /// This member is required.
    public var vpcConfigurationId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        vpcConfigurationId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.vpcConfigurationId = vpcConfigurationId
    }
}

public struct DeleteApplicationVpcConfigurationOutput {
    /// The ARN of the Managed Service for Apache Flink application.
    public var applicationARN: Swift.String?
    /// The updated version ID of the application.
    public var applicationVersionId: Swift.Int?
    /// Operation ID for tracking DeleteApplicationVpcConfiguration request
    public var operationId: Swift.String?

    public init(
        applicationARN: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.operationId = operationId
    }
}

public struct DescribeApplicationInput {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Displays verbose information about a Managed Service for Apache Flink application, including the application's job plan.
    public var includeAdditionalDetails: Swift.Bool?

    public init(
        applicationName: Swift.String? = nil,
        includeAdditionalDetails: Swift.Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.includeAdditionalDetails = includeAdditionalDetails
    }
}

public struct DescribeApplicationOutput {
    /// Provides a description of the application, such as the application's Amazon Resource Name (ARN), status, and latest version.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init(
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

/// Request for information about a specific operation performed on a Managed Service for Apache Flink application
public struct DescribeApplicationOperationInput {
    /// The name of the application
    /// This member is required.
    public var applicationName: Swift.String?
    /// Identifier of the Operation
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.operationId = operationId
    }
}

/// Provides details of the operation corresponding to the operation-ID on a Managed Service for Apache Flink application
public struct DescribeApplicationOperationOutput {
    /// Provides a description of the operation, such as the operation-type and status
    public var applicationOperationInfoDetails: KinesisAnalyticsV2ClientTypes.ApplicationOperationInfoDetails?

    public init(
        applicationOperationInfoDetails: KinesisAnalyticsV2ClientTypes.ApplicationOperationInfoDetails? = nil
    )
    {
        self.applicationOperationInfoDetails = applicationOperationInfoDetails
    }
}

public struct DescribeApplicationSnapshotInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The identifier of an application snapshot. You can retrieve this value using .
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotName = snapshotName
    }
}

extension KinesisAnalyticsV2ClientTypes {

    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Provides details about a snapshot of application state.
    public struct SnapshotDetails {
        /// The current application version ID when the snapshot was created.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// The Flink Runtime for the application snapshot.
        public var runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
        /// The timestamp of the application snapshot.
        public var snapshotCreationTimestamp: Foundation.Date?
        /// The identifier for the application snapshot.
        /// This member is required.
        public var snapshotName: Swift.String?
        /// The status of the application snapshot.
        /// This member is required.
        public var snapshotStatus: KinesisAnalyticsV2ClientTypes.SnapshotStatus?

        public init(
            applicationVersionId: Swift.Int? = nil,
            runtimeEnvironment: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil,
            snapshotCreationTimestamp: Foundation.Date? = nil,
            snapshotName: Swift.String? = nil,
            snapshotStatus: KinesisAnalyticsV2ClientTypes.SnapshotStatus? = nil
        )
        {
            self.applicationVersionId = applicationVersionId
            self.runtimeEnvironment = runtimeEnvironment
            self.snapshotCreationTimestamp = snapshotCreationTimestamp
            self.snapshotName = snapshotName
            self.snapshotStatus = snapshotStatus
        }
    }

}

public struct DescribeApplicationSnapshotOutput {
    /// An object containing information about the application snapshot.
    /// This member is required.
    public var snapshotDetails: KinesisAnalyticsV2ClientTypes.SnapshotDetails?

    public init(
        snapshotDetails: KinesisAnalyticsV2ClientTypes.SnapshotDetails? = nil
    )
    {
        self.snapshotDetails = snapshotDetails
    }
}

public struct DescribeApplicationVersionInput {
    /// The name of the application for which you want to get the version description.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The ID of the application version for which you want to get the description.
    /// This member is required.
    public var applicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        applicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationVersionId = applicationVersionId
    }
}

public struct DescribeApplicationVersionOutput {
    /// Describes the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configurations.
    public var applicationVersionDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?

    public init(
        applicationVersionDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationVersionDetail = applicationVersionDetail
    }
}

/// Discovery failed to get a record from the streaming source because of the Kinesis Streams ProvisionedThroughputExceededException. For more information, see [GetRecords](http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html) in the Amazon Kinesis Streams API Reference.
public struct ResourceProvisionedThroughputExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceProvisionedThroughputExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service cannot complete the request.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The data format is not valid. Kinesis Data Analytics cannot detect the schema for the given streaming source.
public struct UnableToDetectSchemaException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
        public internal(set) var processedInputRecords: [Swift.String]? = nil
        /// Raw stream data that was sampled to infer the schema.
        public internal(set) var rawInputRecords: [Swift.String]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnableToDetectSchemaException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.properties.message = message
        self.properties.processedInputRecords = processedInputRecords
        self.properties.rawInputRecords = rawInputRecords
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// For a SQL-based Kinesis Data Analytics application, provides a description of an Amazon S3 data source, including the Amazon Resource Name (ARN) of the S3 bucket and the name of the Amazon S3 object that contains the data.
    public struct S3Configuration {
        /// The ARN of the S3 bucket that contains the data.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The name of the object that contains the data.
        /// This member is required.
        public var fileKey: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }
    }

}

public struct DiscoverInputSchemaInput {
    /// The [InputProcessingConfiguration] to use to preprocess the records before discovering the schema of the records.
    public var inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?
    /// The point at which you want Kinesis Data Analytics to start reading records from the specified streaming source for discovery purposes.
    public var inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?
    /// The Amazon Resource Name (ARN) of the streaming source.
    public var resourceARN: Swift.String?
    /// Specify this parameter to discover a schema from data in an Amazon S3 object.
    public var s3Configuration: KinesisAnalyticsV2ClientTypes.S3Configuration?
    /// The ARN of the role that is used to access the streaming source.
    /// This member is required.
    public var serviceExecutionRole: Swift.String?

    public init(
        inputProcessingConfiguration: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration? = nil,
        inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration? = nil,
        resourceARN: Swift.String? = nil,
        s3Configuration: KinesisAnalyticsV2ClientTypes.S3Configuration? = nil,
        serviceExecutionRole: Swift.String? = nil
    )
    {
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.resourceARN = resourceARN
        self.s3Configuration = s3Configuration
        self.serviceExecutionRole = serviceExecutionRole
    }
}

public struct DiscoverInputSchemaOutput {
    /// The schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.
    public var inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema?
    /// An array of elements, where each element corresponds to a row in a stream record (a stream record can have more than one row).
    public var parsedInputRecords: [[Swift.String]]?
    /// The stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
    public var processedInputRecords: [Swift.String]?
    /// The raw stream data that was sampled to infer the schema.
    public var rawInputRecords: [Swift.String]?

    public init(
        inputSchema: KinesisAnalyticsV2ClientTypes.SourceSchema? = nil,
        parsedInputRecords: [[Swift.String]]? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.inputSchema = inputSchema
        self.parsedInputRecords = parsedInputRecords
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

/// Request to list operations performed on an application
public struct ListApplicationOperationsInput {
    /// The name of the application
    /// This member is required.
    public var applicationName: Swift.String?
    /// Limit on the number of records returned in the response
    public var limit: Swift.Int?
    /// If a previous command returned a pagination token, pass it into this value to retrieve the next set of results
    public var nextToken: Swift.String?
    /// Type of operation performed on an application
    public var operation: Swift.String?
    /// Status of the operation performed on an application
    public var operationStatus: KinesisAnalyticsV2ClientTypes.OperationStatus?

    public init(
        applicationName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operation: Swift.String? = nil,
        operationStatus: KinesisAnalyticsV2ClientTypes.OperationStatus? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
        self.operation = operation
        self.operationStatus = operationStatus
    }
}

/// Response with the list of operations for an application
public struct ListApplicationOperationsOutput {
    /// List of ApplicationOperationInfo for an application
    public var applicationOperationInfoList: [KinesisAnalyticsV2ClientTypes.ApplicationOperationInfo]?
    /// If a previous command returned a pagination token, pass it into this value to retrieve the next set of results
    public var nextToken: Swift.String?

    public init(
        applicationOperationInfoList: [KinesisAnalyticsV2ClientTypes.ApplicationOperationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationOperationInfoList = applicationOperationInfoList
        self.nextToken = nextToken
    }
}

public struct ListApplicationsInput {
    /// The maximum number of applications to list.
    public var limit: Swift.Int?
    /// If a previous command returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput {
    /// A list of ApplicationSummary objects.
    /// This member is required.
    public var applicationSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationSummary]?
    /// The pagination token for the next set of results, or null if there are no additional results. Pass this token into a subsequent command to retrieve the next set of items For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init(
        applicationSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.nextToken = nextToken
    }
}

public struct ListApplicationSnapshotsInput {
    /// The name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The maximum number of application snapshots to list.
    public var limit: Swift.Int?
    /// Use this parameter if you receive a NextToken response in a previous request that indicates that there is more output available. Set it to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct ListApplicationSnapshotsOutput {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A collection of objects containing information about the application snapshots.
    public var snapshotSummaries: [KinesisAnalyticsV2ClientTypes.SnapshotDetails]?

    public init(
        nextToken: Swift.String? = nil,
        snapshotSummaries: [KinesisAnalyticsV2ClientTypes.SnapshotDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshotSummaries = snapshotSummaries
    }
}

public struct ListApplicationVersionsInput {
    /// The name of the application for which you want to list all versions.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The maximum number of versions to list in this invocation of the operation.
    public var limit: Swift.Int?
    /// If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct ListApplicationVersionsOutput {
    /// A list of the application versions and the associated configuration summaries. The list includes application versions that were rolled back. To get the complete description of a specific application version, invoke the [DescribeApplicationVersion] operation.
    public var applicationVersionSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]?
    /// The pagination token for the next set of results, or null if there are no additional results. To retrieve the next set of items, pass this token into a subsequent invocation of this operation. For more information about pagination, see [Using the Amazon Command Line Interface's Pagination Options](https://docs.aws.amazon.com/cli/latest/userguide/pagination.html).
    public var nextToken: Swift.String?

    public init(
        applicationVersionSummaries: [KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationVersionSummaries = applicationVersionSummaries
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the application for which to retrieve tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value tags assigned to the application.
    public var tags: [KinesisAnalyticsV2ClientTypes.Tag]?

    public init(
        tags: [KinesisAnalyticsV2ClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct RollbackApplicationInput {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current application version ID. You can retrieve the application version ID using [DescribeApplication].
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

public struct RollbackApplicationOutput {
    /// Describes the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configurations.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
    /// Operation ID for tracking RollbackApplication request
    public var operationId: Swift.String?

    public init(
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.applicationDetail = applicationDetail
        self.operationId = operationId
    }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting parameters for a SQL-based Kinesis Data Analytics application.
    public struct SqlRunConfiguration {
        /// The input source ID. You can get this ID by calling the [DescribeApplication] operation.
        /// This member is required.
        public var inputId: Swift.String?
        /// The point at which you want the application to start processing records from the streaming source.
        /// This member is required.
        public var inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?

        public init(
            inputId: Swift.String? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration? = nil
        )
        {
            self.inputId = inputId
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        }
    }

}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the starting parameters for an Managed Service for Apache Flink application.
    public struct RunConfiguration {
        /// Describes the restore behavior of a restarting application.
        public var applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Managed Service for Apache Flink application.
        public var flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?
        /// Describes the starting parameters for a SQL-based Kinesis Data Analytics application application.
        public var sqlRunConfigurations: [KinesisAnalyticsV2ClientTypes.SqlRunConfiguration]?

        public init(
            applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration? = nil,
            flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration? = nil,
            sqlRunConfigurations: [KinesisAnalyticsV2ClientTypes.SqlRunConfiguration]? = nil
        )
        {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
            self.sqlRunConfigurations = sqlRunConfigurations
        }
    }

}

public struct StartApplicationInput {
    /// The name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Identifies the run configuration (start parameters) of a Managed Service for Apache Flink application.
    public var runConfiguration: KinesisAnalyticsV2ClientTypes.RunConfiguration?

    public init(
        applicationName: Swift.String? = nil,
        runConfiguration: KinesisAnalyticsV2ClientTypes.RunConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.runConfiguration = runConfiguration
    }
}

public struct StartApplicationOutput {
    /// Operation ID for tracking StartApplication request
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct StopApplicationInput {
    /// The name of the running application to stop.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Set to true to force the application to stop. If you set Force to true, Managed Service for Apache Flink stops the application without taking a snapshot. Force-stopping your application may lead to data loss or duplication. To prevent data loss or duplicate processing of data during application restarts, we recommend you to take frequent snapshots of your application. You can only force stop a Managed Service for Apache Flink application. You can't force stop a SQL-based Kinesis Data Analytics application. The application must be in the STARTING, UPDATING, STOPPING, AUTOSCALING, or RUNNING status.
    public var force: Swift.Bool?

    public init(
        applicationName: Swift.String? = nil,
        force: Swift.Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.force = force
    }
}

public struct StopApplicationOutput {
    /// Operation ID for tracking StopApplication request
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct TagResourceInput {
    /// The ARN of the application to assign the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value tags to assign to the application.
    /// This member is required.
    public var tags: [KinesisAnalyticsV2ClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [KinesisAnalyticsV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the Managed Service for Apache Flink application from which to remove the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of keys of tags to remove from the specified application.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension KinesisAnalyticsV2ClientTypes {
    /// Describes the updates to the starting parameters for a Managed Service for Apache Flink application.
    public struct RunConfigurationUpdate {
        /// Describes updates to the restore behavior of a restarting application.
        public var applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Managed Service for Apache Flink application.
        public var flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?

        public init(
            applicationRestoreConfiguration: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration? = nil,
            flinkRunConfiguration: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration? = nil
        )
        {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
        }
    }

}

public struct UpdateApplicationInput {
    /// Describes application configuration updates.
    public var applicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate?
    /// The name of the application to update.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Describes application Amazon CloudWatch logging option updates. You can only update existing CloudWatch logging options with this action. To add a new CloudWatch logging option, use [AddApplicationCloudWatchLoggingOption].
    public var cloudWatchLoggingOptionUpdates: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]?
    /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var conditionalToken: Swift.String?
    /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using [DescribeApplication]. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
    public var currentApplicationVersionId: Swift.Int?
    /// Describes updates to the application's starting parameters.
    public var runConfigurationUpdate: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate?
    /// Updates the Managed Service for Apache Flink runtime environment used to run your code. To avoid issues you must:
    ///
    /// * Ensure your new jar and dependencies are compatible with the new runtime selected.
    ///
    /// * Ensure your new code's state is compatible with the snapshot from which your application will start
    public var runtimeEnvironmentUpdate: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment?
    /// Describes updates to the service execution role.
    public var serviceExecutionRoleUpdate: Swift.String?

    public init(
        applicationConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate? = nil,
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptionUpdates: [KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate]? = nil,
        conditionalToken: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        runConfigurationUpdate: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate? = nil,
        runtimeEnvironmentUpdate: KinesisAnalyticsV2ClientTypes.RuntimeEnvironment? = nil,
        serviceExecutionRoleUpdate: Swift.String? = nil
    )
    {
        self.applicationConfigurationUpdate = applicationConfigurationUpdate
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.runConfigurationUpdate = runConfigurationUpdate
        self.runtimeEnvironmentUpdate = runtimeEnvironmentUpdate
        self.serviceExecutionRoleUpdate = serviceExecutionRoleUpdate
    }
}

public struct UpdateApplicationOutput {
    /// Describes application updates.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail?
    /// Operation ID for tracking UpdateApplication request
    public var operationId: Swift.String?

    public init(
        applicationDetail: KinesisAnalyticsV2ClientTypes.ApplicationDetail? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.applicationDetail = applicationDetail
        self.operationId = operationId
    }
}

public struct UpdateApplicationMaintenanceConfigurationInput {
    /// Describes the application maintenance configuration update.
    /// This member is required.
    public var applicationMaintenanceConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate?
    /// The name of the application for which you want to update the maintenance configuration.
    /// This member is required.
    public var applicationName: Swift.String?

    public init(
        applicationMaintenanceConfigurationUpdate: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate? = nil,
        applicationName: Swift.String? = nil
    )
    {
        self.applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdate
        self.applicationName = applicationName
    }
}

public struct UpdateApplicationMaintenanceConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the application.
    public var applicationARN: Swift.String?
    /// The application maintenance configuration description after the update.
    public var applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription?

    public init(
        applicationARN: Swift.String? = nil,
        applicationMaintenanceConfigurationDescription: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
    }
}

extension AddApplicationCloudWatchLoggingOptionInput {

    static func urlPathProvider(_ value: AddApplicationCloudWatchLoggingOptionInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationInputInput {

    static func urlPathProvider(_ value: AddApplicationInputInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationInputProcessingConfigurationInput {

    static func urlPathProvider(_ value: AddApplicationInputProcessingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationOutputInput {

    static func urlPathProvider(_ value: AddApplicationOutputInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationReferenceDataSourceInput {

    static func urlPathProvider(_ value: AddApplicationReferenceDataSourceInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationVpcConfigurationInput {

    static func urlPathProvider(_ value: AddApplicationVpcConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationPresignedUrlInput {

    static func urlPathProvider(_ value: CreateApplicationPresignedUrlInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationSnapshotInput {

    static func urlPathProvider(_ value: CreateApplicationSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput {

    static func urlPathProvider(_ value: DeleteApplicationCloudWatchLoggingOptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInputProcessingConfigurationInput {

    static func urlPathProvider(_ value: DeleteApplicationInputProcessingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationOutputInput {

    static func urlPathProvider(_ value: DeleteApplicationOutputInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationReferenceDataSourceInput {

    static func urlPathProvider(_ value: DeleteApplicationReferenceDataSourceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationSnapshotInput {

    static func urlPathProvider(_ value: DeleteApplicationSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationVpcConfigurationInput {

    static func urlPathProvider(_ value: DeleteApplicationVpcConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationInput {

    static func urlPathProvider(_ value: DescribeApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationOperationInput {

    static func urlPathProvider(_ value: DescribeApplicationOperationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationSnapshotInput {

    static func urlPathProvider(_ value: DescribeApplicationSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationVersionInput {

    static func urlPathProvider(_ value: DescribeApplicationVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DiscoverInputSchemaInput {

    static func urlPathProvider(_ value: DiscoverInputSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationOperationsInput {

    static func urlPathProvider(_ value: ListApplicationOperationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationSnapshotsInput {

    static func urlPathProvider(_ value: ListApplicationSnapshotsInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationVersionsInput {

    static func urlPathProvider(_ value: ListApplicationVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RollbackApplicationInput {

    static func urlPathProvider(_ value: RollbackApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StartApplicationInput {

    static func urlPathProvider(_ value: StartApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StopApplicationInput {

    static func urlPathProvider(_ value: StopApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: UpdateApplicationMaintenanceConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationCloudWatchLoggingOptionInput {

    static func write(value: AddApplicationCloudWatchLoggingOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOption"].write(value.cloudWatchLoggingOption, with: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption.write(value:to:))
        try writer["ConditionalToken"].write(value.conditionalToken)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
    }
}

extension AddApplicationInputInput {

    static func write(value: AddApplicationInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["Input"].write(value.input, with: KinesisAnalyticsV2ClientTypes.Input.write(value:to:))
    }
}

extension AddApplicationInputProcessingConfigurationInput {

    static func write(value: AddApplicationInputProcessingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["InputId"].write(value.inputId)
        try writer["InputProcessingConfiguration"].write(value.inputProcessingConfiguration, with: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration.write(value:to:))
    }
}

extension AddApplicationOutputInput {

    static func write(value: AddApplicationOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["Output"].write(value.output, with: KinesisAnalyticsV2ClientTypes.Output.write(value:to:))
    }
}

extension AddApplicationReferenceDataSourceInput {

    static func write(value: AddApplicationReferenceDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["ReferenceDataSource"].write(value.referenceDataSource, with: KinesisAnalyticsV2ClientTypes.ReferenceDataSource.write(value:to:))
    }
}

extension AddApplicationVpcConfigurationInput {

    static func write(value: AddApplicationVpcConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["ConditionalToken"].write(value.conditionalToken)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["VpcConfiguration"].write(value.vpcConfiguration, with: KinesisAnalyticsV2ClientTypes.VpcConfiguration.write(value:to:))
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationConfiguration"].write(value.applicationConfiguration, with: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration.write(value:to:))
        try writer["ApplicationDescription"].write(value.applicationDescription)
        try writer["ApplicationMode"].write(value.applicationMode)
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOptions"].writeList(value.cloudWatchLoggingOptions, memberWritingClosure: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RuntimeEnvironment"].write(value.runtimeEnvironment)
        try writer["ServiceExecutionRole"].write(value.serviceExecutionRole)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KinesisAnalyticsV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateApplicationPresignedUrlInput {

    static func write(value: CreateApplicationPresignedUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["SessionExpirationDurationInSeconds"].write(value.sessionExpirationDurationInSeconds)
        try writer["UrlType"].write(value.urlType)
    }
}

extension CreateApplicationSnapshotInput {

    static func write(value: CreateApplicationSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["SnapshotName"].write(value.snapshotName)
    }
}

extension DeleteApplicationInput {

    static func write(value: DeleteApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CreateTimestamp"].writeTimestamp(value.createTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput {

    static func write(value: DeleteApplicationCloudWatchLoggingOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOptionId"].write(value.cloudWatchLoggingOptionId)
        try writer["ConditionalToken"].write(value.conditionalToken)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
    }
}

extension DeleteApplicationInputProcessingConfigurationInput {

    static func write(value: DeleteApplicationInputProcessingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["InputId"].write(value.inputId)
    }
}

extension DeleteApplicationOutputInput {

    static func write(value: DeleteApplicationOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["OutputId"].write(value.outputId)
    }
}

extension DeleteApplicationReferenceDataSourceInput {

    static func write(value: DeleteApplicationReferenceDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["ReferenceId"].write(value.referenceId)
    }
}

extension DeleteApplicationSnapshotInput {

    static func write(value: DeleteApplicationSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["SnapshotCreationTimestamp"].writeTimestamp(value.snapshotCreationTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["SnapshotName"].write(value.snapshotName)
    }
}

extension DeleteApplicationVpcConfigurationInput {

    static func write(value: DeleteApplicationVpcConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["ConditionalToken"].write(value.conditionalToken)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["VpcConfigurationId"].write(value.vpcConfigurationId)
    }
}

extension DescribeApplicationInput {

    static func write(value: DescribeApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["IncludeAdditionalDetails"].write(value.includeAdditionalDetails)
    }
}

extension DescribeApplicationOperationInput {

    static func write(value: DescribeApplicationOperationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["OperationId"].write(value.operationId)
    }
}

extension DescribeApplicationSnapshotInput {

    static func write(value: DescribeApplicationSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["SnapshotName"].write(value.snapshotName)
    }
}

extension DescribeApplicationVersionInput {

    static func write(value: DescribeApplicationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["ApplicationVersionId"].write(value.applicationVersionId)
    }
}

extension DiscoverInputSchemaInput {

    static func write(value: DiscoverInputSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputProcessingConfiguration"].write(value.inputProcessingConfiguration, with: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration.write(value:to:))
        try writer["InputStartingPositionConfiguration"].write(value.inputStartingPositionConfiguration, with: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration.write(value:to:))
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["S3Configuration"].write(value.s3Configuration, with: KinesisAnalyticsV2ClientTypes.S3Configuration.write(value:to:))
        try writer["ServiceExecutionRole"].write(value.serviceExecutionRole)
    }
}

extension ListApplicationOperationsInput {

    static func write(value: ListApplicationOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["Operation"].write(value.operation)
        try writer["OperationStatus"].write(value.operationStatus)
    }
}

extension ListApplicationsInput {

    static func write(value: ListApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationSnapshotsInput {

    static func write(value: ListApplicationSnapshotsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationVersionsInput {

    static func write(value: ListApplicationVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension RollbackApplicationInput {

    static func write(value: RollbackApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
    }
}

extension StartApplicationInput {

    static func write(value: StartApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["RunConfiguration"].write(value.runConfiguration, with: KinesisAnalyticsV2ClientTypes.RunConfiguration.write(value:to:))
    }
}

extension StopApplicationInput {

    static func write(value: StopApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["Force"].write(value.force)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KinesisAnalyticsV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationConfigurationUpdate"].write(value.applicationConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate.write(value:to:))
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOptionUpdates"].writeList(value.cloudWatchLoggingOptionUpdates, memberWritingClosure: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConditionalToken"].write(value.conditionalToken)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["RunConfigurationUpdate"].write(value.runConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate.write(value:to:))
        try writer["RuntimeEnvironmentUpdate"].write(value.runtimeEnvironmentUpdate)
        try writer["ServiceExecutionRoleUpdate"].write(value.serviceExecutionRoleUpdate)
    }
}

extension UpdateApplicationMaintenanceConfigurationInput {

    static func write(value: UpdateApplicationMaintenanceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationMaintenanceConfigurationUpdate"].write(value.applicationMaintenanceConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate.write(value:to:))
        try writer["ApplicationName"].write(value.applicationName)
    }
}

extension AddApplicationCloudWatchLoggingOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationCloudWatchLoggingOptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddApplicationCloudWatchLoggingOptionOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.cloudWatchLoggingOptionDescriptions = try reader["CloudWatchLoggingOptionDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension AddApplicationInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddApplicationInputOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.inputDescriptions = try reader["InputDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.InputDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddApplicationInputProcessingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationInputProcessingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddApplicationInputProcessingConfigurationOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.inputId = try reader["InputId"].readIfPresent()
        value.inputProcessingConfigurationDescription = try reader["InputProcessingConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription.read(from:))
        return value
    }
}

extension AddApplicationOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddApplicationOutputOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.outputDescriptions = try reader["OutputDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.OutputDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddApplicationReferenceDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationReferenceDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddApplicationReferenceDataSourceOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.referenceDataSourceDescriptions = try reader["ReferenceDataSourceDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddApplicationVpcConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationVpcConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddApplicationVpcConfigurationOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.vpcConfigurationDescription = try reader["VpcConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription.read(from:))
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationDetail = try reader["ApplicationDetail"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationDetail.read(from:))
        return value
    }
}

extension CreateApplicationPresignedUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationPresignedUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationPresignedUrlOutput()
        value.authorizedUrl = try reader["AuthorizedUrl"].readIfPresent()
        return value
    }
}

extension CreateApplicationSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationSnapshotOutput {
        return CreateApplicationSnapshotOutput()
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationCloudWatchLoggingOptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApplicationCloudWatchLoggingOptionOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.cloudWatchLoggingOptionDescriptions = try reader["CloudWatchLoggingOptionDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension DeleteApplicationInputProcessingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationInputProcessingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApplicationInputProcessingConfigurationOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        return value
    }
}

extension DeleteApplicationOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApplicationOutputOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        return value
    }
}

extension DeleteApplicationReferenceDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationReferenceDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApplicationReferenceDataSourceOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        return value
    }
}

extension DeleteApplicationSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationSnapshotOutput {
        return DeleteApplicationSnapshotOutput()
    }
}

extension DeleteApplicationVpcConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationVpcConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApplicationVpcConfigurationOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension DescribeApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationOutput()
        value.applicationDetail = try reader["ApplicationDetail"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationDetail.read(from:))
        return value
    }
}

extension DescribeApplicationOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationOperationOutput()
        value.applicationOperationInfoDetails = try reader["ApplicationOperationInfoDetails"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationOperationInfoDetails.read(from:))
        return value
    }
}

extension DescribeApplicationSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationSnapshotOutput()
        value.snapshotDetails = try reader["SnapshotDetails"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.SnapshotDetails.read(from:))
        return value
    }
}

extension DescribeApplicationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationVersionOutput()
        value.applicationVersionDetail = try reader["ApplicationVersionDetail"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationDetail.read(from:))
        return value
    }
}

extension DiscoverInputSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DiscoverInputSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DiscoverInputSchemaOutput()
        value.inputSchema = try reader["InputSchema"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.SourceSchema.read(from:))
        value.parsedInputRecords = try reader["ParsedInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.processedInputRecords = try reader["ProcessedInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rawInputRecords = try reader["RawInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApplicationOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationOperationsOutput()
        value.applicationOperationInfoList = try reader["ApplicationOperationInfoList"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.ApplicationOperationInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applicationSummaries = try reader["ApplicationSummaries"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationSnapshotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationSnapshotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationSnapshotsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.snapshotSummaries = try reader["SnapshotSummaries"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.SnapshotDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApplicationVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationVersionsOutput()
        value.applicationVersionSummaries = try reader["ApplicationVersionSummaries"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RollbackApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RollbackApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RollbackApplicationOutput()
        value.applicationDetail = try reader["ApplicationDetail"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationDetail.read(from:))
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension StartApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartApplicationOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension StopApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopApplicationOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.applicationDetail = try reader["ApplicationDetail"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationDetail.read(from:))
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdateApplicationMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationMaintenanceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationMaintenanceConfigurationOutput()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent()
        value.applicationMaintenanceConfigurationDescription = try reader["ApplicationMaintenanceConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription.read(from:))
        return value
    }
}

enum AddApplicationCloudWatchLoggingOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeValidationException": return try CodeValidationException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationInputProcessingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationReferenceDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationVpcConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeValidationException": return try CodeValidationException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationPresignedUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationCloudWatchLoggingOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationInputProcessingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationReferenceDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationVpcConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DiscoverInputSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceProvisionedThroughputExceededException": return try ResourceProvisionedThroughputExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnableToDetectSchemaException": return try UnableToDetectSchemaException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationSnapshotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RollbackApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeValidationException": return try CodeValidationException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidApplicationConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApplicationConfigurationException {
        let reader = baseError.errorBodyReader
        var value = InvalidApplicationConfigurationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CodeValidationException {
        let reader = baseError.errorBodyReader
        var value = CodeValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceProvisionedThroughputExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceProvisionedThroughputExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceProvisionedThroughputExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnableToDetectSchemaException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnableToDetectSchemaException {
        let reader = baseError.errorBodyReader
        var value = UnableToDetectSchemaException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.processedInputRecords = try reader["ProcessedInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.rawInputRecords = try reader["RawInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription()
        value.cloudWatchLoggingOptionId = try reader["CloudWatchLoggingOptionId"].readIfPresent()
        value.logStreamARN = try reader["LogStreamARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.InputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.InputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.InputDescription()
        value.inputId = try reader["InputId"].readIfPresent()
        value.namePrefix = try reader["NamePrefix"].readIfPresent()
        value.inAppStreamNames = try reader["InAppStreamNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputProcessingConfigurationDescription = try reader["InputProcessingConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription.read(from:))
        value.kinesisStreamsInputDescription = try reader["KinesisStreamsInputDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription.read(from:))
        value.kinesisFirehoseInputDescription = try reader["KinesisFirehoseInputDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription.read(from:))
        value.inputSchema = try reader["InputSchema"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.SourceSchema.read(from:))
        value.inputParallelism = try reader["InputParallelism"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.InputParallelism.read(from:))
        value.inputStartingPositionConfiguration = try reader["InputStartingPositionConfiguration"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputStartingPosition"].write(value.inputStartingPosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration()
        value.inputStartingPosition = try reader["InputStartingPosition"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.InputParallelism {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputParallelism?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Count"].write(value.count)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.InputParallelism {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.InputParallelism()
        value.count = try reader["Count"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.SourceSchema {

    static func write(value: KinesisAnalyticsV2ClientTypes.SourceSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordColumns"].writeList(value.recordColumns, memberWritingClosure: KinesisAnalyticsV2ClientTypes.RecordColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordEncoding"].write(value.recordEncoding)
        try writer["RecordFormat"].write(value.recordFormat, with: KinesisAnalyticsV2ClientTypes.RecordFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.SourceSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.SourceSchema()
        value.recordFormat = try reader["RecordFormat"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.RecordFormat.read(from:))
        value.recordEncoding = try reader["RecordEncoding"].readIfPresent()
        value.recordColumns = try reader["RecordColumns"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.RecordColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.RecordColumn {

    static func write(value: KinesisAnalyticsV2ClientTypes.RecordColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mapping"].write(value.mapping)
        try writer["Name"].write(value.name)
        try writer["SqlType"].write(value.sqlType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.RecordColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.RecordColumn()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.mapping = try reader["Mapping"].readIfPresent()
        value.sqlType = try reader["SqlType"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.RecordFormat {

    static func write(value: KinesisAnalyticsV2ClientTypes.RecordFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MappingParameters"].write(value.mappingParameters, with: KinesisAnalyticsV2ClientTypes.MappingParameters.write(value:to:))
        try writer["RecordFormatType"].write(value.recordFormatType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.RecordFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.RecordFormat()
        value.recordFormatType = try reader["RecordFormatType"].readIfPresent() ?? .sdkUnknown("")
        value.mappingParameters = try reader["MappingParameters"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.MappingParameters.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.MappingParameters {

    static func write(value: KinesisAnalyticsV2ClientTypes.MappingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CSVMappingParameters"].write(value.csvMappingParameters, with: KinesisAnalyticsV2ClientTypes.CSVMappingParameters.write(value:to:))
        try writer["JSONMappingParameters"].write(value.jsonMappingParameters, with: KinesisAnalyticsV2ClientTypes.JSONMappingParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.MappingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.MappingParameters()
        value.jsonMappingParameters = try reader["JSONMappingParameters"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.JSONMappingParameters.read(from:))
        value.csvMappingParameters = try reader["CSVMappingParameters"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.CSVMappingParameters.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CSVMappingParameters {

    static func write(value: KinesisAnalyticsV2ClientTypes.CSVMappingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordColumnDelimiter"].write(value.recordColumnDelimiter)
        try writer["RecordRowDelimiter"].write(value.recordRowDelimiter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.CSVMappingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.CSVMappingParameters()
        value.recordRowDelimiter = try reader["RecordRowDelimiter"].readIfPresent() ?? ""
        value.recordColumnDelimiter = try reader["RecordColumnDelimiter"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.JSONMappingParameters {

    static func write(value: KinesisAnalyticsV2ClientTypes.JSONMappingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordRowPath"].write(value.recordRowPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.JSONMappingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.JSONMappingParameters()
        value.recordRowPath = try reader["RecordRowPath"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.KinesisStreamsInputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationDescription()
        value.inputLambdaProcessorDescription = try reader["InputLambdaProcessorDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.InputLambdaProcessorDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.OutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.OutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.OutputDescription()
        value.outputId = try reader["OutputId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.kinesisStreamsOutputDescription = try reader["KinesisStreamsOutputDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription.read(from:))
        value.kinesisFirehoseOutputDescription = try reader["KinesisFirehoseOutputDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription.read(from:))
        value.lambdaOutputDescription = try reader["LambdaOutputDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.LambdaOutputDescription.read(from:))
        value.destinationSchema = try reader["DestinationSchema"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.DestinationSchema.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.DestinationSchema {

    static func write(value: KinesisAnalyticsV2ClientTypes.DestinationSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordFormatType"].write(value.recordFormatType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.DestinationSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.DestinationSchema()
        value.recordFormatType = try reader["RecordFormatType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.LambdaOutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.LambdaOutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.LambdaOutputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription()
        value.referenceId = try reader["ReferenceId"].readIfPresent() ?? ""
        value.tableName = try reader["TableName"].readIfPresent() ?? ""
        value.s3ReferenceDataSourceDescription = try reader["S3ReferenceDataSourceDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription.read(from:))
        value.referenceSchema = try reader["ReferenceSchema"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.SourceSchema.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceDescription()
        value.bucketARN = try reader["BucketARN"].readIfPresent() ?? ""
        value.fileKey = try reader["FileKey"].readIfPresent() ?? ""
        value.referenceRoleARN = try reader["ReferenceRoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription()
        value.vpcConfigurationId = try reader["VpcConfigurationId"].readIfPresent() ?? ""
        value.vpcId = try reader["VpcId"].readIfPresent() ?? ""
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationDetail()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent() ?? ""
        value.applicationDescription = try reader["ApplicationDescription"].readIfPresent()
        value.applicationName = try reader["ApplicationName"].readIfPresent() ?? ""
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent() ?? .sdkUnknown("")
        value.serviceExecutionRole = try reader["ServiceExecutionRole"].readIfPresent()
        value.applicationStatus = try reader["ApplicationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent() ?? 0
        value.createTimestamp = try reader["CreateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTimestamp = try reader["LastUpdateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.applicationConfigurationDescription = try reader["ApplicationConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription.read(from:))
        value.cloudWatchLoggingOptionDescriptions = try reader["CloudWatchLoggingOptionDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationMaintenanceConfigurationDescription = try reader["ApplicationMaintenanceConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription.read(from:))
        value.applicationVersionUpdatedFrom = try reader["ApplicationVersionUpdatedFrom"].readIfPresent()
        value.applicationVersionRolledBackFrom = try reader["ApplicationVersionRolledBackFrom"].readIfPresent()
        value.applicationVersionCreateTimestamp = try reader["ApplicationVersionCreateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.conditionalToken = try reader["ConditionalToken"].readIfPresent()
        value.applicationVersionRolledBackTo = try reader["ApplicationVersionRolledBackTo"].readIfPresent()
        value.applicationMode = try reader["ApplicationMode"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationDescription()
        value.applicationMaintenanceWindowStartTime = try reader["ApplicationMaintenanceWindowStartTime"].readIfPresent() ?? ""
        value.applicationMaintenanceWindowEndTime = try reader["ApplicationMaintenanceWindowEndTime"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationConfigurationDescription()
        value.sqlApplicationConfigurationDescription = try reader["SqlApplicationConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription.read(from:))
        value.applicationCodeConfigurationDescription = try reader["ApplicationCodeConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription.read(from:))
        value.runConfigurationDescription = try reader["RunConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.RunConfigurationDescription.read(from:))
        value.flinkApplicationConfigurationDescription = try reader["FlinkApplicationConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription.read(from:))
        value.environmentPropertyDescriptions = try reader["EnvironmentPropertyDescriptions"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions.read(from:))
        value.applicationSnapshotConfigurationDescription = try reader["ApplicationSnapshotConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription.read(from:))
        value.applicationSystemRollbackConfigurationDescription = try reader["ApplicationSystemRollbackConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationDescription.read(from:))
        value.vpcConfigurationDescriptions = try reader["VpcConfigurationDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.VpcConfigurationDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.zeppelinApplicationConfigurationDescription = try reader["ZeppelinApplicationConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationDescription()
        value.monitoringConfigurationDescription = try reader["MonitoringConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription.read(from:))
        value.catalogConfigurationDescription = try reader["CatalogConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription.read(from:))
        value.deployAsApplicationConfigurationDescription = try reader["DeployAsApplicationConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription.read(from:))
        value.customArtifactsConfigurationDescription = try reader["CustomArtifactsConfigurationDescription"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.CustomArtifactConfigurationDescription()
        value.artifactType = try reader["ArtifactType"].readIfPresent()
        value.s3ContentLocationDescription = try reader["S3ContentLocationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.S3ContentLocation.read(from:))
        value.mavenReferenceDescription = try reader["MavenReferenceDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.MavenReference.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.MavenReference {

    static func write(value: KinesisAnalyticsV2ClientTypes.MavenReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactId"].write(value.artifactId)
        try writer["GroupId"].write(value.groupId)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.MavenReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.MavenReference()
        value.groupId = try reader["GroupId"].readIfPresent() ?? ""
        value.artifactId = try reader["ArtifactId"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ContentLocation {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3ContentLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARN"].write(value.bucketARN)
        try writer["FileKey"].write(value.fileKey)
        try writer["ObjectVersion"].write(value.objectVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.S3ContentLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.S3ContentLocation()
        value.bucketARN = try reader["BucketARN"].readIfPresent() ?? ""
        value.fileKey = try reader["FileKey"].readIfPresent() ?? ""
        value.objectVersion = try reader["ObjectVersion"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationDescription()
        value.s3ContentLocationDescription = try reader["S3ContentLocationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationDescription()
        value.bucketARN = try reader["BucketARN"].readIfPresent() ?? ""
        value.basePath = try reader["BasePath"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.CatalogConfigurationDescription()
        value.glueDataCatalogConfigurationDescription = try reader["GlueDataCatalogConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationDescription()
        value.databaseARN = try reader["DatabaseARN"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationDescription()
        value.logLevel = try reader["LogLevel"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationDescription()
        value.rollbackEnabled = try reader["RollbackEnabled"].readIfPresent() ?? false
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationDescription()
        value.snapshotsEnabled = try reader["SnapshotsEnabled"].readIfPresent() ?? false
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.EnvironmentPropertyDescriptions()
        value.propertyGroupDescriptions = try reader["PropertyGroupDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.PropertyGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.PropertyGroup {

    static func write(value: KinesisAnalyticsV2ClientTypes.PropertyGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PropertyGroupId"].write(value.propertyGroupId)
        try writer["PropertyMap"].writeMap(value.propertyMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.PropertyGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.PropertyGroup()
        value.propertyGroupId = try reader["PropertyGroupId"].readIfPresent() ?? ""
        value.propertyMap = try reader["PropertyMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationDescription()
        value.checkpointConfigurationDescription = try reader["CheckpointConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription.read(from:))
        value.monitoringConfigurationDescription = try reader["MonitoringConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription.read(from:))
        value.parallelismConfigurationDescription = try reader["ParallelismConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription.read(from:))
        value.jobPlanDescription = try reader["JobPlanDescription"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ParallelismConfigurationDescription()
        value.configurationType = try reader["ConfigurationType"].readIfPresent()
        value.parallelism = try reader["Parallelism"].readIfPresent()
        value.parallelismPerKPU = try reader["ParallelismPerKPU"].readIfPresent()
        value.currentParallelism = try reader["CurrentParallelism"].readIfPresent()
        value.autoScalingEnabled = try reader["AutoScalingEnabled"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.MonitoringConfigurationDescription()
        value.configurationType = try reader["ConfigurationType"].readIfPresent()
        value.metricsLevel = try reader["MetricsLevel"].readIfPresent()
        value.logLevel = try reader["LogLevel"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.CheckpointConfigurationDescription()
        value.configurationType = try reader["ConfigurationType"].readIfPresent()
        value.checkpointingEnabled = try reader["CheckpointingEnabled"].readIfPresent()
        value.checkpointInterval = try reader["CheckpointInterval"].readIfPresent()
        value.minPauseBetweenCheckpoints = try reader["MinPauseBetweenCheckpoints"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.RunConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.RunConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.RunConfigurationDescription()
        value.applicationRestoreConfigurationDescription = try reader["ApplicationRestoreConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration.read(from:))
        value.flinkRunConfigurationDescription = try reader["FlinkRunConfigurationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowNonRestoredState"].write(value.allowNonRestoredState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration()
        value.allowNonRestoredState = try reader["AllowNonRestoredState"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationRestoreType"].write(value.applicationRestoreType)
        try writer["SnapshotName"].write(value.snapshotName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration()
        value.applicationRestoreType = try reader["ApplicationRestoreType"].readIfPresent() ?? .sdkUnknown("")
        value.snapshotName = try reader["SnapshotName"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationDescription()
        value.codeContentType = try reader["CodeContentType"].readIfPresent() ?? .sdkUnknown("")
        value.codeContentDescription = try reader["CodeContentDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.CodeContentDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CodeContentDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.CodeContentDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.CodeContentDescription()
        value.textContent = try reader["TextContent"].readIfPresent()
        value.codeMD5 = try reader["CodeMD5"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent()
        value.s3ApplicationCodeLocationDescription = try reader["S3ApplicationCodeLocationDescription"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.S3ApplicationCodeLocationDescription()
        value.bucketARN = try reader["BucketARN"].readIfPresent() ?? ""
        value.fileKey = try reader["FileKey"].readIfPresent() ?? ""
        value.objectVersion = try reader["ObjectVersion"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationDescription()
        value.inputDescriptions = try reader["InputDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.InputDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputDescriptions = try reader["OutputDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.OutputDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.referenceDataSourceDescriptions = try reader["ReferenceDataSourceDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsV2ClientTypes.ReferenceDataSourceDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationOperationInfoDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationOperationInfoDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationOperationInfoDetails()
        value.operation = try reader["Operation"].readIfPresent() ?? ""
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.operationStatus = try reader["OperationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.applicationVersionChangeDetails = try reader["ApplicationVersionChangeDetails"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ApplicationVersionChangeDetails.read(from:))
        value.operationFailureDetails = try reader["OperationFailureDetails"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.OperationFailureDetails.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.OperationFailureDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.OperationFailureDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.OperationFailureDetails()
        value.rollbackOperationId = try reader["RollbackOperationId"].readIfPresent()
        value.errorInfo = try reader["ErrorInfo"].readIfPresent(with: KinesisAnalyticsV2ClientTypes.ErrorInfo.read(from:))
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ErrorInfo()
        value.errorString = try reader["ErrorString"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationVersionChangeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationVersionChangeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationVersionChangeDetails()
        value.applicationVersionUpdatedFrom = try reader["ApplicationVersionUpdatedFrom"].readIfPresent() ?? 0
        value.applicationVersionUpdatedTo = try reader["ApplicationVersionUpdatedTo"].readIfPresent() ?? 0
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.SnapshotDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.SnapshotDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.SnapshotDetails()
        value.snapshotName = try reader["SnapshotName"].readIfPresent() ?? ""
        value.snapshotStatus = try reader["SnapshotStatus"].readIfPresent() ?? .sdkUnknown("")
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent() ?? 0
        value.snapshotCreationTimestamp = try reader["SnapshotCreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationOperationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationOperationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationOperationInfo()
        value.operation = try reader["Operation"].readIfPresent()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.operationStatus = try reader["OperationStatus"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationSummary()
        value.applicationName = try reader["ApplicationName"].readIfPresent() ?? ""
        value.applicationARN = try reader["ApplicationARN"].readIfPresent() ?? ""
        value.applicationStatus = try reader["ApplicationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent() ?? 0
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent() ?? .sdkUnknown("")
        value.applicationMode = try reader["ApplicationMode"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.ApplicationVersionSummary()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent() ?? 0
        value.applicationStatus = try reader["ApplicationStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.Tag {

    static func write(value: KinesisAnalyticsV2ClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsV2ClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsV2ClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption {

    static func write(value: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogStreamARN"].write(value.logStreamARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.Input {

    static func write(value: KinesisAnalyticsV2ClientTypes.Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputParallelism"].write(value.inputParallelism, with: KinesisAnalyticsV2ClientTypes.InputParallelism.write(value:to:))
        try writer["InputProcessingConfiguration"].write(value.inputProcessingConfiguration, with: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration.write(value:to:))
        try writer["InputSchema"].write(value.inputSchema, with: KinesisAnalyticsV2ClientTypes.SourceSchema.write(value:to:))
        try writer["KinesisFirehoseInput"].write(value.kinesisFirehoseInput, with: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput.write(value:to:))
        try writer["KinesisStreamsInput"].write(value.kinesisStreamsInput, with: KinesisAnalyticsV2ClientTypes.KinesisStreamsInput.write(value:to:))
        try writer["NamePrefix"].write(value.namePrefix)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsInput {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputLambdaProcessor"].write(value.inputLambdaProcessor, with: KinesisAnalyticsV2ClientTypes.InputLambdaProcessor.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.InputLambdaProcessor {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputLambdaProcessor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.Output {

    static func write(value: KinesisAnalyticsV2ClientTypes.Output?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationSchema"].write(value.destinationSchema, with: KinesisAnalyticsV2ClientTypes.DestinationSchema.write(value:to:))
        try writer["KinesisFirehoseOutput"].write(value.kinesisFirehoseOutput, with: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput.write(value:to:))
        try writer["KinesisStreamsOutput"].write(value.kinesisStreamsOutput, with: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput.write(value:to:))
        try writer["LambdaOutput"].write(value.lambdaOutput, with: KinesisAnalyticsV2ClientTypes.LambdaOutput.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension KinesisAnalyticsV2ClientTypes.LambdaOutput {

    static func write(value: KinesisAnalyticsV2ClientTypes.LambdaOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.ReferenceDataSource {

    static func write(value: KinesisAnalyticsV2ClientTypes.ReferenceDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReferenceSchema"].write(value.referenceSchema, with: KinesisAnalyticsV2ClientTypes.SourceSchema.write(value:to:))
        try writer["S3ReferenceDataSource"].write(value.s3ReferenceDataSource, with: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource.write(value:to:))
        try writer["TableName"].write(value.tableName)
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARN"].write(value.bucketARN)
        try writer["FileKey"].write(value.fileKey)
    }
}

extension KinesisAnalyticsV2ClientTypes.VpcConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.VpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationCodeConfiguration"].write(value.applicationCodeConfiguration, with: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration.write(value:to:))
        try writer["ApplicationSnapshotConfiguration"].write(value.applicationSnapshotConfiguration, with: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration.write(value:to:))
        try writer["ApplicationSystemRollbackConfiguration"].write(value.applicationSystemRollbackConfiguration, with: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfiguration.write(value:to:))
        try writer["EnvironmentProperties"].write(value.environmentProperties, with: KinesisAnalyticsV2ClientTypes.EnvironmentProperties.write(value:to:))
        try writer["FlinkApplicationConfiguration"].write(value.flinkApplicationConfiguration, with: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration.write(value:to:))
        try writer["SqlApplicationConfiguration"].write(value.sqlApplicationConfiguration, with: KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration.write(value:to:))
        try writer["VpcConfigurations"].writeList(value.vpcConfigurations, memberWritingClosure: KinesisAnalyticsV2ClientTypes.VpcConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ZeppelinApplicationConfiguration"].write(value.zeppelinApplicationConfiguration, with: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogConfiguration"].write(value.catalogConfiguration, with: KinesisAnalyticsV2ClientTypes.CatalogConfiguration.write(value:to:))
        try writer["CustomArtifactsConfiguration"].writeList(value.customArtifactsConfiguration, memberWritingClosure: KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeployAsApplicationConfiguration"].write(value.deployAsApplicationConfiguration, with: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration.write(value:to:))
        try writer["MonitoringConfiguration"].write(value.monitoringConfiguration, with: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactType"].write(value.artifactType)
        try writer["MavenReference"].write(value.mavenReference, with: KinesisAnalyticsV2ClientTypes.MavenReference.write(value:to:))
        try writer["S3ContentLocation"].write(value.s3ContentLocation, with: KinesisAnalyticsV2ClientTypes.S3ContentLocation.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3ContentLocation"].write(value.s3ContentLocation, with: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BasePath"].write(value.basePath)
        try writer["BucketARN"].write(value.bucketARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.CatalogConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.CatalogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GlueDataCatalogConfiguration"].write(value.glueDataCatalogConfiguration, with: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseARN"].write(value.databaseARN)
    }
}

extension KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogLevel"].write(value.logLevel)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RollbackEnabled"].write(value.rollbackEnabled)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapshotsEnabled"].write(value.snapshotsEnabled)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeContent"].write(value.codeContent, with: KinesisAnalyticsV2ClientTypes.CodeContent.write(value:to:))
        try writer["CodeContentType"].write(value.codeContentType)
    }
}

extension KinesisAnalyticsV2ClientTypes.CodeContent {

    static func write(value: KinesisAnalyticsV2ClientTypes.CodeContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3ContentLocation"].write(value.s3ContentLocation, with: KinesisAnalyticsV2ClientTypes.S3ContentLocation.write(value:to:))
        try writer["TextContent"].write(value.textContent)
        try writer["ZipFileContent"].write(value.zipFileContent)
    }
}

extension KinesisAnalyticsV2ClientTypes.EnvironmentProperties {

    static func write(value: KinesisAnalyticsV2ClientTypes.EnvironmentProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PropertyGroups"].writeList(value.propertyGroups, memberWritingClosure: KinesisAnalyticsV2ClientTypes.PropertyGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CheckpointConfiguration"].write(value.checkpointConfiguration, with: KinesisAnalyticsV2ClientTypes.CheckpointConfiguration.write(value:to:))
        try writer["MonitoringConfiguration"].write(value.monitoringConfiguration, with: KinesisAnalyticsV2ClientTypes.MonitoringConfiguration.write(value:to:))
        try writer["ParallelismConfiguration"].write(value.parallelismConfiguration, with: KinesisAnalyticsV2ClientTypes.ParallelismConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.ParallelismConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.ParallelismConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingEnabled"].write(value.autoScalingEnabled)
        try writer["ConfigurationType"].write(value.configurationType)
        try writer["Parallelism"].write(value.parallelism)
        try writer["ParallelismPerKPU"].write(value.parallelismPerKPU)
    }
}

extension KinesisAnalyticsV2ClientTypes.MonitoringConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.MonitoringConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationType"].write(value.configurationType)
        try writer["LogLevel"].write(value.logLevel)
        try writer["MetricsLevel"].write(value.metricsLevel)
    }
}

extension KinesisAnalyticsV2ClientTypes.CheckpointConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.CheckpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CheckpointInterval"].write(value.checkpointInterval)
        try writer["CheckpointingEnabled"].write(value.checkpointingEnabled)
        try writer["ConfigurationType"].write(value.configurationType)
        try writer["MinPauseBetweenCheckpoints"].write(value.minPauseBetweenCheckpoints)
    }
}

extension KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.SqlApplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: KinesisAnalyticsV2ClientTypes.Input.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: KinesisAnalyticsV2ClientTypes.Output.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReferenceDataSources"].writeList(value.referenceDataSources, memberWritingClosure: KinesisAnalyticsV2ClientTypes.ReferenceDataSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsV2ClientTypes.S3Configuration {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARN"].write(value.bucketARN)
        try writer["FileKey"].write(value.fileKey)
    }
}

extension KinesisAnalyticsV2ClientTypes.RunConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.RunConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationRestoreConfiguration"].write(value.applicationRestoreConfiguration, with: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration.write(value:to:))
        try writer["FlinkRunConfiguration"].write(value.flinkRunConfiguration, with: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration.write(value:to:))
        try writer["SqlRunConfigurations"].writeList(value.sqlRunConfigurations, memberWritingClosure: KinesisAnalyticsV2ClientTypes.SqlRunConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsV2ClientTypes.SqlRunConfiguration {

    static func write(value: KinesisAnalyticsV2ClientTypes.SqlRunConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputId"].write(value.inputId)
        try writer["InputStartingPositionConfiguration"].write(value.inputStartingPositionConfiguration, with: KinesisAnalyticsV2ClientTypes.InputStartingPositionConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationCodeConfigurationUpdate"].write(value.applicationCodeConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate.write(value:to:))
        try writer["ApplicationSnapshotConfigurationUpdate"].write(value.applicationSnapshotConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate.write(value:to:))
        try writer["ApplicationSystemRollbackConfigurationUpdate"].write(value.applicationSystemRollbackConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationUpdate.write(value:to:))
        try writer["EnvironmentPropertyUpdates"].write(value.environmentPropertyUpdates, with: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates.write(value:to:))
        try writer["FlinkApplicationConfigurationUpdate"].write(value.flinkApplicationConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate.write(value:to:))
        try writer["SqlApplicationConfigurationUpdate"].write(value.sqlApplicationConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate.write(value:to:))
        try writer["VpcConfigurationUpdates"].writeList(value.vpcConfigurationUpdates, memberWritingClosure: KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ZeppelinApplicationConfigurationUpdate"].write(value.zeppelinApplicationConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ZeppelinApplicationConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogConfigurationUpdate"].write(value.catalogConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate.write(value:to:))
        try writer["CustomArtifactsConfigurationUpdate"].writeList(value.customArtifactsConfigurationUpdate, memberWritingClosure: KinesisAnalyticsV2ClientTypes.CustomArtifactConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeployAsApplicationConfigurationUpdate"].write(value.deployAsApplicationConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate.write(value:to:))
        try writer["MonitoringConfigurationUpdate"].write(value.monitoringConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.DeployAsApplicationConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3ContentLocationUpdate"].write(value.s3ContentLocationUpdate, with: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3ContentBaseLocationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BasePathUpdate"].write(value.basePathUpdate)
        try writer["BucketARNUpdate"].write(value.bucketARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.CatalogConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GlueDataCatalogConfigurationUpdate"].write(value.glueDataCatalogConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.GlueDataCatalogConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseARNUpdate"].write(value.databaseARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ZeppelinMonitoringConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogLevelUpdate"].write(value.logLevelUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.VpcConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIdUpdates"].writeList(value.securityGroupIdUpdates, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIdUpdates"].writeList(value.subnetIdUpdates, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcConfigurationId"].write(value.vpcConfigurationId)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationSystemRollbackConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RollbackEnabledUpdate"].write(value.rollbackEnabledUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationSnapshotConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapshotsEnabledUpdate"].write(value.snapshotsEnabledUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates {

    static func write(value: KinesisAnalyticsV2ClientTypes.EnvironmentPropertyUpdates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PropertyGroups"].writeList(value.propertyGroups, memberWritingClosure: KinesisAnalyticsV2ClientTypes.PropertyGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.FlinkApplicationConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CheckpointConfigurationUpdate"].write(value.checkpointConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate.write(value:to:))
        try writer["MonitoringConfigurationUpdate"].write(value.monitoringConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate.write(value:to:))
        try writer["ParallelismConfigurationUpdate"].write(value.parallelismConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ParallelismConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingEnabledUpdate"].write(value.autoScalingEnabledUpdate)
        try writer["ConfigurationTypeUpdate"].write(value.configurationTypeUpdate)
        try writer["ParallelismPerKPUUpdate"].write(value.parallelismPerKPUUpdate)
        try writer["ParallelismUpdate"].write(value.parallelismUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.MonitoringConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationTypeUpdate"].write(value.configurationTypeUpdate)
        try writer["LogLevelUpdate"].write(value.logLevelUpdate)
        try writer["MetricsLevelUpdate"].write(value.metricsLevelUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.CheckpointConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CheckpointIntervalUpdate"].write(value.checkpointIntervalUpdate)
        try writer["CheckpointingEnabledUpdate"].write(value.checkpointingEnabledUpdate)
        try writer["ConfigurationTypeUpdate"].write(value.configurationTypeUpdate)
        try writer["MinPauseBetweenCheckpointsUpdate"].write(value.minPauseBetweenCheckpointsUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationCodeConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeContentTypeUpdate"].write(value.codeContentTypeUpdate)
        try writer["CodeContentUpdate"].write(value.codeContentUpdate, with: KinesisAnalyticsV2ClientTypes.CodeContentUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.CodeContentUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.CodeContentUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3ContentLocationUpdate"].write(value.s3ContentLocationUpdate, with: KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate.write(value:to:))
        try writer["TextContentUpdate"].write(value.textContentUpdate)
        try writer["ZipFileContentUpdate"].write(value.zipFileContentUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3ContentLocationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARNUpdate"].write(value.bucketARNUpdate)
        try writer["FileKeyUpdate"].write(value.fileKeyUpdate)
        try writer["ObjectVersionUpdate"].write(value.objectVersionUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.SqlApplicationConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputUpdates"].writeList(value.inputUpdates, memberWritingClosure: KinesisAnalyticsV2ClientTypes.InputUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutputUpdates"].writeList(value.outputUpdates, memberWritingClosure: KinesisAnalyticsV2ClientTypes.OutputUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReferenceDataSourceUpdates"].writeList(value.referenceDataSourceUpdates, memberWritingClosure: KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ReferenceDataSourceUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReferenceId"].write(value.referenceId)
        try writer["ReferenceSchemaUpdate"].write(value.referenceSchemaUpdate, with: KinesisAnalyticsV2ClientTypes.SourceSchema.write(value:to:))
        try writer["S3ReferenceDataSourceUpdate"].write(value.s3ReferenceDataSourceUpdate, with: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate.write(value:to:))
        try writer["TableNameUpdate"].write(value.tableNameUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.S3ReferenceDataSourceUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARNUpdate"].write(value.bucketARNUpdate)
        try writer["FileKeyUpdate"].write(value.fileKeyUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.OutputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.OutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationSchemaUpdate"].write(value.destinationSchemaUpdate, with: KinesisAnalyticsV2ClientTypes.DestinationSchema.write(value:to:))
        try writer["KinesisFirehoseOutputUpdate"].write(value.kinesisFirehoseOutputUpdate, with: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate.write(value:to:))
        try writer["KinesisStreamsOutputUpdate"].write(value.kinesisStreamsOutputUpdate, with: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate.write(value:to:))
        try writer["LambdaOutputUpdate"].write(value.lambdaOutputUpdate, with: KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate.write(value:to:))
        try writer["NameUpdate"].write(value.nameUpdate)
        try writer["OutputId"].write(value.outputId)
    }
}

extension KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.LambdaOutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisFirehoseOutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisStreamsOutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.InputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputId"].write(value.inputId)
        try writer["InputParallelismUpdate"].write(value.inputParallelismUpdate, with: KinesisAnalyticsV2ClientTypes.InputParallelismUpdate.write(value:to:))
        try writer["InputProcessingConfigurationUpdate"].write(value.inputProcessingConfigurationUpdate, with: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate.write(value:to:))
        try writer["InputSchemaUpdate"].write(value.inputSchemaUpdate, with: KinesisAnalyticsV2ClientTypes.InputSchemaUpdate.write(value:to:))
        try writer["KinesisFirehoseInputUpdate"].write(value.kinesisFirehoseInputUpdate, with: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate.write(value:to:))
        try writer["KinesisStreamsInputUpdate"].write(value.kinesisStreamsInputUpdate, with: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate.write(value:to:))
        try writer["NamePrefixUpdate"].write(value.namePrefixUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.InputParallelismUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputParallelismUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CountUpdate"].write(value.countUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.InputSchemaUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputSchemaUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordColumnUpdates"].writeList(value.recordColumnUpdates, memberWritingClosure: KinesisAnalyticsV2ClientTypes.RecordColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordEncodingUpdate"].write(value.recordEncodingUpdate)
        try writer["RecordFormatUpdate"].write(value.recordFormatUpdate, with: KinesisAnalyticsV2ClientTypes.RecordFormat.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisFirehoseInputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.KinesisStreamsInputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputProcessingConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputLambdaProcessorUpdate"].write(value.inputLambdaProcessorUpdate, with: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.InputLambdaProcessorUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.RunConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationRestoreConfiguration"].write(value.applicationRestoreConfiguration, with: KinesisAnalyticsV2ClientTypes.ApplicationRestoreConfiguration.write(value:to:))
        try writer["FlinkRunConfiguration"].write(value.flinkRunConfiguration, with: KinesisAnalyticsV2ClientTypes.FlinkRunConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.CloudWatchLoggingOptionUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLoggingOptionId"].write(value.cloudWatchLoggingOptionId)
        try writer["LogStreamARNUpdate"].write(value.logStreamARNUpdate)
    }
}

extension KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate {

    static func write(value: KinesisAnalyticsV2ClientTypes.ApplicationMaintenanceConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationMaintenanceWindowStartTimeUpdate"].write(value.applicationMaintenanceWindowStartTimeUpdate)
    }
}

public enum KinesisAnalyticsV2ClientTypes {}
