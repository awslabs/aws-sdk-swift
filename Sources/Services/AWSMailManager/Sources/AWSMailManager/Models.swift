//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension MailManagerClientTypes {

    public enum AcceptAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptAction] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Occurs when a user is denied access to a specific resource or action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MailManagerClientTypes {

    public enum ActionFailurePolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `continue`
        case drop
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionFailurePolicy] {
            return [
                .continue,
                .drop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continue: return "CONTINUE"
            case .drop: return "DROP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The action to add a header to a message. When executed, this action will add the given header to the message.
    public struct AddHeaderAction {
        /// The name of the header to add to an email. The header must be prefixed with "X-". Headers are added regardless of whether the header name pre-existed in the email.
        /// This member is required.
        public var headerName: Swift.String?
        /// The value of the header to add to the email.
        /// This member is required.
        public var headerValue: Swift.String?

        public init(
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }

}

extension MailManagerClientTypes {
    /// An Add On instance represents a specific configuration of an Add On.
    public struct AddonInstance {
        /// The Amazon Resource Name (ARN) of the Add On instance.
        public var addonInstanceArn: Swift.String?
        /// The unique ID of the Add On instance.
        public var addonInstanceId: Swift.String?
        /// The name of the Add On for the instance.
        public var addonName: Swift.String?
        /// The subscription ID for the instance.
        public var addonSubscriptionId: Swift.String?
        /// The timestamp of when the Add On instance was created.
        public var createdTimestamp: Foundation.Date?

        public init(
            addonInstanceArn: Swift.String? = nil,
            addonInstanceId: Swift.String? = nil,
            addonName: Swift.String? = nil,
            addonSubscriptionId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil
        )
        {
            self.addonInstanceArn = addonInstanceArn
            self.addonInstanceId = addonInstanceId
            self.addonName = addonName
            self.addonSubscriptionId = addonSubscriptionId
            self.createdTimestamp = createdTimestamp
        }
    }

}

/// The request configuration has conflicts. For details, see the accompanying error message.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when a requested resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when an operation exceeds a predefined service quota or limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request validation has failed. For details, see the accompanying error message.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MailManagerClientTypes {
    /// A key-value pair (the value is optional), that you can define and assign to Amazon Web Services resources.
    public struct Tag {
        /// The key of the key-value tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension MailManagerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

public struct CreateAddonInstanceInput {
    /// The unique ID of a previously created subscription that an Add On instance is created for. You can only have one instance per subscription.
    /// This member is required.
    public var addonSubscriptionId: Swift.String?
    /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        addonSubscriptionId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.addonSubscriptionId = addonSubscriptionId
        self.clientToken = clientToken
        self.tags = tags
    }
}

public struct CreateAddonInstanceOutput {
    /// The unique ID of the Add On instance created by this API.
    /// This member is required.
    public var addonInstanceId: Swift.String?

    public init(
        addonInstanceId: Swift.String? = nil
    )
    {
        self.addonInstanceId = addonInstanceId
    }
}

public struct DeleteAddonInstanceInput {
    /// The Add On instance ID to delete.
    /// This member is required.
    public var addonInstanceId: Swift.String?

    public init(
        addonInstanceId: Swift.String? = nil
    )
    {
        self.addonInstanceId = addonInstanceId
    }
}

public struct DeleteAddonInstanceOutput {

    public init() { }
}

public struct GetAddonInstanceInput {
    /// The Add On instance ID to retrieve information for.
    /// This member is required.
    public var addonInstanceId: Swift.String?

    public init(
        addonInstanceId: Swift.String? = nil
    )
    {
        self.addonInstanceId = addonInstanceId
    }
}

public struct GetAddonInstanceOutput {
    /// The Amazon Resource Name (ARN) of the Add On instance.
    public var addonInstanceArn: Swift.String?
    /// The name of the Add On provider associated to the subscription of the instance.
    public var addonName: Swift.String?
    /// The subscription ID associated to the instance.
    public var addonSubscriptionId: Swift.String?
    /// The timestamp of when the Add On instance was created.
    public var createdTimestamp: Foundation.Date?

    public init(
        addonInstanceArn: Swift.String? = nil,
        addonName: Swift.String? = nil,
        addonSubscriptionId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil
    )
    {
        self.addonInstanceArn = addonInstanceArn
        self.addonName = addonName
        self.addonSubscriptionId = addonSubscriptionId
        self.createdTimestamp = createdTimestamp
    }
}

public struct ListAddonInstancesInput {
    /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    public var nextToken: Swift.String?
    /// The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

public struct ListAddonInstancesOutput {
    /// The list of ingress endpoints.
    public var addonInstances: [MailManagerClientTypes.AddonInstance]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        addonInstances: [MailManagerClientTypes.AddonInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addonInstances = addonInstances
        self.nextToken = nextToken
    }
}

extension MailManagerClientTypes {
    /// A subscription for an Add On representing the acceptance of its terms of use and additional pricing.
    public struct AddonSubscription {
        /// The name of the Add On.
        public var addonName: Swift.String?
        /// The Amazon Resource Name (ARN) of the Add On subscription.
        public var addonSubscriptionArn: Swift.String?
        /// The unique ID of the Add On subscription.
        public var addonSubscriptionId: Swift.String?
        /// The timestamp of when the Add On subscription was created.
        public var createdTimestamp: Foundation.Date?

        public init(
            addonName: Swift.String? = nil,
            addonSubscriptionArn: Swift.String? = nil,
            addonSubscriptionId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil
        )
        {
            self.addonName = addonName
            self.addonSubscriptionArn = addonSubscriptionArn
            self.addonSubscriptionId = addonSubscriptionId
            self.createdTimestamp = createdTimestamp
        }
    }

}

public struct CreateAddonSubscriptionInput {
    /// The name of the Add On to subscribe to. You can only have one subscription for each Add On name.
    /// This member is required.
    public var addonName: Swift.String?
    /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        addonName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.addonName = addonName
        self.clientToken = clientToken
        self.tags = tags
    }
}

public struct CreateAddonSubscriptionOutput {
    /// The unique ID of the Add On subscription created by this API.
    /// This member is required.
    public var addonSubscriptionId: Swift.String?

    public init(
        addonSubscriptionId: Swift.String? = nil
    )
    {
        self.addonSubscriptionId = addonSubscriptionId
    }
}

public struct DeleteAddonSubscriptionInput {
    /// The Add On subscription ID to delete.
    /// This member is required.
    public var addonSubscriptionId: Swift.String?

    public init(
        addonSubscriptionId: Swift.String? = nil
    )
    {
        self.addonSubscriptionId = addonSubscriptionId
    }
}

public struct DeleteAddonSubscriptionOutput {

    public init() { }
}

public struct GetAddonSubscriptionInput {
    /// The Add On subscription ID to retrieve information for.
    /// This member is required.
    public var addonSubscriptionId: Swift.String?

    public init(
        addonSubscriptionId: Swift.String? = nil
    )
    {
        self.addonSubscriptionId = addonSubscriptionId
    }
}

public struct GetAddonSubscriptionOutput {
    /// The name of the Add On for the subscription.
    public var addonName: Swift.String?
    /// Amazon Resource Name (ARN) for the subscription.
    public var addonSubscriptionArn: Swift.String?
    /// The timestamp of when the Add On subscription was created.
    public var createdTimestamp: Foundation.Date?

    public init(
        addonName: Swift.String? = nil,
        addonSubscriptionArn: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil
    )
    {
        self.addonName = addonName
        self.addonSubscriptionArn = addonSubscriptionArn
        self.createdTimestamp = createdTimestamp
    }
}

public struct ListAddonSubscriptionsInput {
    /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    public var nextToken: Swift.String?
    /// The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

public struct ListAddonSubscriptionsOutput {
    /// The list of ingress endpoints.
    public var addonSubscriptions: [MailManagerClientTypes.AddonSubscription]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        addonSubscriptions: [MailManagerClientTypes.AddonSubscription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addonSubscriptions = addonSubscriptions
        self.nextToken = nextToken
    }
}

extension MailManagerClientTypes {
    /// The result of an analysis can be used in conditions to trigger actions. Analyses can inspect the email content and report a certain aspect of the email.
    public struct Analysis {
        /// The Amazon Resource Name (ARN) of an Add On.
        /// This member is required.
        public var analyzer: Swift.String?
        /// The returned value from an Add On.
        /// This member is required.
        public var resultField: Swift.String?

        public init(
            analyzer: Swift.String? = nil,
            resultField: Swift.String? = nil
        )
        {
            self.analyzer = analyzer
            self.resultField = resultField
        }
    }

}

extension MailManagerClientTypes {

    public enum ArchiveState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case pendingDeletion
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveState] {
            return [
                .active,
                .pendingDeletion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pendingDeletion: return "PENDING_DELETION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// An archive resource for storing and retaining emails.
    public struct Archive {
        /// The unique identifier of the archive.
        /// This member is required.
        public var archiveId: Swift.String?
        /// The unique name assigned to the archive.
        public var archiveName: Swift.String?
        /// The current state of the archive:
        ///
        /// * ACTIVE – The archive is ready and available for use.
        ///
        /// * PENDING_DELETION – The archive has been marked for deletion and will be permanently deleted in 30 days. No further modifications can be made in this state.
        public var archiveState: MailManagerClientTypes.ArchiveState?
        /// The timestamp of when the archive was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?

        public init(
            archiveId: Swift.String? = nil,
            archiveName: Swift.String? = nil,
            archiveState: MailManagerClientTypes.ArchiveState? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil
        )
        {
            self.archiveId = archiveId
            self.archiveName = archiveName
            self.archiveState = archiveState
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
        }
    }

}

extension MailManagerClientTypes {
    /// The action to archive the email by delivering the email to an Amazon SES archive.
    public struct ArchiveAction {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified archive has been deleted.
        public var actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy?
        /// The identifier of the archive to send the email to.
        /// This member is required.
        public var targetArchive: Swift.String?

        public init(
            actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy? = nil,
            targetArchive: Swift.String? = nil
        )
        {
            self.actionFailurePolicy = actionFailurePolicy
            self.targetArchive = targetArchive
        }
    }

}

extension MailManagerClientTypes {

    public enum ArchiveBooleanEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hasAttachments
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveBooleanEmailAttribute] {
            return [
                .hasAttachments
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hasAttachments: return "HAS_ATTACHMENTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The attribute to evaluate in a boolean expression.
    public enum ArchiveBooleanToEvaluate {
        /// The name of the email attribute to evaluate.
        case attribute(MailManagerClientTypes.ArchiveBooleanEmailAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum ArchiveBooleanOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case isFalse
        case isTrue
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveBooleanOperator] {
            return [
                .isFalse,
                .isTrue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .isFalse: return "IS_FALSE"
            case .isTrue: return "IS_TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A boolean expression to evaluate email attribute values.
    public struct ArchiveBooleanExpression {
        /// The email attribute value to evaluate.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.ArchiveBooleanToEvaluate?
        /// The boolean operator to use for evaluation.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.ArchiveBooleanOperator?

        public init(
            evaluate: MailManagerClientTypes.ArchiveBooleanToEvaluate? = nil,
            `operator`: MailManagerClientTypes.ArchiveBooleanOperator? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
        }
    }

}

extension MailManagerClientTypes {

    public enum ArchiveStringEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cc
        case from
        case subject
        case to
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveStringEmailAttribute] {
            return [
                .cc,
                .from,
                .subject,
                .to
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cc: return "CC"
            case .from: return "FROM"
            case .subject: return "SUBJECT"
            case .to: return "TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// Specifies the email attribute to evaluate in a string expression.
    public enum ArchiveStringToEvaluate {
        /// The name of the email attribute to evaluate.
        case attribute(MailManagerClientTypes.ArchiveStringEmailAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum ArchiveStringOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveStringOperator] {
            return [
                .contains
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A string expression to evaluate an email attribute value against one or more string values.
    public struct ArchiveStringExpression {
        /// The attribute of the email to evaluate.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.ArchiveStringToEvaluate?
        /// The operator to use when evaluating the string values.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.ArchiveStringOperator?
        /// The list of string values to evaluate the email attribute against.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            evaluate: MailManagerClientTypes.ArchiveStringToEvaluate? = nil,
            `operator`: MailManagerClientTypes.ArchiveStringOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {
    /// A filter condition used to include or exclude emails when exporting from or searching an archive.
    public enum ArchiveFilterCondition {
        /// A string expression to evaluate against email attributes.
        case stringexpression(MailManagerClientTypes.ArchiveStringExpression)
        /// A boolean expression to evaluate against email attributes.
        case booleanexpression(MailManagerClientTypes.ArchiveBooleanExpression)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {
    /// A set of filter conditions to include and/or exclude emails.
    public struct ArchiveFilters {
        /// The filter conditions for emails to include.
        public var include: [MailManagerClientTypes.ArchiveFilterCondition]?
        /// The filter conditions for emails to exclude.
        public var unless: [MailManagerClientTypes.ArchiveFilterCondition]?

        public init(
            include: [MailManagerClientTypes.ArchiveFilterCondition]? = nil,
            unless: [MailManagerClientTypes.ArchiveFilterCondition]? = nil
        )
        {
            self.include = include
            self.unless = unless
        }
    }

}

extension MailManagerClientTypes {

    public enum RetentionPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eighteenMonths
        case eightYears
        case fiveYears
        case fourYears
        case nineMonths
        case nineYears
        case oneYear
        case permanent
        case sevenYears
        case sixMonths
        case sixYears
        case tenYears
        case thirtyMonths
        case threeMonths
        case threeYears
        case twoYears
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionPeriod] {
            return [
                .eighteenMonths,
                .eightYears,
                .fiveYears,
                .fourYears,
                .nineMonths,
                .nineYears,
                .oneYear,
                .permanent,
                .sevenYears,
                .sixMonths,
                .sixYears,
                .tenYears,
                .thirtyMonths,
                .threeMonths,
                .threeYears,
                .twoYears
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eighteenMonths: return "EIGHTEEN_MONTHS"
            case .eightYears: return "EIGHT_YEARS"
            case .fiveYears: return "FIVE_YEARS"
            case .fourYears: return "FOUR_YEARS"
            case .nineMonths: return "NINE_MONTHS"
            case .nineYears: return "NINE_YEARS"
            case .oneYear: return "ONE_YEAR"
            case .permanent: return "PERMANENT"
            case .sevenYears: return "SEVEN_YEARS"
            case .sixMonths: return "SIX_MONTHS"
            case .sixYears: return "SIX_YEARS"
            case .tenYears: return "TEN_YEARS"
            case .thirtyMonths: return "THIRTY_MONTHS"
            case .threeMonths: return "THREE_MONTHS"
            case .threeYears: return "THREE_YEARS"
            case .twoYears: return "TWO_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The retention policy for an email archive that specifies how long emails are kept before being automatically deleted.
    public enum ArchiveRetention {
        /// The enum value sets the period for retaining emails in an archive.
        case retentionperiod(MailManagerClientTypes.RetentionPeriod)
        case sdkUnknown(Swift.String)
    }

}

/// Occurs when a service's request rate limit is exceeded, resulting in throttling of further requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request to create a new email archive.
public struct CreateArchiveInput {
    /// A unique name for the new archive.
    /// This member is required.
    public var archiveName: Swift.String?
    /// A unique token Amazon SES uses to recognize retries of this request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key for encrypting emails in the archive.
    public var kmsKeyArn: Swift.String?
    /// The period for retaining emails in the archive before automatic deletion.
    public var retention: MailManagerClientTypes.ArchiveRetention?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        archiveName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        retention: MailManagerClientTypes.ArchiveRetention? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.archiveName = archiveName
        self.clientToken = clientToken
        self.kmsKeyArn = kmsKeyArn
        self.retention = retention
        self.tags = tags
    }
}

/// The response from creating a new email archive.
public struct CreateArchiveOutput {
    /// The unique identifier for the newly created archive.
    /// This member is required.
    public var archiveId: Swift.String?

    public init(
        archiveId: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
    }
}

/// The request to initiate deletion of an email archive.
public struct DeleteArchiveInput {
    /// The identifier of the archive to delete.
    /// This member is required.
    public var archiveId: Swift.String?

    public init(
        archiveId: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
    }
}

/// The response indicating if the archive deletion was successfully initiated. On success, returns an HTTP 200 status code. On failure, returns an error message.
public struct DeleteArchiveOutput {

    public init() { }
}

/// The request to retrieve details of an email archive.
public struct GetArchiveInput {
    /// The identifier of the archive to retrieve.
    /// This member is required.
    public var archiveId: Swift.String?

    public init(
        archiveId: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
    }
}

/// The response containing details of the requested archive.
public struct GetArchiveOutput {
    /// The Amazon Resource Name (ARN) of the archive.
    /// This member is required.
    public var archiveArn: Swift.String?
    /// The unique identifier of the archive.
    /// This member is required.
    public var archiveId: Swift.String?
    /// The unique name assigned to the archive.
    /// This member is required.
    public var archiveName: Swift.String?
    /// The current state of the archive:
    ///
    /// * ACTIVE – The archive is ready and available for use.
    ///
    /// * PENDING_DELETION – The archive has been marked for deletion and will be permanently deleted in 30 days. No further modifications can be made in this state.
    /// This member is required.
    public var archiveState: MailManagerClientTypes.ArchiveState?
    /// The timestamp of when the archive was created.
    public var createdTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the archive.
    public var kmsKeyArn: Swift.String?
    /// The timestamp of when the archive was modified.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// The retention period for emails in this archive.
    /// This member is required.
    public var retention: MailManagerClientTypes.ArchiveRetention?

    public init(
        archiveArn: Swift.String? = nil,
        archiveId: Swift.String? = nil,
        archiveName: Swift.String? = nil,
        archiveState: MailManagerClientTypes.ArchiveState? = nil,
        createdTimestamp: Foundation.Date? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastUpdatedTimestamp: Foundation.Date? = nil,
        retention: MailManagerClientTypes.ArchiveRetention? = nil
    )
    {
        self.archiveArn = archiveArn
        self.archiveId = archiveId
        self.archiveName = archiveName
        self.archiveState = archiveState
        self.createdTimestamp = createdTimestamp
        self.kmsKeyArn = kmsKeyArn
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.retention = retention
    }
}

/// The request to list email archives in your account.
public struct ListArchivesInput {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The maximum number of archives that are returned per call. You can use NextToken to obtain further pages of archives.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

/// The response containing a list of your email archives.
public struct ListArchivesOutput {
    /// The list of archive details.
    /// This member is required.
    public var archives: [MailManagerClientTypes.Archive]?
    /// If present, use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        archives: [MailManagerClientTypes.Archive]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.archives = archives
        self.nextToken = nextToken
    }
}

/// The request to update properties of an existing email archive.
public struct UpdateArchiveInput {
    /// The identifier of the archive to update.
    /// This member is required.
    public var archiveId: Swift.String?
    /// A new, unique name for the archive.
    public var archiveName: Swift.String?
    /// A new retention period for emails in the archive.
    public var retention: MailManagerClientTypes.ArchiveRetention?

    public init(
        archiveId: Swift.String? = nil,
        archiveName: Swift.String? = nil,
        retention: MailManagerClientTypes.ArchiveRetention? = nil
    )
    {
        self.archiveId = archiveId
        self.archiveName = archiveName
        self.retention = retention
    }
}

/// The response indicating if the archive update succeeded or failed. On success, returns an HTTP 200 status code. On failure, returns an error message.
public struct UpdateArchiveOutput {

    public init() { }
}

extension MailManagerClientTypes {
    /// The configuration of the ingress endpoint resource.
    public enum IngressPointConfiguration {
        /// The password of the ingress endpoint resource.
        case smtppassword(Swift.String)
        /// The SecretsManager::Secret ARN of the ingress endpoint resource.
        case secretarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum IngressPointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auth
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressPointType] {
            return [
                .auth,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auth: return "AUTH"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIngressPointInput {
    /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    public var clientToken: Swift.String?
    /// If you choose an Authenticated ingress endpoint, you must configure either an SMTP password or a secret ARN.
    public var ingressPointConfiguration: MailManagerClientTypes.IngressPointConfiguration?
    /// A user friendly name for an ingress endpoint resource.
    /// This member is required.
    public var ingressPointName: Swift.String?
    /// The identifier of an existing rule set that you attach to an ingress endpoint resource.
    /// This member is required.
    public var ruleSetId: Swift.String?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?
    /// The identifier of an existing traffic policy that you attach to an ingress endpoint resource.
    /// This member is required.
    public var trafficPolicyId: Swift.String?
    /// The type of the ingress endpoint to create.
    /// This member is required.
    public var type: MailManagerClientTypes.IngressPointType?

    public init(
        clientToken: Swift.String? = nil,
        ingressPointConfiguration: MailManagerClientTypes.IngressPointConfiguration? = nil,
        ingressPointName: Swift.String? = nil,
        ruleSetId: Swift.String? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil,
        trafficPolicyId: Swift.String? = nil,
        type: MailManagerClientTypes.IngressPointType? = nil
    )
    {
        self.clientToken = clientToken
        self.ingressPointConfiguration = ingressPointConfiguration
        self.ingressPointName = ingressPointName
        self.ruleSetId = ruleSetId
        self.tags = tags
        self.trafficPolicyId = trafficPolicyId
        self.type = type
    }
}

public struct CreateIngressPointOutput {
    /// The unique identifier for a previously created ingress endpoint.
    /// This member is required.
    public var ingressPointId: Swift.String?

    public init(
        ingressPointId: Swift.String? = nil
    )
    {
        self.ingressPointId = ingressPointId
    }
}

extension MailManagerClientTypes {
    /// Explicitly indicate that the relay destination server does not require SMTP credential authentication.
    public struct NoAuthentication {

        public init() { }
    }

}

extension MailManagerClientTypes {
    /// Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored, or specify an empty NoAuthentication structure if the relay destination server does not require SMTP credential authentication.
    public enum RelayAuthentication {
        /// The ARN of the secret created in secrets manager where the relay server's SMTP credentials are stored.
        case secretarn(Swift.String)
        /// Keep an empty structure if the relay destination server does not require SMTP credential authentication.
        case noauthentication(MailManagerClientTypes.NoAuthentication)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateRelayInput {
    /// Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored.
    /// This member is required.
    public var authentication: MailManagerClientTypes.RelayAuthentication?
    /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    public var clientToken: Swift.String?
    /// The unique name of the relay resource.
    /// This member is required.
    public var relayName: Swift.String?
    /// The destination relay server address.
    /// This member is required.
    public var serverName: Swift.String?
    /// The destination relay server port.
    /// This member is required.
    public var serverPort: Swift.Int?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        authentication: MailManagerClientTypes.RelayAuthentication? = nil,
        clientToken: Swift.String? = nil,
        relayName: Swift.String? = nil,
        serverName: Swift.String? = nil,
        serverPort: Swift.Int? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.authentication = authentication
        self.clientToken = clientToken
        self.relayName = relayName
        self.serverName = serverName
        self.serverPort = serverPort
        self.tags = tags
    }
}

public struct CreateRelayOutput {
    /// A unique identifier of the created relay resource.
    /// This member is required.
    public var relayId: Swift.String?

    public init(
        relayId: Swift.String? = nil
    )
    {
        self.relayId = relayId
    }
}

extension MailManagerClientTypes {
    /// This action to delivers an email to a mailbox.
    public struct DeliverToMailboxAction {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the mailbox ARN is no longer valid.
        public var actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy?
        /// The Amazon Resource Name (ARN) of a WorkMail organization to deliver the email to.
        /// This member is required.
        public var mailboxArn: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role to use to execute this action. The role must have access to the workmail:DeliverToMailbox API.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy? = nil,
            mailboxArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.actionFailurePolicy = actionFailurePolicy
            self.mailboxArn = mailboxArn
            self.roleArn = roleArn
        }
    }

}

extension MailManagerClientTypes {
    /// This action causes processing to stop and the email to be dropped. If the action applies only to certain recipients, only those recipients are dropped, and processing continues for other recipients.
    public struct DropAction {

        public init() { }
    }

}

extension MailManagerClientTypes {

    public enum MailFrom: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case preserve
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [MailFrom] {
            return [
                .preserve,
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .preserve: return "PRESERVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The action relays the email via SMTP to another specific SMTP server.
    public struct RelayAction {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified relay has been deleted.
        public var actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy?
        /// This action specifies whether to preserve or replace original mail from address while relaying received emails to a destination server.
        public var mailFrom: MailManagerClientTypes.MailFrom?
        /// The identifier of the relay resource to be used when relaying an email.
        /// This member is required.
        public var relay: Swift.String?

        public init(
            actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy? = nil,
            mailFrom: MailManagerClientTypes.MailFrom? = nil,
            relay: Swift.String? = nil
        )
        {
            self.actionFailurePolicy = actionFailurePolicy
            self.mailFrom = mailFrom
            self.relay = relay
        }
    }

}

extension MailManagerClientTypes {
    /// This action replaces the email envelope recipients with the given list of recipients. If the condition of this action applies only to a subset of recipients, only those recipients are replaced with the recipients specified in the action. The message contents and headers are unaffected by this action, only the envelope recipients are updated.
    public struct ReplaceRecipientAction {
        /// This action specifies the replacement recipient email addresses to insert.
        public var replaceWith: [Swift.String]?

        public init(
            replaceWith: [Swift.String]? = nil
        )
        {
            self.replaceWith = replaceWith
        }
    }

}

extension MailManagerClientTypes.ReplaceRecipientAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplaceRecipientAction(replaceWith: \"CONTENT_REDACTED\")"}
}

extension MailManagerClientTypes {
    /// Sends the email to the internet using the ses:SendRawEmail API.
    public struct SendAction {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the caller does not have the permissions to call the sendRawEmail API.
        public var actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy?
        /// The Amazon Resource Name (ARN) of the role to use for this action. This role must have access to the ses:SendRawEmail API.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.actionFailurePolicy = actionFailurePolicy
            self.roleArn = roleArn
        }
    }

}

extension MailManagerClientTypes {
    /// Writes the MIME content of the email to an S3 bucket.
    public struct S3Action {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified the bucket has been deleted.
        public var actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy?
        /// The Amazon Resource Name (ARN) of the IAM Role to use while writing to S3. This role must have access to the s3:PutObject, kms:Encrypt, and kms:GenerateDataKey APIs for the given bucket.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The bucket name of the S3 bucket to write to.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The S3 prefix to use for the write to the s3 bucket.
        public var s3Prefix: Swift.String?
        /// The KMS Key ID to use to encrypt the message in S3.
        public var s3SseKmsKeyId: Swift.String?

        public init(
            actionFailurePolicy: MailManagerClientTypes.ActionFailurePolicy? = nil,
            roleArn: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil,
            s3SseKmsKeyId: Swift.String? = nil
        )
        {
            self.actionFailurePolicy = actionFailurePolicy
            self.roleArn = roleArn
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.s3SseKmsKeyId = s3SseKmsKeyId
        }
    }

}

extension MailManagerClientTypes {
    /// The action for a rule to take. Only one of the contained actions can be set.
    public enum RuleAction {
        /// This action terminates the evaluation of rules in the rule set.
        case drop(MailManagerClientTypes.DropAction)
        /// This action relays the email to another SMTP server.
        case relay(MailManagerClientTypes.RelayAction)
        /// This action archives the email. This can be used to deliver an email to an archive.
        case archive(MailManagerClientTypes.ArchiveAction)
        /// This action writes the MIME content of the email to an S3 bucket.
        case writetos3(MailManagerClientTypes.S3Action)
        /// This action sends the email to the internet.
        case send(MailManagerClientTypes.SendAction)
        /// This action adds a header. This can be used to add arbitrary email headers.
        case addheader(MailManagerClientTypes.AddHeaderAction)
        /// The action replaces certain or all recipients with a different set of recipients.
        case replacerecipient(MailManagerClientTypes.ReplaceRecipientAction)
        /// This action delivers an email to a WorkMail mailbox.
        case delivertomailbox(MailManagerClientTypes.DeliverToMailboxAction)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum RuleBooleanEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case readReceiptRequested
        case tls
        case tlsWrapped
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleBooleanEmailAttribute] {
            return [
                .readReceiptRequested,
                .tls,
                .tlsWrapped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .readReceiptRequested: return "READ_RECEIPT_REQUESTED"
            case .tls: return "TLS"
            case .tlsWrapped: return "TLS_WRAPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The union type representing the allowed types of operands for a boolean condition.
    public enum RuleBooleanToEvaluate {
        /// The boolean type representing the allowed attribute types for an email.
        case attribute(MailManagerClientTypes.RuleBooleanEmailAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum RuleBooleanOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case isFalse
        case isTrue
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleBooleanOperator] {
            return [
                .isFalse,
                .isTrue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .isFalse: return "IS_FALSE"
            case .isTrue: return "IS_TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A boolean expression to be used in a rule condition.
    public struct RuleBooleanExpression {
        /// The operand on which to perform a boolean condition operation.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.RuleBooleanToEvaluate?
        /// The matching operator for a boolean condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.RuleBooleanOperator?

        public init(
            evaluate: MailManagerClientTypes.RuleBooleanToEvaluate? = nil,
            `operator`: MailManagerClientTypes.RuleBooleanOperator? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
        }
    }

}

extension MailManagerClientTypes {

    public enum RuleDmarcOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleDmarcOperator] {
            return [
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {

    public enum RuleDmarcPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case quarantine
        case reject
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleDmarcPolicy] {
            return [
                .none,
                .quarantine,
                .reject
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .quarantine: return "QUARANTINE"
            case .reject: return "REJECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A DMARC policy expression. The condition matches if the given DMARC policy matches that of the incoming email.
    public struct RuleDmarcExpression {
        /// The operator to apply to the DMARC policy of the incoming email.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.RuleDmarcOperator?
        /// The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.
        /// This member is required.
        public var values: [MailManagerClientTypes.RuleDmarcPolicy]?

        public init(
            `operator`: MailManagerClientTypes.RuleDmarcOperator? = nil,
            values: [MailManagerClientTypes.RuleDmarcPolicy]? = nil
        )
        {
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {

    public enum RuleIpEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sourceIp
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleIpEmailAttribute] {
            return [
                .sourceIp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sourceIp: return "SOURCE_IP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The IP address to evaluate for this condition.
    public enum RuleIpToEvaluate {
        /// The attribute of the email to evaluate.
        case attribute(MailManagerClientTypes.RuleIpEmailAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum RuleIpOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cidrMatches
        case notCidrMatches
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleIpOperator] {
            return [
                .cidrMatches,
                .notCidrMatches
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cidrMatches: return "CIDR_MATCHES"
            case .notCidrMatches: return "NOT_CIDR_MATCHES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// An IP address expression matching certain IP addresses within a given range of IP addresses.
    public struct RuleIpExpression {
        /// The IP address to evaluate in this condition.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.RuleIpToEvaluate?
        /// The operator to evaluate the IP address.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.RuleIpOperator?
        /// The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            evaluate: MailManagerClientTypes.RuleIpToEvaluate? = nil,
            `operator`: MailManagerClientTypes.RuleIpOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {

    public enum RuleNumberEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case messageSize
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleNumberEmailAttribute] {
            return [
                .messageSize
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .messageSize: return "MESSAGE_SIZE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The number to evaluate in a numeric condition expression.
    public enum RuleNumberToEvaluate {
        /// An email attribute that is used as the number to evaluate.
        case attribute(MailManagerClientTypes.RuleNumberEmailAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum RuleNumberOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case greaterThan
        case greaterThanOrEqual
        case lessThan
        case lessThanOrEqual
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleNumberOperator] {
            return [
                .equals,
                .greaterThan,
                .greaterThanOrEqual,
                .lessThan,
                .lessThanOrEqual,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A number expression to match numeric conditions with integers from the incoming email.
    public struct RuleNumberExpression {
        /// The number to evaluate in a numeric condition expression.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.RuleNumberToEvaluate?
        /// The operator for a numeric condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.RuleNumberOperator?
        /// The value to evaluate in a numeric condition expression.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            evaluate: MailManagerClientTypes.RuleNumberToEvaluate? = nil,
            `operator`: MailManagerClientTypes.RuleNumberOperator? = nil,
            value: Swift.Double? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension MailManagerClientTypes {

    public enum RuleStringEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cc
        case from
        case helo
        case mailFrom
        case recipient
        case sender
        case subject
        case to
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStringEmailAttribute] {
            return [
                .cc,
                .from,
                .helo,
                .mailFrom,
                .recipient,
                .sender,
                .subject,
                .to
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cc: return "CC"
            case .from: return "FROM"
            case .helo: return "HELO"
            case .mailFrom: return "MAIL_FROM"
            case .recipient: return "RECIPIENT"
            case .sender: return "SENDER"
            case .subject: return "SUBJECT"
            case .to: return "TO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The string to evaluate in a string condition expression.
    public enum RuleStringToEvaluate {
        /// The email attribute to evaluate in a string condition expression.
        case attribute(MailManagerClientTypes.RuleStringEmailAttribute)
        /// The email MIME X-Header attribute to evaluate in a string condition expression.
        case mimeheaderattribute(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum RuleStringOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case endsWith
        case equals
        case notEquals
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStringOperator] {
            return [
                .contains,
                .endsWith,
                .equals,
                .notEquals,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A string expression is evaluated against strings or substrings of the email.
    public struct RuleStringExpression {
        /// The string to evaluate in a string condition expression.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.RuleStringToEvaluate?
        /// The matching operator for a string condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.RuleStringOperator?
        /// The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            evaluate: MailManagerClientTypes.RuleStringToEvaluate? = nil,
            `operator`: MailManagerClientTypes.RuleStringOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {

    public enum RuleVerdictAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dkim
        case spf
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleVerdictAttribute] {
            return [
                .dkim,
                .spf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dkim: return "DKIM"
            case .spf: return "SPF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The verdict to evaluate in a verdict condition expression.
    public enum RuleVerdictToEvaluate {
        /// The email verdict attribute to evaluate in a string verdict expression.
        case attribute(MailManagerClientTypes.RuleVerdictAttribute)
        /// The Add On ARN and its returned value to evaluate in a verdict condition expression.
        case analysis(MailManagerClientTypes.Analysis)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum RuleVerdictOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleVerdictOperator] {
            return [
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {

    public enum RuleVerdict: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case gray
        case pass
        case processingFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleVerdict] {
            return [
                .fail,
                .gray,
                .pass,
                .processingFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .gray: return "GRAY"
            case .pass: return "PASS"
            case .processingFailed: return "PROCESSING_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// A verdict expression is evaluated against verdicts of the email.
    public struct RuleVerdictExpression {
        /// The verdict to evaluate in a verdict condition expression.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.RuleVerdictToEvaluate?
        /// The matching operator for a verdict condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.RuleVerdictOperator?
        /// The values to match with the email's verdict using the given operator. For the EQUALS operator, if multiple values are given, the condition is deemed to match if any of the given verdicts match that of the email. For the NOT_EQUALS operator, if multiple values are given, the condition is deemed to match of none of the given verdicts match the verdict of the email.
        /// This member is required.
        public var values: [MailManagerClientTypes.RuleVerdict]?

        public init(
            evaluate: MailManagerClientTypes.RuleVerdictToEvaluate? = nil,
            `operator`: MailManagerClientTypes.RuleVerdictOperator? = nil,
            values: [MailManagerClientTypes.RuleVerdict]? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {
    /// The conditional expression used to evaluate an email for determining if a rule action should be taken.
    public enum RuleCondition {
        /// The condition applies to a boolean expression passed in this field.
        case booleanexpression(MailManagerClientTypes.RuleBooleanExpression)
        /// The condition applies to a string expression passed in this field.
        case stringexpression(MailManagerClientTypes.RuleStringExpression)
        /// The condition applies to a number expression passed in this field.
        case numberexpression(MailManagerClientTypes.RuleNumberExpression)
        /// The condition applies to an IP address expression passed in this field.
        case ipexpression(MailManagerClientTypes.RuleIpExpression)
        /// The condition applies to a verdict expression passed in this field.
        case verdictexpression(MailManagerClientTypes.RuleVerdictExpression)
        /// The condition applies to a DMARC policy expression passed in this field.
        case dmarcexpression(MailManagerClientTypes.RuleDmarcExpression)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {
    /// A rule contains conditions, "unless conditions" and actions. For each envelope recipient of an email, if all conditions match and none of the "unless conditions" match, then all of the actions are executed sequentially. If no conditions are provided, the rule always applies and the actions are implicitly executed. If only "unless conditions" are provided, the rule applies if the email does not match the evaluation of the "unless conditions".
    public struct Rule {
        /// The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.
        /// This member is required.
        public var actions: [MailManagerClientTypes.RuleAction]?
        /// The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"
        public var conditions: [MailManagerClientTypes.RuleCondition]?
        /// The user-friendly name of the rule.
        public var name: Swift.String?
        /// The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.
        public var unless: [MailManagerClientTypes.RuleCondition]?

        public init(
            actions: [MailManagerClientTypes.RuleAction]? = nil,
            conditions: [MailManagerClientTypes.RuleCondition]? = nil,
            name: Swift.String? = nil,
            unless: [MailManagerClientTypes.RuleCondition]? = nil
        )
        {
            self.actions = actions
            self.conditions = conditions
            self.name = name
            self.unless = unless
        }
    }

}

public struct CreateRuleSetInput {
    /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    public var clientToken: Swift.String?
    /// A user-friendly name for the rule set.
    /// This member is required.
    public var ruleSetName: Swift.String?
    /// Conditional rules that are evaluated for determining actions on email.
    /// This member is required.
    public var rules: [MailManagerClientTypes.Rule]?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        ruleSetName: Swift.String? = nil,
        rules: [MailManagerClientTypes.Rule]? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.ruleSetName = ruleSetName
        self.rules = rules
        self.tags = tags
    }
}

public struct CreateRuleSetOutput {
    /// The identifier of the created rule set.
    /// This member is required.
    public var ruleSetId: Swift.String?

    public init(
        ruleSetId: Swift.String? = nil
    )
    {
        self.ruleSetId = ruleSetId
    }
}

extension MailManagerClientTypes {
    /// The Add On ARN and its returned value that is evaluated in a policy statement's conditional expression to either deny or block the incoming email.
    public struct IngressAnalysis {
        /// The Amazon Resource Name (ARN) of an Add On.
        /// This member is required.
        public var analyzer: Swift.String?
        /// The returned value from an Add On.
        /// This member is required.
        public var resultField: Swift.String?

        public init(
            analyzer: Swift.String? = nil,
            resultField: Swift.String? = nil
        )
        {
            self.analyzer = analyzer
            self.resultField = resultField
        }
    }

}

extension MailManagerClientTypes {
    /// The union type representing the allowed types of operands for a boolean condition.
    public enum IngressBooleanToEvaluate {
        /// The structure type for a boolean condition stating the Add On ARN and its returned value.
        case analysis(MailManagerClientTypes.IngressAnalysis)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum IngressBooleanOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case isFalse
        case isTrue
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressBooleanOperator] {
            return [
                .isFalse,
                .isTrue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .isFalse: return "IS_FALSE"
            case .isTrue: return "IS_TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The structure for a boolean condition matching on the incoming mail.
    public struct IngressBooleanExpression {
        /// The operand on which to perform a boolean condition operation.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.IngressBooleanToEvaluate?
        /// The matching operator for a boolean condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.IngressBooleanOperator?

        public init(
            evaluate: MailManagerClientTypes.IngressBooleanToEvaluate? = nil,
            `operator`: MailManagerClientTypes.IngressBooleanOperator? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
        }
    }

}

extension MailManagerClientTypes {

    public enum IngressIpv4Attribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case senderIp
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressIpv4Attribute] {
            return [
                .senderIp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .senderIp: return "SENDER_IP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The structure for an IP based condition matching on the incoming mail.
    public enum IngressIpToEvaluate {
        /// An enum type representing the allowed attribute types for an IP condition.
        case attribute(MailManagerClientTypes.IngressIpv4Attribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum IngressIpOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cidrMatches
        case notCidrMatches
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressIpOperator] {
            return [
                .cidrMatches,
                .notCidrMatches
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cidrMatches: return "CIDR_MATCHES"
            case .notCidrMatches: return "NOT_CIDR_MATCHES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The union type representing the allowed types for the left hand side of an IP condition.
    public struct IngressIpv4Expression {
        /// The left hand side argument of an IP condition expression.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.IngressIpToEvaluate?
        /// The matching operator for an IP condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.IngressIpOperator?
        /// The right hand side argument of an IP condition expression.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            evaluate: MailManagerClientTypes.IngressIpToEvaluate? = nil,
            `operator`: MailManagerClientTypes.IngressIpOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {

    public enum IngressStringEmailAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case recipient
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressStringEmailAttribute] {
            return [
                .recipient
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .recipient: return "RECIPIENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The union type representing the allowed types for the left hand side of a string condition.
    public enum IngressStringToEvaluate {
        /// The enum type representing the allowed attribute types for a string condition.
        case attribute(MailManagerClientTypes.IngressStringEmailAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum IngressStringOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case endsWith
        case equals
        case notEquals
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressStringOperator] {
            return [
                .contains,
                .endsWith,
                .equals,
                .notEquals,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The structure for a string based condition matching on the incoming mail.
    public struct IngressStringExpression {
        /// The left hand side argument of a string condition expression.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.IngressStringToEvaluate?
        /// The matching operator for a string condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.IngressStringOperator?
        /// The right hand side argument of a string condition expression.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            evaluate: MailManagerClientTypes.IngressStringToEvaluate? = nil,
            `operator`: MailManagerClientTypes.IngressStringOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension MailManagerClientTypes {

    public enum IngressTlsAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tlsProtocol
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressTlsAttribute] {
            return [
                .tlsProtocol
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tlsProtocol: return "TLS_PROTOCOL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The union type representing the allowed types for the left hand side of a TLS condition.
    public enum IngressTlsProtocolToEvaluate {
        /// The enum type representing the allowed attribute types for the TLS condition.
        case attribute(MailManagerClientTypes.IngressTlsAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum IngressTlsProtocolOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `is`
        case minimumTlsVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressTlsProtocolOperator] {
            return [
                .is,
                .minimumTlsVersion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .is: return "IS"
            case .minimumTlsVersion: return "MINIMUM_TLS_VERSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {

    public enum IngressTlsProtocolAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tls12
        case tls13
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressTlsProtocolAttribute] {
            return [
                .tls12,
                .tls13
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tls12: return "TLS1_2"
            case .tls13: return "TLS1_3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The structure for a TLS related condition matching on the incoming mail.
    public struct IngressTlsProtocolExpression {
        /// The left hand side argument of a TLS condition expression.
        /// This member is required.
        public var evaluate: MailManagerClientTypes.IngressTlsProtocolToEvaluate?
        /// The matching operator for a TLS condition expression.
        /// This member is required.
        public var `operator`: MailManagerClientTypes.IngressTlsProtocolOperator?
        /// The right hand side argument of a TLS condition expression.
        /// This member is required.
        public var value: MailManagerClientTypes.IngressTlsProtocolAttribute?

        public init(
            evaluate: MailManagerClientTypes.IngressTlsProtocolToEvaluate? = nil,
            `operator`: MailManagerClientTypes.IngressTlsProtocolOperator? = nil,
            value: MailManagerClientTypes.IngressTlsProtocolAttribute? = nil
        )
        {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension MailManagerClientTypes {
    /// The email traffic filtering conditions which are contained in a traffic policy resource.
    public enum PolicyCondition {
        /// This represents a string based condition matching on the incoming mail. It performs the string operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case stringexpression(MailManagerClientTypes.IngressStringExpression)
        /// This represents an IP based condition matching on the incoming mail. It performs the operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case ipexpression(MailManagerClientTypes.IngressIpv4Expression)
        /// This represents a TLS based condition matching on the incoming mail. It performs the operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case tlsexpression(MailManagerClientTypes.IngressTlsProtocolExpression)
        /// This represents a boolean type condition matching on the incoming mail. It performs the boolean operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case booleanexpression(MailManagerClientTypes.IngressBooleanExpression)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {
    /// The structure containing traffic policy conditions and actions.
    public struct PolicyStatement {
        /// The action that informs a traffic policy resource to either allow or block the email if it matches a condition in the policy statement.
        /// This member is required.
        public var action: MailManagerClientTypes.AcceptAction?
        /// The list of conditions to apply to incoming messages for filtering email traffic.
        /// This member is required.
        public var conditions: [MailManagerClientTypes.PolicyCondition]?

        public init(
            action: MailManagerClientTypes.AcceptAction? = nil,
            conditions: [MailManagerClientTypes.PolicyCondition]? = nil
        )
        {
            self.action = action
            self.conditions = conditions
        }
    }

}

public struct CreateTrafficPolicyInput {
    /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    public var clientToken: Swift.String?
    /// Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
    /// This member is required.
    public var defaultAction: MailManagerClientTypes.AcceptAction?
    /// The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
    public var maxMessageSizeBytes: Swift.Int?
    /// Conditional statements for filtering email traffic.
    /// This member is required.
    public var policyStatements: [MailManagerClientTypes.PolicyStatement]?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public var tags: [MailManagerClientTypes.Tag]?
    /// A user-friendly name for the traffic policy resource.
    /// This member is required.
    public var trafficPolicyName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        defaultAction: MailManagerClientTypes.AcceptAction? = nil,
        maxMessageSizeBytes: Swift.Int? = nil,
        policyStatements: [MailManagerClientTypes.PolicyStatement]? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil,
        trafficPolicyName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultAction = defaultAction
        self.maxMessageSizeBytes = maxMessageSizeBytes
        self.policyStatements = policyStatements
        self.tags = tags
        self.trafficPolicyName = trafficPolicyName
    }
}

public struct CreateTrafficPolicyOutput {
    /// The identifier of the traffic policy resource.
    /// This member is required.
    public var trafficPolicyId: Swift.String?

    public init(
        trafficPolicyId: Swift.String? = nil
    )
    {
        self.trafficPolicyId = trafficPolicyId
    }
}

public struct DeleteIngressPointInput {
    /// The identifier of the ingress endpoint resource that you want to delete.
    /// This member is required.
    public var ingressPointId: Swift.String?

    public init(
        ingressPointId: Swift.String? = nil
    )
    {
        self.ingressPointId = ingressPointId
    }
}

public struct DeleteIngressPointOutput {

    public init() { }
}

public struct DeleteRelayInput {
    /// The unique relay identifier.
    /// This member is required.
    public var relayId: Swift.String?

    public init(
        relayId: Swift.String? = nil
    )
    {
        self.relayId = relayId
    }
}

public struct DeleteRelayOutput {

    public init() { }
}

public struct DeleteRuleSetInput {
    /// The identifier of an existing rule set resource to delete.
    /// This member is required.
    public var ruleSetId: Swift.String?

    public init(
        ruleSetId: Swift.String? = nil
    )
    {
        self.ruleSetId = ruleSetId
    }
}

public struct DeleteRuleSetOutput {

    public init() { }
}

public struct DeleteTrafficPolicyInput {
    /// The identifier of the traffic policy that you want to delete.
    /// This member is required.
    public var trafficPolicyId: Swift.String?

    public init(
        trafficPolicyId: Swift.String? = nil
    )
    {
        self.trafficPolicyId = trafficPolicyId
    }
}

public struct DeleteTrafficPolicyOutput {

    public init() { }
}

extension MailManagerClientTypes {
    /// The configuration for exporting email data to an Amazon S3 bucket.
    public struct S3ExportDestinationConfiguration {
        /// The S3 location to deliver the exported email data.
        public var s3Location: Swift.String?

        public init(
            s3Location: Swift.String? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension MailManagerClientTypes {
    /// The destination configuration for delivering exported email data.
    public enum ExportDestinationConfiguration {
        /// Configuration for delivering to an Amazon S3 bucket.
        case s3(MailManagerClientTypes.S3ExportDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension MailManagerClientTypes {

    public enum ExportState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case preprocessing
        case processing
        case queued
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportState] {
            return [
                .cancelled,
                .completed,
                .failed,
                .preprocessing,
                .processing,
                .queued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .preprocessing: return "PREPROCESSING"
            case .processing: return "PROCESSING"
            case .queued: return "QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The current status of an archive export job.
    public struct ExportStatus {
        /// The timestamp of when the export job completed (if finished).
        public var completionTimestamp: Foundation.Date?
        /// An error message if the export job failed.
        public var errorMessage: Swift.String?
        /// The current state of the export job.
        public var state: MailManagerClientTypes.ExportState?
        /// The timestamp of when the export job was submitted.
        public var submissionTimestamp: Foundation.Date?

        public init(
            completionTimestamp: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            state: MailManagerClientTypes.ExportState? = nil,
            submissionTimestamp: Foundation.Date? = nil
        )
        {
            self.completionTimestamp = completionTimestamp
            self.errorMessage = errorMessage
            self.state = state
            self.submissionTimestamp = submissionTimestamp
        }
    }

}

extension MailManagerClientTypes {
    /// Summary statuses of an archive export job.
    public struct ExportSummary {
        /// The unique identifier of the export job.
        public var exportId: Swift.String?
        /// The current status of the export job.
        public var status: MailManagerClientTypes.ExportStatus?

        public init(
            exportId: Swift.String? = nil,
            status: MailManagerClientTypes.ExportStatus? = nil
        )
        {
            self.exportId = exportId
            self.status = status
        }
    }

}

/// The request to retrieve details of a specific archive export job.
public struct GetArchiveExportInput {
    /// The identifier of the export job to get details for.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

/// The response containing details of the specified archive export job.
public struct GetArchiveExportOutput {
    /// The identifier of the archive the email export was performed from.
    public var archiveId: Swift.String?
    /// Where the exported emails are being delivered.
    public var exportDestinationConfiguration: MailManagerClientTypes.ExportDestinationConfiguration?
    /// The criteria used to filter emails included in the export.
    public var filters: MailManagerClientTypes.ArchiveFilters?
    /// The start of the timestamp range the exported emails cover.
    public var fromTimestamp: Foundation.Date?
    /// The maximum number of email items included in the export.
    public var maxResults: Swift.Int?
    /// The current status of the export job.
    public var status: MailManagerClientTypes.ExportStatus?
    /// The end of the date range the exported emails cover.
    public var toTimestamp: Foundation.Date?

    public init(
        archiveId: Swift.String? = nil,
        exportDestinationConfiguration: MailManagerClientTypes.ExportDestinationConfiguration? = nil,
        filters: MailManagerClientTypes.ArchiveFilters? = nil,
        fromTimestamp: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        status: MailManagerClientTypes.ExportStatus? = nil,
        toTimestamp: Foundation.Date? = nil
    )
    {
        self.archiveId = archiveId
        self.exportDestinationConfiguration = exportDestinationConfiguration
        self.filters = filters
        self.fromTimestamp = fromTimestamp
        self.maxResults = maxResults
        self.status = status
        self.toTimestamp = toTimestamp
    }
}

/// The request to get details of a specific email message stored in an archive.
public struct GetArchiveMessageInput {
    /// The unique identifier of the archived email message.
    /// This member is required.
    public var archivedMessageId: Swift.String?

    public init(
        archivedMessageId: Swift.String? = nil
    )
    {
        self.archivedMessageId = archivedMessageId
    }
}

/// The response containing details about the requested archived email message.
public struct GetArchiveMessageOutput {
    /// A pre-signed URL to temporarily download the full message content.
    public var messageDownloadLink: Swift.String?

    public init(
        messageDownloadLink: Swift.String? = nil
    )
    {
        self.messageDownloadLink = messageDownloadLink
    }
}

/// The request to get the textual content of a specific email message stored in an archive.
public struct GetArchiveMessageContentInput {
    /// The unique identifier of the archived email message.
    /// This member is required.
    public var archivedMessageId: Swift.String?

    public init(
        archivedMessageId: Swift.String? = nil
    )
    {
        self.archivedMessageId = archivedMessageId
    }
}

extension MailManagerClientTypes {
    /// The textual body content of an email message.
    public struct MessageBody {
        /// The HTML body content of the message.
        public var html: Swift.String?
        /// A flag indicating if the email was malformed.
        public var messageMalformed: Swift.Bool?
        /// The plain text body content of the message.
        public var text: Swift.String?

        public init(
            html: Swift.String? = nil,
            messageMalformed: Swift.Bool? = nil,
            text: Swift.String? = nil
        )
        {
            self.html = html
            self.messageMalformed = messageMalformed
            self.text = text
        }
    }

}

/// The response containing the textual content of the requested archived email message.
public struct GetArchiveMessageContentOutput {
    /// The textual body content of the email message.
    public var body: MailManagerClientTypes.MessageBody?

    public init(
        body: MailManagerClientTypes.MessageBody? = nil
    )
    {
        self.body = body
    }
}

/// The request to retrieve details of a specific archive search job.
public struct GetArchiveSearchInput {
    /// The identifier of the search job to get details for.
    /// This member is required.
    public var searchId: Swift.String?

    public init(
        searchId: Swift.String? = nil
    )
    {
        self.searchId = searchId
    }
}

extension MailManagerClientTypes {

    public enum SearchState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchState] {
            return [
                .cancelled,
                .completed,
                .failed,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MailManagerClientTypes {
    /// The current status of an archive search job.
    public struct SearchStatus {
        /// The timestamp of when the search completed (if finished).
        public var completionTimestamp: Foundation.Date?
        /// An error message if the search failed.
        public var errorMessage: Swift.String?
        /// The current state of the search job.
        public var state: MailManagerClientTypes.SearchState?
        /// The timestamp of when the search was submitted.
        public var submissionTimestamp: Foundation.Date?

        public init(
            completionTimestamp: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            state: MailManagerClientTypes.SearchState? = nil,
            submissionTimestamp: Foundation.Date? = nil
        )
        {
            self.completionTimestamp = completionTimestamp
            self.errorMessage = errorMessage
            self.state = state
            self.submissionTimestamp = submissionTimestamp
        }
    }

}

/// The response containing details of the specified archive search job.
public struct GetArchiveSearchOutput {
    /// The identifier of the archive the email search was performed in.
    public var archiveId: Swift.String?
    /// The criteria used to filter emails included in the search.
    public var filters: MailManagerClientTypes.ArchiveFilters?
    /// The start timestamp of the range the searched emails cover.
    public var fromTimestamp: Foundation.Date?
    /// The maximum number of search results to return.
    public var maxResults: Swift.Int?
    /// The current status of the search job.
    public var status: MailManagerClientTypes.SearchStatus?
    /// The end timestamp of the range the searched emails cover.
    public var toTimestamp: Foundation.Date?

    public init(
        archiveId: Swift.String? = nil,
        filters: MailManagerClientTypes.ArchiveFilters? = nil,
        fromTimestamp: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        status: MailManagerClientTypes.SearchStatus? = nil,
        toTimestamp: Foundation.Date? = nil
    )
    {
        self.archiveId = archiveId
        self.filters = filters
        self.fromTimestamp = fromTimestamp
        self.maxResults = maxResults
        self.status = status
        self.toTimestamp = toTimestamp
    }
}

/// The request to retrieve results from a completed archive search job.
public struct GetArchiveSearchResultsInput {
    /// The identifier of the completed search job.
    /// This member is required.
    public var searchId: Swift.String?

    public init(
        searchId: Swift.String? = nil
    )
    {
        self.searchId = searchId
    }
}

extension MailManagerClientTypes {
    /// A result row containing metadata for an archived email message.
    public struct Row {
        /// The unique identifier of the archived message.
        public var archivedMessageId: Swift.String?
        /// The email addresses in the CC header.
        public var cc: Swift.String?
        /// The date the email was sent.
        public var date: Swift.String?
        /// The email address of the sender.
        public var from: Swift.String?
        /// A flag indicating if the email has attachments.
        public var hasAttachments: Swift.Bool?
        /// The email message ID this is a reply to.
        public var inReplyTo: Swift.String?
        /// The unique message ID of the email.
        public var messageId: Swift.String?
        /// The received headers from the email delivery path.
        public var receivedHeaders: [Swift.String]?
        /// The timestamp of when the email was received.
        public var receivedTimestamp: Foundation.Date?
        /// The subject header value of the email.
        public var subject: Swift.String?
        /// The email addresses in the To header.
        public var to: Swift.String?
        /// The user agent that sent the email.
        public var xMailer: Swift.String?
        /// The original user agent that sent the email.
        public var xOriginalMailer: Swift.String?
        /// The priority level of the email.
        public var xPriority: Swift.String?

        public init(
            archivedMessageId: Swift.String? = nil,
            cc: Swift.String? = nil,
            date: Swift.String? = nil,
            from: Swift.String? = nil,
            hasAttachments: Swift.Bool? = nil,
            inReplyTo: Swift.String? = nil,
            messageId: Swift.String? = nil,
            receivedHeaders: [Swift.String]? = nil,
            receivedTimestamp: Foundation.Date? = nil,
            subject: Swift.String? = nil,
            to: Swift.String? = nil,
            xMailer: Swift.String? = nil,
            xOriginalMailer: Swift.String? = nil,
            xPriority: Swift.String? = nil
        )
        {
            self.archivedMessageId = archivedMessageId
            self.cc = cc
            self.date = date
            self.from = from
            self.hasAttachments = hasAttachments
            self.inReplyTo = inReplyTo
            self.messageId = messageId
            self.receivedHeaders = receivedHeaders
            self.receivedTimestamp = receivedTimestamp
            self.subject = subject
            self.to = to
            self.xMailer = xMailer
            self.xOriginalMailer = xOriginalMailer
            self.xPriority = xPriority
        }
    }

}

/// The response containing search results from a completed archive search.
public struct GetArchiveSearchResultsOutput {
    /// The list of email result objects matching the search criteria.
    public var rows: [MailManagerClientTypes.Row]?

    public init(
        rows: [MailManagerClientTypes.Row]? = nil
    )
    {
        self.rows = rows
    }
}

public struct GetIngressPointInput {
    /// The identifier of an ingress endpoint.
    /// This member is required.
    public var ingressPointId: Swift.String?

    public init(
        ingressPointId: Swift.String? = nil
    )
    {
        self.ingressPointId = ingressPointId
    }
}

extension MailManagerClientTypes {
    /// The password configuration of the ingress endpoint resource.
    public struct IngressPointPasswordConfiguration {
        /// The previous password expiry timestamp of the ingress endpoint resource.
        public var previousSmtpPasswordExpiryTimestamp: Foundation.Date?
        /// The previous password version of the ingress endpoint resource.
        public var previousSmtpPasswordVersion: Swift.String?
        /// The current password expiry timestamp of the ingress endpoint resource.
        public var smtpPasswordVersion: Swift.String?

        public init(
            previousSmtpPasswordExpiryTimestamp: Foundation.Date? = nil,
            previousSmtpPasswordVersion: Swift.String? = nil,
            smtpPasswordVersion: Swift.String? = nil
        )
        {
            self.previousSmtpPasswordExpiryTimestamp = previousSmtpPasswordExpiryTimestamp
            self.previousSmtpPasswordVersion = previousSmtpPasswordVersion
            self.smtpPasswordVersion = smtpPasswordVersion
        }
    }

}

extension MailManagerClientTypes {
    /// The authentication configuration for the ingress endpoint resource.
    public struct IngressPointAuthConfiguration {
        /// The ingress endpoint password configuration for the ingress endpoint resource.
        public var ingressPointPasswordConfiguration: MailManagerClientTypes.IngressPointPasswordConfiguration?
        /// The ingress endpoint SecretsManager::Secret ARN configuration for the ingress endpoint resource.
        public var secretArn: Swift.String?

        public init(
            ingressPointPasswordConfiguration: MailManagerClientTypes.IngressPointPasswordConfiguration? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.ingressPointPasswordConfiguration = ingressPointPasswordConfiguration
            self.secretArn = secretArn
        }
    }

}

extension MailManagerClientTypes {

    public enum IngressPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case closed
        case deprovisioning
        case failed
        case provisioning
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressPointStatus] {
            return [
                .active,
                .closed,
                .deprovisioning,
                .failed,
                .provisioning,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .deprovisioning: return "DEPROVISIONING"
            case .failed: return "FAILED"
            case .provisioning: return "PROVISIONING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIngressPointOutput {
    /// The DNS A Record that identifies your ingress endpoint. Configure your DNS Mail Exchange (MX) record with this value to route emails to Mail Manager.
    public var aRecord: Swift.String?
    /// The timestamp of when the ingress endpoint was created.
    public var createdTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the ingress endpoint resource.
    public var ingressPointArn: Swift.String?
    /// The authentication configuration of the ingress endpoint resource.
    public var ingressPointAuthConfiguration: MailManagerClientTypes.IngressPointAuthConfiguration?
    /// The identifier of an ingress endpoint resource.
    /// This member is required.
    public var ingressPointId: Swift.String?
    /// A user friendly name for the ingress endpoint.
    /// This member is required.
    public var ingressPointName: Swift.String?
    /// The timestamp of when the ingress endpoint was last updated.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// The identifier of a rule set resource associated with the ingress endpoint.
    public var ruleSetId: Swift.String?
    /// The status of the ingress endpoint resource.
    public var status: MailManagerClientTypes.IngressPointStatus?
    /// The identifier of the traffic policy resource associated with the ingress endpoint.
    public var trafficPolicyId: Swift.String?
    /// The type of ingress endpoint.
    public var type: MailManagerClientTypes.IngressPointType?

    public init(
        aRecord: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        ingressPointArn: Swift.String? = nil,
        ingressPointAuthConfiguration: MailManagerClientTypes.IngressPointAuthConfiguration? = nil,
        ingressPointId: Swift.String? = nil,
        ingressPointName: Swift.String? = nil,
        lastUpdatedTimestamp: Foundation.Date? = nil,
        ruleSetId: Swift.String? = nil,
        status: MailManagerClientTypes.IngressPointStatus? = nil,
        trafficPolicyId: Swift.String? = nil,
        type: MailManagerClientTypes.IngressPointType? = nil
    )
    {
        self.aRecord = aRecord
        self.createdTimestamp = createdTimestamp
        self.ingressPointArn = ingressPointArn
        self.ingressPointAuthConfiguration = ingressPointAuthConfiguration
        self.ingressPointId = ingressPointId
        self.ingressPointName = ingressPointName
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.ruleSetId = ruleSetId
        self.status = status
        self.trafficPolicyId = trafficPolicyId
        self.type = type
    }
}

public struct GetRelayInput {
    /// A unique relay identifier.
    /// This member is required.
    public var relayId: Swift.String?

    public init(
        relayId: Swift.String? = nil
    )
    {
        self.relayId = relayId
    }
}

public struct GetRelayOutput {
    /// The authentication attribute—contains the secret ARN where the customer relay server credentials are stored.
    public var authentication: MailManagerClientTypes.RelayAuthentication?
    /// The timestamp of when the relay was created.
    public var createdTimestamp: Foundation.Date?
    /// The timestamp of when relay was last updated.
    public var lastModifiedTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the relay.
    public var relayArn: Swift.String?
    /// The unique relay identifier.
    /// This member is required.
    public var relayId: Swift.String?
    /// The unique name of the relay.
    public var relayName: Swift.String?
    /// The destination relay server address.
    public var serverName: Swift.String?
    /// The destination relay server port.
    public var serverPort: Swift.Int?

    public init(
        authentication: MailManagerClientTypes.RelayAuthentication? = nil,
        createdTimestamp: Foundation.Date? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        relayArn: Swift.String? = nil,
        relayId: Swift.String? = nil,
        relayName: Swift.String? = nil,
        serverName: Swift.String? = nil,
        serverPort: Swift.Int? = nil
    )
    {
        self.authentication = authentication
        self.createdTimestamp = createdTimestamp
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.relayArn = relayArn
        self.relayId = relayId
        self.relayName = relayName
        self.serverName = serverName
        self.serverPort = serverPort
    }
}

public struct GetRuleSetInput {
    /// The identifier of an existing rule set to be retrieved.
    /// This member is required.
    public var ruleSetId: Swift.String?

    public init(
        ruleSetId: Swift.String? = nil
    )
    {
        self.ruleSetId = ruleSetId
    }
}

public struct GetRuleSetOutput {
    /// The date of when then rule set was created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date of when the rule set was last modified.
    /// This member is required.
    public var lastModificationDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the rule set resource.
    /// This member is required.
    public var ruleSetArn: Swift.String?
    /// The identifier of the rule set resource.
    /// This member is required.
    public var ruleSetId: Swift.String?
    /// A user-friendly name for the rule set resource.
    /// This member is required.
    public var ruleSetName: Swift.String?
    /// The rules contained in the rule set.
    /// This member is required.
    public var rules: [MailManagerClientTypes.Rule]?

    public init(
        createdDate: Foundation.Date? = nil,
        lastModificationDate: Foundation.Date? = nil,
        ruleSetArn: Swift.String? = nil,
        ruleSetId: Swift.String? = nil,
        ruleSetName: Swift.String? = nil,
        rules: [MailManagerClientTypes.Rule]? = nil
    )
    {
        self.createdDate = createdDate
        self.lastModificationDate = lastModificationDate
        self.ruleSetArn = ruleSetArn
        self.ruleSetId = ruleSetId
        self.ruleSetName = ruleSetName
        self.rules = rules
    }
}

public struct GetTrafficPolicyInput {
    /// The identifier of the traffic policy resource.
    /// This member is required.
    public var trafficPolicyId: Swift.String?

    public init(
        trafficPolicyId: Swift.String? = nil
    )
    {
        self.trafficPolicyId = trafficPolicyId
    }
}

public struct GetTrafficPolicyOutput {
    /// The timestamp of when the traffic policy was created.
    public var createdTimestamp: Foundation.Date?
    /// The default action of the traffic policy.
    public var defaultAction: MailManagerClientTypes.AcceptAction?
    /// The timestamp of when the traffic policy was last updated.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
    public var maxMessageSizeBytes: Swift.Int?
    /// The list of conditions which are in the traffic policy resource.
    public var policyStatements: [MailManagerClientTypes.PolicyStatement]?
    /// The Amazon Resource Name (ARN) of the traffic policy resource.
    public var trafficPolicyArn: Swift.String?
    /// The identifier of the traffic policy resource.
    /// This member is required.
    public var trafficPolicyId: Swift.String?
    /// A user-friendly name for the traffic policy resource.
    /// This member is required.
    public var trafficPolicyName: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        defaultAction: MailManagerClientTypes.AcceptAction? = nil,
        lastUpdatedTimestamp: Foundation.Date? = nil,
        maxMessageSizeBytes: Swift.Int? = nil,
        policyStatements: [MailManagerClientTypes.PolicyStatement]? = nil,
        trafficPolicyArn: Swift.String? = nil,
        trafficPolicyId: Swift.String? = nil,
        trafficPolicyName: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.defaultAction = defaultAction
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.maxMessageSizeBytes = maxMessageSizeBytes
        self.policyStatements = policyStatements
        self.trafficPolicyArn = trafficPolicyArn
        self.trafficPolicyId = trafficPolicyId
        self.trafficPolicyName = trafficPolicyName
    }
}

extension MailManagerClientTypes {
    /// The structure of an ingress endpoint resource.
    public struct IngressPoint {
        /// The DNS A Record that identifies your ingress endpoint. Configure your DNS Mail Exchange (MX) record with this value to route emails to Mail Manager.
        public var aRecord: Swift.String?
        /// The identifier of the ingress endpoint resource.
        /// This member is required.
        public var ingressPointId: Swift.String?
        /// A user friendly name for the ingress endpoint resource.
        /// This member is required.
        public var ingressPointName: Swift.String?
        /// The status of the ingress endpoint resource.
        /// This member is required.
        public var status: MailManagerClientTypes.IngressPointStatus?
        /// The type of ingress endpoint resource.
        /// This member is required.
        public var type: MailManagerClientTypes.IngressPointType?

        public init(
            aRecord: Swift.String? = nil,
            ingressPointId: Swift.String? = nil,
            ingressPointName: Swift.String? = nil,
            status: MailManagerClientTypes.IngressPointStatus? = nil,
            type: MailManagerClientTypes.IngressPointType? = nil
        )
        {
            self.aRecord = aRecord
            self.ingressPointId = ingressPointId
            self.ingressPointName = ingressPointName
            self.status = status
            self.type = type
        }
    }

}

public struct ListIngressPointsInput {
    /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    public var nextToken: Swift.String?
    /// The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

public struct ListIngressPointsOutput {
    /// The list of ingress endpoints.
    public var ingressPoints: [MailManagerClientTypes.IngressPoint]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        ingressPoints: [MailManagerClientTypes.IngressPoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingressPoints = ingressPoints
        self.nextToken = nextToken
    }
}

extension MailManagerClientTypes {

    public enum IngressPointStatusToUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case closed
        case sdkUnknown(Swift.String)

        public static var allCases: [IngressPointStatusToUpdate] {
            return [
                .active,
                .closed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateIngressPointInput {
    /// If you choose an Authenticated ingress endpoint, you must configure either an SMTP password or a secret ARN.
    public var ingressPointConfiguration: MailManagerClientTypes.IngressPointConfiguration?
    /// The identifier for the ingress endpoint you want to update.
    /// This member is required.
    public var ingressPointId: Swift.String?
    /// A user friendly name for the ingress endpoint resource.
    public var ingressPointName: Swift.String?
    /// The identifier of an existing rule set that you attach to an ingress endpoint resource.
    public var ruleSetId: Swift.String?
    /// The update status of an ingress endpoint.
    public var statusToUpdate: MailManagerClientTypes.IngressPointStatusToUpdate?
    /// The identifier of an existing traffic policy that you attach to an ingress endpoint resource.
    public var trafficPolicyId: Swift.String?

    public init(
        ingressPointConfiguration: MailManagerClientTypes.IngressPointConfiguration? = nil,
        ingressPointId: Swift.String? = nil,
        ingressPointName: Swift.String? = nil,
        ruleSetId: Swift.String? = nil,
        statusToUpdate: MailManagerClientTypes.IngressPointStatusToUpdate? = nil,
        trafficPolicyId: Swift.String? = nil
    )
    {
        self.ingressPointConfiguration = ingressPointConfiguration
        self.ingressPointId = ingressPointId
        self.ingressPointName = ingressPointName
        self.ruleSetId = ruleSetId
        self.statusToUpdate = statusToUpdate
        self.trafficPolicyId = trafficPolicyId
    }
}

public struct UpdateIngressPointOutput {

    public init() { }
}

/// The request to list archive export jobs in your account.
public struct ListArchiveExportsInput {
    /// The identifier of the archive.
    /// This member is required.
    public var archiveId: Swift.String?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The maximum number of archive export jobs that are returned per call. You can use NextToken to obtain further pages of archives.
    public var pageSize: Swift.Int?

    public init(
        archiveId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.archiveId = archiveId
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

/// The response containing a list of archive export jobs and their statuses.
public struct ListArchiveExportsOutput {
    /// The list of export job identifiers and statuses.
    public var exports: [MailManagerClientTypes.ExportSummary]?
    /// If present, use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        exports: [MailManagerClientTypes.ExportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exports = exports
        self.nextToken = nextToken
    }
}

/// The request to list archive search jobs in your account.
public struct ListArchiveSearchesInput {
    /// The identifier of the archive.
    /// This member is required.
    public var archiveId: Swift.String?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The maximum number of archive search jobs that are returned per call. You can use NextToken to obtain further pages of archives.
    public var pageSize: Swift.Int?

    public init(
        archiveId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.archiveId = archiveId
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension MailManagerClientTypes {
    /// Summary details of an archive search job.
    public struct SearchSummary {
        /// The unique identifier of the search job.
        public var searchId: Swift.String?
        /// The current status of the search job.
        public var status: MailManagerClientTypes.SearchStatus?

        public init(
            searchId: Swift.String? = nil,
            status: MailManagerClientTypes.SearchStatus? = nil
        )
        {
            self.searchId = searchId
            self.status = status
        }
    }

}

/// The response containing a list of archive search jobs and their statuses.
public struct ListArchiveSearchesOutput {
    /// If present, use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The list of search job identifiers and statuses.
    public var searches: [MailManagerClientTypes.SearchSummary]?

    public init(
        nextToken: Swift.String? = nil,
        searches: [MailManagerClientTypes.SearchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.searches = searches
    }
}

public struct ListRelaysInput {
    /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    public var nextToken: Swift.String?
    /// The number of relays to be returned in one request.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension MailManagerClientTypes {
    /// The relay resource that can be used as a rule to relay receiving emails to the destination relay server.
    public struct Relay {
        /// The timestamp of when the relay was last modified.
        public var lastModifiedTimestamp: Foundation.Date?
        /// The unique relay identifier.
        public var relayId: Swift.String?
        /// The unique relay name.
        public var relayName: Swift.String?

        public init(
            lastModifiedTimestamp: Foundation.Date? = nil,
            relayId: Swift.String? = nil,
            relayName: Swift.String? = nil
        )
        {
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.relayId = relayId
            self.relayName = relayName
        }
    }

}

public struct ListRelaysOutput {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The list of returned relays.
    /// This member is required.
    public var relays: [MailManagerClientTypes.Relay]?

    public init(
        nextToken: Swift.String? = nil,
        relays: [MailManagerClientTypes.Relay]? = nil
    )
    {
        self.nextToken = nextToken
        self.relays = relays
    }
}

public struct ListRuleSetsInput {
    /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    public var nextToken: Swift.String?
    /// The maximum number of rule set resources that are returned per call. You can use NextToken to obtain further rule sets.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension MailManagerClientTypes {
    /// A rule set contains a list of rules that are evaluated in order. Each rule is evaluated sequentially for each email.
    public struct RuleSet {
        /// The last modification date of the rule set.
        public var lastModificationDate: Foundation.Date?
        /// The identifier of the rule set.
        public var ruleSetId: Swift.String?
        /// A user-friendly name for the rule set.
        public var ruleSetName: Swift.String?

        public init(
            lastModificationDate: Foundation.Date? = nil,
            ruleSetId: Swift.String? = nil,
            ruleSetName: Swift.String? = nil
        )
        {
            self.lastModificationDate = lastModificationDate
            self.ruleSetId = ruleSetId
            self.ruleSetName = ruleSetName
        }
    }

}

public struct ListRuleSetsOutput {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The list of rule sets.
    /// This member is required.
    public var ruleSets: [MailManagerClientTypes.RuleSet]?

    public init(
        nextToken: Swift.String? = nil,
        ruleSets: [MailManagerClientTypes.RuleSet]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleSets = ruleSets
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to retrieve tags from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTrafficPoliciesInput {
    /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    public var nextToken: Swift.String?
    /// The maximum number of traffic policy resources that are returned per call. You can use NextToken to obtain further traffic policies.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension MailManagerClientTypes {
    /// The structure of a traffic policy resource which is a container for policy statements.
    public struct TrafficPolicy {
        /// Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
        /// This member is required.
        public var defaultAction: MailManagerClientTypes.AcceptAction?
        /// The identifier of the traffic policy resource.
        /// This member is required.
        public var trafficPolicyId: Swift.String?
        /// A user-friendly name of the traffic policy resource.
        /// This member is required.
        public var trafficPolicyName: Swift.String?

        public init(
            defaultAction: MailManagerClientTypes.AcceptAction? = nil,
            trafficPolicyId: Swift.String? = nil,
            trafficPolicyName: Swift.String? = nil
        )
        {
            self.defaultAction = defaultAction
            self.trafficPolicyId = trafficPolicyId
            self.trafficPolicyName = trafficPolicyName
        }
    }

}

public struct ListTrafficPoliciesOutput {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The list of traffic policies.
    public var trafficPolicies: [MailManagerClientTypes.TrafficPolicy]?

    public init(
        nextToken: Swift.String? = nil,
        trafficPolicies: [MailManagerClientTypes.TrafficPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.trafficPolicies = trafficPolicies
    }
}

public struct UpdateRelayInput {
    /// Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored.
    public var authentication: MailManagerClientTypes.RelayAuthentication?
    /// The unique relay identifier.
    /// This member is required.
    public var relayId: Swift.String?
    /// The name of the relay resource.
    public var relayName: Swift.String?
    /// The destination relay server address.
    public var serverName: Swift.String?
    /// The destination relay server port.
    public var serverPort: Swift.Int?

    public init(
        authentication: MailManagerClientTypes.RelayAuthentication? = nil,
        relayId: Swift.String? = nil,
        relayName: Swift.String? = nil,
        serverName: Swift.String? = nil,
        serverPort: Swift.Int? = nil
    )
    {
        self.authentication = authentication
        self.relayId = relayId
        self.relayName = relayName
        self.serverName = serverName
        self.serverPort = serverPort
    }
}

public struct UpdateRelayOutput {

    public init() { }
}

public struct UpdateRuleSetInput {
    /// The identifier of a rule set you want to update.
    /// This member is required.
    public var ruleSetId: Swift.String?
    /// A user-friendly name for the rule set resource.
    public var ruleSetName: Swift.String?
    /// A new set of rules to replace the current rules of the rule set—these rules will override all the rules of the rule set.
    public var rules: [MailManagerClientTypes.Rule]?

    public init(
        ruleSetId: Swift.String? = nil,
        ruleSetName: Swift.String? = nil,
        rules: [MailManagerClientTypes.Rule]? = nil
    )
    {
        self.ruleSetId = ruleSetId
        self.ruleSetName = ruleSetName
        self.rules = rules
    }
}

public struct UpdateRuleSetOutput {

    public init() { }
}

/// The request to initiate an export of emails from an archive.
public struct StartArchiveExportInput {
    /// The identifier of the archive to export emails from.
    /// This member is required.
    public var archiveId: Swift.String?
    /// Details on where to deliver the exported email data.
    /// This member is required.
    public var exportDestinationConfiguration: MailManagerClientTypes.ExportDestinationConfiguration?
    /// Criteria to filter which emails are included in the export.
    public var filters: MailManagerClientTypes.ArchiveFilters?
    /// The start of the timestamp range to include emails from.
    /// This member is required.
    public var fromTimestamp: Foundation.Date?
    /// The maximum number of email items to include in the export.
    public var maxResults: Swift.Int?
    /// The end of the timestamp range to include emails from.
    /// This member is required.
    public var toTimestamp: Foundation.Date?

    public init(
        archiveId: Swift.String? = nil,
        exportDestinationConfiguration: MailManagerClientTypes.ExportDestinationConfiguration? = nil,
        filters: MailManagerClientTypes.ArchiveFilters? = nil,
        fromTimestamp: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        toTimestamp: Foundation.Date? = nil
    )
    {
        self.archiveId = archiveId
        self.exportDestinationConfiguration = exportDestinationConfiguration
        self.filters = filters
        self.fromTimestamp = fromTimestamp
        self.maxResults = maxResults
        self.toTimestamp = toTimestamp
    }
}

/// The response from initiating an archive export.
public struct StartArchiveExportOutput {
    /// The unique identifier for the initiated export job.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

/// The request to initiate a search across emails in an archive.
public struct StartArchiveSearchInput {
    /// The identifier of the archive to search emails in.
    /// This member is required.
    public var archiveId: Swift.String?
    /// Criteria to filter which emails are included in the search results.
    public var filters: MailManagerClientTypes.ArchiveFilters?
    /// The start timestamp of the range to search emails from.
    /// This member is required.
    public var fromTimestamp: Foundation.Date?
    /// The maximum number of search results to return.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// The end timestamp of the range to search emails from.
    /// This member is required.
    public var toTimestamp: Foundation.Date?

    public init(
        archiveId: Swift.String? = nil,
        filters: MailManagerClientTypes.ArchiveFilters? = nil,
        fromTimestamp: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        toTimestamp: Foundation.Date? = nil
    )
    {
        self.archiveId = archiveId
        self.filters = filters
        self.fromTimestamp = fromTimestamp
        self.maxResults = maxResults
        self.toTimestamp = toTimestamp
    }
}

/// The response from initiating an archive search.
public struct StartArchiveSearchOutput {
    /// The unique identifier for the initiated search job.
    public var searchId: Swift.String?

    public init(
        searchId: Swift.String? = nil
    )
    {
        self.searchId = searchId
    }
}

/// The request to stop an in-progress archive export job.
public struct StopArchiveExportInput {
    /// The identifier of the export job to stop.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

/// The response indicating if the request to stop the export job succeeded. On success, returns an HTTP 200 status code. On failure, returns an error message.
public struct StopArchiveExportOutput {

    public init() { }
}

/// The request to stop an in-progress archive search job.
public struct StopArchiveSearchInput {
    /// The identifier of the search job to stop.
    /// This member is required.
    public var searchId: Swift.String?

    public init(
        searchId: Swift.String? = nil
    )
    {
        self.searchId = searchId
    }
}

/// The response indicating if the request to stop the search job succeeded. On success, returns an HTTP 200 status code. On failure, returns an error message.
public struct StopArchiveSearchOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [MailManagerClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MailManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UpdateTrafficPolicyInput {
    /// Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
    public var defaultAction: MailManagerClientTypes.AcceptAction?
    /// The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
    public var maxMessageSizeBytes: Swift.Int?
    /// The list of conditions to be updated for filtering email traffic.
    public var policyStatements: [MailManagerClientTypes.PolicyStatement]?
    /// The identifier of the traffic policy that you want to update.
    /// This member is required.
    public var trafficPolicyId: Swift.String?
    /// A user-friendly name for the traffic policy resource.
    public var trafficPolicyName: Swift.String?

    public init(
        defaultAction: MailManagerClientTypes.AcceptAction? = nil,
        maxMessageSizeBytes: Swift.Int? = nil,
        policyStatements: [MailManagerClientTypes.PolicyStatement]? = nil,
        trafficPolicyId: Swift.String? = nil,
        trafficPolicyName: Swift.String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.maxMessageSizeBytes = maxMessageSizeBytes
        self.policyStatements = policyStatements
        self.trafficPolicyId = trafficPolicyId
        self.trafficPolicyName = trafficPolicyName
    }
}

public struct UpdateTrafficPolicyOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput {

    public init() { }
}

extension CreateAddonInstanceInput {

    static func urlPathProvider(_ value: CreateAddonInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAddonSubscriptionInput {

    static func urlPathProvider(_ value: CreateAddonSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateArchiveInput {

    static func urlPathProvider(_ value: CreateArchiveInput) -> Swift.String? {
        return "/"
    }
}

extension CreateIngressPointInput {

    static func urlPathProvider(_ value: CreateIngressPointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRelayInput {

    static func urlPathProvider(_ value: CreateRelayInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRuleSetInput {

    static func urlPathProvider(_ value: CreateRuleSetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTrafficPolicyInput {

    static func urlPathProvider(_ value: CreateTrafficPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAddonInstanceInput {

    static func urlPathProvider(_ value: DeleteAddonInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAddonSubscriptionInput {

    static func urlPathProvider(_ value: DeleteAddonSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteArchiveInput {

    static func urlPathProvider(_ value: DeleteArchiveInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteIngressPointInput {

    static func urlPathProvider(_ value: DeleteIngressPointInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRelayInput {

    static func urlPathProvider(_ value: DeleteRelayInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRuleSetInput {

    static func urlPathProvider(_ value: DeleteRuleSetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTrafficPolicyInput {

    static func urlPathProvider(_ value: DeleteTrafficPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetAddonInstanceInput {

    static func urlPathProvider(_ value: GetAddonInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension GetAddonSubscriptionInput {

    static func urlPathProvider(_ value: GetAddonSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension GetArchiveInput {

    static func urlPathProvider(_ value: GetArchiveInput) -> Swift.String? {
        return "/"
    }
}

extension GetArchiveExportInput {

    static func urlPathProvider(_ value: GetArchiveExportInput) -> Swift.String? {
        return "/"
    }
}

extension GetArchiveMessageInput {

    static func urlPathProvider(_ value: GetArchiveMessageInput) -> Swift.String? {
        return "/"
    }
}

extension GetArchiveMessageContentInput {

    static func urlPathProvider(_ value: GetArchiveMessageContentInput) -> Swift.String? {
        return "/"
    }
}

extension GetArchiveSearchInput {

    static func urlPathProvider(_ value: GetArchiveSearchInput) -> Swift.String? {
        return "/"
    }
}

extension GetArchiveSearchResultsInput {

    static func urlPathProvider(_ value: GetArchiveSearchResultsInput) -> Swift.String? {
        return "/"
    }
}

extension GetIngressPointInput {

    static func urlPathProvider(_ value: GetIngressPointInput) -> Swift.String? {
        return "/"
    }
}

extension GetRelayInput {

    static func urlPathProvider(_ value: GetRelayInput) -> Swift.String? {
        return "/"
    }
}

extension GetRuleSetInput {

    static func urlPathProvider(_ value: GetRuleSetInput) -> Swift.String? {
        return "/"
    }
}

extension GetTrafficPolicyInput {

    static func urlPathProvider(_ value: GetTrafficPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListAddonInstancesInput {

    static func urlPathProvider(_ value: ListAddonInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAddonSubscriptionsInput {

    static func urlPathProvider(_ value: ListAddonSubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListArchiveExportsInput {

    static func urlPathProvider(_ value: ListArchiveExportsInput) -> Swift.String? {
        return "/"
    }
}

extension ListArchivesInput {

    static func urlPathProvider(_ value: ListArchivesInput) -> Swift.String? {
        return "/"
    }
}

extension ListArchiveSearchesInput {

    static func urlPathProvider(_ value: ListArchiveSearchesInput) -> Swift.String? {
        return "/"
    }
}

extension ListIngressPointsInput {

    static func urlPathProvider(_ value: ListIngressPointsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRelaysInput {

    static func urlPathProvider(_ value: ListRelaysInput) -> Swift.String? {
        return "/"
    }
}

extension ListRuleSetsInput {

    static func urlPathProvider(_ value: ListRuleSetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTrafficPoliciesInput {

    static func urlPathProvider(_ value: ListTrafficPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension StartArchiveExportInput {

    static func urlPathProvider(_ value: StartArchiveExportInput) -> Swift.String? {
        return "/"
    }
}

extension StartArchiveSearchInput {

    static func urlPathProvider(_ value: StartArchiveSearchInput) -> Swift.String? {
        return "/"
    }
}

extension StopArchiveExportInput {

    static func urlPathProvider(_ value: StopArchiveExportInput) -> Swift.String? {
        return "/"
    }
}

extension StopArchiveSearchInput {

    static func urlPathProvider(_ value: StopArchiveSearchInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateArchiveInput {

    static func urlPathProvider(_ value: UpdateArchiveInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateIngressPointInput {

    static func urlPathProvider(_ value: UpdateIngressPointInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRelayInput {

    static func urlPathProvider(_ value: UpdateRelayInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRuleSetInput {

    static func urlPathProvider(_ value: UpdateRuleSetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTrafficPolicyInput {

    static func urlPathProvider(_ value: UpdateTrafficPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAddonInstanceInput {

    static func write(value: CreateAddonInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddonSubscriptionId"].write(value.addonSubscriptionId)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAddonSubscriptionInput {

    static func write(value: CreateAddonSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddonName"].write(value.addonName)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateArchiveInput {

    static func write(value: CreateArchiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveName"].write(value.archiveName)
        try writer["ClientToken"].write(value.clientToken)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["Retention"].write(value.retention, with: MailManagerClientTypes.ArchiveRetention.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIngressPointInput {

    static func write(value: CreateIngressPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["IngressPointConfiguration"].write(value.ingressPointConfiguration, with: MailManagerClientTypes.IngressPointConfiguration.write(value:to:))
        try writer["IngressPointName"].write(value.ingressPointName)
        try writer["RuleSetId"].write(value.ruleSetId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrafficPolicyId"].write(value.trafficPolicyId)
        try writer["Type"].write(value.type)
    }
}

extension CreateRelayInput {

    static func write(value: CreateRelayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Authentication"].write(value.authentication, with: MailManagerClientTypes.RelayAuthentication.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["RelayName"].write(value.relayName)
        try writer["ServerName"].write(value.serverName)
        try writer["ServerPort"].write(value.serverPort)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRuleSetInput {

    static func write(value: CreateRuleSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["RuleSetName"].write(value.ruleSetName)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: MailManagerClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTrafficPolicyInput {

    static func write(value: CreateTrafficPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DefaultAction"].write(value.defaultAction)
        try writer["MaxMessageSizeBytes"].write(value.maxMessageSizeBytes)
        try writer["PolicyStatements"].writeList(value.policyStatements, memberWritingClosure: MailManagerClientTypes.PolicyStatement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrafficPolicyName"].write(value.trafficPolicyName)
    }
}

extension DeleteAddonInstanceInput {

    static func write(value: DeleteAddonInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddonInstanceId"].write(value.addonInstanceId)
    }
}

extension DeleteAddonSubscriptionInput {

    static func write(value: DeleteAddonSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddonSubscriptionId"].write(value.addonSubscriptionId)
    }
}

extension DeleteArchiveInput {

    static func write(value: DeleteArchiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
    }
}

extension DeleteIngressPointInput {

    static func write(value: DeleteIngressPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IngressPointId"].write(value.ingressPointId)
    }
}

extension DeleteRelayInput {

    static func write(value: DeleteRelayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RelayId"].write(value.relayId)
    }
}

extension DeleteRuleSetInput {

    static func write(value: DeleteRuleSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleSetId"].write(value.ruleSetId)
    }
}

extension DeleteTrafficPolicyInput {

    static func write(value: DeleteTrafficPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrafficPolicyId"].write(value.trafficPolicyId)
    }
}

extension GetAddonInstanceInput {

    static func write(value: GetAddonInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddonInstanceId"].write(value.addonInstanceId)
    }
}

extension GetAddonSubscriptionInput {

    static func write(value: GetAddonSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddonSubscriptionId"].write(value.addonSubscriptionId)
    }
}

extension GetArchiveInput {

    static func write(value: GetArchiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
    }
}

extension GetArchiveExportInput {

    static func write(value: GetArchiveExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportId"].write(value.exportId)
    }
}

extension GetArchiveMessageInput {

    static func write(value: GetArchiveMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchivedMessageId"].write(value.archivedMessageId)
    }
}

extension GetArchiveMessageContentInput {

    static func write(value: GetArchiveMessageContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchivedMessageId"].write(value.archivedMessageId)
    }
}

extension GetArchiveSearchInput {

    static func write(value: GetArchiveSearchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SearchId"].write(value.searchId)
    }
}

extension GetArchiveSearchResultsInput {

    static func write(value: GetArchiveSearchResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SearchId"].write(value.searchId)
    }
}

extension GetIngressPointInput {

    static func write(value: GetIngressPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IngressPointId"].write(value.ingressPointId)
    }
}

extension GetRelayInput {

    static func write(value: GetRelayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RelayId"].write(value.relayId)
    }
}

extension GetRuleSetInput {

    static func write(value: GetRuleSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleSetId"].write(value.ruleSetId)
    }
}

extension GetTrafficPolicyInput {

    static func write(value: GetTrafficPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrafficPolicyId"].write(value.trafficPolicyId)
    }
}

extension ListAddonInstancesInput {

    static func write(value: ListAddonInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListAddonSubscriptionsInput {

    static func write(value: ListAddonSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListArchiveExportsInput {

    static func write(value: ListArchiveExportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListArchivesInput {

    static func write(value: ListArchivesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListArchiveSearchesInput {

    static func write(value: ListArchiveSearchesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListIngressPointsInput {

    static func write(value: ListIngressPointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListRelaysInput {

    static func write(value: ListRelaysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListRuleSetsInput {

    static func write(value: ListRuleSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListTrafficPoliciesInput {

    static func write(value: ListTrafficPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
    }
}

extension StartArchiveExportInput {

    static func write(value: StartArchiveExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
        try writer["ExportDestinationConfiguration"].write(value.exportDestinationConfiguration, with: MailManagerClientTypes.ExportDestinationConfiguration.write(value:to:))
        try writer["Filters"].write(value.filters, with: MailManagerClientTypes.ArchiveFilters.write(value:to:))
        try writer["FromTimestamp"].writeTimestamp(value.fromTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["ToTimestamp"].writeTimestamp(value.toTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension StartArchiveSearchInput {

    static func write(value: StartArchiveSearchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
        try writer["Filters"].write(value.filters, with: MailManagerClientTypes.ArchiveFilters.write(value:to:))
        try writer["FromTimestamp"].writeTimestamp(value.fromTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["ToTimestamp"].writeTimestamp(value.toTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension StopArchiveExportInput {

    static func write(value: StopArchiveExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportId"].write(value.exportId)
    }
}

extension StopArchiveSearchInput {

    static func write(value: StopArchiveSearchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SearchId"].write(value.searchId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MailManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateArchiveInput {

    static func write(value: UpdateArchiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArchiveId"].write(value.archiveId)
        try writer["ArchiveName"].write(value.archiveName)
        try writer["Retention"].write(value.retention, with: MailManagerClientTypes.ArchiveRetention.write(value:to:))
    }
}

extension UpdateIngressPointInput {

    static func write(value: UpdateIngressPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IngressPointConfiguration"].write(value.ingressPointConfiguration, with: MailManagerClientTypes.IngressPointConfiguration.write(value:to:))
        try writer["IngressPointId"].write(value.ingressPointId)
        try writer["IngressPointName"].write(value.ingressPointName)
        try writer["RuleSetId"].write(value.ruleSetId)
        try writer["StatusToUpdate"].write(value.statusToUpdate)
        try writer["TrafficPolicyId"].write(value.trafficPolicyId)
    }
}

extension UpdateRelayInput {

    static func write(value: UpdateRelayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Authentication"].write(value.authentication, with: MailManagerClientTypes.RelayAuthentication.write(value:to:))
        try writer["RelayId"].write(value.relayId)
        try writer["RelayName"].write(value.relayName)
        try writer["ServerName"].write(value.serverName)
        try writer["ServerPort"].write(value.serverPort)
    }
}

extension UpdateRuleSetInput {

    static func write(value: UpdateRuleSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleSetId"].write(value.ruleSetId)
        try writer["RuleSetName"].write(value.ruleSetName)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: MailManagerClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTrafficPolicyInput {

    static func write(value: UpdateTrafficPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultAction"].write(value.defaultAction)
        try writer["MaxMessageSizeBytes"].write(value.maxMessageSizeBytes)
        try writer["PolicyStatements"].writeList(value.policyStatements, memberWritingClosure: MailManagerClientTypes.PolicyStatement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrafficPolicyId"].write(value.trafficPolicyId)
        try writer["TrafficPolicyName"].write(value.trafficPolicyName)
    }
}

extension CreateAddonInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAddonInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAddonInstanceOutput()
        value.addonInstanceId = try reader["AddonInstanceId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAddonSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAddonSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAddonSubscriptionOutput()
        value.addonSubscriptionId = try reader["AddonSubscriptionId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateArchiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateArchiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateArchiveOutput()
        value.archiveId = try reader["ArchiveId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateIngressPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIngressPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngressPointOutput()
        value.ingressPointId = try reader["IngressPointId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRelayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRelayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRelayOutput()
        value.relayId = try reader["RelayId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRuleSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleSetOutput()
        value.ruleSetId = try reader["RuleSetId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTrafficPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTrafficPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrafficPolicyOutput()
        value.trafficPolicyId = try reader["TrafficPolicyId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAddonInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAddonInstanceOutput {
        return DeleteAddonInstanceOutput()
    }
}

extension DeleteAddonSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAddonSubscriptionOutput {
        return DeleteAddonSubscriptionOutput()
    }
}

extension DeleteArchiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteArchiveOutput {
        return DeleteArchiveOutput()
    }
}

extension DeleteIngressPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIngressPointOutput {
        return DeleteIngressPointOutput()
    }
}

extension DeleteRelayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRelayOutput {
        return DeleteRelayOutput()
    }
}

extension DeleteRuleSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleSetOutput {
        return DeleteRuleSetOutput()
    }
}

extension DeleteTrafficPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTrafficPolicyOutput {
        return DeleteTrafficPolicyOutput()
    }
}

extension GetAddonInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAddonInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAddonInstanceOutput()
        value.addonInstanceArn = try reader["AddonInstanceArn"].readIfPresent()
        value.addonName = try reader["AddonName"].readIfPresent()
        value.addonSubscriptionId = try reader["AddonSubscriptionId"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetAddonSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAddonSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAddonSubscriptionOutput()
        value.addonName = try reader["AddonName"].readIfPresent()
        value.addonSubscriptionArn = try reader["AddonSubscriptionArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetArchiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveOutput()
        value.archiveArn = try reader["ArchiveArn"].readIfPresent() ?? ""
        value.archiveId = try reader["ArchiveId"].readIfPresent() ?? ""
        value.archiveName = try reader["ArchiveName"].readIfPresent() ?? ""
        value.archiveState = try reader["ArchiveState"].readIfPresent() ?? .sdkUnknown("")
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.retention = try reader["Retention"].readIfPresent(with: MailManagerClientTypes.ArchiveRetention.read(from:))
        return value
    }
}

extension GetArchiveExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveExportOutput()
        value.archiveId = try reader["ArchiveId"].readIfPresent()
        value.exportDestinationConfiguration = try reader["ExportDestinationConfiguration"].readIfPresent(with: MailManagerClientTypes.ExportDestinationConfiguration.read(from:))
        value.filters = try reader["Filters"].readIfPresent(with: MailManagerClientTypes.ArchiveFilters.read(from:))
        value.fromTimestamp = try reader["FromTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: MailManagerClientTypes.ExportStatus.read(from:))
        value.toTimestamp = try reader["ToTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetArchiveMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveMessageOutput()
        value.messageDownloadLink = try reader["MessageDownloadLink"].readIfPresent()
        return value
    }
}

extension GetArchiveMessageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveMessageContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveMessageContentOutput()
        value.body = try reader["Body"].readIfPresent(with: MailManagerClientTypes.MessageBody.read(from:))
        return value
    }
}

extension GetArchiveSearchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveSearchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveSearchOutput()
        value.archiveId = try reader["ArchiveId"].readIfPresent()
        value.filters = try reader["Filters"].readIfPresent(with: MailManagerClientTypes.ArchiveFilters.read(from:))
        value.fromTimestamp = try reader["FromTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: MailManagerClientTypes.SearchStatus.read(from:))
        value.toTimestamp = try reader["ToTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetArchiveSearchResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveSearchResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveSearchResultsOutput()
        value.rows = try reader["Rows"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.Row.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetIngressPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIngressPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngressPointOutput()
        value.aRecord = try reader["ARecord"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ingressPointArn = try reader["IngressPointArn"].readIfPresent()
        value.ingressPointAuthConfiguration = try reader["IngressPointAuthConfiguration"].readIfPresent(with: MailManagerClientTypes.IngressPointAuthConfiguration.read(from:))
        value.ingressPointId = try reader["IngressPointId"].readIfPresent() ?? ""
        value.ingressPointName = try reader["IngressPointName"].readIfPresent() ?? ""
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ruleSetId = try reader["RuleSetId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.trafficPolicyId = try reader["TrafficPolicyId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetRelayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRelayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRelayOutput()
        value.authentication = try reader["Authentication"].readIfPresent(with: MailManagerClientTypes.RelayAuthentication.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTimestamp = try reader["LastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.relayArn = try reader["RelayArn"].readIfPresent()
        value.relayId = try reader["RelayId"].readIfPresent() ?? ""
        value.relayName = try reader["RelayName"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.serverPort = try reader["ServerPort"].readIfPresent()
        return value
    }
}

extension GetRuleSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuleSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuleSetOutput()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModificationDate = try reader["LastModificationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ruleSetArn = try reader["RuleSetArn"].readIfPresent() ?? ""
        value.ruleSetId = try reader["RuleSetId"].readIfPresent() ?? ""
        value.ruleSetName = try reader["RuleSetName"].readIfPresent() ?? ""
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetTrafficPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrafficPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrafficPolicyOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultAction = try reader["DefaultAction"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxMessageSizeBytes = try reader["MaxMessageSizeBytes"].readIfPresent()
        value.policyStatements = try reader["PolicyStatements"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.PolicyStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.trafficPolicyArn = try reader["TrafficPolicyArn"].readIfPresent()
        value.trafficPolicyId = try reader["TrafficPolicyId"].readIfPresent() ?? ""
        value.trafficPolicyName = try reader["TrafficPolicyName"].readIfPresent() ?? ""
        return value
    }
}

extension ListAddonInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAddonInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAddonInstancesOutput()
        value.addonInstances = try reader["AddonInstances"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.AddonInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAddonSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAddonSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAddonSubscriptionsOutput()
        value.addonSubscriptions = try reader["AddonSubscriptions"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.AddonSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListArchiveExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListArchiveExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListArchiveExportsOutput()
        value.exports = try reader["Exports"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.ExportSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListArchivesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListArchivesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListArchivesOutput()
        value.archives = try reader["Archives"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.Archive.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListArchiveSearchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListArchiveSearchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListArchiveSearchesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.searches = try reader["Searches"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.SearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListIngressPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIngressPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngressPointsOutput()
        value.ingressPoints = try reader["IngressPoints"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.IngressPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRelaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRelaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRelaysOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.relays = try reader["Relays"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.Relay.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRuleSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRuleSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRuleSetsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.ruleSets = try reader["RuleSets"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.RuleSet.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTrafficPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrafficPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrafficPoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.trafficPolicies = try reader["TrafficPolicies"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.TrafficPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartArchiveExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartArchiveExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartArchiveExportOutput()
        value.exportId = try reader["ExportId"].readIfPresent()
        return value
    }
}

extension StartArchiveSearchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartArchiveSearchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartArchiveSearchOutput()
        value.searchId = try reader["SearchId"].readIfPresent()
        return value
    }
}

extension StopArchiveExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopArchiveExportOutput {
        return StopArchiveExportOutput()
    }
}

extension StopArchiveSearchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopArchiveSearchOutput {
        return StopArchiveSearchOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateArchiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateArchiveOutput {
        return UpdateArchiveOutput()
    }
}

extension UpdateIngressPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIngressPointOutput {
        return UpdateIngressPointOutput()
    }
}

extension UpdateRelayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRelayOutput {
        return UpdateRelayOutput()
    }
}

extension UpdateRuleSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleSetOutput {
        return UpdateRuleSetOutput()
    }
}

extension UpdateTrafficPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTrafficPolicyOutput {
        return UpdateTrafficPolicyOutput()
    }
}

enum CreateAddonInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAddonSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateArchiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIngressPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRelayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRuleSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTrafficPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAddonInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAddonSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteArchiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIngressPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRelayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTrafficPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAddonInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAddonSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveMessageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveSearchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveSearchResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIngressPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRelayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuleSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrafficPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAddonInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAddonSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListArchiveExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListArchivesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListArchiveSearchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIngressPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRelaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRuleSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrafficPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartArchiveExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartArchiveSearchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopArchiveExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopArchiveSearchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateArchiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIngressPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRelayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTrafficPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MailManagerClientTypes.ArchiveRetention {

    static func write(value: MailManagerClientTypes.ArchiveRetention?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .retentionperiod(retentionperiod):
                try writer["RetentionPeriod"].write(retentionperiod)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveRetention {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "RetentionPeriod":
                return .retentionperiod(try reader["RetentionPeriod"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.ArchiveFilters {

    static func write(value: MailManagerClientTypes.ArchiveFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Include"].writeList(value.include, memberWritingClosure: MailManagerClientTypes.ArchiveFilterCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Unless"].writeList(value.unless, memberWritingClosure: MailManagerClientTypes.ArchiveFilterCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ArchiveFilters()
        value.include = try reader["Include"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.ArchiveFilterCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unless = try reader["Unless"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.ArchiveFilterCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MailManagerClientTypes.ArchiveFilterCondition {

    static func write(value: MailManagerClientTypes.ArchiveFilterCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .booleanexpression(booleanexpression):
                try writer["BooleanExpression"].write(booleanexpression, with: MailManagerClientTypes.ArchiveBooleanExpression.write(value:to:))
            case let .stringexpression(stringexpression):
                try writer["StringExpression"].write(stringexpression, with: MailManagerClientTypes.ArchiveStringExpression.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveFilterCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "StringExpression":
                return .stringexpression(try reader["StringExpression"].read(with: MailManagerClientTypes.ArchiveStringExpression.read(from:)))
            case "BooleanExpression":
                return .booleanexpression(try reader["BooleanExpression"].read(with: MailManagerClientTypes.ArchiveBooleanExpression.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.ArchiveBooleanExpression {

    static func write(value: MailManagerClientTypes.ArchiveBooleanExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.ArchiveBooleanToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveBooleanExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ArchiveBooleanExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.ArchiveBooleanToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MailManagerClientTypes.ArchiveBooleanToEvaluate {

    static func write(value: MailManagerClientTypes.ArchiveBooleanToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveBooleanToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.ArchiveStringExpression {

    static func write(value: MailManagerClientTypes.ArchiveStringExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.ArchiveStringToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveStringExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ArchiveStringExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.ArchiveStringToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.ArchiveStringToEvaluate {

    static func write(value: MailManagerClientTypes.ArchiveStringToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveStringToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.ExportDestinationConfiguration {

    static func write(value: MailManagerClientTypes.ExportDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3(s3):
                try writer["S3"].write(s3, with: MailManagerClientTypes.S3ExportDestinationConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ExportDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3":
                return .s3(try reader["S3"].read(with: MailManagerClientTypes.S3ExportDestinationConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.S3ExportDestinationConfiguration {

    static func write(value: MailManagerClientTypes.S3ExportDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Location"].write(value.s3Location)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.S3ExportDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.S3ExportDestinationConfiguration()
        value.s3Location = try reader["S3Location"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.ExportStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ExportStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ExportStatus()
        value.submissionTimestamp = try reader["SubmissionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTimestamp = try reader["CompletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.MessageBody {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.MessageBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.MessageBody()
        value.text = try reader["Text"].readIfPresent()
        value.html = try reader["Html"].readIfPresent()
        value.messageMalformed = try reader["MessageMalformed"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.SearchStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.SearchStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.SearchStatus()
        value.submissionTimestamp = try reader["SubmissionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTimestamp = try reader["CompletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.Row {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.Row {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.Row()
        value.archivedMessageId = try reader["ArchivedMessageId"].readIfPresent()
        value.receivedTimestamp = try reader["ReceivedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.date = try reader["Date"].readIfPresent()
        value.to = try reader["To"].readIfPresent()
        value.from = try reader["From"].readIfPresent()
        value.cc = try reader["Cc"].readIfPresent()
        value.subject = try reader["Subject"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.hasAttachments = try reader["HasAttachments"].readIfPresent()
        value.receivedHeaders = try reader["ReceivedHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inReplyTo = try reader["InReplyTo"].readIfPresent()
        value.xMailer = try reader["XMailer"].readIfPresent()
        value.xOriginalMailer = try reader["XOriginalMailer"].readIfPresent()
        value.xPriority = try reader["XPriority"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.IngressPointAuthConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressPointAuthConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressPointAuthConfiguration()
        value.ingressPointPasswordConfiguration = try reader["IngressPointPasswordConfiguration"].readIfPresent(with: MailManagerClientTypes.IngressPointPasswordConfiguration.read(from:))
        value.secretArn = try reader["SecretArn"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.IngressPointPasswordConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressPointPasswordConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressPointPasswordConfiguration()
        value.smtpPasswordVersion = try reader["SmtpPasswordVersion"].readIfPresent()
        value.previousSmtpPasswordVersion = try reader["PreviousSmtpPasswordVersion"].readIfPresent()
        value.previousSmtpPasswordExpiryTimestamp = try reader["PreviousSmtpPasswordExpiryTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MailManagerClientTypes.RelayAuthentication {

    static func write(value: MailManagerClientTypes.RelayAuthentication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .noauthentication(noauthentication):
                try writer["NoAuthentication"].write(noauthentication, with: MailManagerClientTypes.NoAuthentication.write(value:to:))
            case let .secretarn(secretarn):
                try writer["SecretArn"].write(secretarn)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RelayAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "SecretArn":
                return .secretarn(try reader["SecretArn"].read())
            case "NoAuthentication":
                return .noauthentication(try reader["NoAuthentication"].read(with: MailManagerClientTypes.NoAuthentication.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.NoAuthentication {

    static func write(value: MailManagerClientTypes.NoAuthentication?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.NoAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MailManagerClientTypes.NoAuthentication()
    }
}

extension MailManagerClientTypes.Rule {

    static func write(value: MailManagerClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: MailManagerClientTypes.RuleAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Conditions"].writeList(value.conditions, memberWritingClosure: MailManagerClientTypes.RuleCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Unless"].writeList(value.unless, memberWritingClosure: MailManagerClientTypes.RuleCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.Rule()
        value.name = try reader["Name"].readIfPresent()
        value.conditions = try reader["Conditions"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.RuleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unless = try reader["Unless"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.RuleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.RuleAction.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.RuleAction {

    static func write(value: MailManagerClientTypes.RuleAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .addheader(addheader):
                try writer["AddHeader"].write(addheader, with: MailManagerClientTypes.AddHeaderAction.write(value:to:))
            case let .archive(archive):
                try writer["Archive"].write(archive, with: MailManagerClientTypes.ArchiveAction.write(value:to:))
            case let .delivertomailbox(delivertomailbox):
                try writer["DeliverToMailbox"].write(delivertomailbox, with: MailManagerClientTypes.DeliverToMailboxAction.write(value:to:))
            case let .drop(drop):
                try writer["Drop"].write(drop, with: MailManagerClientTypes.DropAction.write(value:to:))
            case let .relay(relay):
                try writer["Relay"].write(relay, with: MailManagerClientTypes.RelayAction.write(value:to:))
            case let .replacerecipient(replacerecipient):
                try writer["ReplaceRecipient"].write(replacerecipient, with: MailManagerClientTypes.ReplaceRecipientAction.write(value:to:))
            case let .send(send):
                try writer["Send"].write(send, with: MailManagerClientTypes.SendAction.write(value:to:))
            case let .writetos3(writetos3):
                try writer["WriteToS3"].write(writetos3, with: MailManagerClientTypes.S3Action.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Drop":
                return .drop(try reader["Drop"].read(with: MailManagerClientTypes.DropAction.read(from:)))
            case "Relay":
                return .relay(try reader["Relay"].read(with: MailManagerClientTypes.RelayAction.read(from:)))
            case "Archive":
                return .archive(try reader["Archive"].read(with: MailManagerClientTypes.ArchiveAction.read(from:)))
            case "WriteToS3":
                return .writetos3(try reader["WriteToS3"].read(with: MailManagerClientTypes.S3Action.read(from:)))
            case "Send":
                return .send(try reader["Send"].read(with: MailManagerClientTypes.SendAction.read(from:)))
            case "AddHeader":
                return .addheader(try reader["AddHeader"].read(with: MailManagerClientTypes.AddHeaderAction.read(from:)))
            case "ReplaceRecipient":
                return .replacerecipient(try reader["ReplaceRecipient"].read(with: MailManagerClientTypes.ReplaceRecipientAction.read(from:)))
            case "DeliverToMailbox":
                return .delivertomailbox(try reader["DeliverToMailbox"].read(with: MailManagerClientTypes.DeliverToMailboxAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.DeliverToMailboxAction {

    static func write(value: MailManagerClientTypes.DeliverToMailboxAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionFailurePolicy"].write(value.actionFailurePolicy)
        try writer["MailboxArn"].write(value.mailboxArn)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.DeliverToMailboxAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.DeliverToMailboxAction()
        value.actionFailurePolicy = try reader["ActionFailurePolicy"].readIfPresent()
        value.mailboxArn = try reader["MailboxArn"].readIfPresent() ?? ""
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.ReplaceRecipientAction {

    static func write(value: MailManagerClientTypes.ReplaceRecipientAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplaceWith"].writeList(value.replaceWith, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ReplaceRecipientAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ReplaceRecipientAction()
        value.replaceWith = try reader["ReplaceWith"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MailManagerClientTypes.AddHeaderAction {

    static func write(value: MailManagerClientTypes.AddHeaderAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HeaderName"].write(value.headerName)
        try writer["HeaderValue"].write(value.headerValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.AddHeaderAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.AddHeaderAction()
        value.headerName = try reader["HeaderName"].readIfPresent() ?? ""
        value.headerValue = try reader["HeaderValue"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.SendAction {

    static func write(value: MailManagerClientTypes.SendAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionFailurePolicy"].write(value.actionFailurePolicy)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.SendAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.SendAction()
        value.actionFailurePolicy = try reader["ActionFailurePolicy"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.S3Action {

    static func write(value: MailManagerClientTypes.S3Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionFailurePolicy"].write(value.actionFailurePolicy)
        try writer["RoleArn"].write(value.roleArn)
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Prefix"].write(value.s3Prefix)
        try writer["S3SseKmsKeyId"].write(value.s3SseKmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.S3Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.S3Action()
        value.actionFailurePolicy = try reader["ActionFailurePolicy"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.s3Bucket = try reader["S3Bucket"].readIfPresent() ?? ""
        value.s3Prefix = try reader["S3Prefix"].readIfPresent()
        value.s3SseKmsKeyId = try reader["S3SseKmsKeyId"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.ArchiveAction {

    static func write(value: MailManagerClientTypes.ArchiveAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionFailurePolicy"].write(value.actionFailurePolicy)
        try writer["TargetArchive"].write(value.targetArchive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ArchiveAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ArchiveAction()
        value.actionFailurePolicy = try reader["ActionFailurePolicy"].readIfPresent()
        value.targetArchive = try reader["TargetArchive"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.RelayAction {

    static func write(value: MailManagerClientTypes.RelayAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionFailurePolicy"].write(value.actionFailurePolicy)
        try writer["MailFrom"].write(value.mailFrom)
        try writer["Relay"].write(value.relay)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RelayAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RelayAction()
        value.actionFailurePolicy = try reader["ActionFailurePolicy"].readIfPresent()
        value.relay = try reader["Relay"].readIfPresent() ?? ""
        value.mailFrom = try reader["MailFrom"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.DropAction {

    static func write(value: MailManagerClientTypes.DropAction?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.DropAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MailManagerClientTypes.DropAction()
    }
}

extension MailManagerClientTypes.RuleCondition {

    static func write(value: MailManagerClientTypes.RuleCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .booleanexpression(booleanexpression):
                try writer["BooleanExpression"].write(booleanexpression, with: MailManagerClientTypes.RuleBooleanExpression.write(value:to:))
            case let .dmarcexpression(dmarcexpression):
                try writer["DmarcExpression"].write(dmarcexpression, with: MailManagerClientTypes.RuleDmarcExpression.write(value:to:))
            case let .ipexpression(ipexpression):
                try writer["IpExpression"].write(ipexpression, with: MailManagerClientTypes.RuleIpExpression.write(value:to:))
            case let .numberexpression(numberexpression):
                try writer["NumberExpression"].write(numberexpression, with: MailManagerClientTypes.RuleNumberExpression.write(value:to:))
            case let .stringexpression(stringexpression):
                try writer["StringExpression"].write(stringexpression, with: MailManagerClientTypes.RuleStringExpression.write(value:to:))
            case let .verdictexpression(verdictexpression):
                try writer["VerdictExpression"].write(verdictexpression, with: MailManagerClientTypes.RuleVerdictExpression.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "BooleanExpression":
                return .booleanexpression(try reader["BooleanExpression"].read(with: MailManagerClientTypes.RuleBooleanExpression.read(from:)))
            case "StringExpression":
                return .stringexpression(try reader["StringExpression"].read(with: MailManagerClientTypes.RuleStringExpression.read(from:)))
            case "NumberExpression":
                return .numberexpression(try reader["NumberExpression"].read(with: MailManagerClientTypes.RuleNumberExpression.read(from:)))
            case "IpExpression":
                return .ipexpression(try reader["IpExpression"].read(with: MailManagerClientTypes.RuleIpExpression.read(from:)))
            case "VerdictExpression":
                return .verdictexpression(try reader["VerdictExpression"].read(with: MailManagerClientTypes.RuleVerdictExpression.read(from:)))
            case "DmarcExpression":
                return .dmarcexpression(try reader["DmarcExpression"].read(with: MailManagerClientTypes.RuleDmarcExpression.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.RuleDmarcExpression {

    static func write(value: MailManagerClientTypes.RuleDmarcExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MailManagerClientTypes.RuleDmarcPolicy>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleDmarcExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleDmarcExpression()
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MailManagerClientTypes.RuleDmarcPolicy>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.RuleVerdictExpression {

    static func write(value: MailManagerClientTypes.RuleVerdictExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.RuleVerdictToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MailManagerClientTypes.RuleVerdict>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleVerdictExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleVerdictExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.RuleVerdictToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MailManagerClientTypes.RuleVerdict>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.RuleVerdictToEvaluate {

    static func write(value: MailManagerClientTypes.RuleVerdictToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .analysis(analysis):
                try writer["Analysis"].write(analysis, with: MailManagerClientTypes.Analysis.write(value:to:))
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleVerdictToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            case "Analysis":
                return .analysis(try reader["Analysis"].read(with: MailManagerClientTypes.Analysis.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.Analysis {

    static func write(value: MailManagerClientTypes.Analysis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Analyzer"].write(value.analyzer)
        try writer["ResultField"].write(value.resultField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.Analysis {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.Analysis()
        value.analyzer = try reader["Analyzer"].readIfPresent() ?? ""
        value.resultField = try reader["ResultField"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.RuleIpExpression {

    static func write(value: MailManagerClientTypes.RuleIpExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.RuleIpToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleIpExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleIpExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.RuleIpToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.RuleIpToEvaluate {

    static func write(value: MailManagerClientTypes.RuleIpToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleIpToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.RuleNumberExpression {

    static func write(value: MailManagerClientTypes.RuleNumberExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.RuleNumberToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleNumberExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleNumberExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.RuleNumberToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension MailManagerClientTypes.RuleNumberToEvaluate {

    static func write(value: MailManagerClientTypes.RuleNumberToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleNumberToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.RuleStringExpression {

    static func write(value: MailManagerClientTypes.RuleStringExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.RuleStringToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleStringExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleStringExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.RuleStringToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.RuleStringToEvaluate {

    static func write(value: MailManagerClientTypes.RuleStringToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .mimeheaderattribute(mimeheaderattribute):
                try writer["MimeHeaderAttribute"].write(mimeheaderattribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleStringToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            case "MimeHeaderAttribute":
                return .mimeheaderattribute(try reader["MimeHeaderAttribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.RuleBooleanExpression {

    static func write(value: MailManagerClientTypes.RuleBooleanExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.RuleBooleanToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleBooleanExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleBooleanExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.RuleBooleanToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MailManagerClientTypes.RuleBooleanToEvaluate {

    static func write(value: MailManagerClientTypes.RuleBooleanToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleBooleanToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.PolicyStatement {

    static func write(value: MailManagerClientTypes.PolicyStatement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Conditions"].writeList(value.conditions, memberWritingClosure: MailManagerClientTypes.PolicyCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.PolicyStatement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.PolicyStatement()
        value.conditions = try reader["Conditions"].readListIfPresent(memberReadingClosure: MailManagerClientTypes.PolicyCondition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.action = try reader["Action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MailManagerClientTypes.PolicyCondition {

    static func write(value: MailManagerClientTypes.PolicyCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .booleanexpression(booleanexpression):
                try writer["BooleanExpression"].write(booleanexpression, with: MailManagerClientTypes.IngressBooleanExpression.write(value:to:))
            case let .ipexpression(ipexpression):
                try writer["IpExpression"].write(ipexpression, with: MailManagerClientTypes.IngressIpv4Expression.write(value:to:))
            case let .stringexpression(stringexpression):
                try writer["StringExpression"].write(stringexpression, with: MailManagerClientTypes.IngressStringExpression.write(value:to:))
            case let .tlsexpression(tlsexpression):
                try writer["TlsExpression"].write(tlsexpression, with: MailManagerClientTypes.IngressTlsProtocolExpression.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.PolicyCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "StringExpression":
                return .stringexpression(try reader["StringExpression"].read(with: MailManagerClientTypes.IngressStringExpression.read(from:)))
            case "IpExpression":
                return .ipexpression(try reader["IpExpression"].read(with: MailManagerClientTypes.IngressIpv4Expression.read(from:)))
            case "TlsExpression":
                return .tlsexpression(try reader["TlsExpression"].read(with: MailManagerClientTypes.IngressTlsProtocolExpression.read(from:)))
            case "BooleanExpression":
                return .booleanexpression(try reader["BooleanExpression"].read(with: MailManagerClientTypes.IngressBooleanExpression.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.IngressBooleanExpression {

    static func write(value: MailManagerClientTypes.IngressBooleanExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.IngressBooleanToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressBooleanExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressBooleanExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.IngressBooleanToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MailManagerClientTypes.IngressBooleanToEvaluate {

    static func write(value: MailManagerClientTypes.IngressBooleanToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .analysis(analysis):
                try writer["Analysis"].write(analysis, with: MailManagerClientTypes.IngressAnalysis.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressBooleanToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Analysis":
                return .analysis(try reader["Analysis"].read(with: MailManagerClientTypes.IngressAnalysis.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.IngressAnalysis {

    static func write(value: MailManagerClientTypes.IngressAnalysis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Analyzer"].write(value.analyzer)
        try writer["ResultField"].write(value.resultField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressAnalysis {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressAnalysis()
        value.analyzer = try reader["Analyzer"].readIfPresent() ?? ""
        value.resultField = try reader["ResultField"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.IngressTlsProtocolExpression {

    static func write(value: MailManagerClientTypes.IngressTlsProtocolExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.IngressTlsProtocolToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressTlsProtocolExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressTlsProtocolExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.IngressTlsProtocolToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MailManagerClientTypes.IngressTlsProtocolToEvaluate {

    static func write(value: MailManagerClientTypes.IngressTlsProtocolToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressTlsProtocolToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.IngressIpv4Expression {

    static func write(value: MailManagerClientTypes.IngressIpv4Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.IngressIpToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressIpv4Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressIpv4Expression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.IngressIpToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.IngressIpToEvaluate {

    static func write(value: MailManagerClientTypes.IngressIpToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressIpToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.IngressStringExpression {

    static func write(value: MailManagerClientTypes.IngressStringExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluate"].write(value.evaluate, with: MailManagerClientTypes.IngressStringToEvaluate.write(value:to:))
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressStringExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressStringExpression()
        value.evaluate = try reader["Evaluate"].readIfPresent(with: MailManagerClientTypes.IngressStringToEvaluate.read(from:))
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MailManagerClientTypes.IngressStringToEvaluate {

    static func write(value: MailManagerClientTypes.IngressStringToEvaluate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .attribute(attribute):
                try writer["Attribute"].write(attribute)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressStringToEvaluate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Attribute":
                return .attribute(try reader["Attribute"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MailManagerClientTypes.AddonInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.AddonInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.AddonInstance()
        value.addonInstanceId = try reader["AddonInstanceId"].readIfPresent()
        value.addonSubscriptionId = try reader["AddonSubscriptionId"].readIfPresent()
        value.addonName = try reader["AddonName"].readIfPresent()
        value.addonInstanceArn = try reader["AddonInstanceArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MailManagerClientTypes.AddonSubscription {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.AddonSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.AddonSubscription()
        value.addonSubscriptionId = try reader["AddonSubscriptionId"].readIfPresent()
        value.addonName = try reader["AddonName"].readIfPresent()
        value.addonSubscriptionArn = try reader["AddonSubscriptionArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MailManagerClientTypes.ExportSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.ExportSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.ExportSummary()
        value.exportId = try reader["ExportId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: MailManagerClientTypes.ExportStatus.read(from:))
        return value
    }
}

extension MailManagerClientTypes.Archive {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.Archive {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.Archive()
        value.archiveId = try reader["ArchiveId"].readIfPresent() ?? ""
        value.archiveName = try reader["ArchiveName"].readIfPresent()
        value.archiveState = try reader["ArchiveState"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MailManagerClientTypes.SearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.SearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.SearchSummary()
        value.searchId = try reader["SearchId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: MailManagerClientTypes.SearchStatus.read(from:))
        return value
    }
}

extension MailManagerClientTypes.IngressPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.IngressPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.IngressPoint()
        value.ingressPointName = try reader["IngressPointName"].readIfPresent() ?? ""
        value.ingressPointId = try reader["IngressPointId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.aRecord = try reader["ARecord"].readIfPresent()
        return value
    }
}

extension MailManagerClientTypes.Relay {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.Relay {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.Relay()
        value.relayId = try reader["RelayId"].readIfPresent()
        value.relayName = try reader["RelayName"].readIfPresent()
        value.lastModifiedTimestamp = try reader["LastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MailManagerClientTypes.RuleSet {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.RuleSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.RuleSet()
        value.ruleSetId = try reader["RuleSetId"].readIfPresent()
        value.ruleSetName = try reader["RuleSetName"].readIfPresent()
        value.lastModificationDate = try reader["LastModificationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MailManagerClientTypes.Tag {

    static func write(value: MailManagerClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension MailManagerClientTypes.TrafficPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> MailManagerClientTypes.TrafficPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MailManagerClientTypes.TrafficPolicy()
        value.trafficPolicyName = try reader["TrafficPolicyName"].readIfPresent() ?? ""
        value.trafficPolicyId = try reader["TrafficPolicyId"].readIfPresent() ?? ""
        value.defaultAction = try reader["DefaultAction"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MailManagerClientTypes.IngressPointConfiguration {

    static func write(value: MailManagerClientTypes.IngressPointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .secretarn(secretarn):
                try writer["SecretArn"].write(secretarn)
            case let .smtppassword(smtppassword):
                try writer["SmtpPassword"].write(smtppassword)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

public enum MailManagerClientTypes {}
