// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SagemakerEdgeClientTypes.Checksum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sum = "Sum"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sum = self.sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.ChecksumType.self, forKey: .type)
        type = typeDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sum)
        sum = sumDecoded
    }
}

extension SagemakerEdgeClientTypes {
    /// Information about the checksum of a model deployed on a device.
    public struct Checksum: Swift.Equatable {
        /// The checksum of the model.
        public var sum: Swift.String?
        /// The type of the checksum.
        public var type: SagemakerEdgeClientTypes.ChecksumType?

        public init(
            sum: Swift.String? = nil,
            type: SagemakerEdgeClientTypes.ChecksumType? = nil
        )
        {
            self.sum = sum
            self.type = type
        }
    }

}

extension SagemakerEdgeClientTypes {
    public enum ChecksumType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha1
        case sdkUnknown(Swift.String)

        public static var allCases: [ChecksumType] {
            return [
                .sha1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "SHA1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChecksumType(rawValue: rawValue) ?? ChecksumType.sdkUnknown(rawValue)
        }
    }
}

extension SagemakerEdgeClientTypes.Definition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum = "Checksum"
        case modelHandle = "ModelHandle"
        case s3Url = "S3Url"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checksum = self.checksum {
            try encodeContainer.encode(checksum, forKey: .checksum)
        }
        if let modelHandle = self.modelHandle {
            try encodeContainer.encode(modelHandle, forKey: .modelHandle)
        }
        if let s3Url = self.s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelHandleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelHandle)
        modelHandle = modelHandleDecoded
        let s3UrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.Checksum.self, forKey: .checksum)
        checksum = checksumDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.ModelState.self, forKey: .state)
        state = stateDecoded
    }
}

extension SagemakerEdgeClientTypes {
    ///
    public struct Definition: Swift.Equatable {
        /// The checksum information of the model.
        public var checksum: SagemakerEdgeClientTypes.Checksum?
        /// The unique model handle.
        public var modelHandle: Swift.String?
        /// The absolute S3 location of the model.
        public var s3Url: Swift.String?
        /// The desired state of the model.
        public var state: SagemakerEdgeClientTypes.ModelState?

        public init(
            checksum: SagemakerEdgeClientTypes.Checksum? = nil,
            modelHandle: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            state: SagemakerEdgeClientTypes.ModelState? = nil
        )
        {
            self.checksum = checksum
            self.modelHandle = modelHandle
            self.s3Url = s3Url
            self.state = state
        }
    }

}

extension SagemakerEdgeClientTypes.DeploymentModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "DesiredState"
        case modelHandle = "ModelHandle"
        case modelName = "ModelName"
        case modelVersion = "ModelVersion"
        case rollbackFailureReason = "RollbackFailureReason"
        case state = "State"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let modelHandle = self.modelHandle {
            try encodeContainer.encode(modelHandle, forKey: .modelHandle)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let rollbackFailureReason = self.rollbackFailureReason {
            try encodeContainer.encode(rollbackFailureReason, forKey: .rollbackFailureReason)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelHandleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelHandle)
        modelHandle = modelHandleDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let desiredStateDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.ModelState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.ModelState.self, forKey: .state)
        state = stateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let rollbackFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rollbackFailureReason)
        rollbackFailureReason = rollbackFailureReasonDecoded
    }
}

extension SagemakerEdgeClientTypes {
    ///
    public struct DeploymentModel: Swift.Equatable {
        /// The desired state of the model.
        public var desiredState: SagemakerEdgeClientTypes.ModelState?
        /// The unique handle of the model.
        public var modelHandle: Swift.String?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The version of the model.
        public var modelVersion: Swift.String?
        /// Returns the error message if there is a rollback.
        public var rollbackFailureReason: Swift.String?
        /// Returns the current state of the model.
        public var state: SagemakerEdgeClientTypes.ModelState?
        /// Returns the deployment status of the model.
        public var status: SagemakerEdgeClientTypes.DeploymentStatus?
        /// Returns the error message for the deployment status result.
        public var statusReason: Swift.String?

        public init(
            desiredState: SagemakerEdgeClientTypes.ModelState? = nil,
            modelHandle: Swift.String? = nil,
            modelName: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            rollbackFailureReason: Swift.String? = nil,
            state: SagemakerEdgeClientTypes.ModelState? = nil,
            status: SagemakerEdgeClientTypes.DeploymentStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.desiredState = desiredState
            self.modelHandle = modelHandle
            self.modelName = modelName
            self.modelVersion = modelVersion
            self.rollbackFailureReason = rollbackFailureReason
            self.state = state
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension SagemakerEdgeClientTypes.DeploymentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentEndTime = "DeploymentEndTime"
        case deploymentModels = "DeploymentModels"
        case deploymentName = "DeploymentName"
        case deploymentStartTime = "DeploymentStartTime"
        case deploymentStatus = "DeploymentStatus"
        case deploymentStatusMessage = "DeploymentStatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentEndTime = self.deploymentEndTime {
            try encodeContainer.encodeTimestamp(deploymentEndTime, format: .epochSeconds, forKey: .deploymentEndTime)
        }
        if let deploymentModels = deploymentModels {
            var deploymentModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentModels)
            for deploymentmodel0 in deploymentModels {
                try deploymentModelsContainer.encode(deploymentmodel0)
            }
        }
        if let deploymentName = self.deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentStartTime = self.deploymentStartTime {
            try encodeContainer.encodeTimestamp(deploymentStartTime, format: .epochSeconds, forKey: .deploymentStartTime)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let deploymentStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deploymentStartTime)
        deploymentStartTime = deploymentStartTimeDecoded
        let deploymentEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deploymentEndTime)
        deploymentEndTime = deploymentEndTimeDecoded
        let deploymentModelsContainer = try containerValues.decodeIfPresent([SagemakerEdgeClientTypes.DeploymentModel?].self, forKey: .deploymentModels)
        var deploymentModelsDecoded0:[SagemakerEdgeClientTypes.DeploymentModel]? = nil
        if let deploymentModelsContainer = deploymentModelsContainer {
            deploymentModelsDecoded0 = [SagemakerEdgeClientTypes.DeploymentModel]()
            for structure0 in deploymentModelsContainer {
                if let structure0 = structure0 {
                    deploymentModelsDecoded0?.append(structure0)
                }
            }
        }
        deploymentModels = deploymentModelsDecoded0
    }
}

extension SagemakerEdgeClientTypes {
    /// Information about the result of a deployment on an edge device that is registered with SageMaker Edge Manager.
    public struct DeploymentResult: Swift.Equatable {
        /// The timestamp of when the deployment was ended, and the agent got the deployment results.
        public var deploymentEndTime: ClientRuntime.Date?
        /// Returns a list of models deployed on the agent.
        public var deploymentModels: [SagemakerEdgeClientTypes.DeploymentModel]?
        /// The name and unique ID of the deployment.
        public var deploymentName: Swift.String?
        /// The timestamp of when the deployment was started on the agent.
        public var deploymentStartTime: ClientRuntime.Date?
        /// Returns the bucket error code.
        public var deploymentStatus: Swift.String?
        /// Returns the detailed error message.
        public var deploymentStatusMessage: Swift.String?

        public init(
            deploymentEndTime: ClientRuntime.Date? = nil,
            deploymentModels: [SagemakerEdgeClientTypes.DeploymentModel]? = nil,
            deploymentName: Swift.String? = nil,
            deploymentStartTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            deploymentStatusMessage: Swift.String? = nil
        )
        {
            self.deploymentEndTime = deploymentEndTime
            self.deploymentModels = deploymentModels
            self.deploymentName = deploymentName
            self.deploymentStartTime = deploymentStartTime
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
        }
    }

}

extension SagemakerEdgeClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .fail,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SagemakerEdgeClientTypes {
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case model
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .model,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .model: return "Model"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentType(rawValue: rawValue) ?? DeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension SagemakerEdgeClientTypes.EdgeDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case deploymentName = "DeploymentName"
        case failureHandlingPolicy = "FailureHandlingPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definitions = definitions {
            var definitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .definitions)
            for definition0 in definitions {
                try definitionsContainer.encode(definition0)
            }
        }
        if let deploymentName = self.deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let failureHandlingPolicy = self.failureHandlingPolicy {
            try encodeContainer.encode(failureHandlingPolicy.rawValue, forKey: .failureHandlingPolicy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.DeploymentType.self, forKey: .type)
        type = typeDecoded
        let failureHandlingPolicyDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.FailureHandlingPolicy.self, forKey: .failureHandlingPolicy)
        failureHandlingPolicy = failureHandlingPolicyDecoded
        let definitionsContainer = try containerValues.decodeIfPresent([SagemakerEdgeClientTypes.Definition?].self, forKey: .definitions)
        var definitionsDecoded0:[SagemakerEdgeClientTypes.Definition]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [SagemakerEdgeClientTypes.Definition]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
    }
}

extension SagemakerEdgeClientTypes {
    /// Information about a deployment on an edge device that is registered with SageMaker Edge Manager.
    public struct EdgeDeployment: Swift.Equatable {
        /// Returns a list of Definition objects.
        public var definitions: [SagemakerEdgeClientTypes.Definition]?
        /// The name and unique ID of the deployment.
        public var deploymentName: Swift.String?
        /// Determines whether to rollback to previous configuration if deployment fails.
        public var failureHandlingPolicy: SagemakerEdgeClientTypes.FailureHandlingPolicy?
        /// The type of the deployment.
        public var type: SagemakerEdgeClientTypes.DeploymentType?

        public init(
            definitions: [SagemakerEdgeClientTypes.Definition]? = nil,
            deploymentName: Swift.String? = nil,
            failureHandlingPolicy: SagemakerEdgeClientTypes.FailureHandlingPolicy? = nil,
            type: SagemakerEdgeClientTypes.DeploymentType? = nil
        )
        {
            self.definitions = definitions
            self.deploymentName = deploymentName
            self.failureHandlingPolicy = failureHandlingPolicy
            self.type = type
        }
    }

}

extension SagemakerEdgeClientTypes.EdgeMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension = "Dimension"
        case metricName = "MetricName"
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension SagemakerEdgeClientTypes {
    /// Information required for edge device metrics.
    public struct EdgeMetric: Swift.Equatable {
        /// The dimension of metrics published.
        public var dimension: Swift.String?
        /// Returns the name of the metric.
        public var metricName: Swift.String?
        /// Timestamp of when the metric was requested.
        public var timestamp: ClientRuntime.Date?
        /// Returns the value of the metric.
        public var value: Swift.Double

        public init(
            dimension: Swift.String? = nil,
            metricName: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.dimension = dimension
            self.metricName = metricName
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension SagemakerEdgeClientTypes {
    public enum FailureHandlingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case donothing
        case rollbackonfailure
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureHandlingPolicy] {
            return [
                .donothing,
                .rollbackonfailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .donothing: return "DO_NOTHING"
            case .rollbackonfailure: return "ROLLBACK_ON_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureHandlingPolicy(rawValue: rawValue) ?? FailureHandlingPolicy.sdkUnknown(rawValue)
        }
    }
}

extension GetDeploymentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceFleetName = self.deviceFleetName {
            try encodeContainer.encode(deviceFleetName, forKey: .deviceFleetName)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }
}

extension GetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDeployments"
    }
}

public struct GetDeploymentsInput: Swift.Equatable {
    /// The name of the fleet that the device belongs to.
    /// This member is required.
    public var deviceFleetName: Swift.String?
    /// The unique name of the device you want to get the configuration of active deployments from.
    /// This member is required.
    public var deviceName: Swift.String?

    public init(
        deviceFleetName: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
    }
}

struct GetDeploymentsInputBody: Swift.Equatable {
    let deviceName: Swift.String?
    let deviceFleetName: Swift.String?
}

extension GetDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceFleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceFleetName)
        deviceFleetName = deviceFleetNameDecoded
    }
}

extension GetDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
        } else {
            self.deployments = nil
        }
    }
}

public struct GetDeploymentsOutput: Swift.Equatable {
    /// Returns a list of the configurations of the active deployments on the device.
    public var deployments: [SagemakerEdgeClientTypes.EdgeDeployment]?

    public init(
        deployments: [SagemakerEdgeClientTypes.EdgeDeployment]? = nil
    )
    {
        self.deployments = deployments
    }
}

struct GetDeploymentsOutputBody: Swift.Equatable {
    let deployments: [SagemakerEdgeClientTypes.EdgeDeployment]?
}

extension GetDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([SagemakerEdgeClientTypes.EdgeDeployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[SagemakerEdgeClientTypes.EdgeDeployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [SagemakerEdgeClientTypes.EdgeDeployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
    }
}

enum GetDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeviceRegistrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceFleetName = self.deviceFleetName {
            try encodeContainer.encode(deviceFleetName, forKey: .deviceFleetName)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }
}

extension GetDeviceRegistrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDeviceRegistration"
    }
}

public struct GetDeviceRegistrationInput: Swift.Equatable {
    /// The name of the fleet that the device belongs to.
    /// This member is required.
    public var deviceFleetName: Swift.String?
    /// The unique name of the device you want to get the registration status from.
    /// This member is required.
    public var deviceName: Swift.String?

    public init(
        deviceFleetName: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
    }
}

struct GetDeviceRegistrationInputBody: Swift.Equatable {
    let deviceName: Swift.String?
    let deviceFleetName: Swift.String?
}

extension GetDeviceRegistrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceFleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceFleetName)
        deviceFleetName = deviceFleetNameDecoded
    }
}

extension GetDeviceRegistrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceRegistrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.cacheTTL = output.cacheTTL
            self.deviceRegistration = output.deviceRegistration
        } else {
            self.cacheTTL = nil
            self.deviceRegistration = nil
        }
    }
}

public struct GetDeviceRegistrationOutput: Swift.Equatable {
    /// The amount of time, in seconds, that the registration status is stored on the deviceâ€™s cache before it is refreshed.
    public var cacheTTL: Swift.String?
    /// Describes if the device is currently registered with SageMaker Edge Manager.
    public var deviceRegistration: Swift.String?

    public init(
        cacheTTL: Swift.String? = nil,
        deviceRegistration: Swift.String? = nil
    )
    {
        self.cacheTTL = cacheTTL
        self.deviceRegistration = deviceRegistration
    }
}

struct GetDeviceRegistrationOutputBody: Swift.Equatable {
    let deviceRegistration: Swift.String?
    let cacheTTL: Swift.String?
}

extension GetDeviceRegistrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheTTL = "CacheTTL"
        case deviceRegistration = "DeviceRegistration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceRegistration)
        deviceRegistration = deviceRegistrationDecoded
        let cacheTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheTTL)
        cacheTTL = cacheTTLDecoded
    }
}

enum GetDeviceRegistrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal failure occurred. Try your request again. If the problem persists, contact Amazon Web Services customer support.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SagemakerEdgeClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestInference = "LatestInference"
        case latestSampleTime = "LatestSampleTime"
        case modelMetrics = "ModelMetrics"
        case modelName = "ModelName"
        case modelVersion = "ModelVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestInference = self.latestInference {
            try encodeContainer.encodeTimestamp(latestInference, format: .epochSeconds, forKey: .latestInference)
        }
        if let latestSampleTime = self.latestSampleTime {
            try encodeContainer.encodeTimestamp(latestSampleTime, format: .epochSeconds, forKey: .latestSampleTime)
        }
        if let modelMetrics = modelMetrics {
            var modelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelMetrics)
            for edgemetric0 in modelMetrics {
                try modelMetricsContainer.encode(edgemetric0)
            }
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let latestSampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestSampleTime)
        latestSampleTime = latestSampleTimeDecoded
        let latestInferenceDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestInference)
        latestInference = latestInferenceDecoded
        let modelMetricsContainer = try containerValues.decodeIfPresent([SagemakerEdgeClientTypes.EdgeMetric?].self, forKey: .modelMetrics)
        var modelMetricsDecoded0:[SagemakerEdgeClientTypes.EdgeMetric]? = nil
        if let modelMetricsContainer = modelMetricsContainer {
            modelMetricsDecoded0 = [SagemakerEdgeClientTypes.EdgeMetric]()
            for structure0 in modelMetricsContainer {
                if let structure0 = structure0 {
                    modelMetricsDecoded0?.append(structure0)
                }
            }
        }
        modelMetrics = modelMetricsDecoded0
    }
}

extension SagemakerEdgeClientTypes {
    /// Information about a model deployed on an edge device that is registered with SageMaker Edge Manager.
    public struct Model: Swift.Equatable {
        /// The timestamp of the last inference that was made.
        public var latestInference: ClientRuntime.Date?
        /// The timestamp of the last data sample taken.
        public var latestSampleTime: ClientRuntime.Date?
        /// Information required for model metrics.
        public var modelMetrics: [SagemakerEdgeClientTypes.EdgeMetric]?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The version of the model.
        public var modelVersion: Swift.String?

        public init(
            latestInference: ClientRuntime.Date? = nil,
            latestSampleTime: ClientRuntime.Date? = nil,
            modelMetrics: [SagemakerEdgeClientTypes.EdgeMetric]? = nil,
            modelName: Swift.String? = nil,
            modelVersion: Swift.String? = nil
        )
        {
            self.latestInference = latestInference
            self.latestSampleTime = latestSampleTime
            self.modelMetrics = modelMetrics
            self.modelName = modelName
            self.modelVersion = modelVersion
        }
    }

}

extension SagemakerEdgeClientTypes {
    public enum ModelState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploy
        case undeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelState] {
            return [
                .deploy,
                .undeploy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploy: return "DEPLOY"
            case .undeploy: return "UNDEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelState(rawValue: rawValue) ?? ModelState.sdkUnknown(rawValue)
        }
    }
}

extension SendHeartbeatInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentMetrics = "AgentMetrics"
        case agentVersion = "AgentVersion"
        case deploymentResult = "DeploymentResult"
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
        case models = "Models"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentMetrics = agentMetrics {
            var agentMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentMetrics)
            for edgemetric0 in agentMetrics {
                try agentMetricsContainer.encode(edgemetric0)
            }
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let deploymentResult = self.deploymentResult {
            try encodeContainer.encode(deploymentResult, forKey: .deploymentResult)
        }
        if let deviceFleetName = self.deviceFleetName {
            try encodeContainer.encode(deviceFleetName, forKey: .deviceFleetName)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let models = models {
            var modelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .models)
            for model0 in models {
                try modelsContainer.encode(model0)
            }
        }
    }
}

extension SendHeartbeatInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SendHeartbeat"
    }
}

public struct SendHeartbeatInput: Swift.Equatable {
    /// For internal use. Returns a list of SageMaker Edge Manager agent operating metrics.
    public var agentMetrics: [SagemakerEdgeClientTypes.EdgeMetric]?
    /// Returns the version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Returns the result of a deployment on the device.
    public var deploymentResult: SagemakerEdgeClientTypes.DeploymentResult?
    /// The name of the fleet that the device belongs to.
    /// This member is required.
    public var deviceFleetName: Swift.String?
    /// The unique name of the device.
    /// This member is required.
    public var deviceName: Swift.String?
    /// Returns a list of models deployed on the the device.
    public var models: [SagemakerEdgeClientTypes.Model]?

    public init(
        agentMetrics: [SagemakerEdgeClientTypes.EdgeMetric]? = nil,
        agentVersion: Swift.String? = nil,
        deploymentResult: SagemakerEdgeClientTypes.DeploymentResult? = nil,
        deviceFleetName: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        models: [SagemakerEdgeClientTypes.Model]? = nil
    )
    {
        self.agentMetrics = agentMetrics
        self.agentVersion = agentVersion
        self.deploymentResult = deploymentResult
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
        self.models = models
    }
}

struct SendHeartbeatInputBody: Swift.Equatable {
    let agentMetrics: [SagemakerEdgeClientTypes.EdgeMetric]?
    let models: [SagemakerEdgeClientTypes.Model]?
    let agentVersion: Swift.String?
    let deviceName: Swift.String?
    let deviceFleetName: Swift.String?
    let deploymentResult: SagemakerEdgeClientTypes.DeploymentResult?
}

extension SendHeartbeatInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentMetrics = "AgentMetrics"
        case agentVersion = "AgentVersion"
        case deploymentResult = "DeploymentResult"
        case deviceFleetName = "DeviceFleetName"
        case deviceName = "DeviceName"
        case models = "Models"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentMetricsContainer = try containerValues.decodeIfPresent([SagemakerEdgeClientTypes.EdgeMetric?].self, forKey: .agentMetrics)
        var agentMetricsDecoded0:[SagemakerEdgeClientTypes.EdgeMetric]? = nil
        if let agentMetricsContainer = agentMetricsContainer {
            agentMetricsDecoded0 = [SagemakerEdgeClientTypes.EdgeMetric]()
            for structure0 in agentMetricsContainer {
                if let structure0 = structure0 {
                    agentMetricsDecoded0?.append(structure0)
                }
            }
        }
        agentMetrics = agentMetricsDecoded0
        let modelsContainer = try containerValues.decodeIfPresent([SagemakerEdgeClientTypes.Model?].self, forKey: .models)
        var modelsDecoded0:[SagemakerEdgeClientTypes.Model]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [SagemakerEdgeClientTypes.Model]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceFleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceFleetName)
        deviceFleetName = deviceFleetNameDecoded
        let deploymentResultDecoded = try containerValues.decodeIfPresent(SagemakerEdgeClientTypes.DeploymentResult.self, forKey: .deploymentResult)
        deploymentResult = deploymentResultDecoded
    }
}

extension SendHeartbeatOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendHeartbeatOutput: Swift.Equatable {

    public init() { }
}

enum SendHeartbeatOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
