// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternetMonitorClientTypes.AvailabilityMeasurement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experienceScore = "ExperienceScore"
        case percentOfClientLocationImpacted = "PercentOfClientLocationImpacted"
        case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let experienceScore = self.experienceScore {
            try encodeContainer.encode(experienceScore, forKey: .experienceScore)
        }
        if let percentOfClientLocationImpacted = self.percentOfClientLocationImpacted {
            try encodeContainer.encode(percentOfClientLocationImpacted, forKey: .percentOfClientLocationImpacted)
        }
        if let percentOfTotalTrafficImpacted = self.percentOfTotalTrafficImpacted {
            try encodeContainer.encode(percentOfTotalTrafficImpacted, forKey: .percentOfTotalTrafficImpacted)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experienceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .experienceScore)
        experienceScore = experienceScoreDecoded
        let percentOfTotalTrafficImpactedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfTotalTrafficImpacted)
        percentOfTotalTrafficImpacted = percentOfTotalTrafficImpactedDecoded
        let percentOfClientLocationImpactedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfClientLocationImpacted)
        percentOfClientLocationImpacted = percentOfClientLocationImpactedDecoded
    }
}

extension InternetMonitorClientTypes {
    /// Measurements about the availability for your application on the internet, calculated by Amazon CloudWatch Internet Monitor. Amazon Web Services has substantial historical data about internet performance and availability between Amazon Web Services services and different network providers and geographies. By applying statistical analysis to the data, Internet Monitor can detect when the performance and availability for your application has dropped, compared to an estimated baseline that's already calculated. To make it easier to see those drops, we report that information to you in the form of health scores: a performance score and an availability score. Availability in Internet Monitor represents the estimated percentage of traffic that is not seeing an availability drop. For example, an availability score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing an availability drop for that pair. For more information, see [ How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
    public struct AvailabilityMeasurement: Swift.Equatable {
        /// Experience scores, or health scores are calculated for different geographic and network provider combinations (that is, different granularities) and also summed into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and availability scores, and when it creates and resolves health events. For more information, see [ How Amazon Web Services calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var experienceScore: Swift.Double?
        /// The percentage of impact caused by a health event for client location traffic globally. For information about how Internet Monitor calculates impact, see [ Inside Internet Monitor](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
        public var percentOfClientLocationImpacted: Swift.Double?
        /// The percentage of impact caused by a health event for total traffic globally. For information about how Internet Monitor calculates impact, see [ Inside Internet Monitor](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
        public var percentOfTotalTrafficImpacted: Swift.Double?

        public init (
            experienceScore: Swift.Double? = nil,
            percentOfClientLocationImpacted: Swift.Double? = nil,
            percentOfTotalTrafficImpacted: Swift.Double? = nil
        )
        {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A bad request was received.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource is in use.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
        case monitorName = "MonitorName"
        case resources = "Resources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if maxCityNetworksToMonitor != 0 {
            try encodeContainer.encode(maxCityNetworksToMonitor, forKey: .maxCityNetworksToMonitor)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for arn0 in resources {
                try resourcesContainer.encode(arn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20210603/Monitors"
    }
}

public struct CreateMonitorInput: Swift.Equatable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The maximum number of city-network combinations (that is, combinations of a city location and network, such as an ISP) to be monitored for your resources.
    /// This member is required.
    public var maxCityNetworksToMonitor: Swift.Int
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). You can add a combination of Amazon Virtual Private Clouds (VPCs) and Amazon CloudFront distributions, or you can add Amazon WorkSpaces directories. You can't add all three types of resources. If you add only VPC resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet connectivity.
    public var resources: [Swift.String]?
    /// The tags for a monitor. You can add a maximum of 50 tags in Internet Monitor.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        maxCityNetworksToMonitor: Swift.Int = 0,
        monitorName: Swift.String? = nil,
        resources: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
        self.monitorName = monitorName
        self.resources = resources
        self.tags = tags
    }
}

struct CreateMonitorInputBody: Swift.Equatable {
    let monitorName: Swift.String?
    let resources: [Swift.String]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let maxCityNetworksToMonitor: Swift.Int
}

extension CreateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
        case monitorName = "MonitorName"
        case resources = "Resources"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let maxCityNetworksToMonitorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCityNetworksToMonitor) ?? 0
        maxCityNetworksToMonitor = maxCityNetworksToMonitorDecoded
    }
}

extension CreateMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.status = output.status
        } else {
            self.arn = nil
            self.status = nil
        }
    }
}

public struct CreateMonitorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var arn: Swift.String?
    /// The status of a monitor.
    /// This member is required.
    public var status: InternetMonitorClientTypes.MonitorConfigState?

    public init (
        arn: Swift.String? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil
    )
    {
        self.arn = arn
        self.status = status
    }
}

struct CreateMonitorOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let status: InternetMonitorClientTypes.MonitorConfigState?
}

extension CreateMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorConfigState.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())"
    }
}

public struct DeleteMonitorInput: Swift.Equatable {
    /// The name of the monitor to delete.
    /// This member is required.
    public var monitorName: Swift.String?

    public init (
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

struct DeleteMonitorInputBody: Swift.Equatable {
}

extension DeleteMonitorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMonitorOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetHealthEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        guard let eventId = eventId else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/HealthEvents/\(eventId.urlPercentEncoding())"
    }
}

public struct GetHealthEventInput: Swift.Equatable {
    /// The internally generated identifier of a health event. Because EventID contains the forward slash (“/”) character, you must URL-encode the EventID field in the request URL.
    /// This member is required.
    public var eventId: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?

    public init (
        eventId: Swift.String? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.monitorName = monitorName
    }
}

struct GetHealthEventInputBody: Swift.Equatable {
}

extension GetHealthEventInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetHealthEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHealthEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetHealthEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHealthEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetHealthEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.endedAt = output.endedAt
            self.eventArn = output.eventArn
            self.eventId = output.eventId
            self.impactType = output.impactType
            self.impactedLocations = output.impactedLocations
            self.lastUpdatedAt = output.lastUpdatedAt
            self.percentOfTotalTrafficImpacted = output.percentOfTotalTrafficImpacted
            self.startedAt = output.startedAt
            self.status = output.status
        } else {
            self.createdAt = nil
            self.endedAt = nil
            self.eventArn = nil
            self.eventId = nil
            self.impactType = nil
            self.impactedLocations = nil
            self.lastUpdatedAt = nil
            self.percentOfTotalTrafficImpacted = nil
            self.startedAt = nil
            self.status = nil
        }
    }
}

public struct GetHealthEventOutputResponse: Swift.Equatable {
    /// The time when a health event was created.
    public var createdAt: ClientRuntime.Date?
    /// The time when a health event was resolved. If the health event is still active, the end time is not set.
    public var endedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the event.
    /// This member is required.
    public var eventArn: Swift.String?
    /// The internally generated identifier of a health event.
    /// This member is required.
    public var eventId: Swift.String?
    /// The type of impairment of a specific health event.
    /// This member is required.
    public var impactType: InternetMonitorClientTypes.HealthEventImpactType?
    /// The locations affected by a health event.
    /// This member is required.
    public var impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]?
    /// The time when a health event was last updated or recalculated.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The impact on total traffic that a health event has.
    public var percentOfTotalTrafficImpacted: Swift.Double?
    /// The time when a health event started.
    /// This member is required.
    public var startedAt: ClientRuntime.Date?
    /// The status of a health event.
    /// This member is required.
    public var status: InternetMonitorClientTypes.HealthEventStatus?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        endedAt: ClientRuntime.Date? = nil,
        eventArn: Swift.String? = nil,
        eventId: Swift.String? = nil,
        impactType: InternetMonitorClientTypes.HealthEventImpactType? = nil,
        impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        percentOfTotalTrafficImpacted: Swift.Double? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: InternetMonitorClientTypes.HealthEventStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.endedAt = endedAt
        self.eventArn = eventArn
        self.eventId = eventId
        self.impactType = impactType
        self.impactedLocations = impactedLocations
        self.lastUpdatedAt = lastUpdatedAt
        self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
        self.startedAt = startedAt
        self.status = status
    }
}

struct GetHealthEventOutputResponseBody: Swift.Equatable {
    let eventArn: Swift.String?
    let eventId: Swift.String?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]?
    let status: InternetMonitorClientTypes.HealthEventStatus?
    let percentOfTotalTrafficImpacted: Swift.Double?
    let impactType: InternetMonitorClientTypes.HealthEventImpactType?
}

extension GetHealthEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case endedAt = "EndedAt"
        case eventArn = "EventArn"
        case eventId = "EventId"
        case impactType = "ImpactType"
        case impactedLocations = "ImpactedLocations"
        case lastUpdatedAt = "LastUpdatedAt"
        case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
        case startedAt = "StartedAt"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let impactedLocationsContainer = try containerValues.decodeIfPresent([InternetMonitorClientTypes.ImpactedLocation?].self, forKey: .impactedLocations)
        var impactedLocationsDecoded0:[InternetMonitorClientTypes.ImpactedLocation]? = nil
        if let impactedLocationsContainer = impactedLocationsContainer {
            impactedLocationsDecoded0 = [InternetMonitorClientTypes.ImpactedLocation]()
            for structure0 in impactedLocationsContainer {
                if let structure0 = structure0 {
                    impactedLocationsDecoded0?.append(structure0)
                }
            }
        }
        impactedLocations = impactedLocationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.HealthEventStatus.self, forKey: .status)
        status = statusDecoded
        let percentOfTotalTrafficImpactedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfTotalTrafficImpacted)
        percentOfTotalTrafficImpacted = percentOfTotalTrafficImpactedDecoded
        let impactTypeDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.HealthEventImpactType.self, forKey: .impactType)
        impactType = impactTypeDecoded
    }
}

extension GetMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())"
    }
}

public struct GetMonitorInput: Swift.Equatable {
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?

    public init (
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

struct GetMonitorInputBody: Swift.Equatable {
}

extension GetMonitorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.maxCityNetworksToMonitor = output.maxCityNetworksToMonitor
            self.modifiedAt = output.modifiedAt
            self.monitorArn = output.monitorArn
            self.monitorName = output.monitorName
            self.processingStatus = output.processingStatus
            self.processingStatusInfo = output.processingStatusInfo
            self.resources = output.resources
            self.status = output.status
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.maxCityNetworksToMonitor = 0
            self.modifiedAt = nil
            self.monitorArn = nil
            self.monitorName = nil
            self.processingStatus = nil
            self.processingStatusInfo = nil
            self.resources = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetMonitorOutputResponse: Swift.Equatable {
    /// The time when the monitor was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The maximum number of city-network combinations (that is, combinations of a city location and network, such as an ISP) to be monitored for your resources.
    /// This member is required.
    public var maxCityNetworksToMonitor: Swift.Int
    /// The last time that the monitor was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The health of the data processing for the monitor.
    public var processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode?
    /// Additional information about the health of the data processing for the monitor.
    public var processingStatusInfo: Swift.String?
    /// The resources that have been added for the monitor. Resources are listed by their Amazon Resource Names (ARNs).
    /// This member is required.
    public var resources: [Swift.String]?
    /// The status of the monitor.
    /// This member is required.
    public var status: InternetMonitorClientTypes.MonitorConfigState?
    /// The tags that have been added to monitor.
    public var tags: [Swift.String:Swift.String]?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        maxCityNetworksToMonitor: Swift.Int = 0,
        modifiedAt: ClientRuntime.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode? = nil,
        processingStatusInfo: Swift.String? = nil,
        resources: [Swift.String]? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.processingStatus = processingStatus
        self.processingStatusInfo = processingStatusInfo
        self.resources = resources
        self.status = status
        self.tags = tags
    }
}

struct GetMonitorOutputResponseBody: Swift.Equatable {
    let monitorName: Swift.String?
    let monitorArn: Swift.String?
    let resources: [Swift.String]?
    let status: InternetMonitorClientTypes.MonitorConfigState?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode?
    let processingStatusInfo: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let maxCityNetworksToMonitor: Swift.Int
}

extension GetMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
        case modifiedAt = "ModifiedAt"
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
        case processingStatus = "ProcessingStatus"
        case processingStatusInfo = "ProcessingStatusInfo"
        case resources = "Resources"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorConfigState.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let processingStatusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorProcessingStatusCode.self, forKey: .processingStatus)
        processingStatus = processingStatusDecoded
        let processingStatusInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .processingStatusInfo)
        processingStatusInfo = processingStatusInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let maxCityNetworksToMonitorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCityNetworksToMonitor) ?? 0
        maxCityNetworksToMonitor = maxCityNetworksToMonitorDecoded
    }
}

extension InternetMonitorClientTypes.HealthEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case endedAt = "EndedAt"
        case eventArn = "EventArn"
        case eventId = "EventId"
        case impactType = "ImpactType"
        case impactedLocations = "ImpactedLocations"
        case lastUpdatedAt = "LastUpdatedAt"
        case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
        case startedAt = "StartedAt"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let impactType = self.impactType {
            try encodeContainer.encode(impactType.rawValue, forKey: .impactType)
        }
        if let impactedLocations = impactedLocations {
            var impactedLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .impactedLocations)
            for impactedlocation0 in impactedLocations {
                try impactedLocationsContainer.encode(impactedlocation0)
            }
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let percentOfTotalTrafficImpacted = self.percentOfTotalTrafficImpacted {
            try encodeContainer.encode(percentOfTotalTrafficImpacted, forKey: .percentOfTotalTrafficImpacted)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let impactedLocationsContainer = try containerValues.decodeIfPresent([InternetMonitorClientTypes.ImpactedLocation?].self, forKey: .impactedLocations)
        var impactedLocationsDecoded0:[InternetMonitorClientTypes.ImpactedLocation]? = nil
        if let impactedLocationsContainer = impactedLocationsContainer {
            impactedLocationsDecoded0 = [InternetMonitorClientTypes.ImpactedLocation]()
            for structure0 in impactedLocationsContainer {
                if let structure0 = structure0 {
                    impactedLocationsDecoded0?.append(structure0)
                }
            }
        }
        impactedLocations = impactedLocationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.HealthEventStatus.self, forKey: .status)
        status = statusDecoded
        let percentOfTotalTrafficImpactedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfTotalTrafficImpacted)
        percentOfTotalTrafficImpacted = percentOfTotalTrafficImpactedDecoded
        let impactTypeDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.HealthEventImpactType.self, forKey: .impactType)
        impactType = impactTypeDecoded
    }
}

extension InternetMonitorClientTypes {
    /// Information about a health event created in a monitor in Amazon CloudWatch Internet Monitor.
    public struct HealthEvent: Swift.Equatable {
        /// When the health event was created.
        public var createdAt: ClientRuntime.Date?
        /// The time when a health event ended. If the health event is still active, then the end time is not set.
        public var endedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the event.
        /// This member is required.
        public var eventArn: Swift.String?
        /// The internally generated identifier of a specific network traffic impairment health event.
        /// This member is required.
        public var eventId: Swift.String?
        /// The type of impairment for a health event.
        /// This member is required.
        public var impactType: InternetMonitorClientTypes.HealthEventImpactType?
        /// The locations impacted by the health event.
        /// This member is required.
        public var impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]?
        /// When the health event was last updated.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The impact on global traffic monitored by this monitor for this health event.
        public var percentOfTotalTrafficImpacted: Swift.Double?
        /// When a health event started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// Health event list member.
        /// This member is required.
        public var status: InternetMonitorClientTypes.HealthEventStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            endedAt: ClientRuntime.Date? = nil,
            eventArn: Swift.String? = nil,
            eventId: Swift.String? = nil,
            impactType: InternetMonitorClientTypes.HealthEventImpactType? = nil,
            impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            percentOfTotalTrafficImpacted: Swift.Double? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: InternetMonitorClientTypes.HealthEventStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.impactType = impactType
            self.impactedLocations = impactedLocations
            self.lastUpdatedAt = lastUpdatedAt
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.startedAt = startedAt
            self.status = status
        }
    }

}

extension InternetMonitorClientTypes {
    public enum HealthEventImpactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case availability
        case performance
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthEventImpactType] {
            return [
                .availability,
                .performance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .availability: return "AVAILABILITY"
            case .performance: return "PERFORMANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthEventImpactType(rawValue: rawValue) ?? HealthEventImpactType.sdkUnknown(rawValue)
        }
    }
}

extension InternetMonitorClientTypes {
    public enum HealthEventStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthEventStatus] {
            return [
                .active,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthEventStatus(rawValue: rawValue) ?? HealthEventStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternetMonitorClientTypes.ImpactedLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asName = "ASName"
        case asNumber = "ASNumber"
        case causedBy = "CausedBy"
        case city = "City"
        case country = "Country"
        case countryCode = "CountryCode"
        case internetHealth = "InternetHealth"
        case latitude = "Latitude"
        case longitude = "Longitude"
        case metro = "Metro"
        case serviceLocation = "ServiceLocation"
        case status = "Status"
        case subdivision = "Subdivision"
        case subdivisionCode = "SubdivisionCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asName = self.asName {
            try encodeContainer.encode(asName, forKey: .asName)
        }
        if let asNumber = self.asNumber {
            try encodeContainer.encode(asNumber, forKey: .asNumber)
        }
        if let causedBy = self.causedBy {
            try encodeContainer.encode(causedBy, forKey: .causedBy)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let internetHealth = self.internetHealth {
            try encodeContainer.encode(internetHealth, forKey: .internetHealth)
        }
        if let latitude = self.latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = self.longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
        if let metro = self.metro {
            try encodeContainer.encode(metro, forKey: .metro)
        }
        if let serviceLocation = self.serviceLocation {
            try encodeContainer.encode(serviceLocation, forKey: .serviceLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subdivision = self.subdivision {
            try encodeContainer.encode(subdivision, forKey: .subdivision)
        }
        if let subdivisionCode = self.subdivisionCode {
            try encodeContainer.encode(subdivisionCode, forKey: .subdivisionCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asName)
        asName = asNameDecoded
        let asNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asNumber)
        asNumber = asNumberDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let subdivisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdivision)
        subdivision = subdivisionDecoded
        let metroDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metro)
        metro = metroDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .longitude)
        longitude = longitudeDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let subdivisionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdivisionCode)
        subdivisionCode = subdivisionCodeDecoded
        let serviceLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceLocation)
        serviceLocation = serviceLocationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.HealthEventStatus.self, forKey: .status)
        status = statusDecoded
        let causedByDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.NetworkImpairment.self, forKey: .causedBy)
        causedBy = causedByDecoded
        let internetHealthDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.InternetHealth.self, forKey: .internetHealth)
        internetHealth = internetHealthDecoded
    }
}

extension InternetMonitorClientTypes {
    /// Information about a location impacted by a health event in Amazon CloudWatch Internet Monitor. Geographic regions are hierarchically categorized into country, subdivision, metro and city geographic granularities. The geographic region is identified based on the IP address used at the client locations.
    public struct ImpactedLocation: Swift.Equatable {
        /// The name of the network at an impacted location.
        /// This member is required.
        public var asName: Swift.String?
        /// The Autonomous System Number (ASN) of the network at an impacted location.
        /// This member is required.
        public var asNumber: Swift.Int?
        /// The cause of the impairment. There are two types of network impairments: Amazon Web Services network issues or internet issues. Internet issues are typically a problem with a network provider, like an internet service provider (ISP).
        public var causedBy: InternetMonitorClientTypes.NetworkImpairment?
        /// The name of the city where the health event is located.
        public var city: Swift.String?
        /// The name of the country where the health event is located.
        /// This member is required.
        public var country: Swift.String?
        /// The country code where the health event is located. The ISO 3166-2 codes for the country is provided, when available.
        public var countryCode: Swift.String?
        /// The calculated health at a specific location.
        public var internetHealth: InternetMonitorClientTypes.InternetHealth?
        /// The latitude where the health event is located.
        public var latitude: Swift.Double?
        /// The longitude where the health event is located.
        public var longitude: Swift.Double?
        /// The metro area where the health event is located. Metro indicates a metropolitan region in the United States, such as the region around New York City. In non-US countries, this is a second-level subdivision. For example, in the United Kingdom, it could be a county, a London borough, a unitary authority, council area, and so on.
        public var metro: Swift.String?
        /// The service location where the health event is located.
        public var serviceLocation: Swift.String?
        /// The status of the health event at an impacted location.
        /// This member is required.
        public var status: InternetMonitorClientTypes.HealthEventStatus?
        /// The subdivision location where the health event is located. The subdivision usually maps to states in most countries (including the United States). For United Kingdom, it maps to a country (England, Scotland, Wales) or province (Northern Ireland).
        public var subdivision: Swift.String?
        /// The subdivision code where the health event is located. The ISO 3166-2 codes for country subdivisions is provided, when available.
        public var subdivisionCode: Swift.String?

        public init (
            asName: Swift.String? = nil,
            asNumber: Swift.Int? = nil,
            causedBy: InternetMonitorClientTypes.NetworkImpairment? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            internetHealth: InternetMonitorClientTypes.InternetHealth? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil,
            metro: Swift.String? = nil,
            serviceLocation: Swift.String? = nil,
            status: InternetMonitorClientTypes.HealthEventStatus? = nil,
            subdivision: Swift.String? = nil,
            subdivisionCode: Swift.String? = nil
        )
        {
            self.asName = asName
            self.asNumber = asNumber
            self.causedBy = causedBy
            self.city = city
            self.country = country
            self.countryCode = countryCode
            self.internetHealth = internetHealth
            self.latitude = latitude
            self.longitude = longitude
            self.metro = metro
            self.serviceLocation = serviceLocation
            self.status = status
            self.subdivision = subdivision
            self.subdivisionCode = subdivisionCode
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal server error.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternetMonitorClientTypes.InternetHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availability = "Availability"
        case performance = "Performance"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availability = self.availability {
            try encodeContainer.encode(availability, forKey: .availability)
        }
        if let performance = self.performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.AvailabilityMeasurement.self, forKey: .availability)
        availability = availabilityDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.PerformanceMeasurement.self, forKey: .performance)
        performance = performanceDecoded
    }
}

extension InternetMonitorClientTypes {
    /// Internet health includes measurements calculated by Amazon CloudWatch Internet Monitor about the performance and availability for your application on the internet. Amazon Web Services has substantial historical data about internet performance and availability between Amazon Web Services services and different network providers and geographies. By applying statistical analysis to the data, Internet Monitor can detect when the performance and availability for your application has dropped, compared to an estimated baseline that's already calculated. To make it easier to see those drops, we report that information to you in the form of health scores: a performance score and an availability score.
    public struct InternetHealth: Swift.Equatable {
        /// Availability in Internet Monitor represents the estimated percentage of traffic that is not seeing an availability drop. For example, an availability score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing an availability drop for that pair. For more information, see [ How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
        public var availability: InternetMonitorClientTypes.AvailabilityMeasurement?
        /// Performance in Internet Monitor represents the estimated percentage of traffic that is not seeing a performance drop. For example, a performance score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing a performance drop for that pair. For more information, see [ How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
        public var performance: InternetMonitorClientTypes.PerformanceMeasurement?

        public init (
            availability: InternetMonitorClientTypes.AvailabilityMeasurement? = nil,
            performance: InternetMonitorClientTypes.PerformanceMeasurement? = nil
        )
        {
            self.availability = availability
            self.performance = performance
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded a service quota.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListHealthEventsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let endTime = endTime {
                let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
                items.append(endTimeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let startTime = startTime {
                let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
                items.append(startTimeQueryItem)
            }
            if let eventStatus = eventStatus {
                let eventStatusQueryItem = ClientRuntime.URLQueryItem(name: "EventStatus".urlPercentEncoding(), value: Swift.String(eventStatus.rawValue).urlPercentEncoding())
                items.append(eventStatusQueryItem)
            }
            return items
        }
    }
}

extension ListHealthEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/HealthEvents"
    }
}

public struct ListHealthEventsInput: Swift.Equatable {
    /// The time when a health event ended. If the health event is still ongoing, then the end time is not set.
    public var endTime: ClientRuntime.Date?
    /// The status of a health event.
    public var eventStatus: InternetMonitorClientTypes.HealthEventStatus?
    /// The number of health event objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The time when a health event started.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        eventStatus: InternetMonitorClientTypes.HealthEventStatus? = nil,
        maxResults: Swift.Int = 0,
        monitorName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.maxResults = maxResults
        self.monitorName = monitorName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListHealthEventsInputBody: Swift.Equatable {
}

extension ListHealthEventsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHealthEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHealthEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListHealthEventsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHealthEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListHealthEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.healthEvents = output.healthEvents
            self.nextToken = output.nextToken
        } else {
            self.healthEvents = nil
            self.nextToken = nil
        }
    }
}

public struct ListHealthEventsOutputResponse: Swift.Equatable {
    /// A list of health events.
    /// This member is required.
    public var healthEvents: [InternetMonitorClientTypes.HealthEvent]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        healthEvents: [InternetMonitorClientTypes.HealthEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.healthEvents = healthEvents
        self.nextToken = nextToken
    }
}

struct ListHealthEventsOutputResponseBody: Swift.Equatable {
    let healthEvents: [InternetMonitorClientTypes.HealthEvent]?
    let nextToken: Swift.String?
}

extension ListHealthEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthEvents = "HealthEvents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthEventsContainer = try containerValues.decodeIfPresent([InternetMonitorClientTypes.HealthEvent?].self, forKey: .healthEvents)
        var healthEventsDecoded0:[InternetMonitorClientTypes.HealthEvent]? = nil
        if let healthEventsContainer = healthEventsContainer {
            healthEventsDecoded0 = [InternetMonitorClientTypes.HealthEvent]()
            for structure0 in healthEventsContainer {
                if let structure0 = structure0 {
                    healthEventsDecoded0?.append(structure0)
                }
            }
        }
        healthEvents = healthEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMonitorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let monitorStatus = monitorStatus {
                let monitorStatusQueryItem = ClientRuntime.URLQueryItem(name: "MonitorStatus".urlPercentEncoding(), value: Swift.String(monitorStatus).urlPercentEncoding())
                items.append(monitorStatusQueryItem)
            }
            return items
        }
    }
}

extension ListMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20210603/Monitors"
    }
}

public struct ListMonitorsInput: Swift.Equatable {
    /// The number of monitor objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The status of a monitor. This includes the status of the data processing for the monitor and the status of the monitor itself. For information about the statuses for a monitor, see [ Monitor](https://docs.aws.amazon.com/internet-monitor/latest/api/API_Monitor.html).
    public var monitorStatus: Swift.String?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        monitorStatus: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorStatus = monitorStatus
        self.nextToken = nextToken
    }
}

struct ListMonitorsInputBody: Swift.Equatable {
}

extension ListMonitorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMonitorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMonitorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMonitorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMonitorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMonitorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.monitors = output.monitors
            self.nextToken = output.nextToken
        } else {
            self.monitors = nil
            self.nextToken = nil
        }
    }
}

public struct ListMonitorsOutputResponse: Swift.Equatable {
    /// A list of monitors.
    /// This member is required.
    public var monitors: [InternetMonitorClientTypes.Monitor]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        monitors: [InternetMonitorClientTypes.Monitor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

struct ListMonitorsOutputResponseBody: Swift.Equatable {
    let monitors: [InternetMonitorClientTypes.Monitor]?
    let nextToken: Swift.String?
}

extension ListMonitorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitors = "Monitors"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorsContainer = try containerValues.decodeIfPresent([InternetMonitorClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[InternetMonitorClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [InternetMonitorClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags for a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternetMonitorClientTypes.Monitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
        case processingStatus = "ProcessingStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let processingStatus = self.processingStatus {
            try encodeContainer.encode(processingStatus.rawValue, forKey: .processingStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorConfigState.self, forKey: .status)
        status = statusDecoded
        let processingStatusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorProcessingStatusCode.self, forKey: .processingStatus)
        processingStatus = processingStatusDecoded
    }
}

extension InternetMonitorClientTypes {
    /// The description of and information about a monitor in Amazon CloudWatch Internet Monitor.
    public struct Monitor: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the monitor.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// The health of data processing for the monitor.
        public var processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode?
        /// The status of a monitor.
        /// This member is required.
        public var status: InternetMonitorClientTypes.MonitorConfigState?

        public init (
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode? = nil,
            status: InternetMonitorClientTypes.MonitorConfigState? = nil
        )
        {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.processingStatus = processingStatus
            self.status = status
        }
    }

}

extension InternetMonitorClientTypes {
    public enum MonitorConfigState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorConfigState] {
            return [
                .active,
                .error,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorConfigState(rawValue: rawValue) ?? MonitorConfigState.sdkUnknown(rawValue)
        }
    }
}

extension InternetMonitorClientTypes {
    public enum MonitorProcessingStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collectingData
        case faultAccessCloudwatch
        case faultService
        case inactive
        case insufficientData
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorProcessingStatusCode] {
            return [
                .collectingData,
                .faultAccessCloudwatch,
                .faultService,
                .inactive,
                .insufficientData,
                .ok,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collectingData: return "COLLECTING_DATA"
            case .faultAccessCloudwatch: return "FAULT_ACCESS_CLOUDWATCH"
            case .faultService: return "FAULT_SERVICE"
            case .inactive: return "INACTIVE"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorProcessingStatusCode(rawValue: rawValue) ?? MonitorProcessingStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension InternetMonitorClientTypes.Network: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asName = "ASName"
        case asNumber = "ASNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asName = self.asName {
            try encodeContainer.encode(asName, forKey: .asName)
        }
        if let asNumber = self.asNumber {
            try encodeContainer.encode(asNumber, forKey: .asNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asName)
        asName = asNameDecoded
        let asNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asNumber)
        asNumber = asNumberDecoded
    }
}

extension InternetMonitorClientTypes {
    /// An internet service provider (ISP) or network in Amazon CloudWatch Internet Monitor.
    public struct Network: Swift.Equatable {
        /// The internet provider name or network name.
        /// This member is required.
        public var asName: Swift.String?
        /// The Autonomous System Number (ASN) of the internet provider or network.
        /// This member is required.
        public var asNumber: Swift.Int?

        public init (
            asName: Swift.String? = nil,
            asNumber: Swift.Int? = nil
        )
        {
            self.asName = asName
            self.asNumber = asNumber
        }
    }

}

extension InternetMonitorClientTypes.NetworkImpairment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asPath = "AsPath"
        case networkEventType = "NetworkEventType"
        case networks = "Networks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asPath = asPath {
            var asPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .asPath)
            for network0 in asPath {
                try asPathContainer.encode(network0)
            }
        }
        if let networkEventType = self.networkEventType {
            try encodeContainer.encode(networkEventType.rawValue, forKey: .networkEventType)
        }
        if let networks = networks {
            var networksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networks)
            for network0 in networks {
                try networksContainer.encode(network0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networksContainer = try containerValues.decodeIfPresent([InternetMonitorClientTypes.Network?].self, forKey: .networks)
        var networksDecoded0:[InternetMonitorClientTypes.Network]? = nil
        if let networksContainer = networksContainer {
            networksDecoded0 = [InternetMonitorClientTypes.Network]()
            for structure0 in networksContainer {
                if let structure0 = structure0 {
                    networksDecoded0?.append(structure0)
                }
            }
        }
        networks = networksDecoded0
        let asPathContainer = try containerValues.decodeIfPresent([InternetMonitorClientTypes.Network?].self, forKey: .asPath)
        var asPathDecoded0:[InternetMonitorClientTypes.Network]? = nil
        if let asPathContainer = asPathContainer {
            asPathDecoded0 = [InternetMonitorClientTypes.Network]()
            for structure0 in asPathContainer {
                if let structure0 = structure0 {
                    asPathDecoded0?.append(structure0)
                }
            }
        }
        asPath = asPathDecoded0
        let networkEventTypeDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.TriangulationEventType.self, forKey: .networkEventType)
        networkEventType = networkEventTypeDecoded
    }
}

extension InternetMonitorClientTypes {
    /// Information about the network impairment for a specific network measured by Amazon CloudWatch Internet Monitor.
    public struct NetworkImpairment: Swift.Equatable {
        /// The combination of the Autonomous System Number (ASN) of the network and the name of the network.
        /// This member is required.
        public var asPath: [InternetMonitorClientTypes.Network]?
        /// Type of network impairment.
        /// This member is required.
        public var networkEventType: InternetMonitorClientTypes.TriangulationEventType?
        /// The networks that could be impacted by a network impairment event.
        /// This member is required.
        public var networks: [InternetMonitorClientTypes.Network]?

        public init (
            asPath: [InternetMonitorClientTypes.Network]? = nil,
            networkEventType: InternetMonitorClientTypes.TriangulationEventType? = nil,
            networks: [InternetMonitorClientTypes.Network]? = nil
        )
        {
            self.asPath = asPath
            self.networkEventType = networkEventType
            self.networks = networks
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request specifies something that doesn't exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternetMonitorClientTypes.PerformanceMeasurement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experienceScore = "ExperienceScore"
        case percentOfClientLocationImpacted = "PercentOfClientLocationImpacted"
        case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
        case roundTripTime = "RoundTripTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let experienceScore = self.experienceScore {
            try encodeContainer.encode(experienceScore, forKey: .experienceScore)
        }
        if let percentOfClientLocationImpacted = self.percentOfClientLocationImpacted {
            try encodeContainer.encode(percentOfClientLocationImpacted, forKey: .percentOfClientLocationImpacted)
        }
        if let percentOfTotalTrafficImpacted = self.percentOfTotalTrafficImpacted {
            try encodeContainer.encode(percentOfTotalTrafficImpacted, forKey: .percentOfTotalTrafficImpacted)
        }
        if let roundTripTime = self.roundTripTime {
            try encodeContainer.encode(roundTripTime, forKey: .roundTripTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experienceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .experienceScore)
        experienceScore = experienceScoreDecoded
        let percentOfTotalTrafficImpactedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfTotalTrafficImpacted)
        percentOfTotalTrafficImpacted = percentOfTotalTrafficImpactedDecoded
        let percentOfClientLocationImpactedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfClientLocationImpacted)
        percentOfClientLocationImpacted = percentOfClientLocationImpactedDecoded
        let roundTripTimeDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.RoundTripTime.self, forKey: .roundTripTime)
        roundTripTime = roundTripTimeDecoded
    }
}

extension InternetMonitorClientTypes {
    /// Measurements about the performance for your application on the internet calculated by Amazon CloudWatch Internet Monitor. Amazon Web Services has substantial historical data about internet performance and availability between Amazon Web Services services and different network providers and geographies. By applying statistical analysis to the data, Internet Monitor can detect when the performance and availability for your application has dropped, compared to an estimated baseline that's already calculated. To make it easier to see those drops, we report that information to you in the form of health scores: a performance score and an availability score. Performance in Internet Monitor represents the estimated percentage of traffic that is not seeing a performance drop. For example, a performance score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing a performance drop for that pair. For more information, see [ How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
    public struct PerformanceMeasurement: Swift.Equatable {
        /// Experience scores, or health scores, are calculated for different geographic and network provider combinations (that is, different granularities) and also totaled into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and availability scores, and when it creates and resolves health events. For more information, see [ How Amazon Web Services calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var experienceScore: Swift.Double?
        /// How much performance impact was caused by a health event at a client location. For performance, this is the percentage of how much latency increased during the event compared to typical performance for traffic, from this client location to an Amazon Web Services location, using a specific client network. For more information, see [ When Amazon Web Services creates and resolves health events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMHealthEventStartStop) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var percentOfClientLocationImpacted: Swift.Double?
        /// How much performance impact was caused by a health event for total traffic globally. For performance, this is the percentage of how much latency increased during the event compared to typical performance for your application traffic globally. For more information, see [ When Amazon Web Services creates and resolves health events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMHealthEventStartStop) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var percentOfTotalTrafficImpacted: Swift.Double?
        /// This is the percentage of how much round-trip time increased during the event compared to typical round-trip time for your application for traffic. For more information, see [ When Amazon Web Services creates and resolves health events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMHealthEventStartStop) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var roundTripTime: InternetMonitorClientTypes.RoundTripTime?

        public init (
            experienceScore: Swift.Double? = nil,
            percentOfClientLocationImpacted: Swift.Double? = nil,
            percentOfTotalTrafficImpacted: Swift.Double? = nil,
            roundTripTime: InternetMonitorClientTypes.RoundTripTime? = nil
        )
        {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.roundTripTime = roundTripTime
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request specifies a resource that doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternetMonitorClientTypes.RoundTripTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case p50 = "P50"
        case p90 = "P90"
        case p95 = "P95"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let p50 = self.p50 {
            try encodeContainer.encode(p50, forKey: .p50)
        }
        if let p90 = self.p90 {
            try encodeContainer.encode(p90, forKey: .p90)
        }
        if let p95 = self.p95 {
            try encodeContainer.encode(p95, forKey: .p95)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let p50Decoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .p50)
        p50 = p50Decoded
        let p90Decoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .p90)
        p90 = p90Decoded
        let p95Decoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .p95)
        p95 = p95Decoded
    }
}

extension InternetMonitorClientTypes {
    /// Round-trip time (RTT) is how long it takes for a request from the user to return a response to the user. Amazon CloudWatch Internet Monitor calculates RTT at different percentiles: p50, p90, and p95.
    public struct RoundTripTime: Swift.Equatable {
        /// RTT at the 50th percentile (p50).
        public var p50: Swift.Double?
        /// RTT at the 90th percentile (p90).
        public var p90: Swift.Double?
        /// RTT at the 95th percentile (p95).
        public var p95: Swift.Double?

        public init (
            p50: Swift.Double? = nil,
            p90: Swift.Double? = nil,
            p95: Swift.Double? = nil
        )
        {
            self.p50 = p50
            self.p90 = p90
            self.p95 = p95
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a tag that you add to a resource. Tags are supported only for monitors in Amazon CloudWatch Internet Monitor.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags that you add to a resource. You can add a maximum of 50 tags in Internet Monitor.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There were too many requests.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternetMonitorClientTypes {
    public enum TriangulationEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case internet
        case sdkUnknown(Swift.String)

        public static var allCases: [TriangulationEventType] {
            return [
                .aws,
                .internet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .internet: return "Internet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriangulationEventType(rawValue: rawValue) ?? TriangulationEventType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a tag you remove a resource from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys that you remove from a resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
        case resourcesToAdd = "ResourcesToAdd"
        case resourcesToRemove = "ResourcesToRemove"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if maxCityNetworksToMonitor != 0 {
            try encodeContainer.encode(maxCityNetworksToMonitor, forKey: .maxCityNetworksToMonitor)
        }
        if let resourcesToAdd = resourcesToAdd {
            var resourcesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcesToAdd)
            for arn0 in resourcesToAdd {
                try resourcesToAddContainer.encode(arn0)
            }
        }
        if let resourcesToRemove = resourcesToRemove {
            var resourcesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcesToRemove)
            for arn0 in resourcesToRemove {
                try resourcesToRemoveContainer.encode(arn0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())"
    }
}

public struct UpdateMonitorInput: Swift.Equatable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The maximum number of city-network combinations (that is, combinations of a city location and network, such as an ISP) to be monitored for your resources.
    public var maxCityNetworksToMonitor: Swift.Int
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). You can add a combination of Amazon Virtual Private Clouds (VPCs) and Amazon CloudFront distributions, or you can add Amazon WorkSpaces directories. You can't add all three types of resources. If you add only VPC resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet connectivity.
    public var resourcesToAdd: [Swift.String]?
    /// The resources to remove from a monitor, which you provide as a set of Amazon Resource Names (ARNs).
    public var resourcesToRemove: [Swift.String]?
    /// The status for a monitor. The accepted values for Status with the UpdateMonitor API call are the following: ACTIVE and INACTIVE. The following values are not accepted: PENDING, and ERROR.
    public var status: InternetMonitorClientTypes.MonitorConfigState?

    public init (
        clientToken: Swift.String? = nil,
        maxCityNetworksToMonitor: Swift.Int = 0,
        monitorName: Swift.String? = nil,
        resourcesToAdd: [Swift.String]? = nil,
        resourcesToRemove: [Swift.String]? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil
    )
    {
        self.clientToken = clientToken
        self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
        self.monitorName = monitorName
        self.resourcesToAdd = resourcesToAdd
        self.resourcesToRemove = resourcesToRemove
        self.status = status
    }
}

struct UpdateMonitorInputBody: Swift.Equatable {
    let resourcesToAdd: [Swift.String]?
    let resourcesToRemove: [Swift.String]?
    let status: InternetMonitorClientTypes.MonitorConfigState?
    let clientToken: Swift.String?
    let maxCityNetworksToMonitor: Swift.Int
}

extension UpdateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
        case resourcesToAdd = "ResourcesToAdd"
        case resourcesToRemove = "ResourcesToRemove"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourcesToAdd)
        var resourcesToAddDecoded0:[Swift.String]? = nil
        if let resourcesToAddContainer = resourcesToAddContainer {
            resourcesToAddDecoded0 = [Swift.String]()
            for string0 in resourcesToAddContainer {
                if let string0 = string0 {
                    resourcesToAddDecoded0?.append(string0)
                }
            }
        }
        resourcesToAdd = resourcesToAddDecoded0
        let resourcesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourcesToRemove)
        var resourcesToRemoveDecoded0:[Swift.String]? = nil
        if let resourcesToRemoveContainer = resourcesToRemoveContainer {
            resourcesToRemoveDecoded0 = [Swift.String]()
            for string0 in resourcesToRemoveContainer {
                if let string0 = string0 {
                    resourcesToRemoveDecoded0?.append(string0)
                }
            }
        }
        resourcesToRemove = resourcesToRemoveDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorConfigState.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let maxCityNetworksToMonitorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCityNetworksToMonitor) ?? 0
        maxCityNetworksToMonitor = maxCityNetworksToMonitorDecoded
    }
}

extension UpdateMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
            self.status = output.status
        } else {
            self.monitorArn = nil
            self.status = nil
        }
    }
}

public struct UpdateMonitorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The status of a monitor.
    /// This member is required.
    public var status: InternetMonitorClientTypes.MonitorConfigState?

    public init (
        monitorArn: Swift.String? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil
    )
    {
        self.monitorArn = monitorArn
        self.status = status
    }
}

struct UpdateMonitorOutputResponseBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let status: InternetMonitorClientTypes.MonitorConfigState?
}

extension UpdateMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InternetMonitorClientTypes.MonitorConfigState.self, forKey: .status)
        status = statusDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalid request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
