//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// The request was denied due to insufficient permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the access denial.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the access denial.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// An internal server error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the internal server error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the resource not found error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that was not found.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was throttled due to too many requests being sent in a short period.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the throttling error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code associated with the throttling error.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The service code associated with the throttling error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension PartnerCentralChannelClientTypes {

    /// Information about a field that failed validation.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The validation error code for the field.
        /// This member is required.
        public var code: Swift.String?
        /// A descriptive message about the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
            self.name = name
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessValidationFailed
        case requestValidationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .businessValidationFailed,
                .requestValidationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessValidationFailed: return "BUSINESS_VALIDATION_FAILED"
            case .requestValidationFailed: return "REQUEST_VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request failed validation due to invalid input parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of fields that failed validation.
        public internal(set) var fieldList: [PartnerCentralChannelClientTypes.ValidationExceptionField]? = nil
        /// A message describing the validation error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: PartnerCentralChannelClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [PartnerCentralChannelClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PartnerCentralChannelClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AcceptChannelHandshakeInput: Swift.Sendable {
    /// The catalog identifier for the handshake request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the channel handshake to accept.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralChannelClientTypes {

    public enum HandshakeStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case canceled
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [HandshakeStatus] {
            return [
                .accepted,
                .canceled,
                .expired,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about an accepted channel handshake.
    public struct AcceptChannelHandshakeDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the accepted handshake.
        public var arn: Swift.String?
        /// The unique identifier of the accepted handshake.
        public var id: Swift.String?
        /// The current status of the accepted handshake.
        public var status: PartnerCentralChannelClientTypes.HandshakeStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            status: PartnerCentralChannelClientTypes.HandshakeStatus? = nil
        ) {
            self.arn = arn
            self.id = id
            self.status = status
        }
    }
}

public struct AcceptChannelHandshakeOutput: Swift.Sendable {
    /// Details of the accepted channel handshake.
    public var channelHandshakeDetail: PartnerCentralChannelClientTypes.AcceptChannelHandshakeDetail?

    public init(
        channelHandshakeDetail: PartnerCentralChannelClientTypes.AcceptChannelHandshakeDetail? = nil
    ) {
        self.channelHandshakeDetail = channelHandshakeDetail
    }
}

extension PartnerCentralChannelClientTypes {

    public enum AssociationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case downstreamSeller
        case endCustomer
        case `internal`
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .downstreamSeller,
                .endCustomer,
                .internal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .downstreamSeller: return "DOWNSTREAM_SELLER"
            case .endCustomer: return "END_CUSTOMER"
            case .internal: return "INTERNAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelChannelHandshakeInput: Swift.Sendable {
    /// The catalog identifier for the handshake request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the channel handshake to cancel.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about a canceled channel handshake.
    public struct CancelChannelHandshakeDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the canceled handshake.
        public var arn: Swift.String?
        /// The unique identifier of the canceled handshake.
        public var id: Swift.String?
        /// The current status of the canceled handshake.
        public var status: PartnerCentralChannelClientTypes.HandshakeStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            status: PartnerCentralChannelClientTypes.HandshakeStatus? = nil
        ) {
            self.arn = arn
            self.id = id
            self.status = status
        }
    }
}

public struct CancelChannelHandshakeOutput: Swift.Sendable {
    /// Details of the canceled channel handshake.
    public var channelHandshakeDetail: PartnerCentralChannelClientTypes.CancelChannelHandshakeDetail?

    public init(
        channelHandshakeDetail: PartnerCentralChannelClientTypes.CancelChannelHandshakeDetail? = nil
    ) {
        self.channelHandshakeDetail = channelHandshakeDetail
    }
}

extension PartnerCentralChannelClientTypes {

    /// Payload for revoke service period handshake requests.
    public struct RevokeServicePeriodPayload: Swift.Sendable {
        /// A note explaining the reason for revoking the service period.
        public var note: Swift.String?
        /// The identifier of the program management account.
        /// This member is required.
        public var programManagementAccountIdentifier: Swift.String?

        public init(
            note: Swift.String? = nil,
            programManagementAccountIdentifier: Swift.String? = nil
        ) {
            self.note = note
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ServicePeriodType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixedCommitmentPeriod
        case minimumNoticePeriod
        case sdkUnknown(Swift.String)

        public static var allCases: [ServicePeriodType] {
            return [
                .fixedCommitmentPeriod,
                .minimumNoticePeriod
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixedCommitmentPeriod: return "FIXED_COMMITMENT_PERIOD"
            case .minimumNoticePeriod: return "MINIMUM_NOTICE_PERIOD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Payload for start service period handshake requests.
    public struct StartServicePeriodPayload: Swift.Sendable {
        /// The end date of the service period.
        public var endDate: Foundation.Date?
        /// The minimum number of days notice required for changes.
        public var minimumNoticeDays: Swift.String?
        /// A note providing additional information about the service period.
        public var note: Swift.String?
        /// The identifier of the program management account.
        /// This member is required.
        public var programManagementAccountIdentifier: Swift.String?
        /// The type of service period being started.
        /// This member is required.
        public var servicePeriodType: PartnerCentralChannelClientTypes.ServicePeriodType?

        public init(
            endDate: Foundation.Date? = nil,
            minimumNoticeDays: Swift.String? = nil,
            note: Swift.String? = nil,
            programManagementAccountIdentifier: Swift.String? = nil,
            servicePeriodType: PartnerCentralChannelClientTypes.ServicePeriodType? = nil
        ) {
            self.endDate = endDate
            self.minimumNoticeDays = minimumNoticeDays
            self.note = note
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
            self.servicePeriodType = servicePeriodType
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains the payload data for different types of channel handshakes.
    public enum ChannelHandshakePayload: Swift.Sendable {
        /// Payload for starting a service period handshake.
        case startserviceperiodpayload(PartnerCentralChannelClientTypes.StartServicePeriodPayload)
        /// Payload for revoking a service period handshake.
        case revokeserviceperiodpayload(PartnerCentralChannelClientTypes.RevokeServicePeriodPayload)
        case sdkUnknown(Swift.String)
    }
}

/// The request could not be completed due to a conflict with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the conflict.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that caused the conflict.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that caused the conflict.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would exceed a service quota limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the service quota exceeded error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code identifying the specific quota that would be exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that would exceed the quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that would exceed the quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension PartnerCentralChannelClientTypes {

    public enum HandshakeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case programManagementAccount
        case revokeServicePeriod
        case startServicePeriod
        case sdkUnknown(Swift.String)

        public static var allCases: [HandshakeType] {
            return [
                .programManagementAccount,
                .revokeServicePeriod,
                .startServicePeriod
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .programManagementAccount: return "PROGRAM_MANAGEMENT_ACCOUNT"
            case .revokeServicePeriod: return "REVOKE_SERVICE_PERIOD"
            case .startServicePeriod: return "START_SERVICE_PERIOD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// A key-value pair that can be associated with a resource.
    public struct Tag: Swift.Sendable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateChannelHandshakeInput: Swift.Sendable {
    /// The identifier of the resource associated with this handshake.
    /// This member is required.
    public var associatedResourceIdentifier: Swift.String?
    /// The catalog identifier for the handshake request.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The type of handshake to create (e.g., start service period, revoke service period).
    /// This member is required.
    public var handshakeType: PartnerCentralChannelClientTypes.HandshakeType?
    /// The payload containing specific details for the handshake type.
    public var payload: PartnerCentralChannelClientTypes.ChannelHandshakePayload?
    /// Key-value pairs to associate with the channel handshake.
    public var tags: [PartnerCentralChannelClientTypes.Tag]?

    public init(
        associatedResourceIdentifier: Swift.String? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        handshakeType: PartnerCentralChannelClientTypes.HandshakeType? = nil,
        payload: PartnerCentralChannelClientTypes.ChannelHandshakePayload? = nil,
        tags: [PartnerCentralChannelClientTypes.Tag]? = nil
    ) {
        self.associatedResourceIdentifier = associatedResourceIdentifier
        self.catalog = catalog
        self.clientToken = clientToken
        self.handshakeType = handshakeType
        self.payload = payload
        self.tags = tags
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about a newly created channel handshake.
    public struct CreateChannelHandshakeDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the created handshake.
        public var arn: Swift.String?
        /// The unique identifier of the created handshake.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        ) {
            self.arn = arn
            self.id = id
        }
    }
}

public struct CreateChannelHandshakeOutput: Swift.Sendable {
    /// Details of the created channel handshake.
    public var channelHandshakeDetail: PartnerCentralChannelClientTypes.CreateChannelHandshakeDetail?

    public init(
        channelHandshakeDetail: PartnerCentralChannelClientTypes.CreateChannelHandshakeDetail? = nil
    ) {
        self.channelHandshakeDetail = channelHandshakeDetail
    }
}

extension PartnerCentralChannelClientTypes {

    public enum Program: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case distribution
        case distributionSeller
        case solutionProvider
        case sdkUnknown(Swift.String)

        public static var allCases: [Program] {
            return [
                .distribution,
                .distributionSeller,
                .solutionProvider
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .distribution: return "DISTRIBUTION"
            case .distributionSeller: return "DISTRIBUTION_SELLER"
            case .solutionProvider: return "SOLUTION_PROVIDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Type-specific filters for program management accounts.
    public struct ProgramManagementAccountTypeFilters: Swift.Sendable {
        /// Filter by program types.
        public var programs: [PartnerCentralChannelClientTypes.Program]?

        public init(
            programs: [PartnerCentralChannelClientTypes.Program]? = nil
        ) {
            self.programs = programs
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Filters specific to revoke service period handshakes.
    public struct RevokeServicePeriodTypeFilters: Swift.Sendable {
        /// Filter by service period types.
        public var servicePeriodTypes: [PartnerCentralChannelClientTypes.ServicePeriodType]?

        public init(
            servicePeriodTypes: [PartnerCentralChannelClientTypes.ServicePeriodType]? = nil
        ) {
            self.servicePeriodTypes = servicePeriodTypes
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Filters specific to start service period handshakes.
    public struct StartServicePeriodTypeFilters: Swift.Sendable {
        /// Filter by service period types.
        public var servicePeriodTypes: [PartnerCentralChannelClientTypes.ServicePeriodType]?

        public init(
            servicePeriodTypes: [PartnerCentralChannelClientTypes.ServicePeriodType]? = nil
        ) {
            self.servicePeriodTypes = servicePeriodTypes
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Type-specific filters for listing channel handshakes.
    public enum ListChannelHandshakesTypeFilters: Swift.Sendable {
        /// Filters specific to start service period handshakes.
        case startserviceperiodtypefilters(PartnerCentralChannelClientTypes.StartServicePeriodTypeFilters)
        /// Filters specific to revoke service period handshakes.
        case revokeserviceperiodtypefilters(PartnerCentralChannelClientTypes.RevokeServicePeriodTypeFilters)
        /// Filters specific to program management account handshakes.
        case programmanagementaccounttypefilters(PartnerCentralChannelClientTypes.ProgramManagementAccountTypeFilters)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ProgramManagementAccountTypeSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [ProgramManagementAccountTypeSortName] {
            return [
                .updatedAt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updatedAt: return "UpdatedAt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Type-specific sorting options for program management accounts.
    public struct ProgramManagementAccountTypeSort: Swift.Sendable {
        /// The field to sort by.
        /// This member is required.
        public var sortBy: PartnerCentralChannelClientTypes.ProgramManagementAccountTypeSortName?
        /// The sort order (ascending or descending).
        /// This member is required.
        public var sortOrder: PartnerCentralChannelClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralChannelClientTypes.ProgramManagementAccountTypeSortName? = nil,
            sortOrder: PartnerCentralChannelClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum RevokeServicePeriodTypeSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [RevokeServicePeriodTypeSortName] {
            return [
                .updatedAt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updatedAt: return "UpdatedAt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Sorting options specific to revoke service period handshakes.
    public struct RevokeServicePeriodTypeSort: Swift.Sendable {
        /// The field to sort by.
        /// This member is required.
        public var sortBy: PartnerCentralChannelClientTypes.RevokeServicePeriodTypeSortName?
        /// The sort order (ascending or descending).
        /// This member is required.
        public var sortOrder: PartnerCentralChannelClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralChannelClientTypes.RevokeServicePeriodTypeSortName? = nil,
            sortOrder: PartnerCentralChannelClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum StartServicePeriodTypeSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [StartServicePeriodTypeSortName] {
            return [
                .updatedAt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updatedAt: return "UpdatedAt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Sorting options specific to start service period handshakes.
    public struct StartServicePeriodTypeSort: Swift.Sendable {
        /// The field to sort by.
        /// This member is required.
        public var sortBy: PartnerCentralChannelClientTypes.StartServicePeriodTypeSortName?
        /// The sort order (ascending or descending).
        /// This member is required.
        public var sortOrder: PartnerCentralChannelClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralChannelClientTypes.StartServicePeriodTypeSortName? = nil,
            sortOrder: PartnerCentralChannelClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Type-specific sorting options for listing channel handshakes.
    public enum ListChannelHandshakesTypeSort: Swift.Sendable {
        /// Sorting options specific to start service period handshakes.
        case startserviceperiodtypesort(PartnerCentralChannelClientTypes.StartServicePeriodTypeSort)
        /// Sorting options specific to revoke service period handshakes.
        case revokeserviceperiodtypesort(PartnerCentralChannelClientTypes.RevokeServicePeriodTypeSort)
        /// Sorting options specific to program management account handshakes.
        case programmanagementaccounttypesort(PartnerCentralChannelClientTypes.ProgramManagementAccountTypeSort)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ParticipantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case receiver
        case sender
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantType] {
            return [
                .receiver,
                .sender
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .receiver: return "RECEIVER"
            case .sender: return "SENDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListChannelHandshakesInput: Swift.Sendable {
    /// Filter by associated resource identifiers.
    public var associatedResourceIdentifiers: [Swift.String]?
    /// The catalog identifier to filter handshakes.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter results by handshake type.
    /// This member is required.
    public var handshakeType: PartnerCentralChannelClientTypes.HandshakeType?
    /// Type-specific filters for handshakes.
    public var handshakeTypeFilters: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeFilters?
    /// Type-specific sorting options for handshakes.
    public var handshakeTypeSort: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeSort?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// Filter by participant type (sender or receiver).
    /// This member is required.
    public var participantType: PartnerCentralChannelClientTypes.ParticipantType?
    /// Filter results by handshake status.
    public var statuses: [PartnerCentralChannelClientTypes.HandshakeStatus]?

    public init(
        associatedResourceIdentifiers: [Swift.String]? = nil,
        catalog: Swift.String? = nil,
        handshakeType: PartnerCentralChannelClientTypes.HandshakeType? = nil,
        handshakeTypeFilters: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeFilters? = nil,
        handshakeTypeSort: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeSort? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        participantType: PartnerCentralChannelClientTypes.ParticipantType? = nil,
        statuses: [PartnerCentralChannelClientTypes.HandshakeStatus]? = nil
    ) {
        self.associatedResourceIdentifiers = associatedResourceIdentifiers
        self.catalog = catalog
        self.handshakeType = handshakeType
        self.handshakeTypeFilters = handshakeTypeFilters
        self.handshakeTypeSort = handshakeTypeSort
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.participantType = participantType
        self.statuses = statuses
    }
}

extension PartnerCentralChannelClientTypes {

    /// Details specific to program management account handshakes.
    public struct ProgramManagementAccountHandshakeDetail: Swift.Sendable {
        /// The program associated with the handshake.
        public var program: PartnerCentralChannelClientTypes.Program?

        public init(
            program: PartnerCentralChannelClientTypes.Program? = nil
        ) {
            self.program = program
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Details specific to revoke service period handshakes.
    public struct RevokeServicePeriodHandshakeDetail: Swift.Sendable {
        /// The end date of the service period being revoked.
        public var endDate: Foundation.Date?
        /// The minimum number of days notice required for revocation.
        public var minimumNoticeDays: Swift.String?
        /// A note explaining the reason for revoking the service period.
        public var note: Swift.String?
        /// The type of service period being revoked.
        public var servicePeriodType: PartnerCentralChannelClientTypes.ServicePeriodType?
        /// The start date of the service period being revoked.
        public var startDate: Foundation.Date?

        public init(
            endDate: Foundation.Date? = nil,
            minimumNoticeDays: Swift.String? = nil,
            note: Swift.String? = nil,
            servicePeriodType: PartnerCentralChannelClientTypes.ServicePeriodType? = nil,
            startDate: Foundation.Date? = nil
        ) {
            self.endDate = endDate
            self.minimumNoticeDays = minimumNoticeDays
            self.note = note
            self.servicePeriodType = servicePeriodType
            self.startDate = startDate
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Details specific to start service period handshakes.
    public struct StartServicePeriodHandshakeDetail: Swift.Sendable {
        /// The end date of the service period.
        public var endDate: Foundation.Date?
        /// The minimum number of days notice required for changes.
        public var minimumNoticeDays: Swift.String?
        /// A note providing additional information about the service period.
        public var note: Swift.String?
        /// The type of service period being started.
        public var servicePeriodType: PartnerCentralChannelClientTypes.ServicePeriodType?
        /// The start date of the service period.
        public var startDate: Foundation.Date?

        public init(
            endDate: Foundation.Date? = nil,
            minimumNoticeDays: Swift.String? = nil,
            note: Swift.String? = nil,
            servicePeriodType: PartnerCentralChannelClientTypes.ServicePeriodType? = nil,
            startDate: Foundation.Date? = nil
        ) {
            self.endDate = endDate
            self.minimumNoticeDays = minimumNoticeDays
            self.note = note
            self.servicePeriodType = servicePeriodType
            self.startDate = startDate
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains detailed information about different types of handshakes.
    public enum HandshakeDetail: Swift.Sendable {
        /// Details for a start service period handshake.
        case startserviceperiodhandshakedetail(PartnerCentralChannelClientTypes.StartServicePeriodHandshakeDetail)
        /// Details for a revoke service period handshake.
        case revokeserviceperiodhandshakedetail(PartnerCentralChannelClientTypes.RevokeServicePeriodHandshakeDetail)
        /// Details for a program management account handshake.
        case programmanagementaccounthandshakedetail(PartnerCentralChannelClientTypes.ProgramManagementAccountHandshakeDetail)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralChannelClientTypes {

    /// Summary information about a channel handshake.
    public struct ChannelHandshakeSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the handshake.
        public var arn: Swift.String?
        /// The identifier of the resource associated with the handshake.
        public var associatedResourceId: Swift.String?
        /// The catalog identifier associated with the handshake.
        public var catalog: Swift.String?
        /// The timestamp when the handshake was created.
        public var createdAt: Foundation.Date?
        /// Detailed information about the handshake.
        public var detail: PartnerCentralChannelClientTypes.HandshakeDetail?
        /// The type of the handshake.
        public var handshakeType: PartnerCentralChannelClientTypes.HandshakeType?
        /// The unique identifier of the handshake.
        public var id: Swift.String?
        /// The AWS account ID of the handshake owner.
        public var ownerAccountId: Swift.String?
        /// The AWS account ID of the handshake receiver.
        public var receiverAccountId: Swift.String?
        /// The AWS account ID of the handshake sender.
        public var senderAccountId: Swift.String?
        /// The display name of the handshake sender.
        public var senderDisplayName: Swift.String?
        /// The current status of the handshake.
        public var status: PartnerCentralChannelClientTypes.HandshakeStatus?
        /// The timestamp when the handshake was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            associatedResourceId: Swift.String? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            detail: PartnerCentralChannelClientTypes.HandshakeDetail? = nil,
            handshakeType: PartnerCentralChannelClientTypes.HandshakeType? = nil,
            id: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            receiverAccountId: Swift.String? = nil,
            senderAccountId: Swift.String? = nil,
            senderDisplayName: Swift.String? = nil,
            status: PartnerCentralChannelClientTypes.HandshakeStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.associatedResourceId = associatedResourceId
            self.catalog = catalog
            self.createdAt = createdAt
            self.detail = detail
            self.handshakeType = handshakeType
            self.id = id
            self.ownerAccountId = ownerAccountId
            self.receiverAccountId = receiverAccountId
            self.senderAccountId = senderAccountId
            self.senderDisplayName = senderDisplayName
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListChannelHandshakesOutput: Swift.Sendable {
    /// List of channel handshakes matching the criteria.
    public var items: [PartnerCentralChannelClientTypes.ChannelHandshakeSummary]?
    /// Token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?

    public init(
        items: [PartnerCentralChannelClientTypes.ChannelHandshakeSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct RejectChannelHandshakeInput: Swift.Sendable {
    /// The catalog identifier for the handshake request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the channel handshake to reject.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about a rejected channel handshake.
    public struct RejectChannelHandshakeDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the rejected handshake.
        public var arn: Swift.String?
        /// The unique identifier of the rejected handshake.
        public var id: Swift.String?
        /// The current status of the rejected handshake.
        public var status: PartnerCentralChannelClientTypes.HandshakeStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            status: PartnerCentralChannelClientTypes.HandshakeStatus? = nil
        ) {
            self.arn = arn
            self.id = id
            self.status = status
        }
    }
}

public struct RejectChannelHandshakeOutput: Swift.Sendable {
    /// Details of the rejected channel handshake.
    public var channelHandshakeDetail: PartnerCentralChannelClientTypes.RejectChannelHandshakeDetail?

    public init(
        channelHandshakeDetail: PartnerCentralChannelClientTypes.RejectChannelHandshakeDetail? = nil
    ) {
        self.channelHandshakeDetail = channelHandshakeDetail
    }
}

extension PartnerCentralChannelClientTypes {

    public enum Coverage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entireOrganization
        case managementAccountOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [Coverage] {
            return [
                .entireOrganization,
                .managementAccountOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entireOrganization: return "ENTIRE_ORGANIZATION"
            case .managementAccountOnly: return "MANAGEMENT_ACCOUNT_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProgramManagementAccountInput: Swift.Sendable {
    /// The AWS account ID to associate with the program management account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The catalog identifier for the program management account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A human-readable name for the program management account.
    /// This member is required.
    public var displayName: Swift.String?
    /// The program type for the management account.
    /// This member is required.
    public var program: PartnerCentralChannelClientTypes.Program?
    /// Key-value pairs to associate with the program management account.
    public var tags: [PartnerCentralChannelClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        program: PartnerCentralChannelClientTypes.Program? = nil,
        tags: [PartnerCentralChannelClientTypes.Tag]? = nil
    ) {
        self.accountId = accountId
        self.catalog = catalog
        self.clientToken = clientToken
        self.displayName = displayName
        self.program = program
        self.tags = tags
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about a newly created program management account.
    public struct CreateProgramManagementAccountDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the created program management account.
        public var arn: Swift.String?
        /// The unique identifier of the created program management account.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        ) {
            self.arn = arn
            self.id = id
        }
    }
}

public struct CreateProgramManagementAccountOutput: Swift.Sendable {
    /// Details of the created program management account.
    public var programManagementAccountDetail: PartnerCentralChannelClientTypes.CreateProgramManagementAccountDetail?

    public init(
        programManagementAccountDetail: PartnerCentralChannelClientTypes.CreateProgramManagementAccountDetail? = nil
    ) {
        self.programManagementAccountDetail = programManagementAccountDetail
    }
}

extension PartnerCentralChannelClientTypes {

    public enum Provider: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case distributionSeller
        case distributor
        case sdkUnknown(Swift.String)

        public static var allCases: [Provider] {
            return [
                .distributionSeller,
                .distributor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .distributionSeller: return "DISTRIBUTION_SELLER"
            case .distributor: return "DISTRIBUTOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Configuration for partner-led support plans.
    public struct PartnerLedSupport: Swift.Sendable {
        /// The coverage level for partner-led support.
        /// This member is required.
        public var coverage: PartnerCentralChannelClientTypes.Coverage?
        /// The provider of the partner-led support.
        public var provider: PartnerCentralChannelClientTypes.Provider?
        /// The location of the Technical Account Manager (TAM).
        /// This member is required.
        public var tamLocation: Swift.String?

        public init(
            coverage: PartnerCentralChannelClientTypes.Coverage? = nil,
            provider: PartnerCentralChannelClientTypes.Provider? = nil,
            tamLocation: Swift.String? = nil
        ) {
            self.coverage = coverage
            self.provider = provider
            self.tamLocation = tamLocation
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Configuration for resold business support plans.
    public struct ResoldBusiness: Swift.Sendable {
        /// The coverage level for resold business support.
        /// This member is required.
        public var coverage: PartnerCentralChannelClientTypes.Coverage?

        public init(
            coverage: PartnerCentralChannelClientTypes.Coverage? = nil
        ) {
            self.coverage = coverage
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Configuration for resold enterprise support plans.
    public struct ResoldEnterprise: Swift.Sendable {
        /// The AWS account ID to charge for the support plan.
        public var chargeAccountId: Swift.String?
        /// The coverage level for resold enterprise support.
        /// This member is required.
        public var coverage: PartnerCentralChannelClientTypes.Coverage?
        /// The location of the Technical Account Manager (TAM).
        /// This member is required.
        public var tamLocation: Swift.String?

        public init(
            chargeAccountId: Swift.String? = nil,
            coverage: PartnerCentralChannelClientTypes.Coverage? = nil,
            tamLocation: Swift.String? = nil
        ) {
            self.chargeAccountId = chargeAccountId
            self.coverage = coverage
            self.tamLocation = tamLocation
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Configuration for different types of support plans.
    public enum SupportPlan: Swift.Sendable {
        /// Configuration for resold business support plans.
        case resoldbusiness(PartnerCentralChannelClientTypes.ResoldBusiness)
        /// Configuration for resold enterprise support plans.
        case resoldenterprise(PartnerCentralChannelClientTypes.ResoldEnterprise)
        /// Configuration for partner-led support plans.
        case partnerledsupport(PartnerCentralChannelClientTypes.PartnerLedSupport)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ResaleAccountModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case distributor
        case endCustomer
        case solutionProvider
        case sdkUnknown(Swift.String)

        public static var allCases: [ResaleAccountModel] {
            return [
                .distributor,
                .endCustomer,
                .solutionProvider
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .distributor: return "DISTRIBUTOR"
            case .endCustomer: return "END_CUSTOMER"
            case .solutionProvider: return "SOLUTION_PROVIDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum Sector: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case commercial
        case government
        case governmentException
        case sdkUnknown(Swift.String)

        public static var allCases: [Sector] {
            return [
                .commercial,
                .government,
                .governmentException
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .commercial: return "COMMERCIAL"
            case .government: return "GOVERNMENT"
            case .governmentException: return "GOVERNMENT_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRelationshipInput: Swift.Sendable {
    /// The AWS account ID to associate in this relationship.
    /// This member is required.
    public var associatedAccountId: Swift.String?
    /// The type of association for the relationship (e.g., reseller, distributor).
    /// This member is required.
    public var associationType: PartnerCentralChannelClientTypes.AssociationType?
    /// The catalog identifier for the relationship.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A human-readable name for the relationship.
    /// This member is required.
    public var displayName: Swift.String?
    /// The identifier of the program management account for this relationship.
    /// This member is required.
    public var programManagementAccountIdentifier: Swift.String?
    /// The support plan requested for this relationship.
    public var requestedSupportPlan: PartnerCentralChannelClientTypes.SupportPlan?
    /// The resale account model for the relationship.
    public var resaleAccountModel: PartnerCentralChannelClientTypes.ResaleAccountModel?
    /// The business sector for the relationship.
    /// This member is required.
    public var sector: PartnerCentralChannelClientTypes.Sector?
    /// Key-value pairs to associate with the relationship.
    public var tags: [PartnerCentralChannelClientTypes.Tag]?

    public init(
        associatedAccountId: Swift.String? = nil,
        associationType: PartnerCentralChannelClientTypes.AssociationType? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        programManagementAccountIdentifier: Swift.String? = nil,
        requestedSupportPlan: PartnerCentralChannelClientTypes.SupportPlan? = nil,
        resaleAccountModel: PartnerCentralChannelClientTypes.ResaleAccountModel? = nil,
        sector: PartnerCentralChannelClientTypes.Sector? = nil,
        tags: [PartnerCentralChannelClientTypes.Tag]? = nil
    ) {
        self.associatedAccountId = associatedAccountId
        self.associationType = associationType
        self.catalog = catalog
        self.clientToken = clientToken
        self.displayName = displayName
        self.programManagementAccountIdentifier = programManagementAccountIdentifier
        self.requestedSupportPlan = requestedSupportPlan
        self.resaleAccountModel = resaleAccountModel
        self.sector = sector
        self.tags = tags
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about a newly created relationship.
    public struct CreateRelationshipDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the created relationship.
        public var arn: Swift.String?
        /// The unique identifier of the created relationship.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        ) {
            self.arn = arn
            self.id = id
        }
    }
}

public struct CreateRelationshipOutput: Swift.Sendable {
    /// Details of the created relationship.
    public var relationshipDetail: PartnerCentralChannelClientTypes.CreateRelationshipDetail?

    public init(
        relationshipDetail: PartnerCentralChannelClientTypes.CreateRelationshipDetail? = nil
    ) {
        self.relationshipDetail = relationshipDetail
    }
}

public struct DeleteProgramManagementAccountInput: Swift.Sendable {
    /// The catalog identifier for the program management account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the program management account to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
    }
}

public struct DeleteProgramManagementAccountOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRelationshipInput: Swift.Sendable {
    /// The catalog identifier for the relationship.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the relationship to delete.
    /// This member is required.
    public var identifier: Swift.String?
    /// The identifier of the program management account associated with the relationship.
    /// This member is required.
    public var programManagementAccountIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        programManagementAccountIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.programManagementAccountIdentifier = programManagementAccountIdentifier
    }
}

public struct DeleteRelationshipOutput: Swift.Sendable {

    public init() { }
}

public struct GetRelationshipInput: Swift.Sendable {
    /// The catalog identifier for the relationship.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the relationship to retrieve.
    /// This member is required.
    public var identifier: Swift.String?
    /// The identifier of the program management account associated with the relationship.
    /// This member is required.
    public var programManagementAccountIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil,
        programManagementAccountIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
        self.programManagementAccountIdentifier = programManagementAccountIdentifier
    }
}

extension PartnerCentralChannelClientTypes {

    /// Detailed information about a partner relationship.
    public struct RelationshipDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the relationship.
        public var arn: Swift.String?
        /// The AWS account ID associated in this relationship.
        public var associatedAccountId: Swift.String?
        /// The type of association for the relationship.
        public var associationType: PartnerCentralChannelClientTypes.AssociationType?
        /// The catalog identifier associated with the relationship.
        public var catalog: Swift.String?
        /// The timestamp when the relationship was created.
        public var createdAt: Foundation.Date?
        /// The display name of the relationship.
        public var displayName: Swift.String?
        /// The unique identifier of the relationship.
        public var id: Swift.String?
        /// The identifier of the program management account.
        public var programManagementAccountId: Swift.String?
        /// The resale account model for the relationship.
        public var resaleAccountModel: PartnerCentralChannelClientTypes.ResaleAccountModel?
        /// The current revision number of the relationship.
        public var revision: Swift.String?
        /// The business sector for the relationship.
        public var sector: PartnerCentralChannelClientTypes.Sector?
        /// The start date of the relationship.
        public var startDate: Foundation.Date?
        /// The timestamp when the relationship was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            associatedAccountId: Swift.String? = nil,
            associationType: PartnerCentralChannelClientTypes.AssociationType? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            programManagementAccountId: Swift.String? = nil,
            resaleAccountModel: PartnerCentralChannelClientTypes.ResaleAccountModel? = nil,
            revision: Swift.String? = nil,
            sector: PartnerCentralChannelClientTypes.Sector? = nil,
            startDate: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.associatedAccountId = associatedAccountId
            self.associationType = associationType
            self.catalog = catalog
            self.createdAt = createdAt
            self.displayName = displayName
            self.id = id
            self.programManagementAccountId = programManagementAccountId
            self.resaleAccountModel = resaleAccountModel
            self.revision = revision
            self.sector = sector
            self.startDate = startDate
            self.updatedAt = updatedAt
        }
    }
}

public struct GetRelationshipOutput: Swift.Sendable {
    /// Details of the requested relationship.
    public var relationshipDetail: PartnerCentralChannelClientTypes.RelationshipDetail?

    public init(
        relationshipDetail: PartnerCentralChannelClientTypes.RelationshipDetail? = nil
    ) {
        self.relationshipDetail = relationshipDetail
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ListProgramManagementAccountsSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [ListProgramManagementAccountsSortName] {
            return [
                .updatedAt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updatedAt: return "UpdatedAt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Base sorting configuration for program management accounts.
    public struct ListProgramManagementAccountsSortBase: Swift.Sendable {
        /// The field to sort by.
        /// This member is required.
        public var sortBy: PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortName?
        /// The sort order (ascending or descending).
        /// This member is required.
        public var sortOrder: PartnerCentralChannelClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortName? = nil,
            sortOrder: PartnerCentralChannelClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ProgramManagementAccountStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ProgramManagementAccountStatus] {
            return [
                .active,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListProgramManagementAccountsInput: Swift.Sendable {
    /// Filter by AWS account IDs.
    public var accountIds: [Swift.String]?
    /// The catalog identifier to filter accounts.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter by display names.
    public var displayNames: [Swift.String]?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// Filter by program types.
    public var programs: [PartnerCentralChannelClientTypes.Program]?
    /// Sorting options for the results.
    public var sort: PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortBase?
    /// Filter by program management account statuses.
    public var statuses: [PartnerCentralChannelClientTypes.ProgramManagementAccountStatus]?

    public init(
        accountIds: [Swift.String]? = nil,
        catalog: Swift.String? = nil,
        displayNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        programs: [PartnerCentralChannelClientTypes.Program]? = nil,
        sort: PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortBase? = nil,
        statuses: [PartnerCentralChannelClientTypes.ProgramManagementAccountStatus]? = nil
    ) {
        self.accountIds = accountIds
        self.catalog = catalog
        self.displayNames = displayNames
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.programs = programs
        self.sort = sort
        self.statuses = statuses
    }
}

extension PartnerCentralChannelClientTypes {

    /// Summary information about a program management account.
    public struct ProgramManagementAccountSummary: Swift.Sendable {
        /// The AWS account ID associated with the program management account.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the program management account.
        public var arn: Swift.String?
        /// The catalog identifier associated with the account.
        public var catalog: Swift.String?
        /// The timestamp when the account was created.
        public var createdAt: Foundation.Date?
        /// The display name of the program management account.
        public var displayName: Swift.String?
        /// The unique identifier of the program management account.
        public var id: Swift.String?
        /// The program type for the management account.
        public var program: PartnerCentralChannelClientTypes.Program?
        /// The current revision number of the program management account.
        public var revision: Swift.String?
        /// The start date of the program management account.
        public var startDate: Foundation.Date?
        /// The current status of the program management account.
        public var status: PartnerCentralChannelClientTypes.ProgramManagementAccountStatus?
        /// The timestamp when the account was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            program: PartnerCentralChannelClientTypes.Program? = nil,
            revision: Swift.String? = nil,
            startDate: Foundation.Date? = nil,
            status: PartnerCentralChannelClientTypes.ProgramManagementAccountStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.accountId = accountId
            self.arn = arn
            self.catalog = catalog
            self.createdAt = createdAt
            self.displayName = displayName
            self.id = id
            self.program = program
            self.revision = revision
            self.startDate = startDate
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListProgramManagementAccountsOutput: Swift.Sendable {
    /// List of program management accounts matching the criteria.
    public var items: [PartnerCentralChannelClientTypes.ProgramManagementAccountSummary]?
    /// Token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?

    public init(
        items: [PartnerCentralChannelClientTypes.ProgramManagementAccountSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension PartnerCentralChannelClientTypes {

    public enum ListRelationshipsSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [ListRelationshipsSortName] {
            return [
                .updatedAt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updatedAt: return "UpdatedAt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralChannelClientTypes {

    /// Base sorting configuration for relationships.
    public struct ListRelationshipsSortBase: Swift.Sendable {
        /// The field to sort by.
        /// This member is required.
        public var sortBy: PartnerCentralChannelClientTypes.ListRelationshipsSortName?
        /// The sort order (ascending or descending).
        /// This member is required.
        public var sortOrder: PartnerCentralChannelClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralChannelClientTypes.ListRelationshipsSortName? = nil,
            sortOrder: PartnerCentralChannelClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

public struct ListRelationshipsInput: Swift.Sendable {
    /// Filter by associated AWS account IDs.
    public var associatedAccountIds: [Swift.String]?
    /// Filter by association types.
    public var associationTypes: [PartnerCentralChannelClientTypes.AssociationType]?
    /// The catalog identifier to filter relationships.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter by display names.
    public var displayNames: [Swift.String]?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// Filter by program management account identifiers.
    public var programManagementAccountIdentifiers: [Swift.String]?
    /// Sorting options for the results.
    public var sort: PartnerCentralChannelClientTypes.ListRelationshipsSortBase?

    public init(
        associatedAccountIds: [Swift.String]? = nil,
        associationTypes: [PartnerCentralChannelClientTypes.AssociationType]? = nil,
        catalog: Swift.String? = nil,
        displayNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        programManagementAccountIdentifiers: [Swift.String]? = nil,
        sort: PartnerCentralChannelClientTypes.ListRelationshipsSortBase? = nil
    ) {
        self.associatedAccountIds = associatedAccountIds
        self.associationTypes = associationTypes
        self.catalog = catalog
        self.displayNames = displayNames
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.programManagementAccountIdentifiers = programManagementAccountIdentifiers
        self.sort = sort
    }
}

extension PartnerCentralChannelClientTypes {

    /// Summary information about a partner relationship.
    public struct RelationshipSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the relationship.
        public var arn: Swift.String?
        /// The AWS account ID associated in this relationship.
        public var associatedAccountId: Swift.String?
        /// The type of association for the relationship.
        public var associationType: PartnerCentralChannelClientTypes.AssociationType?
        /// The catalog identifier associated with the relationship.
        public var catalog: Swift.String?
        /// The timestamp when the relationship was created.
        public var createdAt: Foundation.Date?
        /// The display name of the relationship.
        public var displayName: Swift.String?
        /// The unique identifier of the relationship.
        public var id: Swift.String?
        /// The identifier of the program management account.
        public var programManagementAccountId: Swift.String?
        /// The current revision number of the relationship.
        public var revision: Swift.String?
        /// The business sector for the relationship.
        public var sector: PartnerCentralChannelClientTypes.Sector?
        /// The start date of the relationship.
        public var startDate: Foundation.Date?
        /// The timestamp when the relationship was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            associatedAccountId: Swift.String? = nil,
            associationType: PartnerCentralChannelClientTypes.AssociationType? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            programManagementAccountId: Swift.String? = nil,
            revision: Swift.String? = nil,
            sector: PartnerCentralChannelClientTypes.Sector? = nil,
            startDate: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.associatedAccountId = associatedAccountId
            self.associationType = associationType
            self.catalog = catalog
            self.createdAt = createdAt
            self.displayName = displayName
            self.id = id
            self.programManagementAccountId = programManagementAccountId
            self.revision = revision
            self.sector = sector
            self.startDate = startDate
            self.updatedAt = updatedAt
        }
    }
}

public struct ListRelationshipsOutput: Swift.Sendable {
    /// List of relationships matching the criteria.
    public var items: [PartnerCentralChannelClientTypes.RelationshipSummary]?
    /// Token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?

    public init(
        items: [PartnerCentralChannelClientTypes.RelationshipSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Key-value pairs associated with the resource.
    public var tags: [PartnerCentralChannelClientTypes.Tag]?

    public init(
        tags: [PartnerCentralChannelClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct UpdateProgramManagementAccountInput: Swift.Sendable {
    /// The catalog identifier for the program management account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The new display name for the program management account.
    public var displayName: Swift.String?
    /// The unique identifier of the program management account to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The current revision number of the program management account.
    public var revision: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.displayName = displayName
        self.identifier = identifier
        self.revision = revision
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about an updated program management account.
    public struct UpdateProgramManagementAccountDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the updated program management account.
        public var arn: Swift.String?
        /// The updated display name of the program management account.
        public var displayName: Swift.String?
        /// The unique identifier of the updated program management account.
        public var id: Swift.String?
        /// The new revision number of the program management account.
        public var revision: Swift.String?

        public init(
            arn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        ) {
            self.arn = arn
            self.displayName = displayName
            self.id = id
            self.revision = revision
        }
    }
}

public struct UpdateProgramManagementAccountOutput: Swift.Sendable {
    /// Details of the updated program management account.
    public var programManagementAccountDetail: PartnerCentralChannelClientTypes.UpdateProgramManagementAccountDetail?

    public init(
        programManagementAccountDetail: PartnerCentralChannelClientTypes.UpdateProgramManagementAccountDetail? = nil
    ) {
        self.programManagementAccountDetail = programManagementAccountDetail
    }
}

public struct UpdateRelationshipInput: Swift.Sendable {
    /// The catalog identifier for the relationship.
    /// This member is required.
    public var catalog: Swift.String?
    /// The new display name for the relationship.
    public var displayName: Swift.String?
    /// The unique identifier of the relationship to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The identifier of the program management account associated with the relationship.
    /// This member is required.
    public var programManagementAccountIdentifier: Swift.String?
    /// The updated support plan for the relationship.
    public var requestedSupportPlan: PartnerCentralChannelClientTypes.SupportPlan?
    /// The current revision number of the relationship.
    public var revision: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identifier: Swift.String? = nil,
        programManagementAccountIdentifier: Swift.String? = nil,
        requestedSupportPlan: PartnerCentralChannelClientTypes.SupportPlan? = nil,
        revision: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.displayName = displayName
        self.identifier = identifier
        self.programManagementAccountIdentifier = programManagementAccountIdentifier
        self.requestedSupportPlan = requestedSupportPlan
        self.revision = revision
    }
}

extension PartnerCentralChannelClientTypes {

    /// Contains details about an updated relationship.
    public struct UpdateRelationshipDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the updated relationship.
        public var arn: Swift.String?
        /// The updated display name of the relationship.
        public var displayName: Swift.String?
        /// The unique identifier of the updated relationship.
        public var id: Swift.String?
        /// The new revision number of the relationship.
        public var revision: Swift.String?

        public init(
            arn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        ) {
            self.arn = arn
            self.displayName = displayName
            self.id = id
            self.revision = revision
        }
    }
}

public struct UpdateRelationshipOutput: Swift.Sendable {
    /// Details of the updated relationship.
    public var relationshipDetail: PartnerCentralChannelClientTypes.UpdateRelationshipDetail?

    public init(
        relationshipDetail: PartnerCentralChannelClientTypes.UpdateRelationshipDetail? = nil
    ) {
        self.relationshipDetail = relationshipDetail
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [PartnerCentralChannelClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PartnerCentralChannelClientTypes.Tag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AcceptChannelHandshakeInput {

    static func urlPathProvider(_ value: AcceptChannelHandshakeInput) -> Swift.String? {
        return "/"
    }
}

extension CancelChannelHandshakeInput {

    static func urlPathProvider(_ value: CancelChannelHandshakeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateChannelHandshakeInput {

    static func urlPathProvider(_ value: CreateChannelHandshakeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProgramManagementAccountInput {

    static func urlPathProvider(_ value: CreateProgramManagementAccountInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRelationshipInput {

    static func urlPathProvider(_ value: CreateRelationshipInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProgramManagementAccountInput {

    static func urlPathProvider(_ value: DeleteProgramManagementAccountInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRelationshipInput {

    static func urlPathProvider(_ value: DeleteRelationshipInput) -> Swift.String? {
        return "/"
    }
}

extension GetRelationshipInput {

    static func urlPathProvider(_ value: GetRelationshipInput) -> Swift.String? {
        return "/"
    }
}

extension ListChannelHandshakesInput {

    static func urlPathProvider(_ value: ListChannelHandshakesInput) -> Swift.String? {
        return "/"
    }
}

extension ListProgramManagementAccountsInput {

    static func urlPathProvider(_ value: ListProgramManagementAccountsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRelationshipsInput {

    static func urlPathProvider(_ value: ListRelationshipsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RejectChannelHandshakeInput {

    static func urlPathProvider(_ value: RejectChannelHandshakeInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProgramManagementAccountInput {

    static func urlPathProvider(_ value: UpdateProgramManagementAccountInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRelationshipInput {

    static func urlPathProvider(_ value: UpdateRelationshipInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptChannelHandshakeInput {

    static func write(value: AcceptChannelHandshakeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["identifier"].write(value.identifier)
    }
}

extension CancelChannelHandshakeInput {

    static func write(value: CancelChannelHandshakeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["identifier"].write(value.identifier)
    }
}

extension CreateChannelHandshakeInput {

    static func write(value: CreateChannelHandshakeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedResourceIdentifier"].write(value.associatedResourceIdentifier)
        try writer["catalog"].write(value.catalog)
        try writer["clientToken"].write(value.clientToken)
        try writer["handshakeType"].write(value.handshakeType)
        try writer["payload"].write(value.payload, with: PartnerCentralChannelClientTypes.ChannelHandshakePayload.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: PartnerCentralChannelClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProgramManagementAccountInput {

    static func write(value: CreateProgramManagementAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["catalog"].write(value.catalog)
        try writer["clientToken"].write(value.clientToken)
        try writer["displayName"].write(value.displayName)
        try writer["program"].write(value.program)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PartnerCentralChannelClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRelationshipInput {

    static func write(value: CreateRelationshipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedAccountId"].write(value.associatedAccountId)
        try writer["associationType"].write(value.associationType)
        try writer["catalog"].write(value.catalog)
        try writer["clientToken"].write(value.clientToken)
        try writer["displayName"].write(value.displayName)
        try writer["programManagementAccountIdentifier"].write(value.programManagementAccountIdentifier)
        try writer["requestedSupportPlan"].write(value.requestedSupportPlan, with: PartnerCentralChannelClientTypes.SupportPlan.write(value:to:))
        try writer["resaleAccountModel"].write(value.resaleAccountModel)
        try writer["sector"].write(value.sector)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PartnerCentralChannelClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteProgramManagementAccountInput {

    static func write(value: DeleteProgramManagementAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["clientToken"].write(value.clientToken)
        try writer["identifier"].write(value.identifier)
    }
}

extension DeleteRelationshipInput {

    static func write(value: DeleteRelationshipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["clientToken"].write(value.clientToken)
        try writer["identifier"].write(value.identifier)
        try writer["programManagementAccountIdentifier"].write(value.programManagementAccountIdentifier)
    }
}

extension GetRelationshipInput {

    static func write(value: GetRelationshipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["identifier"].write(value.identifier)
        try writer["programManagementAccountIdentifier"].write(value.programManagementAccountIdentifier)
    }
}

extension ListChannelHandshakesInput {

    static func write(value: ListChannelHandshakesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedResourceIdentifiers"].writeList(value.associatedResourceIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["catalog"].write(value.catalog)
        try writer["handshakeType"].write(value.handshakeType)
        try writer["handshakeTypeFilters"].write(value.handshakeTypeFilters, with: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeFilters.write(value:to:))
        try writer["handshakeTypeSort"].write(value.handshakeTypeSort, with: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeSort.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["participantType"].write(value.participantType)
        try writer["statuses"].writeList(value.statuses, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.HandshakeStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListProgramManagementAccountsInput {

    static func write(value: ListProgramManagementAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["catalog"].write(value.catalog)
        try writer["displayNames"].writeList(value.displayNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["programs"].writeList(value.programs, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.Program>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sort"].write(value.sort, with: PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortBase.write(value:to:))
        try writer["statuses"].writeList(value.statuses, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.ProgramManagementAccountStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListRelationshipsInput {

    static func write(value: ListRelationshipsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedAccountIds"].writeList(value.associatedAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["associationTypes"].writeList(value.associationTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.AssociationType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["catalog"].write(value.catalog)
        try writer["displayNames"].writeList(value.displayNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["programManagementAccountIdentifiers"].writeList(value.programManagementAccountIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sort"].write(value.sort, with: PartnerCentralChannelClientTypes.ListRelationshipsSortBase.write(value:to:))
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension RejectChannelHandshakeInput {

    static func write(value: RejectChannelHandshakeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["identifier"].write(value.identifier)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PartnerCentralChannelClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateProgramManagementAccountInput {

    static func write(value: UpdateProgramManagementAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["displayName"].write(value.displayName)
        try writer["identifier"].write(value.identifier)
        try writer["revision"].write(value.revision)
    }
}

extension UpdateRelationshipInput {

    static func write(value: UpdateRelationshipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalog"].write(value.catalog)
        try writer["displayName"].write(value.displayName)
        try writer["identifier"].write(value.identifier)
        try writer["programManagementAccountIdentifier"].write(value.programManagementAccountIdentifier)
        try writer["requestedSupportPlan"].write(value.requestedSupportPlan, with: PartnerCentralChannelClientTypes.SupportPlan.write(value:to:))
        try writer["revision"].write(value.revision)
    }
}

extension AcceptChannelHandshakeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptChannelHandshakeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptChannelHandshakeOutput()
        value.channelHandshakeDetail = try reader["channelHandshakeDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.AcceptChannelHandshakeDetail.read(from:))
        return value
    }
}

extension CancelChannelHandshakeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelChannelHandshakeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelChannelHandshakeOutput()
        value.channelHandshakeDetail = try reader["channelHandshakeDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.CancelChannelHandshakeDetail.read(from:))
        return value
    }
}

extension CreateChannelHandshakeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelHandshakeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelHandshakeOutput()
        value.channelHandshakeDetail = try reader["channelHandshakeDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.CreateChannelHandshakeDetail.read(from:))
        return value
    }
}

extension CreateProgramManagementAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProgramManagementAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProgramManagementAccountOutput()
        value.programManagementAccountDetail = try reader["programManagementAccountDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.CreateProgramManagementAccountDetail.read(from:))
        return value
    }
}

extension CreateRelationshipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRelationshipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRelationshipOutput()
        value.relationshipDetail = try reader["relationshipDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.CreateRelationshipDetail.read(from:))
        return value
    }
}

extension DeleteProgramManagementAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProgramManagementAccountOutput {
        return DeleteProgramManagementAccountOutput()
    }
}

extension DeleteRelationshipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRelationshipOutput {
        return DeleteRelationshipOutput()
    }
}

extension GetRelationshipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRelationshipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRelationshipOutput()
        value.relationshipDetail = try reader["relationshipDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.RelationshipDetail.read(from:))
        return value
    }
}

extension ListChannelHandshakesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelHandshakesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelHandshakesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: PartnerCentralChannelClientTypes.ChannelHandshakeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProgramManagementAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProgramManagementAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProgramManagementAccountsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: PartnerCentralChannelClientTypes.ProgramManagementAccountSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRelationshipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRelationshipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRelationshipsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: PartnerCentralChannelClientTypes.RelationshipSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: PartnerCentralChannelClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RejectChannelHandshakeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectChannelHandshakeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectChannelHandshakeOutput()
        value.channelHandshakeDetail = try reader["channelHandshakeDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.RejectChannelHandshakeDetail.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateProgramManagementAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProgramManagementAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProgramManagementAccountOutput()
        value.programManagementAccountDetail = try reader["programManagementAccountDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.UpdateProgramManagementAccountDetail.read(from:))
        return value
    }
}

extension UpdateRelationshipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRelationshipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRelationshipOutput()
        value.relationshipDetail = try reader["relationshipDetail"].readIfPresent(with: PartnerCentralChannelClientTypes.UpdateRelationshipDetail.read(from:))
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.AWSJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum AcceptChannelHandshakeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelChannelHandshakeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelHandshakeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProgramManagementAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRelationshipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProgramManagementAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRelationshipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRelationshipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelHandshakesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProgramManagementAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRelationshipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectChannelHandshakeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProgramManagementAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRelationshipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: PartnerCentralChannelClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PartnerCentralChannelClientTypes.AcceptChannelHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.AcceptChannelHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.AcceptChannelHandshakeDetail()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.CancelChannelHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.CancelChannelHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.CancelChannelHandshakeDetail()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.CreateChannelHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.CreateChannelHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.CreateChannelHandshakeDetail()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.CreateProgramManagementAccountDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.CreateProgramManagementAccountDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.CreateProgramManagementAccountDetail()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.CreateRelationshipDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.CreateRelationshipDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.CreateRelationshipDetail()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.RelationshipDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.RelationshipDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.RelationshipDetail()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.catalog = try reader["catalog"].readIfPresent()
        value.associationType = try reader["associationType"].readIfPresent()
        value.programManagementAccountId = try reader["programManagementAccountId"].readIfPresent()
        value.associatedAccountId = try reader["associatedAccountId"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.resaleAccountModel = try reader["resaleAccountModel"].readIfPresent()
        value.sector = try reader["sector"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PartnerCentralChannelClientTypes.ChannelHandshakeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.ChannelHandshakeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.ChannelHandshakeSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.catalog = try reader["catalog"].readIfPresent()
        value.handshakeType = try reader["handshakeType"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent()
        value.senderAccountId = try reader["senderAccountId"].readIfPresent()
        value.senderDisplayName = try reader["senderDisplayName"].readIfPresent()
        value.receiverAccountId = try reader["receiverAccountId"].readIfPresent()
        value.associatedResourceId = try reader["associatedResourceId"].readIfPresent()
        value.detail = try reader["detail"].readIfPresent(with: PartnerCentralChannelClientTypes.HandshakeDetail.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.HandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.HandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "startServicePeriodHandshakeDetail":
                return .startserviceperiodhandshakedetail(try reader["startServicePeriodHandshakeDetail"].read(with: PartnerCentralChannelClientTypes.StartServicePeriodHandshakeDetail.read(from:)))
            case "revokeServicePeriodHandshakeDetail":
                return .revokeserviceperiodhandshakedetail(try reader["revokeServicePeriodHandshakeDetail"].read(with: PartnerCentralChannelClientTypes.RevokeServicePeriodHandshakeDetail.read(from:)))
            case "programManagementAccountHandshakeDetail":
                return .programmanagementaccounthandshakedetail(try reader["programManagementAccountHandshakeDetail"].read(with: PartnerCentralChannelClientTypes.ProgramManagementAccountHandshakeDetail.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralChannelClientTypes.ProgramManagementAccountHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.ProgramManagementAccountHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.ProgramManagementAccountHandshakeDetail()
        value.program = try reader["program"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.RevokeServicePeriodHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.RevokeServicePeriodHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.RevokeServicePeriodHandshakeDetail()
        value.note = try reader["note"].readIfPresent()
        value.servicePeriodType = try reader["servicePeriodType"].readIfPresent()
        value.minimumNoticeDays = try reader["minimumNoticeDays"].readIfPresent()
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endDate = try reader["endDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PartnerCentralChannelClientTypes.StartServicePeriodHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.StartServicePeriodHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.StartServicePeriodHandshakeDetail()
        value.note = try reader["note"].readIfPresent()
        value.servicePeriodType = try reader["servicePeriodType"].readIfPresent()
        value.minimumNoticeDays = try reader["minimumNoticeDays"].readIfPresent()
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endDate = try reader["endDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PartnerCentralChannelClientTypes.ProgramManagementAccountSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.ProgramManagementAccountSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.ProgramManagementAccountSummary()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.catalog = try reader["catalog"].readIfPresent()
        value.program = try reader["program"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.RelationshipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.RelationshipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.RelationshipSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.catalog = try reader["catalog"].readIfPresent()
        value.associationType = try reader["associationType"].readIfPresent()
        value.programManagementAccountId = try reader["programManagementAccountId"].readIfPresent()
        value.associatedAccountId = try reader["associatedAccountId"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.sector = try reader["sector"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PartnerCentralChannelClientTypes.Tag {

    static func write(value: PartnerCentralChannelClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralChannelClientTypes.RejectChannelHandshakeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.RejectChannelHandshakeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.RejectChannelHandshakeDetail()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.UpdateProgramManagementAccountDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.UpdateProgramManagementAccountDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.UpdateProgramManagementAccountDetail()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.UpdateRelationshipDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.UpdateRelationshipDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.UpdateRelationshipDetail()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension PartnerCentralChannelClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralChannelClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralChannelClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralChannelClientTypes.ChannelHandshakePayload {

    static func write(value: PartnerCentralChannelClientTypes.ChannelHandshakePayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .revokeserviceperiodpayload(revokeserviceperiodpayload):
                try writer["revokeServicePeriodPayload"].write(revokeserviceperiodpayload, with: PartnerCentralChannelClientTypes.RevokeServicePeriodPayload.write(value:to:))
            case let .startserviceperiodpayload(startserviceperiodpayload):
                try writer["startServicePeriodPayload"].write(startserviceperiodpayload, with: PartnerCentralChannelClientTypes.StartServicePeriodPayload.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PartnerCentralChannelClientTypes.RevokeServicePeriodPayload {

    static func write(value: PartnerCentralChannelClientTypes.RevokeServicePeriodPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["note"].write(value.note)
        try writer["programManagementAccountIdentifier"].write(value.programManagementAccountIdentifier)
    }
}

extension PartnerCentralChannelClientTypes.StartServicePeriodPayload {

    static func write(value: PartnerCentralChannelClientTypes.StartServicePeriodPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["minimumNoticeDays"].write(value.minimumNoticeDays)
        try writer["note"].write(value.note)
        try writer["programManagementAccountIdentifier"].write(value.programManagementAccountIdentifier)
        try writer["servicePeriodType"].write(value.servicePeriodType)
    }
}

extension PartnerCentralChannelClientTypes.SupportPlan {

    static func write(value: PartnerCentralChannelClientTypes.SupportPlan?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .partnerledsupport(partnerledsupport):
                try writer["partnerLedSupport"].write(partnerledsupport, with: PartnerCentralChannelClientTypes.PartnerLedSupport.write(value:to:))
            case let .resoldbusiness(resoldbusiness):
                try writer["resoldBusiness"].write(resoldbusiness, with: PartnerCentralChannelClientTypes.ResoldBusiness.write(value:to:))
            case let .resoldenterprise(resoldenterprise):
                try writer["resoldEnterprise"].write(resoldenterprise, with: PartnerCentralChannelClientTypes.ResoldEnterprise.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PartnerCentralChannelClientTypes.PartnerLedSupport {

    static func write(value: PartnerCentralChannelClientTypes.PartnerLedSupport?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["coverage"].write(value.coverage)
        try writer["provider"].write(value.provider)
        try writer["tamLocation"].write(value.tamLocation)
    }
}

extension PartnerCentralChannelClientTypes.ResoldEnterprise {

    static func write(value: PartnerCentralChannelClientTypes.ResoldEnterprise?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chargeAccountId"].write(value.chargeAccountId)
        try writer["coverage"].write(value.coverage)
        try writer["tamLocation"].write(value.tamLocation)
    }
}

extension PartnerCentralChannelClientTypes.ResoldBusiness {

    static func write(value: PartnerCentralChannelClientTypes.ResoldBusiness?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["coverage"].write(value.coverage)
    }
}

extension PartnerCentralChannelClientTypes.ListChannelHandshakesTypeFilters {

    static func write(value: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .programmanagementaccounttypefilters(programmanagementaccounttypefilters):
                try writer["programManagementAccountTypeFilters"].write(programmanagementaccounttypefilters, with: PartnerCentralChannelClientTypes.ProgramManagementAccountTypeFilters.write(value:to:))
            case let .revokeserviceperiodtypefilters(revokeserviceperiodtypefilters):
                try writer["revokeServicePeriodTypeFilters"].write(revokeserviceperiodtypefilters, with: PartnerCentralChannelClientTypes.RevokeServicePeriodTypeFilters.write(value:to:))
            case let .startserviceperiodtypefilters(startserviceperiodtypefilters):
                try writer["startServicePeriodTypeFilters"].write(startserviceperiodtypefilters, with: PartnerCentralChannelClientTypes.StartServicePeriodTypeFilters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PartnerCentralChannelClientTypes.ProgramManagementAccountTypeFilters {

    static func write(value: PartnerCentralChannelClientTypes.ProgramManagementAccountTypeFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["programs"].writeList(value.programs, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.Program>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PartnerCentralChannelClientTypes.RevokeServicePeriodTypeFilters {

    static func write(value: PartnerCentralChannelClientTypes.RevokeServicePeriodTypeFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["servicePeriodTypes"].writeList(value.servicePeriodTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.ServicePeriodType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PartnerCentralChannelClientTypes.StartServicePeriodTypeFilters {

    static func write(value: PartnerCentralChannelClientTypes.StartServicePeriodTypeFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["servicePeriodTypes"].writeList(value.servicePeriodTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralChannelClientTypes.ServicePeriodType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PartnerCentralChannelClientTypes.ListChannelHandshakesTypeSort {

    static func write(value: PartnerCentralChannelClientTypes.ListChannelHandshakesTypeSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .programmanagementaccounttypesort(programmanagementaccounttypesort):
                try writer["programManagementAccountTypeSort"].write(programmanagementaccounttypesort, with: PartnerCentralChannelClientTypes.ProgramManagementAccountTypeSort.write(value:to:))
            case let .revokeserviceperiodtypesort(revokeserviceperiodtypesort):
                try writer["revokeServicePeriodTypeSort"].write(revokeserviceperiodtypesort, with: PartnerCentralChannelClientTypes.RevokeServicePeriodTypeSort.write(value:to:))
            case let .startserviceperiodtypesort(startserviceperiodtypesort):
                try writer["startServicePeriodTypeSort"].write(startserviceperiodtypesort, with: PartnerCentralChannelClientTypes.StartServicePeriodTypeSort.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PartnerCentralChannelClientTypes.ProgramManagementAccountTypeSort {

    static func write(value: PartnerCentralChannelClientTypes.ProgramManagementAccountTypeSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralChannelClientTypes.RevokeServicePeriodTypeSort {

    static func write(value: PartnerCentralChannelClientTypes.RevokeServicePeriodTypeSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralChannelClientTypes.StartServicePeriodTypeSort {

    static func write(value: PartnerCentralChannelClientTypes.StartServicePeriodTypeSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortBase {

    static func write(value: PartnerCentralChannelClientTypes.ListProgramManagementAccountsSortBase?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralChannelClientTypes.ListRelationshipsSortBase {

    static func write(value: PartnerCentralChannelClientTypes.ListRelationshipsSortBase?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

public enum PartnerCentralChannelClientTypes {}
