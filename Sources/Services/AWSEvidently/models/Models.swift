// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchEvaluateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requests = requests {
            var requestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requests)
            for evaluationrequest0 in requests {
                try requestsContainer.encode(evaluationrequest0)
            }
        }
    }
}

extension BatchEvaluateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/evaluations"
    }
}

public struct BatchEvaluateFeatureInput: Swift.Equatable {
    /// The name or ARN of the project that contains the feature being evaluated.
    /// This member is required.
    public var project: Swift.String?
    /// An array of structures, where each structure assigns a feature variation to one user session.
    /// This member is required.
    public var requests: [EvidentlyClientTypes.EvaluationRequest]?

    public init(
        project: Swift.String? = nil,
        requests: [EvidentlyClientTypes.EvaluationRequest]? = nil
    )
    {
        self.project = project
        self.requests = requests
    }
}

struct BatchEvaluateFeatureInputBody: Swift.Equatable {
    let requests: [EvidentlyClientTypes.EvaluationRequest]?
}

extension BatchEvaluateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationRequest?].self, forKey: .requests)
        var requestsDecoded0:[EvidentlyClientTypes.EvaluationRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [EvidentlyClientTypes.EvaluationRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

extension BatchEvaluateFeatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchEvaluateFeatureOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
        } else {
            self.results = nil
        }
    }
}

public struct BatchEvaluateFeatureOutput: Swift.Equatable {
    /// An array of structures, where each structure displays the results of one feature evaluation assignment to one user session.
    public var results: [EvidentlyClientTypes.EvaluationResult]?

    public init(
        results: [EvidentlyClientTypes.EvaluationResult]? = nil
    )
    {
        self.results = results
    }
}

struct BatchEvaluateFeatureOutputBody: Swift.Equatable {
    let results: [EvidentlyClientTypes.EvaluationResult]?
}

extension BatchEvaluateFeatureOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationResult?].self, forKey: .results)
        var resultsDecoded0:[EvidentlyClientTypes.EvaluationResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [EvidentlyClientTypes.EvaluationResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

enum BatchEvaluateFeatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ChangeDirectionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decrease
        case increase
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeDirectionEnum] {
            return [
                .decrease,
                .increase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decrease: return "DECREASE"
            case .increase: return "INCREASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeDirectionEnum(rawValue: rawValue) ?? ChangeDirectionEnum.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.CloudWatchLogsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure containing the CloudWatch Logs log group where the project stores evaluation events.
    public struct CloudWatchLogsDestination: Swift.Equatable {
        /// The name of the log group where the project stores evaluation events.
        public var logGroup: Swift.String?

        public init(
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }

}

extension EvidentlyClientTypes.CloudWatchLogsDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure containing the CloudWatch Logs log group where the project stores evaluation events.
    public struct CloudWatchLogsDestinationConfig: Swift.Equatable {
        /// The name of the log group where the project stores evaluation events.
        public var logGroup: Swift.String?

        public init(
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case name
        case onlineAbConfig
        case randomizationSalt
        case samplingRate
        case segment
        case tags
        case treatments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let metricGoals = metricGoals {
            var metricGoalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricGoals)
            for metricgoalconfig0 in metricGoals {
                try metricGoalsContainer.encode(metricgoalconfig0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let onlineAbConfig = self.onlineAbConfig {
            try encodeContainer.encode(onlineAbConfig, forKey: .onlineAbConfig)
        }
        if let randomizationSalt = self.randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let samplingRate = self.samplingRate {
            try encodeContainer.encode(samplingRate, forKey: .samplingRate)
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let treatments = treatments {
            var treatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatments)
            for treatmentconfig0 in treatments {
                try treatmentsContainer.encode(treatmentconfig0)
            }
        }
    }
}

extension CreateExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments"
    }
}

public struct CreateExperimentInput: Swift.Equatable {
    /// An optional description of the experiment.
    public var description: Swift.String?
    /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
    /// This member is required.
    public var metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    /// A name for the new experiment.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the configuration of which variation to use as the "control" version. tThe "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public var onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    /// The name or ARN of the project that you want to create the new experiment in.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to an experiment, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the experiment name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// The portion of the available audience that you want to allocate to this experiment, in thousandths of a percent. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent. For example, specify 10,000 to allocate 10% of the available audience.
    public var samplingRate: Swift.Int?
    /// Specifies an audience segment to use in the experiment. When a segment is used in an experiment, only user sessions that match the segment pattern are used in the experiment.
    public var segment: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the experiment. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with an experiment. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// An array of structures that describe the configuration of each feature variation used in the experiment.
    /// This member is required.
    public var treatments: [EvidentlyClientTypes.TreatmentConfig]?

    public init(
        description: Swift.String? = nil,
        metricGoals: [EvidentlyClientTypes.MetricGoalConfig]? = nil,
        name: Swift.String? = nil,
        onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        samplingRate: Swift.Int? = nil,
        segment: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        treatments: [EvidentlyClientTypes.TreatmentConfig]? = nil
    )
    {
        self.description = description
        self.metricGoals = metricGoals
        self.name = name
        self.onlineAbConfig = onlineAbConfig
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.samplingRate = samplingRate
        self.segment = segment
        self.tags = tags
        self.treatments = treatments
    }
}

struct CreateExperimentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let treatments: [EvidentlyClientTypes.TreatmentConfig]?
    let metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    let randomizationSalt: Swift.String?
    let samplingRate: Swift.Int?
    let onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    let segment: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case name
        case onlineAbConfig
        case randomizationSalt
        case samplingRate
        case segment
        case tags
        case treatments
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let treatmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.TreatmentConfig?].self, forKey: .treatments)
        var treatmentsDecoded0:[EvidentlyClientTypes.TreatmentConfig]? = nil
        if let treatmentsContainer = treatmentsContainer {
            treatmentsDecoded0 = [EvidentlyClientTypes.TreatmentConfig]()
            for structure0 in treatmentsContainer {
                if let structure0 = structure0 {
                    treatmentsDecoded0?.append(structure0)
                }
            }
        }
        treatments = treatmentsDecoded0
        let metricGoalsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricGoalConfig?].self, forKey: .metricGoals)
        var metricGoalsDecoded0:[EvidentlyClientTypes.MetricGoalConfig]? = nil
        if let metricGoalsContainer = metricGoalsContainer {
            metricGoalsDecoded0 = [EvidentlyClientTypes.MetricGoalConfig]()
            for structure0 in metricGoalsContainer {
                if let structure0 = structure0 {
                    metricGoalsDecoded0?.append(structure0)
                }
            }
        }
        metricGoals = metricGoalsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        let onlineAbConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.OnlineAbConfig.self, forKey: .onlineAbConfig)
        onlineAbConfig = onlineAbConfigDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segment)
        segment = segmentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct CreateExperimentOutput: Swift.Equatable {
    /// A structure containing the configuration details of the experiment that you created.
    /// This member is required.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init(
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct CreateExperimentOutputBody: Swift.Equatable {
    let experiment: EvidentlyClientTypes.Experiment?
}

extension CreateExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

enum CreateExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case name
        case tags
        case variations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVariation = self.defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityOverrides = entityOverrides {
            var entityOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .entityOverrides)
            for (dictKey0, entityOverrideMap0) in entityOverrides {
                try entityOverridesContainer.encode(entityOverrideMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let evaluationStrategy = self.evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variations = variations {
            var variationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variations)
            for variationconfig0 in variations {
                try variationsContainer.encode(variationconfig0)
            }
        }
    }
}

extension CreateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features"
    }
}

public struct CreateFeatureInput: Swift.Equatable {
    /// The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit defaultVariation, the first variation listed in the variations structure is used as the default variation.
    public var defaultVariation: Swift.String?
    /// An optional description of the feature.
    public var description: Swift.String?
    /// Specify users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served. This parameter is limited to 2500 overrides or a total of 40KB. The 40KB limit includes an overhead of 6 bytes per override.
    public var entityOverrides: [Swift.String:Swift.String]?
    /// Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
    public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    /// The name for the new feature.
    /// This member is required.
    public var name: Swift.String?
    /// The name or ARN of the project that is to contain the new feature.
    /// This member is required.
    public var project: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the feature. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a feature. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// An array of structures that contain the configuration of the feature's different variations.
    /// This member is required.
    public var variations: [EvidentlyClientTypes.VariationConfig]?

    public init(
        defaultVariation: Swift.String? = nil,
        description: Swift.String? = nil,
        entityOverrides: [Swift.String:Swift.String]? = nil,
        evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
        name: Swift.String? = nil,
        project: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        variations: [EvidentlyClientTypes.VariationConfig]? = nil
    )
    {
        self.defaultVariation = defaultVariation
        self.description = description
        self.entityOverrides = entityOverrides
        self.evaluationStrategy = evaluationStrategy
        self.name = name
        self.project = project
        self.tags = tags
        self.variations = variations
    }
}

struct CreateFeatureInputBody: Swift.Equatable {
    let name: Swift.String?
    let evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    let description: Swift.String?
    let variations: [EvidentlyClientTypes.VariationConfig]?
    let defaultVariation: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let entityOverrides: [Swift.String:Swift.String]?
}

extension CreateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case name
        case tags
        case variations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variationsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.VariationConfig?].self, forKey: .variations)
        var variationsDecoded0:[EvidentlyClientTypes.VariationConfig]? = nil
        if let variationsContainer = variationsContainer {
            variationsDecoded0 = [EvidentlyClientTypes.VariationConfig]()
            for structure0 in variationsContainer {
                if let structure0 = structure0 {
                    variationsDecoded0?.append(structure0)
                }
            }
        }
        variations = variationsDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let entityOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .entityOverrides)
        var entityOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let entityOverridesContainer = entityOverridesContainer {
            entityOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in entityOverridesContainer {
                if let variationname0 = variationname0 {
                    entityOverridesDecoded0?[key0] = variationname0
                }
            }
        }
        entityOverrides = entityOverridesDecoded0
    }
}

extension CreateFeatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFeatureOutputBody = try responseDecoder.decode(responseBody: data)
            self.feature = output.feature
        } else {
            self.feature = nil
        }
    }
}

public struct CreateFeatureOutput: Swift.Equatable {
    /// A structure that contains information about the new feature.
    public var feature: EvidentlyClientTypes.Feature?

    public init(
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

struct CreateFeatureOutputBody: Swift.Equatable {
    let feature: EvidentlyClientTypes.Feature?
}

extension CreateFeatureOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
    }
}

enum CreateFeatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case name
        case randomizationSalt
        case scheduledSplitsConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for launchgroupconfig0 in groups {
                try groupsContainer.encode(launchgroupconfig0)
            }
        }
        if let metricMonitors = metricMonitors {
            var metricMonitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricMonitors)
            for metricmonitorconfig0 in metricMonitors {
                try metricMonitorsContainer.encode(metricmonitorconfig0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let randomizationSalt = self.randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let scheduledSplitsConfig = self.scheduledSplitsConfig {
            try encodeContainer.encode(scheduledSplitsConfig, forKey: .scheduledSplitsConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches"
    }
}

public struct CreateLaunchInput: Swift.Equatable {
    /// An optional description for the launch.
    public var description: Swift.String?
    /// An array of structures that contains the feature and variations that are to be used for the launch.
    /// This member is required.
    public var groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    /// An array of structures that define the metrics that will be used to monitor the launch performance.
    public var metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    /// The name for the new launch.
    /// This member is required.
    public var name: Swift.String?
    /// The name or ARN of the project that you want to create the launch in.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to a launch, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the launch name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
    public var scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
    /// Assigns one or more tags (key-value pairs) to the launch. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a launch. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        groups: [EvidentlyClientTypes.LaunchGroupConfig]? = nil,
        metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]? = nil,
        name: Swift.String? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.groups = groups
        self.metricMonitors = metricMonitors
        self.name = name
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.scheduledSplitsConfig = scheduledSplitsConfig
        self.tags = tags
    }
}

struct CreateLaunchInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
    let metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    let groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    let randomizationSalt: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case name
        case randomizationSalt
        case scheduledSplitsConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduledSplitsConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ScheduledSplitsLaunchConfig.self, forKey: .scheduledSplitsConfig)
        scheduledSplitsConfig = scheduledSplitsConfigDecoded
        let metricMonitorsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricMonitorConfig?].self, forKey: .metricMonitors)
        var metricMonitorsDecoded0:[EvidentlyClientTypes.MetricMonitorConfig]? = nil
        if let metricMonitorsContainer = metricMonitorsContainer {
            metricMonitorsDecoded0 = [EvidentlyClientTypes.MetricMonitorConfig]()
            for structure0 in metricMonitorsContainer {
                if let structure0 = structure0 {
                    metricMonitorsDecoded0?.append(structure0)
                }
            }
        }
        metricMonitors = metricMonitorsDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.LaunchGroupConfig?].self, forKey: .groups)
        var groupsDecoded0:[EvidentlyClientTypes.LaunchGroupConfig]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [EvidentlyClientTypes.LaunchGroupConfig]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLaunchOutputBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct CreateLaunchOutput: Swift.Equatable {
    /// A structure that contains the configuration of the launch that was created.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct CreateLaunchOutputBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension CreateLaunchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

enum CreateLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appConfigResource
        case dataDelivery
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appConfigResource = self.appConfigResource {
            try encodeContainer.encode(appConfigResource, forKey: .appConfigResource)
        }
        if let dataDelivery = self.dataDelivery {
            try encodeContainer.encode(dataDelivery, forKey: .dataDelivery)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// Use this parameter if the project will use client-side evaluation powered by AppConfig. Client-side evaluation allows your application to assign variations to user sessions locally instead of by calling the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation. This mitigates the latency and availability risks that come with an API call. For more information, see [ Client-side evaluation - powered by AppConfig.](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-client-side-evaluation.html) This parameter is a structure that contains information about the AppConfig application and environment that will be used as for client-side evaluation. To create a project that uses client-side evaluation, you must have the evidently:ExportProjectAsConfiguration permission.
    public var appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig?
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage, if you choose to do so. If you choose not to store these events, Evidently deletes them after using them to produce metrics and other experiment results that you can view.
    public var dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig?
    /// An optional description of the project.
    public var description: Swift.String?
    /// The name for the project.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the project. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a project. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig? = nil,
        dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.appConfigResource = appConfigResource
        self.dataDelivery = dataDelivery
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig?
    let appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appConfigResource
        case dataDelivery
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataDeliveryDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectDataDeliveryConfig.self, forKey: .dataDelivery)
        dataDelivery = dataDeliveryDecoded
        let appConfigResourceDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectAppConfigResourceConfig.self, forKey: .appConfigResource)
        appConfigResource = appConfigResourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct CreateProjectOutput: Swift.Equatable {
    /// A structure that contains information about the created project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSegmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case pattern
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSegmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/segments"
    }
}

public struct CreateSegmentInput: Swift.Equatable {
    /// An optional description for this segment.
    public var description: Swift.String?
    /// A name for the segment.
    /// This member is required.
    public var name: Swift.String?
    /// The pattern to use for the segment. For more information about pattern syntax, see [ Segment rule pattern syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-segments.html#CloudWatch-Evidently-segments-syntax.html).
    /// This member is required.
    public var pattern: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the segment. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a segment. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pattern: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.pattern = pattern
        self.tags = tags
    }
}

struct CreateSegmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let pattern: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSegmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case pattern
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSegmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSegmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.segment = output.segment
        } else {
            self.segment = nil
        }
    }
}

public struct CreateSegmentOutput: Swift.Equatable {
    /// A structure that contains the complete information about the segment that was just created.
    /// This member is required.
    public var segment: EvidentlyClientTypes.Segment?

    public init(
        segment: EvidentlyClientTypes.Segment? = nil
    )
    {
        self.segment = segment
    }
}

struct CreateSegmentOutputBody: Swift.Equatable {
    let segment: EvidentlyClientTypes.Segment?
}

extension CreateSegmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case segment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
    }
}

enum CreateSegmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

public struct DeleteExperimentInput: Swift.Equatable {
    /// The name of the experiment to delete.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.experiment = experiment
        self.project = project
    }
}

struct DeleteExperimentInputBody: Swift.Equatable {
}

extension DeleteExperimentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteExperimentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

public struct DeleteFeatureInput: Swift.Equatable {
    /// The name of the feature to delete.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.feature = feature
        self.project = project
    }
}

struct DeleteFeatureInputBody: Swift.Equatable {
}

extension DeleteFeatureInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFeatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFeatureOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFeatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

public struct DeleteLaunchInput: Swift.Equatable {
    /// The name of the launch to delete.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

struct DeleteLaunchInputBody: Swift.Equatable {
}

extension DeleteLaunchInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLaunchOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name or ARN of the project to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        project: Swift.String? = nil
    )
    {
        self.project = project
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSegmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let segment = segment else {
            return nil
        }
        return "/segments/\(segment.urlPercentEncoding())"
    }
}

public struct DeleteSegmentInput: Swift.Equatable {
    /// Specifies the segment to delete.
    /// This member is required.
    public var segment: Swift.String?

    public init(
        segment: Swift.String? = nil
    )
    {
        self.segment = segment
    }
}

struct DeleteSegmentInputBody: Swift.Equatable {
}

extension DeleteSegmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSegmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSegmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSegmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvaluateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case evaluationContext
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let evaluationContext = self.evaluationContext {
            try encodeContainer.encode(evaluationContext, forKey: .evaluationContext)
        }
    }
}

extension EvaluateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/evaluations/\(feature.urlPercentEncoding())"
    }
}

public struct EvaluateFeatureInput: Swift.Equatable {
    /// An internal ID that represents a unique user of the application. This entityID is checked against any override rules assigned for this feature.
    /// This member is required.
    public var entityId: Swift.String?
    /// A JSON object of attributes that you can optionally pass in as part of the evaluation event sent to Evidently from the user session. Evidently can use this value to match user sessions with defined audience segments. For more information, see [Use segments to focus your audience](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-segments.html). If you include this parameter, the value must be a JSON object. A JSON array is not supported.
    public var evaluationContext: Swift.String?
    /// The name of the feature being evaluated.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains this feature.
    /// This member is required.
    public var project: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        evaluationContext: Swift.String? = nil,
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.evaluationContext = evaluationContext
        self.feature = feature
        self.project = project
    }
}

struct EvaluateFeatureInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let evaluationContext: Swift.String?
}

extension EvaluateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case evaluationContext
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let evaluationContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationContext)
        evaluationContext = evaluationContextDecoded
    }
}

extension EvaluateFeatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EvaluateFeatureOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.reason = output.reason
            self.value = output.value
            self.variation = output.variation
        } else {
            self.details = nil
            self.reason = nil
            self.value = nil
            self.variation = nil
        }
    }
}

public struct EvaluateFeatureOutput: Swift.Equatable {
    /// If this user was assigned to a launch or experiment, this field lists the launch or experiment name.
    public var details: Swift.String?
    /// Specifies the reason that the user session was assigned this variation. Possible values include DEFAULT, meaning the user was served the default variation; LAUNCH_RULE_MATCH, if the user session was enrolled in a launch; EXPERIMENT_RULE_MATCH, if the user session was enrolled in an experiment; or ENTITY_OVERRIDES_MATCH, if the user's entityId matches an override rule.
    public var reason: Swift.String?
    /// The value assigned to this variation to differentiate it from the other variations of this feature.
    public var value: EvidentlyClientTypes.VariableValue?
    /// The name of the variation that was served to the user session.
    public var variation: Swift.String?

    public init(
        details: Swift.String? = nil,
        reason: Swift.String? = nil,
        value: EvidentlyClientTypes.VariableValue? = nil,
        variation: Swift.String? = nil
    )
    {
        self.details = details
        self.reason = reason
        self.value = value
        self.variation = variation
    }
}

struct EvaluateFeatureOutputBody: Swift.Equatable {
    let variation: Swift.String?
    let value: EvidentlyClientTypes.VariableValue?
    let reason: Swift.String?
    let details: Swift.String?
}

extension EvaluateFeatureOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case reason
        case value
        case variation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

enum EvaluateFeatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvidentlyClientTypes.EvaluationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case evaluationContext
        case feature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let evaluationContext = self.evaluationContext {
            try encodeContainer.encode(evaluationContext, forKey: .evaluationContext)
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let evaluationContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationContext)
        evaluationContext = evaluationContextDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure assigns a feature variation to one user session.
    public struct EvaluationRequest: Swift.Equatable {
        /// An internal ID that represents a unique user session of the application. This entityID is checked against any override rules assigned for this feature.
        /// This member is required.
        public var entityId: Swift.String?
        /// A JSON block of attributes that you can optionally pass in. This JSON block is included in the evaluation events sent to Evidently from the user session.
        public var evaluationContext: Swift.String?
        /// The name of the feature being evaluated.
        /// This member is required.
        public var feature: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            evaluationContext: Swift.String? = nil,
            feature: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.evaluationContext = evaluationContext
            self.feature = feature
        }
    }

}

extension EvidentlyClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case entityId
        case feature
        case project
        case reason
        case value
        case variation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let variation = self.variation {
            try encodeContainer.encode(variation, forKey: .variation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure displays the results of one feature evaluation assignment to one user session.
    public struct EvaluationResult: Swift.Equatable {
        /// If this user was assigned to a launch or experiment, this field lists the launch or experiment name.
        public var details: Swift.String?
        /// An internal ID that represents a unique user session of the application.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the feature being evaluated.
        /// This member is required.
        public var feature: Swift.String?
        /// The name or ARN of the project that contains the feature being evaluated.
        public var project: Swift.String?
        /// Specifies the reason that the user session was assigned this variation. Possible values include DEFAULT, meaning the user was served the default variation; LAUNCH_RULE_MATCH, if the user session was enrolled in a launch; or EXPERIMENT_RULE_MATCH, if the user session was enrolled in an experiment.
        public var reason: Swift.String?
        /// The value assigned to this variation to differentiate it from the other variations of this feature.
        public var value: EvidentlyClientTypes.VariableValue?
        /// The name of the variation that was served to the user session.
        public var variation: Swift.String?

        public init(
            details: Swift.String? = nil,
            entityId: Swift.String? = nil,
            feature: Swift.String? = nil,
            project: Swift.String? = nil,
            reason: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil,
            variation: Swift.String? = nil
        )
        {
            self.details = details
            self.entityId = entityId
            self.feature = feature
            self.project = project
            self.reason = reason
            self.value = value
            self.variation = variation
        }
    }

}

extension EvidentlyClientTypes.EvaluationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the information about an evaluation rule for this feature, if it is used in a launch or experiment.
    public struct EvaluationRule: Swift.Equatable {
        /// The name of the experiment or launch.
        public var name: Swift.String?
        /// This value is aws.evidently.splits if this is an evaluation rule for a launch, and it is aws.evidently.onlineab if this is an evaluation rule for an experiment.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension EvidentlyClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case timestamp
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.EventType.self, forKey: .type)
        type = typeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the information about one evaluation event or custom event sent to Evidently. This is a JSON payload. If this event specifies a pre-defined event type, the payload must follow the defined event schema.
    public struct Event: Swift.Equatable {
        /// The event data.
        /// This member is required.
        public var data: Swift.String?
        /// The timestamp of the event.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// aws.evidently.evaluation specifies an evaluation event, which determines which feature variation that a user sees. aws.evidently.custom specifies a custom event, which generates metrics from user actions such as clicks and checkouts.
        /// This member is required.
        public var type: EvidentlyClientTypes.EventType?

        public init(
            data: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: EvidentlyClientTypes.EventType? = nil
        )
        {
            self.data = data
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension EvidentlyClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case evaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .custom,
                .evaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "aws.evidently.custom"
            case .evaluation: return "aws.evidently.evaluation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.Experiment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case execution
        case lastUpdatedTime
        case metricGoals
        case name
        case onlineAbDefinition
        case project
        case randomizationSalt
        case samplingRate
        case schedule
        case segment
        case status
        case statusReason
        case tags
        case treatments
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let execution = self.execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let metricGoals = metricGoals {
            var metricGoalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricGoals)
            for metricgoal0 in metricGoals {
                try metricGoalsContainer.encode(metricgoal0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let onlineAbDefinition = self.onlineAbDefinition {
            try encodeContainer.encode(onlineAbDefinition, forKey: .onlineAbDefinition)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let randomizationSalt = self.randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if samplingRate != 0 {
            try encodeContainer.encode(samplingRate, forKey: .samplingRate)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let treatments = treatments {
            var treatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatments)
            for treatment0 in treatments {
                try treatmentsContainer.encode(treatment0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let executionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentExecution.self, forKey: .execution)
        execution = executionDecoded
        let treatmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Treatment?].self, forKey: .treatments)
        var treatmentsDecoded0:[EvidentlyClientTypes.Treatment]? = nil
        if let treatmentsContainer = treatmentsContainer {
            treatmentsDecoded0 = [EvidentlyClientTypes.Treatment]()
            for structure0 in treatmentsContainer {
                if let structure0 = structure0 {
                    treatmentsDecoded0?.append(structure0)
                }
            }
        }
        treatments = treatmentsDecoded0
        let metricGoalsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricGoal?].self, forKey: .metricGoals)
        var metricGoalsDecoded0:[EvidentlyClientTypes.MetricGoal]? = nil
        if let metricGoalsContainer = metricGoalsContainer {
            metricGoalsDecoded0 = [EvidentlyClientTypes.MetricGoal]()
            for structure0 in metricGoalsContainer {
                if let structure0 = structure0 {
                    metricGoalsDecoded0?.append(structure0)
                }
            }
        }
        metricGoals = metricGoalsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate) ?? 0
        samplingRate = samplingRateDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segment)
        segment = segmentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentType.self, forKey: .type)
        type = typeDecoded
        let onlineAbDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.OnlineAbDefinition.self, forKey: .onlineAbDefinition)
        onlineAbDefinition = onlineAbDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure containing the configuration details of an experiment.
    public struct Experiment: Swift.Equatable {
        /// The ARN of the experiment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the experiment is first created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// A description of the experiment.
        public var description: Swift.String?
        /// A structure that contains the date and time that the experiment started and ended.
        public var execution: EvidentlyClientTypes.ExperimentExecution?
        /// The date and time that the experiment was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
        public var metricGoals: [EvidentlyClientTypes.MetricGoal]?
        /// The name of the experiment.
        /// This member is required.
        public var name: Swift.String?
        /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
        public var onlineAbDefinition: EvidentlyClientTypes.OnlineAbDefinition?
        /// The name or ARN of the project that contains this experiment.
        public var project: Swift.String?
        /// This value is used when Evidently assigns a particular user session to the experiment. It helps create a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt.
        public var randomizationSalt: Swift.String?
        /// In thousandths of a percent, the amount of the available audience that is allocated to this experiment. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent, so a value of 10,000 is 10% of the available audience.
        public var samplingRate: Swift.Int
        /// A structure that contains the time and date that Evidently completed the analysis of the experiment.
        public var schedule: EvidentlyClientTypes.ExperimentSchedule?
        /// The audience segment being used for the experiment, if a segment is being used.
        public var segment: Swift.String?
        /// The current state of the experiment.
        /// This member is required.
        public var status: EvidentlyClientTypes.ExperimentStatus?
        /// If the experiment was stopped, this is the string that was entered by the person who stopped the experiment, to explain why it was stopped.
        public var statusReason: Swift.String?
        /// The list of tag keys and values associated with this experiment.
        public var tags: [Swift.String:Swift.String]?
        /// An array of structures that describe the configuration of each feature variation used in the experiment.
        public var treatments: [EvidentlyClientTypes.Treatment]?
        /// The type of this experiment. Currently, this value must be aws.experiment.onlineab.
        /// This member is required.
        public var type: EvidentlyClientTypes.ExperimentType?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            execution: EvidentlyClientTypes.ExperimentExecution? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            metricGoals: [EvidentlyClientTypes.MetricGoal]? = nil,
            name: Swift.String? = nil,
            onlineAbDefinition: EvidentlyClientTypes.OnlineAbDefinition? = nil,
            project: Swift.String? = nil,
            randomizationSalt: Swift.String? = nil,
            samplingRate: Swift.Int = 0,
            schedule: EvidentlyClientTypes.ExperimentSchedule? = nil,
            segment: Swift.String? = nil,
            status: EvidentlyClientTypes.ExperimentStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            treatments: [EvidentlyClientTypes.Treatment]? = nil,
            type: EvidentlyClientTypes.ExperimentType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.execution = execution
            self.lastUpdatedTime = lastUpdatedTime
            self.metricGoals = metricGoals
            self.name = name
            self.onlineAbDefinition = onlineAbDefinition
            self.project = project
            self.randomizationSalt = randomizationSalt
            self.samplingRate = samplingRate
            self.schedule = schedule
            self.segment = segment
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.treatments = treatments
            self.type = type
        }
    }

}

extension EvidentlyClientTypes {
    public enum ExperimentBaseStat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mean
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentBaseStat] {
            return [
                .mean,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mean: return "Mean"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentBaseStat(rawValue: rawValue) ?? ExperimentBaseStat.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.ExperimentExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
        case startedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedTime = self.endedTime {
            try encodeContainer.encodeTimestamp(endedTime, format: .epochSeconds, forKey: .endedTime)
        }
        if let startedTime = self.startedTime {
            try encodeContainer.encodeTimestamp(startedTime, format: .epochSeconds, forKey: .startedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedTime)
        startedTime = startedTimeDecoded
        let endedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the date and time that the experiment started and ended.
    public struct ExperimentExecution: Swift.Equatable {
        /// The date and time that the experiment ended.
        public var endedTime: ClientRuntime.Date?
        /// The date and time that the experiment started.
        public var startedTime: ClientRuntime.Date?

        public init(
            endedTime: ClientRuntime.Date? = nil,
            startedTime: ClientRuntime.Date? = nil
        )
        {
            self.endedTime = endedTime
            self.startedTime = startedTime
        }
    }

}

extension EvidentlyClientTypes.ExperimentReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case metricName
        case reportName
        case treatmentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let reportName = self.reportName {
            try encodeContainer.encode(reportName.rawValue, forKey: .reportName)
        }
        if let treatmentName = self.treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
        let reportNameDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentReportName.self, forKey: .reportName)
        reportName = reportNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains results of an experiment.
    public struct ExperimentReport: Swift.Equatable {
        /// The content of the report.
        public var content: Swift.String?
        /// The name of the metric that is analyzed in this experiment report.
        public var metricName: Swift.String?
        /// The type of analysis used for this report.
        public var reportName: EvidentlyClientTypes.ExperimentReportName?
        /// The name of the variation that this report pertains to.
        public var treatmentName: Swift.String?

        public init(
            content: Swift.String? = nil,
            metricName: Swift.String? = nil,
            reportName: EvidentlyClientTypes.ExperimentReportName? = nil,
            treatmentName: Swift.String? = nil
        )
        {
            self.content = content
            self.metricName = metricName
            self.reportName = reportName
            self.treatmentName = treatmentName
        }
    }

}

extension EvidentlyClientTypes {
    public enum ExperimentReportName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bayesianInference
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentReportName] {
            return [
                .bayesianInference,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bayesianInference: return "BayesianInference"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentReportName(rawValue: rawValue) ?? ExperimentReportName.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentResultRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case baseStat
        case confidenceInterval
        case pValue
        case treatmentEffect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentResultRequestType] {
            return [
                .baseStat,
                .confidenceInterval,
                .pValue,
                .treatmentEffect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .baseStat: return "BaseStat"
            case .confidenceInterval: return "ConfidenceInterval"
            case .pValue: return "PValue"
            case .treatmentEffect: return "TreatmentEffect"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentResultRequestType(rawValue: rawValue) ?? ExperimentResultRequestType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentResultResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confidenceIntervalLowerbound
        case confidenceIntervalUpperbound
        case mean
        case pValue
        case treatmentEffect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentResultResponseType] {
            return [
                .confidenceIntervalLowerbound,
                .confidenceIntervalUpperbound,
                .mean,
                .pValue,
                .treatmentEffect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confidenceIntervalLowerbound: return "ConfidenceIntervalLowerBound"
            case .confidenceIntervalUpperbound: return "ConfidenceIntervalUpperBound"
            case .mean: return "Mean"
            case .pValue: return "PValue"
            case .treatmentEffect: return "TreatmentEffect"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentResultResponseType(rawValue: rawValue) ?? ExperimentResultResponseType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.ExperimentResultsData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case resultStat
        case treatmentName
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let resultStat = self.resultStat {
            try encodeContainer.encode(resultStat.rawValue, forKey: .resultStat)
        }
        if let treatmentName = self.treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for double0 in values {
                try valuesContainer.encode(double0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
        let resultStatDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentResultResponseType.self, forKey: .resultStat)
        resultStat = resultStatDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .values)
        var valuesDecoded0:[Swift.Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains experiment results for one metric that is monitored in the experiment.
    public struct ExperimentResultsData: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The experiment statistic that these results pertain to.
        public var resultStat: EvidentlyClientTypes.ExperimentResultResponseType?
        /// The treatment, or variation, that returned the values in this structure.
        public var treatmentName: Swift.String?
        /// The values for the metricName that were recorded in the experiment.
        public var values: [Swift.Double]?

        public init(
            metricName: Swift.String? = nil,
            resultStat: EvidentlyClientTypes.ExperimentResultResponseType? = nil,
            treatmentName: Swift.String? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.metricName = metricName
            self.resultStat = resultStat
            self.treatmentName = treatmentName
            self.values = values
        }
    }

}

extension EvidentlyClientTypes.ExperimentSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisCompleteTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisCompleteTime = self.analysisCompleteTime {
            try encodeContainer.encodeTimestamp(analysisCompleteTime, format: .epochSeconds, forKey: .analysisCompleteTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisCompleteTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .analysisCompleteTime)
        analysisCompleteTime = analysisCompleteTimeDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the time and date that Evidently completed the analysis of the experiment.
    public struct ExperimentSchedule: Swift.Equatable {
        /// The time and date that Evidently completed the analysis of the experiment.
        public var analysisCompleteTime: ClientRuntime.Date?

        public init(
            analysisCompleteTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisCompleteTime = analysisCompleteTime
        }
    }

}

extension EvidentlyClientTypes {
    public enum ExperimentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case created
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .cancelled,
                .completed,
                .created,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStatus(rawValue: rawValue) ?? ExperimentStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentStopDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStopDesiredState] {
            return [
                .cancelled,
                .completed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStopDesiredState(rawValue: rawValue) ?? ExperimentStopDesiredState.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum ExperimentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onlineAbExperiment
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentType] {
            return [
                .onlineAbExperiment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onlineAbExperiment: return "aws.evidently.onlineab"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentType(rawValue: rawValue) ?? ExperimentType.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.Feature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case defaultVariation
        case description
        case entityOverrides
        case evaluationRules
        case evaluationStrategy
        case lastUpdatedTime
        case name
        case project
        case status
        case tags
        case valueType
        case variations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let defaultVariation = self.defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityOverrides = entityOverrides {
            var entityOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .entityOverrides)
            for (dictKey0, entityOverrideMap0) in entityOverrides {
                try entityOverridesContainer.encode(entityOverrideMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let evaluationRules = evaluationRules {
            var evaluationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationRules)
            for evaluationrule0 in evaluationRules {
                try evaluationRulesContainer.encode(evaluationrule0)
            }
        }
        if let evaluationStrategy = self.evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let valueType = self.valueType {
            try encodeContainer.encode(valueType.rawValue, forKey: .valueType)
        }
        if let variations = variations {
            var variationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variations)
            for variation0 in variations {
                try variationsContainer.encode(variation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let valueTypeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariationValueType.self, forKey: .valueType)
        valueType = valueTypeDecoded
        let variationsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Variation?].self, forKey: .variations)
        var variationsDecoded0:[EvidentlyClientTypes.Variation]? = nil
        if let variationsContainer = variationsContainer {
            variationsDecoded0 = [EvidentlyClientTypes.Variation]()
            for structure0 in variationsContainer {
                if let structure0 = structure0 {
                    variationsDecoded0?.append(structure0)
                }
            }
        }
        variations = variationsDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let evaluationRulesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationRule?].self, forKey: .evaluationRules)
        var evaluationRulesDecoded0:[EvidentlyClientTypes.EvaluationRule]? = nil
        if let evaluationRulesContainer = evaluationRulesContainer {
            evaluationRulesDecoded0 = [EvidentlyClientTypes.EvaluationRule]()
            for structure0 in evaluationRulesContainer {
                if let structure0 = structure0 {
                    evaluationRulesDecoded0?.append(structure0)
                }
            }
        }
        evaluationRules = evaluationRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let entityOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .entityOverrides)
        var entityOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let entityOverridesContainer = entityOverridesContainer {
            entityOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in entityOverridesContainer {
                if let variationname0 = variationname0 {
                    entityOverridesDecoded0?[key0] = variationname0
                }
            }
        }
        entityOverrides = entityOverridesDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about one Evidently feature in your account.
    public struct Feature: Swift.Equatable {
        /// The ARN of the feature.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the feature is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name of the variation that is used as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit defaultVariation, the first variation listed in the variations structure is used as the default variation.
        public var defaultVariation: Swift.String?
        /// The description of the feature.
        public var description: Swift.String?
        /// A set of key-value pairs that specify users who should always be served a specific variation of a feature. Each key specifies a user using their user ID, account ID, or some other identifier. The value specifies the name of the variation that the user is to be served. For the override to be successful, the value of the key must match the entityId used in the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation.
        public var entityOverrides: [Swift.String:Swift.String]?
        /// An array of structures that define the evaluation rules for the feature.
        public var evaluationRules: [EvidentlyClientTypes.EvaluationRule]?
        /// If this value is ALL_RULES, the traffic allocation specified by any ongoing launches or experiments is being used. If this is DEFAULT_VARIATION, the default variation is being served to all users.
        /// This member is required.
        public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
        /// The date and time that the feature was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the feature.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the feature.
        public var project: Swift.String?
        /// The current state of the feature.
        /// This member is required.
        public var status: EvidentlyClientTypes.FeatureStatus?
        /// The list of tag keys and values associated with this feature.
        public var tags: [Swift.String:Swift.String]?
        /// Defines the type of value used to define the different feature variations. For more information, see [Variation types](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-variationtypes.html)
        /// This member is required.
        public var valueType: EvidentlyClientTypes.VariationValueType?
        /// An array of structures that contain the configuration of the feature's different variations.
        /// This member is required.
        public var variations: [EvidentlyClientTypes.Variation]?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            defaultVariation: Swift.String? = nil,
            description: Swift.String? = nil,
            entityOverrides: [Swift.String:Swift.String]? = nil,
            evaluationRules: [EvidentlyClientTypes.EvaluationRule]? = nil,
            evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            status: EvidentlyClientTypes.FeatureStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            valueType: EvidentlyClientTypes.VariationValueType? = nil,
            variations: [EvidentlyClientTypes.Variation]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.defaultVariation = defaultVariation
            self.description = description
            self.entityOverrides = entityOverrides
            self.evaluationRules = evaluationRules
            self.evaluationStrategy = evaluationStrategy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.project = project
            self.status = status
            self.tags = tags
            self.valueType = valueType
            self.variations = variations
        }
    }

}

extension EvidentlyClientTypes {
    public enum FeatureEvaluationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allRules
        case defaultVariation
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureEvaluationStrategy] {
            return [
                .allRules,
                .defaultVariation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allRules: return "ALL_RULES"
            case .defaultVariation: return "DEFAULT_VARIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureEvaluationStrategy(rawValue: rawValue) ?? FeatureEvaluationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum FeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .available,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureStatus(rawValue: rawValue) ?? FeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.FeatureSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case defaultVariation
        case evaluationRules
        case evaluationStrategy
        case lastUpdatedTime
        case name
        case project
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let defaultVariation = self.defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let evaluationRules = evaluationRules {
            var evaluationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationRules)
            for evaluationrule0 in evaluationRules {
                try evaluationRulesContainer.encode(evaluationrule0)
            }
        }
        if let evaluationStrategy = self.evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let evaluationRulesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.EvaluationRule?].self, forKey: .evaluationRules)
        var evaluationRulesDecoded0:[EvidentlyClientTypes.EvaluationRule]? = nil
        if let evaluationRulesContainer = evaluationRulesContainer {
            evaluationRulesDecoded0 = [EvidentlyClientTypes.EvaluationRule]()
            for structure0 in evaluationRulesContainer {
                if let structure0 = structure0 {
                    evaluationRulesDecoded0?.append(structure0)
                }
            }
        }
        evaluationRules = evaluationRulesDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about one Evidently feature in your account.
    public struct FeatureSummary: Swift.Equatable {
        /// The ARN of the feature.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the feature is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name of the variation that is used as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature.
        public var defaultVariation: Swift.String?
        /// An array of structures that define
        public var evaluationRules: [EvidentlyClientTypes.EvaluationRule]?
        /// If this value is ALL_RULES, the traffic allocation specified by any ongoing launches or experiments is being used. If this is DEFAULT_VARIATION, the default variation is being served to all users.
        /// This member is required.
        public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
        /// The date and time that the feature was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the feature.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the feature.
        public var project: Swift.String?
        /// The current state of the feature.
        /// This member is required.
        public var status: EvidentlyClientTypes.FeatureStatus?
        /// The list of tag keys and values associated with this feature.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            defaultVariation: Swift.String? = nil,
            evaluationRules: [EvidentlyClientTypes.EvaluationRule]? = nil,
            evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            status: EvidentlyClientTypes.FeatureStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.defaultVariation = defaultVariation
            self.evaluationRules = evaluationRules
            self.evaluationStrategy = evaluationStrategy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.project = project
            self.status = status
            self.tags = tags
        }
    }

}

extension GetExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

public struct GetExperimentInput: Swift.Equatable {
    /// The name of the experiment that you want to see the details of.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment.
    /// This member is required.
    public var project: Swift.String?

    public init(
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.experiment = experiment
        self.project = project
    }
}

struct GetExperimentInputBody: Swift.Equatable {
}

extension GetExperimentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct GetExperimentOutput: Swift.Equatable {
    /// A structure containing the configuration details of the experiment.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init(
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct GetExperimentOutputBody: Swift.Equatable {
    let experiment: EvidentlyClientTypes.Experiment?
}

extension GetExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

enum GetExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExperimentResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseStat
        case endTime
        case metricNames
        case period
        case reportNames
        case resultStats
        case startTime
        case treatmentNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseStat = self.baseStat {
            try encodeContainer.encode(baseStat.rawValue, forKey: .baseStat)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let metricNames = metricNames {
            var metricNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricNames)
            for cwdimensionsafename0 in metricNames {
                try metricNamesContainer.encode(cwdimensionsafename0)
            }
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let reportNames = reportNames {
            var reportNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportNames)
            for experimentreportname0 in reportNames {
                try reportNamesContainer.encode(experimentreportname0.rawValue)
            }
        }
        if let resultStats = resultStats {
            var resultStatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultStats)
            for experimentresultrequesttype0 in resultStats {
                try resultStatsContainer.encode(experimentresultrequesttype0.rawValue)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let treatmentNames = treatmentNames {
            var treatmentNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatmentNames)
            for treatmentname0 in treatmentNames {
                try treatmentNamesContainer.encode(treatmentname0)
            }
        }
    }
}

extension GetExperimentResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/results"
    }
}

public struct GetExperimentResultsInput: Swift.Equatable {
    /// The statistic used to calculate experiment results. Currently the only valid value is mean, which uses the mean of the collected values as the statistic.
    public var baseStat: EvidentlyClientTypes.ExperimentBaseStat?
    /// The date and time that the experiment ended, if it is completed. This must be no longer than 30 days after the experiment start time.
    public var endTime: ClientRuntime.Date?
    /// The name of the experiment to retrieve the results of.
    /// This member is required.
    public var experiment: Swift.String?
    /// The names of the experiment metrics that you want to see the results of.
    /// This member is required.
    public var metricNames: [Swift.String]?
    /// In seconds, the amount of time to aggregate results together.
    public var period: Swift.Int
    /// The name or ARN of the project that contains the experiment that you want to see the results of.
    /// This member is required.
    public var project: Swift.String?
    /// The names of the report types that you want to see. Currently, BayesianInference is the only valid value.
    public var reportNames: [EvidentlyClientTypes.ExperimentReportName]?
    /// The statistics that you want to see in the returned results.
    ///
    /// * PValue specifies to use p-values for the results. A p-value is used in hypothesis testing to measure how often you are willing to make a mistake in rejecting the null hypothesis. A general practice is to reject the null hypothesis and declare that the results are statistically significant when the p-value is less than 0.05.
    ///
    /// * ConfidenceInterval specifies a confidence interval for the results. The confidence interval represents the range of values for the chosen metric that is likely to contain the true difference between the baseStat of a variation and the baseline. Evidently returns the 95% confidence interval.
    ///
    /// * TreatmentEffect is the difference in the statistic specified by the baseStat parameter between each variation and the default variation.
    ///
    /// * BaseStat returns the statistical values collected for the metric for each variation. The statistic uses the same statistic specified in the baseStat parameter. Therefore, if baseStat is mean, this returns the mean of the values collected for each variation.
    public var resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]?
    /// The date and time that the experiment started.
    public var startTime: ClientRuntime.Date?
    /// The names of the experiment treatments that you want to see the results for.
    /// This member is required.
    public var treatmentNames: [Swift.String]?

    public init(
        baseStat: EvidentlyClientTypes.ExperimentBaseStat? = nil,
        endTime: ClientRuntime.Date? = nil,
        experiment: Swift.String? = nil,
        metricNames: [Swift.String]? = nil,
        period: Swift.Int = 0,
        project: Swift.String? = nil,
        reportNames: [EvidentlyClientTypes.ExperimentReportName]? = nil,
        resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]? = nil,
        startTime: ClientRuntime.Date? = nil,
        treatmentNames: [Swift.String]? = nil
    )
    {
        self.baseStat = baseStat
        self.endTime = endTime
        self.experiment = experiment
        self.metricNames = metricNames
        self.period = period
        self.project = project
        self.reportNames = reportNames
        self.resultStats = resultStats
        self.startTime = startTime
        self.treatmentNames = treatmentNames
    }
}

struct GetExperimentResultsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metricNames: [Swift.String]?
    let treatmentNames: [Swift.String]?
    let baseStat: EvidentlyClientTypes.ExperimentBaseStat?
    let resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]?
    let reportNames: [EvidentlyClientTypes.ExperimentReportName]?
    let period: Swift.Int
}

extension GetExperimentResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseStat
        case endTime
        case metricNames
        case period
        case reportNames
        case resultStats
        case startTime
        case treatmentNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricNames)
        var metricNamesDecoded0:[Swift.String]? = nil
        if let metricNamesContainer = metricNamesContainer {
            metricNamesDecoded0 = [Swift.String]()
            for string0 in metricNamesContainer {
                if let string0 = string0 {
                    metricNamesDecoded0?.append(string0)
                }
            }
        }
        metricNames = metricNamesDecoded0
        let treatmentNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .treatmentNames)
        var treatmentNamesDecoded0:[Swift.String]? = nil
        if let treatmentNamesContainer = treatmentNamesContainer {
            treatmentNamesDecoded0 = [Swift.String]()
            for string0 in treatmentNamesContainer {
                if let string0 = string0 {
                    treatmentNamesDecoded0?.append(string0)
                }
            }
        }
        treatmentNames = treatmentNamesDecoded0
        let baseStatDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentBaseStat.self, forKey: .baseStat)
        baseStat = baseStatDecoded
        let resultStatsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentResultRequestType?].self, forKey: .resultStats)
        var resultStatsDecoded0:[EvidentlyClientTypes.ExperimentResultRequestType]? = nil
        if let resultStatsContainer = resultStatsContainer {
            resultStatsDecoded0 = [EvidentlyClientTypes.ExperimentResultRequestType]()
            for string0 in resultStatsContainer {
                if let string0 = string0 {
                    resultStatsDecoded0?.append(string0)
                }
            }
        }
        resultStats = resultStatsDecoded0
        let reportNamesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentReportName?].self, forKey: .reportNames)
        var reportNamesDecoded0:[EvidentlyClientTypes.ExperimentReportName]? = nil
        if let reportNamesContainer = reportNamesContainer {
            reportNamesDecoded0 = [EvidentlyClientTypes.ExperimentReportName]()
            for string0 in reportNamesContainer {
                if let string0 = string0 {
                    reportNamesDecoded0?.append(string0)
                }
            }
        }
        reportNames = reportNamesDecoded0
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period) ?? 0
        period = periodDecoded
    }
}

extension GetExperimentResultsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExperimentResultsOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.reports = output.reports
            self.resultsData = output.resultsData
            self.timestamps = output.timestamps
        } else {
            self.details = nil
            self.reports = nil
            self.resultsData = nil
            self.timestamps = nil
        }
    }
}

public struct GetExperimentResultsOutput: Swift.Equatable {
    /// If the experiment doesn't yet have enough events to provide valid results, this field is returned with the message Not enough events to generate results. If there are enough events to provide valid results, this field is not returned.
    public var details: Swift.String?
    /// An array of structures that include the reports that you requested.
    public var reports: [EvidentlyClientTypes.ExperimentReport]?
    /// An array of structures that include experiment results including metric names and values.
    public var resultsData: [EvidentlyClientTypes.ExperimentResultsData]?
    /// The timestamps of each result returned.
    public var timestamps: [ClientRuntime.Date]?

    public init(
        details: Swift.String? = nil,
        reports: [EvidentlyClientTypes.ExperimentReport]? = nil,
        resultsData: [EvidentlyClientTypes.ExperimentResultsData]? = nil,
        timestamps: [ClientRuntime.Date]? = nil
    )
    {
        self.details = details
        self.reports = reports
        self.resultsData = resultsData
        self.timestamps = timestamps
    }
}

struct GetExperimentResultsOutputBody: Swift.Equatable {
    let resultsData: [EvidentlyClientTypes.ExperimentResultsData]?
    let reports: [EvidentlyClientTypes.ExperimentReport]?
    let timestamps: [ClientRuntime.Date]?
    let details: Swift.String?
}

extension GetExperimentResultsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case reports
        case resultsData
        case timestamps
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsDataContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentResultsData?].self, forKey: .resultsData)
        var resultsDataDecoded0:[EvidentlyClientTypes.ExperimentResultsData]? = nil
        if let resultsDataContainer = resultsDataContainer {
            resultsDataDecoded0 = [EvidentlyClientTypes.ExperimentResultsData]()
            for structure0 in resultsDataContainer {
                if let structure0 = structure0 {
                    resultsDataDecoded0?.append(structure0)
                }
            }
        }
        resultsData = resultsDataDecoded0
        let reportsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ExperimentReport?].self, forKey: .reports)
        var reportsDecoded0:[EvidentlyClientTypes.ExperimentReport]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [EvidentlyClientTypes.ExperimentReport]()
            for structure0 in reportsContainer {
                if let structure0 = structure0 {
                    reportsDecoded0?.append(structure0)
                }
            }
        }
        reports = reportsDecoded0
        let timestampsContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .timestamps)
        var timestampsDecoded0:[ClientRuntime.Date]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in timestampsContainer {
                if let timestamp0 = timestamp0 {
                    timestampsDecoded0?.append(timestamp0)
                }
            }
        }
        timestamps = timestampsDecoded0
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

enum GetExperimentResultsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

public struct GetFeatureInput: Swift.Equatable {
    /// The name of the feature that you want to retrieve information for.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature.
    /// This member is required.
    public var project: Swift.String?

    public init(
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.feature = feature
        self.project = project
    }
}

struct GetFeatureInputBody: Swift.Equatable {
}

extension GetFeatureInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFeatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFeatureOutputBody = try responseDecoder.decode(responseBody: data)
            self.feature = output.feature
        } else {
            self.feature = nil
        }
    }
}

public struct GetFeatureOutput: Swift.Equatable {
    /// A structure containing the configuration details of the feature.
    /// This member is required.
    public var feature: EvidentlyClientTypes.Feature?

    public init(
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

struct GetFeatureOutputBody: Swift.Equatable {
    let feature: EvidentlyClientTypes.Feature?
}

extension GetFeatureOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
    }
}

enum GetFeatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

public struct GetLaunchInput: Swift.Equatable {
    /// The name of the launch that you want to see the details of.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch.
    /// This member is required.
    public var project: Swift.String?

    public init(
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

struct GetLaunchInputBody: Swift.Equatable {
}

extension GetLaunchInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchOutputBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct GetLaunchOutput: Swift.Equatable {
    /// A structure containing the configuration details of the launch.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct GetLaunchOutputBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension GetLaunchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

enum GetLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

public struct GetProjectInput: Swift.Equatable {
    /// The name or ARN of the project that you want to see the details of.
    /// This member is required.
    public var project: Swift.String?

    public init(
        project: Swift.String? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectInputBody: Swift.Equatable {
}

extension GetProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct GetProjectOutput: Swift.Equatable {
    /// A structure containing the configuration details of the project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectOutputBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension GetProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

enum GetProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSegmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let segment = segment else {
            return nil
        }
        return "/segments/\(segment.urlPercentEncoding())"
    }
}

public struct GetSegmentInput: Swift.Equatable {
    /// The ARN of the segment to return information for.
    /// This member is required.
    public var segment: Swift.String?

    public init(
        segment: Swift.String? = nil
    )
    {
        self.segment = segment
    }
}

struct GetSegmentInputBody: Swift.Equatable {
}

extension GetSegmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSegmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSegmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.segment = output.segment
        } else {
            self.segment = nil
        }
    }
}

public struct GetSegmentOutput: Swift.Equatable {
    /// A structure that contains the complete information about the segment.
    /// This member is required.
    public var segment: EvidentlyClientTypes.Segment?

    public init(
        segment: EvidentlyClientTypes.Segment? = nil
    )
    {
        self.segment = segment
    }
}

struct GetSegmentOutputBody: Swift.Equatable {
    let segment: EvidentlyClientTypes.Segment?
}

extension GetSegmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case segment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Segment.self, forKey: .segment)
        segment = segmentDecoded
    }
}

enum GetSegmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EvidentlyClientTypes.Launch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case execution
        case groups
        case lastUpdatedTime
        case metricMonitors
        case name
        case project
        case randomizationSalt
        case scheduledSplitsDefinition
        case status
        case statusReason
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let execution = self.execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for launchgroup0 in groups {
                try groupsContainer.encode(launchgroup0)
            }
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let metricMonitors = metricMonitors {
            var metricMonitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricMonitors)
            for metricmonitor0 in metricMonitors {
                try metricMonitorsContainer.encode(metricmonitor0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
        if let randomizationSalt = self.randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let scheduledSplitsDefinition = self.scheduledSplitsDefinition {
            try encodeContainer.encode(scheduledSplitsDefinition, forKey: .scheduledSplitsDefinition)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .project)
        project = projectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let executionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchExecution.self, forKey: .execution)
        execution = executionDecoded
        let groupsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.LaunchGroup?].self, forKey: .groups)
        var groupsDecoded0:[EvidentlyClientTypes.LaunchGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [EvidentlyClientTypes.LaunchGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let metricMonitorsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricMonitor?].self, forKey: .metricMonitors)
        var metricMonitorsDecoded0:[EvidentlyClientTypes.MetricMonitor]? = nil
        if let metricMonitorsContainer = metricMonitorsContainer {
            metricMonitorsDecoded0 = [EvidentlyClientTypes.MetricMonitor]()
            for structure0 in metricMonitorsContainer {
                if let structure0 = structure0 {
                    metricMonitorsDecoded0?.append(structure0)
                }
            }
        }
        metricMonitors = metricMonitorsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchType.self, forKey: .type)
        type = typeDecoded
        let scheduledSplitsDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ScheduledSplitsLaunchDefinition.self, forKey: .scheduledSplitsDefinition)
        scheduledSplitsDefinition = scheduledSplitsDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the configuration details of one Evidently launch.
    public struct Launch: Swift.Equatable {
        /// The ARN of the launch.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the launch is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the launch.
        public var description: Swift.String?
        /// A structure that contains information about the start and end times of the launch.
        public var execution: EvidentlyClientTypes.LaunchExecution?
        /// An array of structures that define the feature variations that are being used in the launch.
        public var groups: [EvidentlyClientTypes.LaunchGroup]?
        /// The date and time that the launch was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// An array of structures that define the metrics that are being used to monitor the launch performance.
        public var metricMonitors: [EvidentlyClientTypes.MetricMonitor]?
        /// The name of the launch.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the launch.
        public var project: Swift.String?
        /// This value is used when Evidently assigns a particular user session to the launch, to help create a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt.
        public var randomizationSalt: Swift.String?
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
        public var scheduledSplitsDefinition: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition?
        /// The current state of the launch.
        /// This member is required.
        public var status: EvidentlyClientTypes.LaunchStatus?
        /// If the launch was stopped, this is the string that was entered by the person who stopped the launch, to explain why it was stopped.
        public var statusReason: Swift.String?
        /// The list of tag keys and values associated with this launch.
        public var tags: [Swift.String:Swift.String]?
        /// The type of launch.
        /// This member is required.
        public var type: EvidentlyClientTypes.LaunchType?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            execution: EvidentlyClientTypes.LaunchExecution? = nil,
            groups: [EvidentlyClientTypes.LaunchGroup]? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            metricMonitors: [EvidentlyClientTypes.MetricMonitor]? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            randomizationSalt: Swift.String? = nil,
            scheduledSplitsDefinition: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition? = nil,
            status: EvidentlyClientTypes.LaunchStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: EvidentlyClientTypes.LaunchType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.execution = execution
            self.groups = groups
            self.lastUpdatedTime = lastUpdatedTime
            self.metricMonitors = metricMonitors
            self.name = name
            self.project = project
            self.randomizationSalt = randomizationSalt
            self.scheduledSplitsDefinition = scheduledSplitsDefinition
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }
    }

}

extension EvidentlyClientTypes.LaunchExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
        case startedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedTime = self.endedTime {
            try encodeContainer.encodeTimestamp(endedTime, format: .epochSeconds, forKey: .endedTime)
        }
        if let startedTime = self.startedTime {
            try encodeContainer.encodeTimestamp(startedTime, format: .epochSeconds, forKey: .startedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedTime)
        startedTime = startedTimeDecoded
        let endedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about the start and end times of the launch.
    public struct LaunchExecution: Swift.Equatable {
        /// The date and time that the launch ended.
        public var endedTime: ClientRuntime.Date?
        /// The date and time that the launch started.
        public var startedTime: ClientRuntime.Date?

        public init(
            endedTime: ClientRuntime.Date? = nil,
            startedTime: ClientRuntime.Date? = nil
        )
        {
            self.endedTime = endedTime
            self.startedTime = startedTime
        }
    }

}

extension EvidentlyClientTypes.LaunchGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case featureVariations
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureVariations = featureVariations {
            var featureVariationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureVariations)
            for (dictKey0, featureToVariationMap0) in featureVariations {
                try featureVariationsContainer.encode(featureToVariationMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureVariationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureVariations)
        var featureVariationsDecoded0: [Swift.String:Swift.String]? = nil
        if let featureVariationsContainer = featureVariationsContainer {
            featureVariationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in featureVariationsContainer {
                if let variationname0 = variationname0 {
                    featureVariationsDecoded0?[key0] = variationname0
                }
            }
        }
        featureVariations = featureVariationsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one launch group in a launch. A launch group is a variation of the feature that you are including in the launch.
    public struct LaunchGroup: Swift.Equatable {
        /// A description of the launch group.
        public var description: Swift.String?
        /// The feature variation for this launch group. This is a key-value pair.
        /// This member is required.
        public var featureVariations: [Swift.String:Swift.String]?
        /// The name of the launch group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            featureVariations: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.featureVariations = featureVariations
            self.name = name
        }
    }

}

extension EvidentlyClientTypes.LaunchGroupConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case feature
        case name
        case variation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variation = self.variation {
            try encodeContainer.encode(variation, forKey: .variation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one launch group in a launch. A launch group is a variation of the feature that you are including in the launch.
    public struct LaunchGroupConfig: Swift.Equatable {
        /// A description of the launch group.
        public var description: Swift.String?
        /// The feature that this launch is using.
        /// This member is required.
        public var feature: Swift.String?
        /// A name for this launch group.
        /// This member is required.
        public var name: Swift.String?
        /// The feature variation to use for this launch group.
        /// This member is required.
        public var variation: Swift.String?

        public init(
            description: Swift.String? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            variation: Swift.String? = nil
        )
        {
            self.description = description
            self.feature = feature
            self.name = name
            self.variation = variation
        }
    }

}

extension EvidentlyClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case created
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .cancelled,
                .completed,
                .created,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum LaunchStopDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStopDesiredState] {
            return [
                .cancelled,
                .completed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStopDesiredState(rawValue: rawValue) ?? LaunchStopDesiredState.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes {
    public enum LaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case scheduledSplitsLaunch
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchType] {
            return [
                .scheduledSplitsLaunch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .scheduledSplitsLaunch: return "aws.evidently.splits"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchType(rawValue: rawValue) ?? LaunchType.sdkUnknown(rawValue)
        }
    }
}

extension ListExperimentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListExperimentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments"
    }
}

public struct ListExperimentsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListExperiments operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the experiment list from.
    /// This member is required.
    public var project: Swift.String?
    /// Use this optional parameter to limit the returned results to only the experiments with the status that you specify here.
    public var status: EvidentlyClientTypes.ExperimentStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil,
        status: EvidentlyClientTypes.ExperimentStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
        self.status = status
    }
}

struct ListExperimentsInputBody: Swift.Equatable {
}

extension ListExperimentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExperimentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiments = output.experiments
            self.nextToken = output.nextToken
        } else {
            self.experiments = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentsOutput: Swift.Equatable {
    /// An array of structures that contain the configuration details of the experiments in the specified project.
    public var experiments: [EvidentlyClientTypes.Experiment]?
    /// The token to use in a subsequent ListExperiments operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        experiments: [EvidentlyClientTypes.Experiment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

struct ListExperimentsOutputBody: Swift.Equatable {
    let experiments: [EvidentlyClientTypes.Experiment]?
    let nextToken: Swift.String?
}

extension ListExperimentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Experiment?].self, forKey: .experiments)
        var experimentsDecoded0:[EvidentlyClientTypes.Experiment]? = nil
        if let experimentsContainer = experimentsContainer {
            experimentsDecoded0 = [EvidentlyClientTypes.Experiment]()
            for structure0 in experimentsContainer {
                if let structure0 = structure0 {
                    experimentsDecoded0?.append(structure0)
                }
            }
        }
        experiments = experimentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExperimentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFeaturesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListFeaturesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features"
    }
}

public struct ListFeaturesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListFeatures operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the feature list from.
    /// This member is required.
    public var project: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
    }
}

struct ListFeaturesInputBody: Swift.Equatable {
}

extension ListFeaturesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFeaturesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFeaturesOutputBody = try responseDecoder.decode(responseBody: data)
            self.features = output.features
            self.nextToken = output.nextToken
        } else {
            self.features = nil
            self.nextToken = nil
        }
    }
}

public struct ListFeaturesOutput: Swift.Equatable {
    /// An array of structures that contain the configuration details of the features in the specified project.
    public var features: [EvidentlyClientTypes.FeatureSummary]?
    /// The token to use in a subsequent ListFeatures operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        features: [EvidentlyClientTypes.FeatureSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.features = features
        self.nextToken = nextToken
    }
}

struct ListFeaturesOutputBody: Swift.Equatable {
    let features: [EvidentlyClientTypes.FeatureSummary]?
    let nextToken: Swift.String?
}

extension ListFeaturesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case features
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featuresContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.FeatureSummary?].self, forKey: .features)
        var featuresDecoded0:[EvidentlyClientTypes.FeatureSummary]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [EvidentlyClientTypes.FeatureSummary]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFeaturesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLaunchesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListLaunchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches"
    }
}

public struct ListLaunchesInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListLaunches operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the launch list from.
    /// This member is required.
    public var project: Swift.String?
    /// Use this optional parameter to limit the returned results to only the launches with the status that you specify here.
    public var status: EvidentlyClientTypes.LaunchStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil,
        status: EvidentlyClientTypes.LaunchStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
        self.status = status
    }
}

struct ListLaunchesInputBody: Swift.Equatable {
}

extension ListLaunchesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLaunchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.launches = output.launches
            self.nextToken = output.nextToken
        } else {
            self.launches = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchesOutput: Swift.Equatable {
    /// An array of structures that contain the configuration details of the launches in the specified project.
    public var launches: [EvidentlyClientTypes.Launch]?
    /// The token to use in a subsequent ListLaunches operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        launches: [EvidentlyClientTypes.Launch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launches = launches
        self.nextToken = nextToken
    }
}

struct ListLaunchesOutputBody: Swift.Equatable {
    let launches: [EvidentlyClientTypes.Launch]?
    let nextToken: Swift.String?
}

extension ListLaunchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launches
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Launch?].self, forKey: .launches)
        var launchesDecoded0:[EvidentlyClientTypes.Launch]? = nil
        if let launchesContainer = launchesContainer {
            launchesDecoded0 = [EvidentlyClientTypes.Launch]()
            for structure0 in launchesContainer {
                if let structure0 = structure0 {
                    launchesDecoded0?.append(structure0)
                }
            }
        }
        launches = launchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLaunchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListProjects operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// The token to use in a subsequent ListProjects operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures that contain the configuration details of the projects in the Region.
    public var projects: [EvidentlyClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [EvidentlyClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let projects: [EvidentlyClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[EvidentlyClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [EvidentlyClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSegmentReferencesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let type = type else {
                let message = "Creating a URL Query Item failed. type is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
            return items
        }
    }
}

extension ListSegmentReferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let segment = segment else {
            return nil
        }
        return "/segments/\(segment.urlPercentEncoding())/references"
    }
}

public struct ListSegmentReferencesInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If you omit this, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListSegmentReferences operation.
    public var nextToken: Swift.String?
    /// The ARN of the segment that you want to view information for.
    /// This member is required.
    public var segment: Swift.String?
    /// Specifies whether to return information about launches or experiments that use this segment.
    /// This member is required.
    public var type: EvidentlyClientTypes.SegmentReferenceResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        segment: Swift.String? = nil,
        type: EvidentlyClientTypes.SegmentReferenceResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.segment = segment
        self.type = type
    }
}

struct ListSegmentReferencesInputBody: Swift.Equatable {
}

extension ListSegmentReferencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSegmentReferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSegmentReferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.referencedBy = output.referencedBy
        } else {
            self.nextToken = nil
            self.referencedBy = nil
        }
    }
}

public struct ListSegmentReferencesOutput: Swift.Equatable {
    /// The token to use in a subsequent ListSegmentReferences operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures, where each structure contains information about one experiment or launch that uses this segment.
    public var referencedBy: [EvidentlyClientTypes.RefResource]?

    public init(
        nextToken: Swift.String? = nil,
        referencedBy: [EvidentlyClientTypes.RefResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.referencedBy = referencedBy
    }
}

struct ListSegmentReferencesOutputBody: Swift.Equatable {
    let referencedBy: [EvidentlyClientTypes.RefResource]?
    let nextToken: Swift.String?
}

extension ListSegmentReferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case referencedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referencedByContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.RefResource?].self, forKey: .referencedBy)
        var referencedByDecoded0:[EvidentlyClientTypes.RefResource]? = nil
        if let referencedByContainer = referencedByContainer {
            referencedByDecoded0 = [EvidentlyClientTypes.RefResource]()
            for structure0 in referencedByContainer {
                if let structure0 = structure0 {
                    referencedByDecoded0?.append(structure0)
                }
            }
        }
        referencedBy = referencedByDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSegmentReferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSegmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSegmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/segments"
    }
}

public struct ListSegmentsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If you omit this, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListSegments operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSegmentsInputBody: Swift.Equatable {
}

extension ListSegmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSegmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSegmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.segments = output.segments
        } else {
            self.nextToken = nil
            self.segments = nil
        }
    }
}

public struct ListSegmentsOutput: Swift.Equatable {
    /// The token to use in a subsequent ListSegments operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures that contain information about the segments in this Region.
    public var segments: [EvidentlyClientTypes.Segment]?

    public init(
        nextToken: Swift.String? = nil,
        segments: [EvidentlyClientTypes.Segment]? = nil
    )
    {
        self.nextToken = nextToken
        self.segments = segments
    }
}

struct ListSegmentsOutputBody: Swift.Equatable {
    let segments: [EvidentlyClientTypes.Segment]?
    let nextToken: Swift.String?
}

extension ListSegmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case segments
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Segment?].self, forKey: .segments)
        var segmentsDecoded0:[EvidentlyClientTypes.Segment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [EvidentlyClientTypes.Segment]()
            for structure0 in segmentsContainer {
                if let structure0 = structure0 {
                    segmentsDecoded0?.append(structure0)
                }
            }
        }
        segments = segmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSegmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource that you want to see the tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tag keys and values associated with the resource you specified.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvidentlyClientTypes.MetricDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityIdKey
        case eventPattern
        case name
        case unitLabel
        case valueKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityIdKey = self.entityIdKey {
            try encodeContainer.encode(entityIdKey, forKey: .entityIdKey)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unitLabel = self.unitLabel {
            try encodeContainer.encode(unitLabel, forKey: .unitLabel)
        }
        if let valueKey = self.valueKey {
            try encodeContainer.encode(valueKey, forKey: .valueKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityIdKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdKey)
        entityIdKey = entityIdKeyDecoded
        let valueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueKey)
        valueKey = valueKeyDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let unitLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitLabel)
        unitLabel = unitLabelDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure defines a metric that is being used to evaluate the variations during a launch or experiment.
    public struct MetricDefinition: Swift.Equatable {
        /// The entity, such as a user or session, that does an action that causes a metric value to be recorded.
        public var entityIdKey: Swift.String?
        /// The EventBridge event pattern that defines how the metric is recorded. For more information about EventBridge event patterns, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).
        public var eventPattern: Swift.String?
        /// The name of the metric.
        public var name: Swift.String?
        /// The label for the units that the metric is measuring.
        public var unitLabel: Swift.String?
        /// The value that is tracked to produce the metric.
        public var valueKey: Swift.String?

        public init(
            entityIdKey: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.entityIdKey = entityIdKey
            self.eventPattern = eventPattern
            self.name = name
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }

}

extension EvidentlyClientTypes.MetricDefinitionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityIdKey
        case eventPattern
        case name
        case unitLabel
        case valueKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityIdKey = self.entityIdKey {
            try encodeContainer.encode(entityIdKey, forKey: .entityIdKey)
        }
        if let eventPattern = self.eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unitLabel = self.unitLabel {
            try encodeContainer.encode(unitLabel, forKey: .unitLabel)
        }
        if let valueKey = self.valueKey {
            try encodeContainer.encode(valueKey, forKey: .valueKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityIdKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdKey)
        entityIdKey = entityIdKeyDecoded
        let valueKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueKey)
        valueKey = valueKeyDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let unitLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitLabel)
        unitLabel = unitLabelDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure defines a metric that you want to use to evaluate the variations during a launch or experiment.
    public struct MetricDefinitionConfig: Swift.Equatable {
        /// The entity, such as a user or session, that does an action that causes a metric value to be recorded. An example is userDetails.userID.
        /// This member is required.
        public var entityIdKey: Swift.String?
        /// The EventBridge event pattern that defines how the metric is recorded. For more information about EventBridge event patterns, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).
        public var eventPattern: Swift.String?
        /// A name for the metric.
        /// This member is required.
        public var name: Swift.String?
        /// A label for the units that the metric is measuring.
        public var unitLabel: Swift.String?
        /// The value that is tracked to produce the metric.
        /// This member is required.
        public var valueKey: Swift.String?

        public init(
            entityIdKey: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.entityIdKey = entityIdKey
            self.eventPattern = eventPattern
            self.name = name
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }

}

extension EvidentlyClientTypes.MetricGoal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredChange
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredChange = self.desiredChange {
            try encodeContainer.encode(desiredChange.rawValue, forKey: .desiredChange)
        }
        if let metricDefinition = self.metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinition.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
        let desiredChangeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ChangeDirectionEnum.self, forKey: .desiredChange)
        desiredChange = desiredChangeDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that tells Evidently whether higher or lower values are desired for a metric that is used in an experiment.
    public struct MetricGoal: Swift.Equatable {
        /// INCREASE means that a variation with a higher number for this metric is performing better. DECREASE means that a variation with a lower number for this metric is performing better.
        public var desiredChange: EvidentlyClientTypes.ChangeDirectionEnum?
        /// A structure that contains details about the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinition?

        public init(
            desiredChange: EvidentlyClientTypes.ChangeDirectionEnum? = nil,
            metricDefinition: EvidentlyClientTypes.MetricDefinition? = nil
        )
        {
            self.desiredChange = desiredChange
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.MetricGoalConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredChange
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredChange = self.desiredChange {
            try encodeContainer.encode(desiredChange.rawValue, forKey: .desiredChange)
        }
        if let metricDefinition = self.metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinitionConfig.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
        let desiredChangeDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ChangeDirectionEnum.self, forKey: .desiredChange)
        desiredChange = desiredChangeDecoded
    }
}

extension EvidentlyClientTypes {
    /// Use this structure to tell Evidently whether higher or lower values are desired for a metric that is used in an experiment.
    public struct MetricGoalConfig: Swift.Equatable {
        /// INCREASE means that a variation with a higher number for this metric is performing better. DECREASE means that a variation with a lower number for this metric is performing better.
        public var desiredChange: EvidentlyClientTypes.ChangeDirectionEnum?
        /// A structure that contains details about the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig?

        public init(
            desiredChange: EvidentlyClientTypes.ChangeDirectionEnum? = nil,
            metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig? = nil
        )
        {
            self.desiredChange = desiredChange
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.MetricMonitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDefinition = self.metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinition.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines a metric to be used to monitor performance of the variations during a launch.
    public struct MetricMonitor: Swift.Equatable {
        /// A structure that defines the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinition?

        public init(
            metricDefinition: EvidentlyClientTypes.MetricDefinition? = nil
        )
        {
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.MetricMonitorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDefinition = self.metricDefinition {
            try encodeContainer.encode(metricDefinition, forKey: .metricDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDefinitionDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.MetricDefinitionConfig.self, forKey: .metricDefinition)
        metricDefinition = metricDefinitionDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines a metric to be used to monitor performance of the variations during a launch.
    public struct MetricMonitorConfig: Swift.Equatable {
        /// A structure that defines the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig?

        public init(
            metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig? = nil
        )
        {
            self.metricDefinition = metricDefinition
        }
    }

}

extension EvidentlyClientTypes.OnlineAbConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlTreatmentName
        case treatmentWeights
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlTreatmentName = self.controlTreatmentName {
            try encodeContainer.encode(controlTreatmentName, forKey: .controlTreatmentName)
        }
        if let treatmentWeights = treatmentWeights {
            var treatmentWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .treatmentWeights)
            for (dictKey0, treatmentToWeightMap0) in treatmentWeights {
                try treatmentWeightsContainer.encode(treatmentToWeightMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlTreatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTreatmentName)
        controlTreatmentName = controlTreatmentNameDecoded
        let treatmentWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .treatmentWeights)
        var treatmentWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let treatmentWeightsContainer = treatmentWeightsContainer {
            treatmentWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in treatmentWeightsContainer {
                if let splitweight0 = splitweight0 {
                    treatmentWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        treatmentWeights = treatmentWeightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public struct OnlineAbConfig: Swift.Equatable {
        /// The name of the variation that is to be the default variation that the other variations are compared to.
        public var controlTreatmentName: Swift.String?
        /// A set of key-value pairs. The keys are variation names, and the values are the portion of experiment traffic to be assigned to that variation. Specify the traffic portion in thousandths of a percent, so 20,000 for a variation would allocate 20% of the experiment traffic to that variation.
        public var treatmentWeights: [Swift.String:Swift.Int]?

        public init(
            controlTreatmentName: Swift.String? = nil,
            treatmentWeights: [Swift.String:Swift.Int]? = nil
        )
        {
            self.controlTreatmentName = controlTreatmentName
            self.treatmentWeights = treatmentWeights
        }
    }

}

extension EvidentlyClientTypes.OnlineAbDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlTreatmentName
        case treatmentWeights
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlTreatmentName = self.controlTreatmentName {
            try encodeContainer.encode(controlTreatmentName, forKey: .controlTreatmentName)
        }
        if let treatmentWeights = treatmentWeights {
            var treatmentWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .treatmentWeights)
            for (dictKey0, treatmentToWeightMap0) in treatmentWeights {
                try treatmentWeightsContainer.encode(treatmentToWeightMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlTreatmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTreatmentName)
        controlTreatmentName = controlTreatmentNameDecoded
        let treatmentWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .treatmentWeights)
        var treatmentWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let treatmentWeightsContainer = treatmentWeightsContainer {
            treatmentWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in treatmentWeightsContainer {
                if let splitweight0 = splitweight0 {
                    treatmentWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        treatmentWeights = treatmentWeightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public struct OnlineAbDefinition: Swift.Equatable {
        /// The name of the variation that is the default variation that the other variations are compared to.
        public var controlTreatmentName: Swift.String?
        /// A set of key-value pairs. The keys are variation names, and the values are the portion of experiment traffic to be assigned to that variation. The traffic portion is specified in thousandths of a percent, so 20,000 for a variation would allocate 20% of the experiment traffic to that variation.
        public var treatmentWeights: [Swift.String:Swift.Int]?

        public init(
            controlTreatmentName: Swift.String? = nil,
            treatmentWeights: [Swift.String:Swift.Int]? = nil
        )
        {
            self.controlTreatmentName = controlTreatmentName
            self.treatmentWeights = treatmentWeights
        }
    }

}

extension EvidentlyClientTypes.Project: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeExperimentCount
        case activeLaunchCount
        case appConfigResource
        case arn
        case createdTime
        case dataDelivery
        case description
        case experimentCount
        case featureCount
        case lastUpdatedTime
        case launchCount
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeExperimentCount = self.activeExperimentCount {
            try encodeContainer.encode(activeExperimentCount, forKey: .activeExperimentCount)
        }
        if let activeLaunchCount = self.activeLaunchCount {
            try encodeContainer.encode(activeLaunchCount, forKey: .activeLaunchCount)
        }
        if let appConfigResource = self.appConfigResource {
            try encodeContainer.encode(appConfigResource, forKey: .appConfigResource)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataDelivery = self.dataDelivery {
            try encodeContainer.encode(dataDelivery, forKey: .dataDelivery)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let experimentCount = self.experimentCount {
            try encodeContainer.encode(experimentCount, forKey: .experimentCount)
        }
        if let featureCount = self.featureCount {
            try encodeContainer.encode(featureCount, forKey: .featureCount)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let launchCount = self.launchCount {
            try encodeContainer.encode(launchCount, forKey: .launchCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .featureCount)
        featureCount = featureCountDecoded
        let launchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .launchCount)
        launchCount = launchCountDecoded
        let activeLaunchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeLaunchCount)
        activeLaunchCount = activeLaunchCountDecoded
        let experimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .experimentCount)
        experimentCount = experimentCountDecoded
        let activeExperimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeExperimentCount)
        activeExperimentCount = activeExperimentCountDecoded
        let dataDeliveryDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectDataDelivery.self, forKey: .dataDelivery)
        dataDelivery = dataDeliveryDecoded
        let appConfigResourceDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectAppConfigResource.self, forKey: .appConfigResource)
        appConfigResource = appConfigResourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure defines a project, which is the logical object in Evidently that can contain features, launches, and experiments. Use projects to group similar features together.
    public struct Project: Swift.Equatable {
        /// The number of ongoing experiments currently in the project.
        public var activeExperimentCount: Swift.Int?
        /// The number of ongoing launches currently in the project.
        public var activeLaunchCount: Swift.Int?
        /// This structure defines the configuration of how your application integrates with AppConfig to run client-side evaluation.
        public var appConfigResource: EvidentlyClientTypes.ProjectAppConfigResource?
        /// The name or ARN of the project.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the project is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
        public var dataDelivery: EvidentlyClientTypes.ProjectDataDelivery?
        /// The user-entered description of the project.
        public var description: Swift.String?
        /// The number of experiments currently in the project. This includes all experiments that have been created and not deleted, whether they are ongoing or not.
        public var experimentCount: Swift.Int?
        /// The number of features currently in the project.
        public var featureCount: Swift.Int?
        /// The date and time that the project was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number of launches currently in the project. This includes all launches that have been created and not deleted, whether they are ongoing or not.
        public var launchCount: Swift.Int?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the project.
        /// This member is required.
        public var status: EvidentlyClientTypes.ProjectStatus?
        /// The list of tag keys and values associated with this project.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeExperimentCount: Swift.Int? = nil,
            activeLaunchCount: Swift.Int? = nil,
            appConfigResource: EvidentlyClientTypes.ProjectAppConfigResource? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataDelivery: EvidentlyClientTypes.ProjectDataDelivery? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            featureCount: Swift.Int? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: EvidentlyClientTypes.ProjectStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeExperimentCount = activeExperimentCount
            self.activeLaunchCount = activeLaunchCount
            self.appConfigResource = appConfigResource
            self.arn = arn
            self.createdTime = createdTime
            self.dataDelivery = dataDelivery
            self.description = description
            self.experimentCount = experimentCount
            self.featureCount = featureCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension EvidentlyClientTypes.ProjectAppConfigResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case configurationProfileId
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let configurationProfileId = self.configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
    }
}

extension EvidentlyClientTypes {
    /// This is a structure that defines the configuration of how your application integrates with AppConfig to run client-side evaluation.
    public struct ProjectAppConfigResource: Swift.Equatable {
        /// The ID of the AppConfig application to use for client-side evaluation.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The ID of the AppConfig profile to use for client-side evaluation.
        /// This member is required.
        public var configurationProfileId: Swift.String?
        /// The ID of the AppConfig environment to use for client-side evaluation. This must be an environment that is within the application that you specify for applicationId.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            configurationProfileId: Swift.String? = nil,
            environmentId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.environmentId = environmentId
        }
    }

}

extension EvidentlyClientTypes.ProjectAppConfigResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension EvidentlyClientTypes {
    /// Use this parameter to configure client-side evaluation for your project. Client-side evaluation allows your application to assign variations to user sessions locally instead of by calling the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation to assign the variations. This mitigates the latency and availability risks that come with an API call. ProjectAppConfigResource is a structure that defines the configuration of how your application integrates with AppConfig to run client-side evaluation.
    public struct ProjectAppConfigResourceConfig: Swift.Equatable {
        /// The ID of the AppConfig application to use for client-side evaluation.
        public var applicationId: Swift.String?
        /// The ID of the AppConfig environment to use for client-side evaluation. This must be an environment that is within the application that you specify for applicationId.
        public var environmentId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            environmentId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.environmentId = environmentId
        }
    }

}

extension EvidentlyClientTypes.ProjectDataDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
    public struct ProjectDataDelivery: Swift.Equatable {
        /// If the project stores evaluation events in CloudWatch Logs, this structure stores the log group name.
        public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestination?
        /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
        public var s3Destination: EvidentlyClientTypes.S3Destination?

        public init(
            cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestination? = nil,
            s3Destination: EvidentlyClientTypes.S3Destination? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Destination = s3Destination
        }
    }

}

extension EvidentlyClientTypes.ProjectDataDeliveryConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.S3DestinationConfig.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.CloudWatchLogsDestinationConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
    public struct ProjectDataDeliveryConfig: Swift.Equatable {
        /// If the project stores evaluation events in CloudWatch Logs, this structure stores the log group name.
        public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
        /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
        public var s3Destination: EvidentlyClientTypes.S3DestinationConfig?

        public init(
            cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig? = nil,
            s3Destination: EvidentlyClientTypes.S3DestinationConfig? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Destination = s3Destination
        }
    }

}

extension EvidentlyClientTypes {
    public enum ProjectStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectStatus] {
            return [
                .available,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectStatus(rawValue: rawValue) ?? ProjectStatus.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeExperimentCount
        case activeLaunchCount
        case arn
        case createdTime
        case description
        case experimentCount
        case featureCount
        case lastUpdatedTime
        case launchCount
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeExperimentCount = self.activeExperimentCount {
            try encodeContainer.encode(activeExperimentCount, forKey: .activeExperimentCount)
        }
        if let activeLaunchCount = self.activeLaunchCount {
            try encodeContainer.encode(activeLaunchCount, forKey: .activeLaunchCount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let experimentCount = self.experimentCount {
            try encodeContainer.encode(experimentCount, forKey: .experimentCount)
        }
        if let featureCount = self.featureCount {
            try encodeContainer.encode(featureCount, forKey: .featureCount)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let launchCount = self.launchCount {
            try encodeContainer.encode(launchCount, forKey: .launchCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .featureCount)
        featureCount = featureCountDecoded
        let launchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .launchCount)
        launchCount = launchCountDecoded
        let activeLaunchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeLaunchCount)
        activeLaunchCount = activeLaunchCountDecoded
        let experimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .experimentCount)
        experimentCount = experimentCountDecoded
        let activeExperimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeExperimentCount)
        activeExperimentCount = activeExperimentCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains configuration information about an Evidently project.
    public struct ProjectSummary: Swift.Equatable {
        /// The number of experiments currently in the project.
        public var activeExperimentCount: Swift.Int?
        /// The number of ongoing launches currently in the project.
        public var activeLaunchCount: Swift.Int?
        /// The name or ARN of the project.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the project is created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the project.
        public var description: Swift.String?
        /// The number of experiments currently in the project.
        public var experimentCount: Swift.Int?
        /// The number of features currently in the project.
        public var featureCount: Swift.Int?
        /// The date and time that the project was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number of launches currently in the project, including launches that are ongoing, completed, and not started yet.
        public var launchCount: Swift.Int?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the project.
        /// This member is required.
        public var status: EvidentlyClientTypes.ProjectStatus?
        /// The list of tag keys and values associated with this project.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeExperimentCount: Swift.Int? = nil,
            activeLaunchCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            featureCount: Swift.Int? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: EvidentlyClientTypes.ProjectStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeExperimentCount = activeExperimentCount
            self.activeLaunchCount = activeLaunchCount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.experimentCount = experimentCount
            self.featureCount = featureCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension PutProjectEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for event0 in events {
                try eventsContainer.encode(event0)
            }
        }
    }
}

extension PutProjectEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/events/projects/\(project.urlPercentEncoding())"
    }
}

public struct PutProjectEventsInput: Swift.Equatable {
    /// An array of event structures that contain the performance data that is being sent to Evidently.
    /// This member is required.
    public var events: [EvidentlyClientTypes.Event]?
    /// The name or ARN of the project to write the events to.
    /// This member is required.
    public var project: Swift.String?

    public init(
        events: [EvidentlyClientTypes.Event]? = nil,
        project: Swift.String? = nil
    )
    {
        self.events = events
        self.project = project
    }
}

struct PutProjectEventsInputBody: Swift.Equatable {
    let events: [EvidentlyClientTypes.Event]?
}

extension PutProjectEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[EvidentlyClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [EvidentlyClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension PutProjectEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutProjectEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventResults = output.eventResults
            self.failedEventCount = output.failedEventCount
        } else {
            self.eventResults = nil
            self.failedEventCount = nil
        }
    }
}

public struct PutProjectEventsOutput: Swift.Equatable {
    /// A structure that contains Evidently's response to the sent events, including an event ID and error codes, if any.
    public var eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]?
    /// The number of events in the operation that could not be used by Evidently.
    public var failedEventCount: Swift.Int?

    public init(
        eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]? = nil,
        failedEventCount: Swift.Int? = nil
    )
    {
        self.eventResults = eventResults
        self.failedEventCount = failedEventCount
    }
}

struct PutProjectEventsOutputBody: Swift.Equatable {
    let failedEventCount: Swift.Int?
    let eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]?
}

extension PutProjectEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventResults
        case failedEventCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEventCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEventCount)
        failedEventCount = failedEventCountDecoded
        let eventResultsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.PutProjectEventsResultEntry?].self, forKey: .eventResults)
        var eventResultsDecoded0:[EvidentlyClientTypes.PutProjectEventsResultEntry]? = nil
        if let eventResultsContainer = eventResultsContainer {
            eventResultsDecoded0 = [EvidentlyClientTypes.PutProjectEventsResultEntry]()
            for structure0 in eventResultsContainer {
                if let structure0 = structure0 {
                    eventResultsDecoded0?.append(structure0)
                }
            }
        }
        eventResults = eventResultsDecoded0
    }
}

enum PutProjectEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvidentlyClientTypes.PutProjectEventsResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains Evidently's response to the sent events, including an event ID and error codes, if any.
    public struct PutProjectEventsResultEntry: Swift.Equatable {
        /// If the PutProjectEvents operation has an error, the error code is returned here.
        public var errorCode: Swift.String?
        /// If the PutProjectEvents operation has an error, the error message is returned here.
        public var errorMessage: Swift.String?
        /// A unique ID assigned to this PutProjectEvents operation.
        public var eventId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }

}

extension EvidentlyClientTypes.RefResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case endTime
        case lastUpdatedOn
        case name
        case startTime
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let lastUpdatedOn = self.lastUpdatedOn {
            try encodeContainer.encode(lastUpdatedOn, forKey: .lastUpdatedOn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedOnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedOn)
        lastUpdatedOn = lastUpdatedOnDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that contains information about one experiment or launch that uses the specified segment.
    public struct RefResource: Swift.Equatable {
        /// The ARN of the experiment or launch.
        public var arn: Swift.String?
        /// The day and time that this experiment or launch ended.
        public var endTime: Swift.String?
        /// The day and time that this experiment or launch was most recently updated.
        public var lastUpdatedOn: Swift.String?
        /// The name of the experiment or launch.
        /// This member is required.
        public var name: Swift.String?
        /// The day and time that this experiment or launch started.
        public var startTime: Swift.String?
        /// The status of the experiment or launch.
        public var status: Swift.String?
        /// Specifies whether the resource that this structure contains information about is an experiment or a launch.
        /// This member is required.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            endTime: Swift.String? = nil,
            lastUpdatedOn: Swift.String? = nil,
            name: Swift.String? = nil,
            startTime: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.endTime = endTime
            self.lastUpdatedOn = lastUpdatedOn
            self.name = name
            self.startTime = startTime
            self.status = status
            self.type = type
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension EvidentlyClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension EvidentlyClientTypes {
    /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
    public struct S3Destination: Swift.Equatable {
        /// The name of the bucket in which Evidently stores evaluation events.
        public var bucket: Swift.String?
        /// The bucket prefix in which Evidently stores evaluation events.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension EvidentlyClientTypes.S3DestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension EvidentlyClientTypes {
    /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
    public struct S3DestinationConfig: Swift.Equatable {
        /// The name of the bucket in which Evidently stores evaluation events.
        public var bucket: Swift.String?
        /// The bucket prefix in which Evidently stores evaluation events.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupWeights
        case segmentOverrides
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupWeights = groupWeights {
            var groupWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .groupWeights)
            for (dictKey0, groupToWeightMap0) in groupWeights {
                try groupWeightsContainer.encode(groupToWeightMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let segmentOverrides = segmentOverrides {
            var segmentOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentOverrides)
            for segmentoverride0 in segmentOverrides {
                try segmentOverridesContainer.encode(segmentoverride0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let groupWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .groupWeights)
        var groupWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let groupWeightsContainer = groupWeightsContainer {
            groupWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in groupWeightsContainer {
                if let splitweight0 = splitweight0 {
                    groupWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        groupWeights = groupWeightsDecoded0
        let segmentOverridesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.SegmentOverride?].self, forKey: .segmentOverrides)
        var segmentOverridesDecoded0:[EvidentlyClientTypes.SegmentOverride]? = nil
        if let segmentOverridesContainer = segmentOverridesContainer {
            segmentOverridesDecoded0 = [EvidentlyClientTypes.SegmentOverride]()
            for structure0 in segmentOverridesContainer {
                if let structure0 = structure0 {
                    segmentOverridesDecoded0?.append(structure0)
                }
            }
        }
        segmentOverrides = segmentOverridesDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure defines the traffic allocation percentages among the feature variations during one step of a launch, and the start time of that step.
    public struct ScheduledSplit: Swift.Equatable {
        /// The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step. The values is expressed in thousandths of a percent, so assigning a weight of 50000 assigns 50% of traffic to that variation. If the sum of the weights for all the variations in a segment override does not add up to 100,000, then the remaining traffic that matches this segment is not assigned by this segment override, and instead moves on to the next segment override or the default traffic split.
        public var groupWeights: [Swift.String:Swift.Int]?
        /// Use this parameter to specify different traffic splits for one or more audience segments. A segment is a portion of your audience that share one or more characteristics. Examples could be Chrome browser users, users in Europe, or Firefox browser users in Europe who also fit other criteria that your application collects, such as age. This parameter is an array of up to six segment override objects. Each of these objects specifies a segment that you have already created, and defines the traffic split for that segment.
        public var segmentOverrides: [EvidentlyClientTypes.SegmentOverride]?
        /// The date and time that this step of the launch starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            groupWeights: [Swift.String:Swift.Int]? = nil,
            segmentOverrides: [EvidentlyClientTypes.SegmentOverride]? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.groupWeights = groupWeights
            self.segmentOverrides = segmentOverrides
            self.startTime = startTime
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplitConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupWeights
        case segmentOverrides
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupWeights = groupWeights {
            var groupWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .groupWeights)
            for (dictKey0, groupToWeightMap0) in groupWeights {
                try groupWeightsContainer.encode(groupToWeightMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let segmentOverrides = segmentOverrides {
            var segmentOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentOverrides)
            for segmentoverride0 in segmentOverrides {
                try segmentOverridesContainer.encode(segmentoverride0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let groupWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .groupWeights)
        var groupWeightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let groupWeightsContainer = groupWeightsContainer {
            groupWeightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in groupWeightsContainer {
                if let splitweight0 = splitweight0 {
                    groupWeightsDecoded0?[key0] = splitweight0
                }
            }
        }
        groupWeights = groupWeightsDecoded0
        let segmentOverridesContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.SegmentOverride?].self, forKey: .segmentOverrides)
        var segmentOverridesDecoded0:[EvidentlyClientTypes.SegmentOverride]? = nil
        if let segmentOverridesContainer = segmentOverridesContainer {
            segmentOverridesDecoded0 = [EvidentlyClientTypes.SegmentOverride]()
            for structure0 in segmentOverridesContainer {
                if let structure0 = structure0 {
                    segmentOverridesDecoded0?.append(structure0)
                }
            }
        }
        segmentOverrides = segmentOverridesDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure defines the traffic allocation percentages among the feature variations during one step of a launch, and the start time of that step.
    public struct ScheduledSplitConfig: Swift.Equatable {
        /// The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step. The values is expressed in thousandths of a percent, so assigning a weight of 50000 assigns 50% of traffic to that variation. If the sum of the weights for all the variations in a segment override does not add up to 100,000, then the remaining traffic that matches this segment is not assigned by this segment override, and instead moves on to the next segment override or the default traffic split.
        /// This member is required.
        public var groupWeights: [Swift.String:Swift.Int]?
        /// Use this parameter to specify different traffic splits for one or more audience segments. A segment is a portion of your audience that share one or more characteristics. Examples could be Chrome browser users, users in Europe, or Firefox browser users in Europe who also fit other criteria that your application collects, such as age. This parameter is an array of up to six segment override objects. Each of these objects specifies a segment that you have already created, and defines the traffic split for that segment.
        public var segmentOverrides: [EvidentlyClientTypes.SegmentOverride]?
        /// The date and time that this step of the launch starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            groupWeights: [Swift.String:Swift.Int]? = nil,
            segmentOverrides: [EvidentlyClientTypes.SegmentOverride]? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.groupWeights = groupWeights
            self.segmentOverrides = segmentOverrides
            self.startTime = startTime
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplitsLaunchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for scheduledsplitconfig0 in steps {
                try stepsContainer.encode(scheduledsplitconfig0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ScheduledSplitConfig?].self, forKey: .steps)
        var stepsDecoded0:[EvidentlyClientTypes.ScheduledSplitConfig]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [EvidentlyClientTypes.ScheduledSplitConfig]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of a launch. This also defines the start time of each step.
    public struct ScheduledSplitsLaunchConfig: Swift.Equatable {
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step.
        /// This member is required.
        public var steps: [EvidentlyClientTypes.ScheduledSplitConfig]?

        public init(
            steps: [EvidentlyClientTypes.ScheduledSplitConfig]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension EvidentlyClientTypes.ScheduledSplitsLaunchDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for scheduledsplit0 in steps {
                try stepsContainer.encode(scheduledsplit0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ScheduledSplit?].self, forKey: .steps)
        var stepsDecoded0:[EvidentlyClientTypes.ScheduledSplit]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [EvidentlyClientTypes.ScheduledSplit]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of a launch. This also defines the start time of each step.
    public struct ScheduledSplitsLaunchDefinition: Swift.Equatable {
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step.
        public var steps: [EvidentlyClientTypes.ScheduledSplit]?

        public init(
            steps: [EvidentlyClientTypes.ScheduledSplit]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension EvidentlyClientTypes.Segment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case experimentCount
        case lastUpdatedTime
        case launchCount
        case name
        case pattern
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let experimentCount = self.experimentCount {
            try encodeContainer.encode(experimentCount, forKey: .experimentCount)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let launchCount = self.launchCount {
            try encodeContainer.encode(launchCount, forKey: .launchCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let experimentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .experimentCount)
        experimentCount = experimentCountDecoded
        let launchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .launchCount)
        launchCount = launchCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure contains information about one audience segment. You can use segments in your experiments and launches to narrow the user sessions used for experiment or launch to only the user sessions that match one or more criteria.
    public struct Segment: Swift.Equatable {
        /// The ARN of the segment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that this segment was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The customer-created description for this segment.
        public var description: Swift.String?
        /// The number of experiments that this segment is used in. This count includes all current experiments, not just those that are currently running.
        public var experimentCount: Swift.Int?
        /// The date and time that this segment was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number of launches that this segment is used in. This count includes all current launches, not just those that are currently running.
        public var launchCount: Swift.Int?
        /// The name of the segment.
        /// This member is required.
        public var name: Swift.String?
        /// The pattern that defines the attributes to use to evalute whether a user session will be in the segment. For more information about the pattern syntax, see [Segment rule pattern syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-segments.html).
        /// This member is required.
        public var pattern: Swift.String?
        /// The list of tag keys and values associated with this launch.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.experimentCount = experimentCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.pattern = pattern
            self.tags = tags
        }
    }

}

extension EvidentlyClientTypes.SegmentOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationOrder
        case segment
        case weights
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationOrder = self.evaluationOrder {
            try encodeContainer.encode(evaluationOrder, forKey: .evaluationOrder)
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let weights = weights {
            var weightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .weights)
            for (dictKey0, groupToWeightMap0) in weights {
                try weightsContainer.encode(groupToWeightMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segment)
        segment = segmentDecoded
        let evaluationOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationOrder)
        evaluationOrder = evaluationOrderDecoded
        let weightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .weights)
        var weightsDecoded0: [Swift.String:Swift.Int]? = nil
        if let weightsContainer = weightsContainer {
            weightsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, splitweight0) in weightsContainer {
                if let splitweight0 = splitweight0 {
                    weightsDecoded0?[key0] = splitweight0
                }
            }
        }
        weights = weightsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// This structure specifies a segment that you have already created, and defines the traffic split for that segment to be used in a launch.
    public struct SegmentOverride: Swift.Equatable {
        /// A number indicating the order to use to evaluate segment overrides, if there are more than one. Segment overrides with lower numbers are evaluated first.
        /// This member is required.
        public var evaluationOrder: Swift.Int?
        /// The ARN of the segment to use.
        /// This member is required.
        public var segment: Swift.String?
        /// The traffic allocation percentages among the feature variations to assign to this segment. This is a set of key-value pairs. The keys are variation names. The values represent the amount of traffic to allocate to that variation for this segment. This is expressed in thousandths of a percent, so a weight of 50000 represents 50% of traffic.
        /// This member is required.
        public var weights: [Swift.String:Swift.Int]?

        public init(
            evaluationOrder: Swift.Int? = nil,
            segment: Swift.String? = nil,
            weights: [Swift.String:Swift.Int]? = nil
        )
        {
            self.evaluationOrder = evaluationOrder
            self.segment = segment
            self.weights = weights
        }
    }

}

extension EvidentlyClientTypes {
    public enum SegmentReferenceResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case experiment
        case launch
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentReferenceResourceType] {
            return [
                .experiment,
                .launch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .experiment: return "EXPERIMENT"
            case .launch: return "LAUNCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SegmentReferenceResourceType(rawValue: rawValue) ?? SegmentReferenceResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service was unavailable. Retry the request.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisCompleteTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisCompleteTime = self.analysisCompleteTime {
            try encodeContainer.encodeTimestamp(analysisCompleteTime, format: .epochSeconds, forKey: .analysisCompleteTime)
        }
    }
}

extension StartExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/start"
    }
}

public struct StartExperimentInput: Swift.Equatable {
    /// The date and time to end the experiment. This must be no more than 30 days after the experiment starts.
    /// This member is required.
    public var analysisCompleteTime: ClientRuntime.Date?
    /// The name of the experiment to start.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to start.
    /// This member is required.
    public var project: Swift.String?

    public init(
        analysisCompleteTime: ClientRuntime.Date? = nil,
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.analysisCompleteTime = analysisCompleteTime
        self.experiment = experiment
        self.project = project
    }
}

struct StartExperimentInputBody: Swift.Equatable {
    let analysisCompleteTime: ClientRuntime.Date?
}

extension StartExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisCompleteTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisCompleteTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .analysisCompleteTime)
        analysisCompleteTime = analysisCompleteTimeDecoded
    }
}

extension StartExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.startedTime = output.startedTime
        } else {
            self.startedTime = nil
        }
    }
}

public struct StartExperimentOutput: Swift.Equatable {
    /// A timestamp that indicates when the experiment started.
    public var startedTime: ClientRuntime.Date?

    public init(
        startedTime: ClientRuntime.Date? = nil
    )
    {
        self.startedTime = startedTime
    }
}

struct StartExperimentOutputBody: Swift.Equatable {
    let startedTime: ClientRuntime.Date?
}

extension StartExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startedTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedTime)
        startedTime = startedTimeDecoded
    }
}

enum StartExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())/start"
    }
}

public struct StartLaunchInput: Swift.Equatable {
    /// The name of the launch to start.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch to start.
    /// This member is required.
    public var project: Swift.String?

    public init(
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

struct StartLaunchInputBody: Swift.Equatable {
}

extension StartLaunchInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartLaunchOutputBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct StartLaunchOutput: Swift.Equatable {
    /// A structure that contains information about the launch that was started.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct StartLaunchOutputBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension StartLaunchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

enum StartLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension StopExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/cancel"
    }
}

public struct StopExperimentInput: Swift.Equatable {
    /// Specify whether the experiment is to be considered COMPLETED or CANCELLED after it stops.
    public var desiredState: EvidentlyClientTypes.ExperimentStopDesiredState?
    /// The name of the experiment to stop.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to stop.
    /// This member is required.
    public var project: Swift.String?
    /// A string that describes why you are stopping the experiment.
    public var reason: Swift.String?

    public init(
        desiredState: EvidentlyClientTypes.ExperimentStopDesiredState? = nil,
        experiment: Swift.String? = nil,
        project: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.desiredState = desiredState
        self.experiment = experiment
        self.project = project
        self.reason = reason
    }
}

struct StopExperimentInputBody: Swift.Equatable {
    let desiredState: EvidentlyClientTypes.ExperimentStopDesiredState?
    let reason: Swift.String?
}

extension StopExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ExperimentStopDesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.endedTime = output.endedTime
        } else {
            self.endedTime = nil
        }
    }
}

public struct StopExperimentOutput: Swift.Equatable {
    /// The date and time that the experiment stopped.
    public var endedTime: ClientRuntime.Date?

    public init(
        endedTime: ClientRuntime.Date? = nil
    )
    {
        self.endedTime = endedTime
    }
}

struct StopExperimentOutputBody: Swift.Equatable {
    let endedTime: ClientRuntime.Date?
}

extension StopExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

enum StopExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension StopLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())/cancel"
    }
}

public struct StopLaunchInput: Swift.Equatable {
    /// Specify whether to consider the launch as COMPLETED or CANCELLED after it stops.
    public var desiredState: EvidentlyClientTypes.LaunchStopDesiredState?
    /// The name of the launch to stop.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch that you want to stop.
    /// This member is required.
    public var project: Swift.String?
    /// A string that describes why you are stopping the launch.
    public var reason: Swift.String?

    public init(
        desiredState: EvidentlyClientTypes.LaunchStopDesiredState? = nil,
        launch: Swift.String? = nil,
        project: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.desiredState = desiredState
        self.launch = launch
        self.project = project
        self.reason = reason
    }
}

struct StopLaunchInputBody: Swift.Equatable {
    let desiredState: EvidentlyClientTypes.LaunchStopDesiredState?
    let reason: Swift.String?
}

extension StopLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.LaunchStopDesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopLaunchOutputBody = try responseDecoder.decode(responseBody: data)
            self.endedTime = output.endedTime
        } else {
            self.endedTime = nil
        }
    }
}

public struct StopLaunchOutput: Swift.Equatable {
    /// The date and time that the launch stopped.
    public var endedTime: ClientRuntime.Date?

    public init(
        endedTime: ClientRuntime.Date? = nil
    )
    {
        self.endedTime = endedTime
    }
}

struct StopLaunchOutputBody: Swift.Equatable {
    let endedTime: ClientRuntime.Date?
}

extension StopLaunchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedTime)
        endedTime = endedTimeDecoded
    }
}

enum StopLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch Evidently resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestSegmentPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }
}

extension TestSegmentPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/test-segment-pattern"
    }
}

public struct TestSegmentPatternInput: Swift.Equatable {
    /// The pattern to test.
    /// This member is required.
    public var pattern: Swift.String?
    /// A sample evaluationContext JSON block to test against the specified pattern.
    /// This member is required.
    public var payload: Swift.String?

    public init(
        pattern: Swift.String? = nil,
        payload: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.payload = payload
    }
}

struct TestSegmentPatternInputBody: Swift.Equatable {
    let pattern: Swift.String?
    let payload: Swift.String?
}

extension TestSegmentPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern
        case payload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension TestSegmentPatternOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestSegmentPatternOutputBody = try responseDecoder.decode(responseBody: data)
            self.match = output.match
        } else {
            self.match = nil
        }
    }
}

public struct TestSegmentPatternOutput: Swift.Equatable {
    /// Returns true if the pattern matches the payload.
    /// This member is required.
    public var match: Swift.Bool?

    public init(
        match: Swift.Bool? = nil
    )
    {
        self.match = match
    }
}

struct TestSegmentPatternOutputBody: Swift.Equatable {
    let match: Swift.Bool?
}

extension TestSegmentPatternOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case match
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .match)
        match = matchDecoded
    }
}

enum TestSegmentPatternOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension EvidentlyClientTypes.Treatment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case featureVariations
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureVariations = featureVariations {
            var featureVariationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureVariations)
            for (dictKey0, featureToVariationMap0) in featureVariations {
                try featureVariationsContainer.encode(featureToVariationMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureVariationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureVariations)
        var featureVariationsDecoded0: [Swift.String:Swift.String]? = nil
        if let featureVariationsContainer = featureVariationsContainer {
            featureVariationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in featureVariationsContainer {
                if let variationname0 = variationname0 {
                    featureVariationsDecoded0?[key0] = variationname0
                }
            }
        }
        featureVariations = featureVariationsDecoded0
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one treatment in an experiment. A treatment is a variation of the feature that you are including in the experiment.
    public struct Treatment: Swift.Equatable {
        /// The description of the treatment.
        public var description: Swift.String?
        /// The feature variation used for this treatment. This is a key-value pair. The key is the feature name, and the value is the variation name.
        public var featureVariations: [Swift.String:Swift.String]?
        /// The name of this treatment.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            featureVariations: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.featureVariations = featureVariations
            self.name = name
        }
    }

}

extension EvidentlyClientTypes.TreatmentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case feature
        case name
        case variation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variation = self.variation {
            try encodeContainer.encode(variation, forKey: .variation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let variationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variation)
        variation = variationDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure that defines one treatment in an experiment. A treatment is a variation of the feature that you are including in the experiment.
    public struct TreatmentConfig: Swift.Equatable {
        /// A description for this treatment.
        public var description: Swift.String?
        /// The feature that this experiment is testing.
        /// This member is required.
        public var feature: Swift.String?
        /// A name for this treatment.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the variation to use as this treatment in the experiment.
        /// This member is required.
        public var variation: Swift.String?

        public init(
            description: Swift.String? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            variation: Swift.String? = nil
        )
        {
            self.description = description
            self.feature = feature
            self.name = name
            self.variation = variation
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch Evidently resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case onlineAbConfig
        case randomizationSalt
        case removeSegment
        case samplingRate
        case segment
        case treatments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let metricGoals = metricGoals {
            var metricGoalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricGoals)
            for metricgoalconfig0 in metricGoals {
                try metricGoalsContainer.encode(metricgoalconfig0)
            }
        }
        if let onlineAbConfig = self.onlineAbConfig {
            try encodeContainer.encode(onlineAbConfig, forKey: .onlineAbConfig)
        }
        if let randomizationSalt = self.randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if removeSegment != false {
            try encodeContainer.encode(removeSegment, forKey: .removeSegment)
        }
        if let samplingRate = self.samplingRate {
            try encodeContainer.encode(samplingRate, forKey: .samplingRate)
        }
        if let segment = self.segment {
            try encodeContainer.encode(segment, forKey: .segment)
        }
        if let treatments = treatments {
            var treatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treatments)
            for treatmentconfig0 in treatments {
                try treatmentsContainer.encode(treatmentconfig0)
            }
        }
    }
}

extension UpdateExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let experiment = experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

public struct UpdateExperimentInput: Swift.Equatable {
    /// An optional description of the experiment.
    public var description: Swift.String?
    /// The name of the experiment to update.
    /// This member is required.
    public var experiment: Swift.String?
    /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
    public var metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    /// A structure that contains the configuration of which variation o use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public var onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    /// The name or ARN of the project that contains the experiment that you want to update.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to an experiment, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the experiment name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// Removes a segment from being used in an experiment. You can't use this parameter if the experiment is currently running.
    public var removeSegment: Swift.Bool
    /// The portion of the available audience that you want to allocate to this experiment, in thousandths of a percent. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent. For example, specify 20,000 to allocate 20% of the available audience.
    public var samplingRate: Swift.Int?
    /// Adds an audience segment to an experiment. When a segment is used in an experiment, only user sessions that match the segment pattern are used in the experiment. You can't use this parameter if the experiment is currently running.
    public var segment: Swift.String?
    /// An array of structures that define the variations being tested in the experiment.
    public var treatments: [EvidentlyClientTypes.TreatmentConfig]?

    public init(
        description: Swift.String? = nil,
        experiment: Swift.String? = nil,
        metricGoals: [EvidentlyClientTypes.MetricGoalConfig]? = nil,
        onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        removeSegment: Swift.Bool = false,
        samplingRate: Swift.Int? = nil,
        segment: Swift.String? = nil,
        treatments: [EvidentlyClientTypes.TreatmentConfig]? = nil
    )
    {
        self.description = description
        self.experiment = experiment
        self.metricGoals = metricGoals
        self.onlineAbConfig = onlineAbConfig
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.removeSegment = removeSegment
        self.samplingRate = samplingRate
        self.segment = segment
        self.treatments = treatments
    }
}

struct UpdateExperimentInputBody: Swift.Equatable {
    let description: Swift.String?
    let treatments: [EvidentlyClientTypes.TreatmentConfig]?
    let metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    let randomizationSalt: Swift.String?
    let samplingRate: Swift.Int?
    let segment: Swift.String?
    let removeSegment: Swift.Bool
    let onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
}

extension UpdateExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case metricGoals
        case onlineAbConfig
        case randomizationSalt
        case removeSegment
        case samplingRate
        case segment
        case treatments
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let treatmentsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.TreatmentConfig?].self, forKey: .treatments)
        var treatmentsDecoded0:[EvidentlyClientTypes.TreatmentConfig]? = nil
        if let treatmentsContainer = treatmentsContainer {
            treatmentsDecoded0 = [EvidentlyClientTypes.TreatmentConfig]()
            for structure0 in treatmentsContainer {
                if let structure0 = structure0 {
                    treatmentsDecoded0?.append(structure0)
                }
            }
        }
        treatments = treatmentsDecoded0
        let metricGoalsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricGoalConfig?].self, forKey: .metricGoals)
        var metricGoalsDecoded0:[EvidentlyClientTypes.MetricGoalConfig]? = nil
        if let metricGoalsContainer = metricGoalsContainer {
            metricGoalsDecoded0 = [EvidentlyClientTypes.MetricGoalConfig]()
            for structure0 in metricGoalsContainer {
                if let structure0 = structure0 {
                    metricGoalsDecoded0?.append(structure0)
                }
            }
        }
        metricGoals = metricGoalsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        let segmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segment)
        segment = segmentDecoded
        let removeSegmentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeSegment) ?? false
        removeSegment = removeSegmentDecoded
        let onlineAbConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.OnlineAbConfig.self, forKey: .onlineAbConfig)
        onlineAbConfig = onlineAbConfigDecoded
    }
}

extension UpdateExperimentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateExperimentOutputBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct UpdateExperimentOutput: Swift.Equatable {
    /// A structure containing the configuration details of the experiment that was updated.
    /// This member is required.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init(
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct UpdateExperimentOutputBody: Swift.Equatable {
    let experiment: EvidentlyClientTypes.Experiment?
}

extension UpdateExperimentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

enum UpdateExperimentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFeatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addOrUpdateVariations
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case removeVariations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addOrUpdateVariations = addOrUpdateVariations {
            var addOrUpdateVariationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addOrUpdateVariations)
            for variationconfig0 in addOrUpdateVariations {
                try addOrUpdateVariationsContainer.encode(variationconfig0)
            }
        }
        if let defaultVariation = self.defaultVariation {
            try encodeContainer.encode(defaultVariation, forKey: .defaultVariation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityOverrides = entityOverrides {
            var entityOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .entityOverrides)
            for (dictKey0, entityOverrideMap0) in entityOverrides {
                try entityOverridesContainer.encode(entityOverrideMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let evaluationStrategy = self.evaluationStrategy {
            try encodeContainer.encode(evaluationStrategy.rawValue, forKey: .evaluationStrategy)
        }
        if let removeVariations = removeVariations {
            var removeVariationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeVariations)
            for variationname0 in removeVariations {
                try removeVariationsContainer.encode(variationname0)
            }
        }
    }
}

extension UpdateFeatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let feature = feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

public struct UpdateFeatureInput: Swift.Equatable {
    /// To update variation configurations for this feature, or add new ones, specify this structure. In this array, include any variations that you want to add or update. If the array includes a variation name that already exists for this feature, it is updated. If it includes a new variation name, it is added as a new variation.
    public var addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]?
    /// The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature.
    public var defaultVariation: Swift.String?
    /// An optional description of the feature.
    public var description: Swift.String?
    /// Specified users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served. This parameter is limited to 2500 overrides or a total of 40KB. The 40KB limit includes an overhead of 6 bytes per override.
    public var entityOverrides: [Swift.String:Swift.String]?
    /// Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
    public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    /// The name of the feature to be updated.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature to be updated.
    /// This member is required.
    public var project: Swift.String?
    /// Removes a variation from the feature. If the variation you specify doesn't exist, then this makes no change and does not report an error. This operation fails if you try to remove a variation that is part of an ongoing launch or experiment.
    public var removeVariations: [Swift.String]?

    public init(
        addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]? = nil,
        defaultVariation: Swift.String? = nil,
        description: Swift.String? = nil,
        entityOverrides: [Swift.String:Swift.String]? = nil,
        evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
        feature: Swift.String? = nil,
        project: Swift.String? = nil,
        removeVariations: [Swift.String]? = nil
    )
    {
        self.addOrUpdateVariations = addOrUpdateVariations
        self.defaultVariation = defaultVariation
        self.description = description
        self.entityOverrides = entityOverrides
        self.evaluationStrategy = evaluationStrategy
        self.feature = feature
        self.project = project
        self.removeVariations = removeVariations
    }
}

struct UpdateFeatureInputBody: Swift.Equatable {
    let evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    let description: Swift.String?
    let addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]?
    let removeVariations: [Swift.String]?
    let defaultVariation: Swift.String?
    let entityOverrides: [Swift.String:Swift.String]?
}

extension UpdateFeatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addOrUpdateVariations
        case defaultVariation
        case description
        case entityOverrides
        case evaluationStrategy
        case removeVariations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationStrategyDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.FeatureEvaluationStrategy.self, forKey: .evaluationStrategy)
        evaluationStrategy = evaluationStrategyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addOrUpdateVariationsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.VariationConfig?].self, forKey: .addOrUpdateVariations)
        var addOrUpdateVariationsDecoded0:[EvidentlyClientTypes.VariationConfig]? = nil
        if let addOrUpdateVariationsContainer = addOrUpdateVariationsContainer {
            addOrUpdateVariationsDecoded0 = [EvidentlyClientTypes.VariationConfig]()
            for structure0 in addOrUpdateVariationsContainer {
                if let structure0 = structure0 {
                    addOrUpdateVariationsDecoded0?.append(structure0)
                }
            }
        }
        addOrUpdateVariations = addOrUpdateVariationsDecoded0
        let removeVariationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeVariations)
        var removeVariationsDecoded0:[Swift.String]? = nil
        if let removeVariationsContainer = removeVariationsContainer {
            removeVariationsDecoded0 = [Swift.String]()
            for string0 in removeVariationsContainer {
                if let string0 = string0 {
                    removeVariationsDecoded0?.append(string0)
                }
            }
        }
        removeVariations = removeVariationsDecoded0
        let defaultVariationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVariation)
        defaultVariation = defaultVariationDecoded
        let entityOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .entityOverrides)
        var entityOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let entityOverridesContainer = entityOverridesContainer {
            entityOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variationname0) in entityOverridesContainer {
                if let variationname0 = variationname0 {
                    entityOverridesDecoded0?[key0] = variationname0
                }
            }
        }
        entityOverrides = entityOverridesDecoded0
    }
}

extension UpdateFeatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFeatureOutputBody = try responseDecoder.decode(responseBody: data)
            self.feature = output.feature
        } else {
            self.feature = nil
        }
    }
}

public struct UpdateFeatureOutput: Swift.Equatable {
    /// A structure that contains information about the updated feature.
    /// This member is required.
    public var feature: EvidentlyClientTypes.Feature?

    public init(
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

struct UpdateFeatureOutputBody: Swift.Equatable {
    let feature: EvidentlyClientTypes.Feature?
}

extension UpdateFeatureOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
    }
}

enum UpdateFeatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case randomizationSalt
        case scheduledSplitsConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for launchgroupconfig0 in groups {
                try groupsContainer.encode(launchgroupconfig0)
            }
        }
        if let metricMonitors = metricMonitors {
            var metricMonitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricMonitors)
            for metricmonitorconfig0 in metricMonitors {
                try metricMonitorsContainer.encode(metricmonitorconfig0)
            }
        }
        if let randomizationSalt = self.randomizationSalt {
            try encodeContainer.encode(randomizationSalt, forKey: .randomizationSalt)
        }
        if let scheduledSplitsConfig = self.scheduledSplitsConfig {
            try encodeContainer.encode(scheduledSplitsConfig, forKey: .scheduledSplitsConfig)
        }
    }
}

extension UpdateLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        guard let launch = launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

public struct UpdateLaunchInput: Swift.Equatable {
    /// An optional description for the launch.
    public var description: Swift.String?
    /// An array of structures that contains the feature and variations that are to be used for the launch.
    public var groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    /// The name of the launch that is to be updated.
    /// This member is required.
    public var launch: Swift.String?
    /// An array of structures that define the metrics that will be used to monitor the launch performance.
    public var metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    /// The name or ARN of the project that contains the launch that you want to update.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to a launch, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the launch name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
    public var scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?

    public init(
        description: Swift.String? = nil,
        groups: [EvidentlyClientTypes.LaunchGroupConfig]? = nil,
        launch: Swift.String? = nil,
        metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig? = nil
    )
    {
        self.description = description
        self.groups = groups
        self.launch = launch
        self.metricMonitors = metricMonitors
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.scheduledSplitsConfig = scheduledSplitsConfig
    }
}

struct UpdateLaunchInputBody: Swift.Equatable {
    let description: Swift.String?
    let groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    let metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    let randomizationSalt: Swift.String?
    let scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
}

extension UpdateLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case groups
        case metricMonitors
        case randomizationSalt
        case scheduledSplitsConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let groupsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.LaunchGroupConfig?].self, forKey: .groups)
        var groupsDecoded0:[EvidentlyClientTypes.LaunchGroupConfig]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [EvidentlyClientTypes.LaunchGroupConfig]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let metricMonitorsContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.MetricMonitorConfig?].self, forKey: .metricMonitors)
        var metricMonitorsDecoded0:[EvidentlyClientTypes.MetricMonitorConfig]? = nil
        if let metricMonitorsContainer = metricMonitorsContainer {
            metricMonitorsDecoded0 = [EvidentlyClientTypes.MetricMonitorConfig]()
            for structure0 in metricMonitorsContainer {
                if let structure0 = structure0 {
                    metricMonitorsDecoded0?.append(structure0)
                }
            }
        }
        metricMonitors = metricMonitorsDecoded0
        let randomizationSaltDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomizationSalt)
        randomizationSalt = randomizationSaltDecoded
        let scheduledSplitsConfigDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ScheduledSplitsLaunchConfig.self, forKey: .scheduledSplitsConfig)
        scheduledSplitsConfig = scheduledSplitsConfigDecoded
    }
}

extension UpdateLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchOutputBody = try responseDecoder.decode(responseBody: data)
            self.launch = output.launch
        } else {
            self.launch = nil
        }
    }
}

public struct UpdateLaunchOutput: Swift.Equatable {
    /// A structure that contains the new configuration of the launch that was updated.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

struct UpdateLaunchOutputBody: Swift.Equatable {
    let launch: EvidentlyClientTypes.Launch?
}

extension UpdateLaunchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Launch.self, forKey: .launch)
        launch = launchDecoded
    }
}

enum UpdateLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectDataDeliveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }
}

extension UpdateProjectDataDeliveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/data-delivery"
    }
}

public struct UpdateProjectDataDeliveryInput: Swift.Equatable {
    /// A structure containing the CloudWatch Logs log group where you want to store evaluation events.
    public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
    /// The name or ARN of the project that you want to modify the data storage options for.
    /// This member is required.
    public var project: Swift.String?
    /// A structure containing the S3 bucket name and bucket prefix where you want to store evaluation events.
    public var s3Destination: EvidentlyClientTypes.S3DestinationConfig?

    public init(
        cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig? = nil,
        project: Swift.String? = nil,
        s3Destination: EvidentlyClientTypes.S3DestinationConfig? = nil
    )
    {
        self.cloudWatchLogs = cloudWatchLogs
        self.project = project
        self.s3Destination = s3Destination
    }
}

struct UpdateProjectDataDeliveryInputBody: Swift.Equatable {
    let s3Destination: EvidentlyClientTypes.S3DestinationConfig?
    let cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
}

extension UpdateProjectDataDeliveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Destination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.S3DestinationConfig.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.CloudWatchLogsDestinationConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
    }
}

extension UpdateProjectDataDeliveryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProjectDataDeliveryOutputBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct UpdateProjectDataDeliveryOutput: Swift.Equatable {
    /// A structure containing details about the project that you updated.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectDataDeliveryOutputBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension UpdateProjectDataDeliveryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

enum UpdateProjectDataDeliveryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appConfigResource
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appConfigResource = self.appConfigResource {
            try encodeContainer.encode(appConfigResource, forKey: .appConfigResource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let project = project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// Use this parameter if the project will use client-side evaluation powered by AppConfig. Client-side evaluation allows your application to assign variations to user sessions locally instead of by calling the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation. This mitigates the latency and availability risks that come with an API call. allows you to This parameter is a structure that contains information about the AppConfig application that will be used for client-side evaluation.
    public var appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig?
    /// An optional description of the project.
    public var description: Swift.String?
    /// The name or ARN of the project to update.
    /// This member is required.
    public var project: Swift.String?

    public init(
        appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig? = nil,
        description: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.appConfigResource = appConfigResource
        self.description = description
        self.project = project
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig?
    let description: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appConfigResource
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appConfigResourceDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ProjectAppConfigResourceConfig.self, forKey: .appConfigResource)
        appConfigResource = appConfigResourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct UpdateProjectOutput: Swift.Equatable {
    /// A structure containing information about the updated project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputBody: Swift.Equatable {
    let project: EvidentlyClientTypes.Project?
}

extension UpdateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the exception.
        public internal(set) var fieldList: [EvidentlyClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// A reason for the error.
        public internal(set) var reason: EvidentlyClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [EvidentlyClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: EvidentlyClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EvidentlyClientTypes.ValidationExceptionReason?
    let fieldList: [EvidentlyClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([EvidentlyClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[EvidentlyClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [EvidentlyClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension EvidentlyClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EvidentlyClientTypes {
    /// A structure containing an error name and message.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The error name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension EvidentlyClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension EvidentlyClientTypes.VariableValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case boolvalue = "boolValue"
        case doublevalue = "doubleValue"
        case longvalue = "longValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .boolvalue(boolvalue):
                try container.encode(boolvalue, forKey: .boolvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let boolvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .boolvalue)
        if let boolvalue = boolvalueDecoded {
            self = .boolvalue(boolvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EvidentlyClientTypes {
    /// The value assigned to a feature variation. This structure must contain exactly one field. It can be boolValue, doubleValue, longValue, or stringValue.
    public enum VariableValue: Swift.Equatable {
        /// If this feature uses the Boolean variation type, this field contains the Boolean value of this variation.
        case boolvalue(Swift.Bool)
        /// If this feature uses the string variation type, this field contains the string value of this variation.
        case stringvalue(Swift.String)
        /// If this feature uses the long variation type, this field contains the long value of this variation.
        case longvalue(Swift.Int)
        /// If this feature uses the double integer variation type, this field contains the double integer value of this variation.
        case doublevalue(Swift.Double)
        case sdkUnknown(Swift.String)
    }

}

extension EvidentlyClientTypes.Variation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the name and variation value of one variation of a feature.
    public struct Variation: Swift.Equatable {
        /// The name of the variation.
        public var name: Swift.String?
        /// The value assigned to this variation.
        public var value: EvidentlyClientTypes.VariableValue?

        public init(
            name: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension EvidentlyClientTypes.VariationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EvidentlyClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension EvidentlyClientTypes {
    /// This structure contains the name and variation value of one variation of a feature.
    public struct VariationConfig: Swift.Equatable {
        /// The name of the variation.
        /// This member is required.
        public var name: Swift.String?
        /// The value assigned to this variation.
        /// This member is required.
        public var value: EvidentlyClientTypes.VariableValue?

        public init(
            name: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension EvidentlyClientTypes {
    public enum VariationValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case long
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [VariationValueType] {
            return [
                .boolean,
                .double,
                .long,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VariationValueType(rawValue: rawValue) ?? VariationValueType.sdkUnknown(rawValue)
        }
    }
}
