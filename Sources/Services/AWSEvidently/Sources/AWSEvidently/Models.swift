//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension EvidentlyClientTypes {

    /// A structure containing an error name and message.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The error name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension EvidentlyClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the exception.
        public internal(set) var fieldList: [EvidentlyClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// A reason for the error.
        public internal(set) var reason: EvidentlyClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [EvidentlyClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: EvidentlyClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension EvidentlyClientTypes {

    /// This structure assigns a feature variation to one user session.
    public struct EvaluationRequest: Swift.Sendable {
        /// An internal ID that represents a unique user session of the application. This entityID is checked against any override rules assigned for this feature.
        /// This member is required.
        public var entityId: Swift.String?
        /// A JSON block of attributes that you can optionally pass in. This JSON block is included in the evaluation events sent to Evidently from the user session.
        public var evaluationContext: Swift.String?
        /// The name of the feature being evaluated.
        /// This member is required.
        public var feature: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            evaluationContext: Swift.String? = nil,
            feature: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.evaluationContext = evaluationContext
            self.feature = feature
        }
    }
}

public struct BatchEvaluateFeatureInput: Swift.Sendable {
    /// The name or ARN of the project that contains the feature being evaluated.
    /// This member is required.
    public var project: Swift.String?
    /// An array of structures, where each structure assigns a feature variation to one user session.
    /// This member is required.
    public var requests: [EvidentlyClientTypes.EvaluationRequest]?

    public init(
        project: Swift.String? = nil,
        requests: [EvidentlyClientTypes.EvaluationRequest]? = nil
    )
    {
        self.project = project
        self.requests = requests
    }
}

extension EvidentlyClientTypes {

    /// The value assigned to a feature variation. This structure must contain exactly one field. It can be boolValue, doubleValue, longValue, or stringValue.
    public enum VariableValue: Swift.Sendable {
        /// If this feature uses the Boolean variation type, this field contains the Boolean value of this variation.
        case boolvalue(Swift.Bool)
        /// If this feature uses the string variation type, this field contains the string value of this variation.
        case stringvalue(Swift.String)
        /// If this feature uses the long variation type, this field contains the long value of this variation.
        case longvalue(Swift.Int)
        /// If this feature uses the double integer variation type, this field contains the double integer value of this variation.
        case doublevalue(Swift.Double)
        case sdkUnknown(Swift.String)
    }
}

extension EvidentlyClientTypes {

    /// This structure displays the results of one feature evaluation assignment to one user session.
    public struct EvaluationResult: Swift.Sendable {
        /// If this user was assigned to a launch or experiment, this field lists the launch or experiment name.
        public var details: Swift.String?
        /// An internal ID that represents a unique user session of the application.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the feature being evaluated.
        /// This member is required.
        public var feature: Swift.String?
        /// The name or ARN of the project that contains the feature being evaluated.
        public var project: Swift.String?
        /// Specifies the reason that the user session was assigned this variation. Possible values include DEFAULT, meaning the user was served the default variation; LAUNCH_RULE_MATCH, if the user session was enrolled in a launch; or EXPERIMENT_RULE_MATCH, if the user session was enrolled in an experiment.
        public var reason: Swift.String?
        /// The value assigned to this variation to differentiate it from the other variations of this feature.
        public var value: EvidentlyClientTypes.VariableValue?
        /// The name of the variation that was served to the user session.
        public var variation: Swift.String?

        public init(
            details: Swift.String? = nil,
            entityId: Swift.String? = nil,
            feature: Swift.String? = nil,
            project: Swift.String? = nil,
            reason: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil,
            variation: Swift.String? = nil
        )
        {
            self.details = details
            self.entityId = entityId
            self.feature = feature
            self.project = project
            self.reason = reason
            self.value = value
            self.variation = variation
        }
    }
}

public struct BatchEvaluateFeatureOutput: Swift.Sendable {
    /// An array of structures, where each structure displays the results of one feature evaluation assignment to one user session.
    public var results: [EvidentlyClientTypes.EvaluationResult]?

    public init(
        results: [EvidentlyClientTypes.EvaluationResult]? = nil
    )
    {
        self.results = results
    }
}

extension EvidentlyClientTypes {

    public enum ChangeDirectionEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case decrease
        case increase
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeDirectionEnum] {
            return [
                .decrease,
                .increase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .decrease: return "DECREASE"
            case .increase: return "INCREASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure containing the CloudWatch Logs log group where the project stores evaluation events.
    public struct CloudWatchLogsDestination: Swift.Sendable {
        /// The name of the log group where the project stores evaluation events.
        public var logGroup: Swift.String?

        public init(
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure containing the CloudWatch Logs log group where the project stores evaluation events.
    public struct CloudWatchLogsDestinationConfig: Swift.Sendable {
        /// The name of the log group where the project stores evaluation events.
        public var logGroup: Swift.String?

        public init(
            logGroup: Swift.String? = nil
        )
        {
            self.logGroup = logGroup
        }
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension EvidentlyClientTypes {

    /// This structure defines a metric that you want to use to evaluate the variations during a launch or experiment.
    public struct MetricDefinitionConfig: Swift.Sendable {
        /// The entity, such as a user or session, that does an action that causes a metric value to be recorded. An example is userDetails.userID.
        /// This member is required.
        public var entityIdKey: Swift.String?
        /// The EventBridge event pattern that defines how the metric is recorded. For more information about EventBridge event patterns, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).
        public var eventPattern: Swift.String?
        /// A name for the metric.
        /// This member is required.
        public var name: Swift.String?
        /// A label for the units that the metric is measuring.
        public var unitLabel: Swift.String?
        /// The value that is tracked to produce the metric.
        /// This member is required.
        public var valueKey: Swift.String?

        public init(
            entityIdKey: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.entityIdKey = entityIdKey
            self.eventPattern = eventPattern
            self.name = name
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }
}

extension EvidentlyClientTypes {

    /// Use this structure to tell Evidently whether higher or lower values are desired for a metric that is used in an experiment.
    public struct MetricGoalConfig: Swift.Sendable {
        /// INCREASE means that a variation with a higher number for this metric is performing better. DECREASE means that a variation with a lower number for this metric is performing better.
        public var desiredChange: EvidentlyClientTypes.ChangeDirectionEnum?
        /// A structure that contains details about the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig?

        public init(
            desiredChange: EvidentlyClientTypes.ChangeDirectionEnum? = nil,
            metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig? = nil
        )
        {
            self.desiredChange = desiredChange
            self.metricDefinition = metricDefinition
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public struct OnlineAbConfig: Swift.Sendable {
        /// The name of the variation that is to be the default variation that the other variations are compared to.
        public var controlTreatmentName: Swift.String?
        /// A set of key-value pairs. The keys are variation names, and the values are the portion of experiment traffic to be assigned to that variation. Specify the traffic portion in thousandths of a percent, so 20,000 for a variation would allocate 20% of the experiment traffic to that variation.
        public var treatmentWeights: [Swift.String: Swift.Int]?

        public init(
            controlTreatmentName: Swift.String? = nil,
            treatmentWeights: [Swift.String: Swift.Int]? = nil
        )
        {
            self.controlTreatmentName = controlTreatmentName
            self.treatmentWeights = treatmentWeights
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that defines one treatment in an experiment. A treatment is a variation of the feature that you are including in the experiment.
    public struct TreatmentConfig: Swift.Sendable {
        /// A description for this treatment.
        public var description: Swift.String?
        /// The feature that this experiment is testing.
        /// This member is required.
        public var feature: Swift.String?
        /// A name for this treatment.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the variation to use as this treatment in the experiment.
        /// This member is required.
        public var variation: Swift.String?

        public init(
            description: Swift.String? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            variation: Swift.String? = nil
        )
        {
            self.description = description
            self.feature = feature
            self.name = name
            self.variation = variation
        }
    }
}

public struct CreateExperimentInput: Swift.Sendable {
    /// An optional description of the experiment.
    public var description: Swift.String?
    /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
    /// This member is required.
    public var metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    /// A name for the new experiment.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the configuration of which variation to use as the "control" version. tThe "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public var onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    /// The name or ARN of the project that you want to create the new experiment in.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to an experiment, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the experiment name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// The portion of the available audience that you want to allocate to this experiment, in thousandths of a percent. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent. For example, specify 10,000 to allocate 10% of the available audience.
    public var samplingRate: Swift.Int?
    /// Specifies an audience segment to use in the experiment. When a segment is used in an experiment, only user sessions that match the segment pattern are used in the experiment.
    public var segment: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the experiment. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with an experiment. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// An array of structures that describe the configuration of each feature variation used in the experiment.
    /// This member is required.
    public var treatments: [EvidentlyClientTypes.TreatmentConfig]?

    public init(
        description: Swift.String? = nil,
        metricGoals: [EvidentlyClientTypes.MetricGoalConfig]? = nil,
        name: Swift.String? = nil,
        onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        samplingRate: Swift.Int? = 0,
        segment: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        treatments: [EvidentlyClientTypes.TreatmentConfig]? = nil
    )
    {
        self.description = description
        self.metricGoals = metricGoals
        self.name = name
        self.onlineAbConfig = onlineAbConfig
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.samplingRate = samplingRate
        self.segment = segment
        self.tags = tags
        self.treatments = treatments
    }
}

extension EvidentlyClientTypes {

    /// This structure contains the date and time that the experiment started and ended.
    public struct ExperimentExecution: Swift.Sendable {
        /// The date and time that the experiment ended.
        public var endedTime: Foundation.Date?
        /// The date and time that the experiment started.
        public var startedTime: Foundation.Date?

        public init(
            endedTime: Foundation.Date? = nil,
            startedTime: Foundation.Date? = nil
        )
        {
            self.endedTime = endedTime
            self.startedTime = startedTime
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure defines a metric that is being used to evaluate the variations during a launch or experiment.
    public struct MetricDefinition: Swift.Sendable {
        /// The entity, such as a user or session, that does an action that causes a metric value to be recorded.
        public var entityIdKey: Swift.String?
        /// The EventBridge event pattern that defines how the metric is recorded. For more information about EventBridge event patterns, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).
        public var eventPattern: Swift.String?
        /// The name of the metric.
        public var name: Swift.String?
        /// The label for the units that the metric is measuring.
        public var unitLabel: Swift.String?
        /// The value that is tracked to produce the metric.
        public var valueKey: Swift.String?

        public init(
            entityIdKey: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.entityIdKey = entityIdKey
            self.eventPattern = eventPattern
            self.name = name
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that tells Evidently whether higher or lower values are desired for a metric that is used in an experiment.
    public struct MetricGoal: Swift.Sendable {
        /// INCREASE means that a variation with a higher number for this metric is performing better. DECREASE means that a variation with a lower number for this metric is performing better.
        public var desiredChange: EvidentlyClientTypes.ChangeDirectionEnum?
        /// A structure that contains details about the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinition?

        public init(
            desiredChange: EvidentlyClientTypes.ChangeDirectionEnum? = nil,
            metricDefinition: EvidentlyClientTypes.MetricDefinition? = nil
        )
        {
            self.desiredChange = desiredChange
            self.metricDefinition = metricDefinition
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public struct OnlineAbDefinition: Swift.Sendable {
        /// The name of the variation that is the default variation that the other variations are compared to.
        public var controlTreatmentName: Swift.String?
        /// A set of key-value pairs. The keys are variation names, and the values are the portion of experiment traffic to be assigned to that variation. The traffic portion is specified in thousandths of a percent, so 20,000 for a variation would allocate 20% of the experiment traffic to that variation.
        public var treatmentWeights: [Swift.String: Swift.Int]?

        public init(
            controlTreatmentName: Swift.String? = nil,
            treatmentWeights: [Swift.String: Swift.Int]? = nil
        )
        {
            self.controlTreatmentName = controlTreatmentName
            self.treatmentWeights = treatmentWeights
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure contains the time and date that Evidently completed the analysis of the experiment.
    public struct ExperimentSchedule: Swift.Sendable {
        /// The time and date that Evidently completed the analysis of the experiment.
        public var analysisCompleteTime: Foundation.Date?

        public init(
            analysisCompleteTime: Foundation.Date? = nil
        )
        {
            self.analysisCompleteTime = analysisCompleteTime
        }
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case created
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .cancelled,
                .completed,
                .created,
                .running,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that defines one treatment in an experiment. A treatment is a variation of the feature that you are including in the experiment.
    public struct Treatment: Swift.Sendable {
        /// The description of the treatment.
        public var description: Swift.String?
        /// The feature variation used for this treatment. This is a key-value pair. The key is the feature name, and the value is the variation name.
        public var featureVariations: [Swift.String: Swift.String]?
        /// The name of this treatment.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            featureVariations: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.featureVariations = featureVariations
            self.name = name
        }
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onlineAbExperiment
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentType] {
            return [
                .onlineAbExperiment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onlineAbExperiment: return "aws.evidently.onlineab"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure containing the configuration details of an experiment.
    public struct Experiment: Swift.Sendable {
        /// The ARN of the experiment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the experiment is first created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// A description of the experiment.
        public var description: Swift.String?
        /// A structure that contains the date and time that the experiment started and ended.
        public var execution: EvidentlyClientTypes.ExperimentExecution?
        /// The date and time that the experiment was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
        public var metricGoals: [EvidentlyClientTypes.MetricGoal]?
        /// The name of the experiment.
        /// This member is required.
        public var name: Swift.String?
        /// A structure that contains the configuration of which variation to use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
        public var onlineAbDefinition: EvidentlyClientTypes.OnlineAbDefinition?
        /// The name or ARN of the project that contains this experiment.
        public var project: Swift.String?
        /// This value is used when Evidently assigns a particular user session to the experiment. It helps create a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt.
        public var randomizationSalt: Swift.String?
        /// In thousandths of a percent, the amount of the available audience that is allocated to this experiment. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent, so a value of 10,000 is 10% of the available audience.
        public var samplingRate: Swift.Int
        /// A structure that contains the time and date that Evidently completed the analysis of the experiment.
        public var schedule: EvidentlyClientTypes.ExperimentSchedule?
        /// The audience segment being used for the experiment, if a segment is being used.
        public var segment: Swift.String?
        /// The current state of the experiment.
        /// This member is required.
        public var status: EvidentlyClientTypes.ExperimentStatus?
        /// If the experiment was stopped, this is the string that was entered by the person who stopped the experiment, to explain why it was stopped.
        public var statusReason: Swift.String?
        /// The list of tag keys and values associated with this experiment.
        public var tags: [Swift.String: Swift.String]?
        /// An array of structures that describe the configuration of each feature variation used in the experiment.
        public var treatments: [EvidentlyClientTypes.Treatment]?
        /// The type of this experiment. Currently, this value must be aws.experiment.onlineab.
        /// This member is required.
        public var type: EvidentlyClientTypes.ExperimentType?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            execution: EvidentlyClientTypes.ExperimentExecution? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            metricGoals: [EvidentlyClientTypes.MetricGoal]? = nil,
            name: Swift.String? = nil,
            onlineAbDefinition: EvidentlyClientTypes.OnlineAbDefinition? = nil,
            project: Swift.String? = nil,
            randomizationSalt: Swift.String? = nil,
            samplingRate: Swift.Int = 0,
            schedule: EvidentlyClientTypes.ExperimentSchedule? = nil,
            segment: Swift.String? = nil,
            status: EvidentlyClientTypes.ExperimentStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            treatments: [EvidentlyClientTypes.Treatment]? = nil,
            type: EvidentlyClientTypes.ExperimentType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.execution = execution
            self.lastUpdatedTime = lastUpdatedTime
            self.metricGoals = metricGoals
            self.name = name
            self.onlineAbDefinition = onlineAbDefinition
            self.project = project
            self.randomizationSalt = randomizationSalt
            self.samplingRate = samplingRate
            self.schedule = schedule
            self.segment = segment
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.treatments = treatments
            self.type = type
        }
    }
}

public struct CreateExperimentOutput: Swift.Sendable {
    /// A structure containing the configuration details of the experiment that you created.
    /// This member is required.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init(
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

extension EvidentlyClientTypes {

    public enum FeatureEvaluationStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allRules
        case defaultVariation
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureEvaluationStrategy] {
            return [
                .allRules,
                .defaultVariation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allRules: return "ALL_RULES"
            case .defaultVariation: return "DEFAULT_VARIATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure contains the name and variation value of one variation of a feature.
    public struct VariationConfig: Swift.Sendable {
        /// The name of the variation.
        /// This member is required.
        public var name: Swift.String?
        /// The value assigned to this variation.
        /// This member is required.
        public var value: EvidentlyClientTypes.VariableValue?

        public init(
            name: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

public struct CreateFeatureInput: Swift.Sendable {
    /// The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit defaultVariation, the first variation listed in the variations structure is used as the default variation.
    public var defaultVariation: Swift.String?
    /// An optional description of the feature.
    public var description: Swift.String?
    /// Specify users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served. This parameter is limited to 2500 overrides or a total of 40KB. The 40KB limit includes an overhead of 6 bytes per override.
    public var entityOverrides: [Swift.String: Swift.String]?
    /// Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
    public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    /// The name for the new feature.
    /// This member is required.
    public var name: Swift.String?
    /// The name or ARN of the project that is to contain the new feature.
    /// This member is required.
    public var project: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the feature. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a feature. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// An array of structures that contain the configuration of the feature's different variations.
    /// This member is required.
    public var variations: [EvidentlyClientTypes.VariationConfig]?

    public init(
        defaultVariation: Swift.String? = nil,
        description: Swift.String? = nil,
        entityOverrides: [Swift.String: Swift.String]? = nil,
        evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
        name: Swift.String? = nil,
        project: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        variations: [EvidentlyClientTypes.VariationConfig]? = nil
    )
    {
        self.defaultVariation = defaultVariation
        self.description = description
        self.entityOverrides = entityOverrides
        self.evaluationStrategy = evaluationStrategy
        self.name = name
        self.project = project
        self.tags = tags
        self.variations = variations
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains the information about an evaluation rule for this feature, if it is used in a launch or experiment.
    public struct EvaluationRule: Swift.Sendable {
        /// The name of the experiment or launch.
        public var name: Swift.String?
        /// This value is aws.evidently.splits if this is an evaluation rule for a launch, and it is aws.evidently.onlineab if this is an evaluation rule for an experiment.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension EvidentlyClientTypes {

    public enum FeatureStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .available,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    public enum VariationValueType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case double
        case long
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [VariationValueType] {
            return [
                .boolean,
                .double,
                .long,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure contains the name and variation value of one variation of a feature.
    public struct Variation: Swift.Sendable {
        /// The name of the variation.
        public var name: Swift.String?
        /// The value assigned to this variation.
        public var value: EvidentlyClientTypes.VariableValue?

        public init(
            name: Swift.String? = nil,
            value: EvidentlyClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure contains information about one Evidently feature in your account.
    public struct Feature: Swift.Sendable {
        /// The ARN of the feature.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the feature is created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The name of the variation that is used as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit defaultVariation, the first variation listed in the variations structure is used as the default variation.
        public var defaultVariation: Swift.String?
        /// The description of the feature.
        public var description: Swift.String?
        /// A set of key-value pairs that specify users who should always be served a specific variation of a feature. Each key specifies a user using their user ID, account ID, or some other identifier. The value specifies the name of the variation that the user is to be served. For the override to be successful, the value of the key must match the entityId used in the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation.
        public var entityOverrides: [Swift.String: Swift.String]?
        /// An array of structures that define the evaluation rules for the feature.
        public var evaluationRules: [EvidentlyClientTypes.EvaluationRule]?
        /// If this value is ALL_RULES, the traffic allocation specified by any ongoing launches or experiments is being used. If this is DEFAULT_VARIATION, the default variation is being served to all users.
        /// This member is required.
        public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
        /// The date and time that the feature was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the feature.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the feature.
        public var project: Swift.String?
        /// The current state of the feature.
        /// This member is required.
        public var status: EvidentlyClientTypes.FeatureStatus?
        /// The list of tag keys and values associated with this feature.
        public var tags: [Swift.String: Swift.String]?
        /// Defines the type of value used to define the different feature variations. For more information, see [Variation types](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-variationtypes.html)
        /// This member is required.
        public var valueType: EvidentlyClientTypes.VariationValueType?
        /// An array of structures that contain the configuration of the feature's different variations.
        /// This member is required.
        public var variations: [EvidentlyClientTypes.Variation]?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            defaultVariation: Swift.String? = nil,
            description: Swift.String? = nil,
            entityOverrides: [Swift.String: Swift.String]? = nil,
            evaluationRules: [EvidentlyClientTypes.EvaluationRule]? = nil,
            evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            status: EvidentlyClientTypes.FeatureStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            valueType: EvidentlyClientTypes.VariationValueType? = nil,
            variations: [EvidentlyClientTypes.Variation]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.defaultVariation = defaultVariation
            self.description = description
            self.entityOverrides = entityOverrides
            self.evaluationRules = evaluationRules
            self.evaluationStrategy = evaluationStrategy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.project = project
            self.status = status
            self.tags = tags
            self.valueType = valueType
            self.variations = variations
        }
    }
}

public struct CreateFeatureOutput: Swift.Sendable {
    /// A structure that contains information about the new feature.
    public var feature: EvidentlyClientTypes.Feature?

    public init(
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

extension EvidentlyClientTypes {

    /// A structure that defines one launch group in a launch. A launch group is a variation of the feature that you are including in the launch.
    public struct LaunchGroupConfig: Swift.Sendable {
        /// A description of the launch group.
        public var description: Swift.String?
        /// The feature that this launch is using.
        /// This member is required.
        public var feature: Swift.String?
        /// A name for this launch group.
        /// This member is required.
        public var name: Swift.String?
        /// The feature variation to use for this launch group.
        /// This member is required.
        public var variation: Swift.String?

        public init(
            description: Swift.String? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            variation: Swift.String? = nil
        )
        {
            self.description = description
            self.feature = feature
            self.name = name
            self.variation = variation
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that defines a metric to be used to monitor performance of the variations during a launch.
    public struct MetricMonitorConfig: Swift.Sendable {
        /// A structure that defines the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig?

        public init(
            metricDefinition: EvidentlyClientTypes.MetricDefinitionConfig? = nil
        )
        {
            self.metricDefinition = metricDefinition
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure specifies a segment that you have already created, and defines the traffic split for that segment to be used in a launch.
    public struct SegmentOverride: Swift.Sendable {
        /// A number indicating the order to use to evaluate segment overrides, if there are more than one. Segment overrides with lower numbers are evaluated first.
        /// This member is required.
        public var evaluationOrder: Swift.Int?
        /// The ARN of the segment to use.
        /// This member is required.
        public var segment: Swift.String?
        /// The traffic allocation percentages among the feature variations to assign to this segment. This is a set of key-value pairs. The keys are variation names. The values represent the amount of traffic to allocate to that variation for this segment. This is expressed in thousandths of a percent, so a weight of 50000 represents 50% of traffic.
        /// This member is required.
        public var weights: [Swift.String: Swift.Int]?

        public init(
            evaluationOrder: Swift.Int? = nil,
            segment: Swift.String? = nil,
            weights: [Swift.String: Swift.Int]? = nil
        )
        {
            self.evaluationOrder = evaluationOrder
            self.segment = segment
            self.weights = weights
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure defines the traffic allocation percentages among the feature variations during one step of a launch, and the start time of that step.
    public struct ScheduledSplitConfig: Swift.Sendable {
        /// The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step. The values is expressed in thousandths of a percent, so assigning a weight of 50000 assigns 50% of traffic to that variation. If the sum of the weights for all the variations in a segment override does not add up to 100,000, then the remaining traffic that matches this segment is not assigned by this segment override, and instead moves on to the next segment override or the default traffic split.
        /// This member is required.
        public var groupWeights: [Swift.String: Swift.Int]?
        /// Use this parameter to specify different traffic splits for one or more audience segments. A segment is a portion of your audience that share one or more characteristics. Examples could be Chrome browser users, users in Europe, or Firefox browser users in Europe who also fit other criteria that your application collects, such as age. This parameter is an array of up to six segment override objects. Each of these objects specifies a segment that you have already created, and defines the traffic split for that segment.
        public var segmentOverrides: [EvidentlyClientTypes.SegmentOverride]?
        /// The date and time that this step of the launch starts.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            groupWeights: [Swift.String: Swift.Int]? = nil,
            segmentOverrides: [EvidentlyClientTypes.SegmentOverride]? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.groupWeights = groupWeights
            self.segmentOverrides = segmentOverrides
            self.startTime = startTime
        }
    }
}

extension EvidentlyClientTypes {

    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of a launch. This also defines the start time of each step.
    public struct ScheduledSplitsLaunchConfig: Swift.Sendable {
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step.
        /// This member is required.
        public var steps: [EvidentlyClientTypes.ScheduledSplitConfig]?

        public init(
            steps: [EvidentlyClientTypes.ScheduledSplitConfig]? = nil
        )
        {
            self.steps = steps
        }
    }
}

public struct CreateLaunchInput: Swift.Sendable {
    /// An optional description for the launch.
    public var description: Swift.String?
    /// An array of structures that contains the feature and variations that are to be used for the launch.
    /// This member is required.
    public var groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    /// An array of structures that define the metrics that will be used to monitor the launch performance.
    public var metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    /// The name for the new launch.
    /// This member is required.
    public var name: Swift.String?
    /// The name or ARN of the project that you want to create the launch in.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to a launch, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the launch name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
    public var scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?
    /// Assigns one or more tags (key-value pairs) to the launch. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a launch. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        groups: [EvidentlyClientTypes.LaunchGroupConfig]? = nil,
        metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]? = nil,
        name: Swift.String? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.groups = groups
        self.metricMonitors = metricMonitors
        self.name = name
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.scheduledSplitsConfig = scheduledSplitsConfig
        self.tags = tags
    }
}

extension EvidentlyClientTypes {

    /// This structure contains information about the start and end times of the launch.
    public struct LaunchExecution: Swift.Sendable {
        /// The date and time that the launch ended.
        public var endedTime: Foundation.Date?
        /// The date and time that the launch started.
        public var startedTime: Foundation.Date?

        public init(
            endedTime: Foundation.Date? = nil,
            startedTime: Foundation.Date? = nil
        )
        {
            self.endedTime = endedTime
            self.startedTime = startedTime
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that defines one launch group in a launch. A launch group is a variation of the feature that you are including in the launch.
    public struct LaunchGroup: Swift.Sendable {
        /// A description of the launch group.
        public var description: Swift.String?
        /// The feature variation for this launch group. This is a key-value pair.
        /// This member is required.
        public var featureVariations: [Swift.String: Swift.String]?
        /// The name of the launch group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            featureVariations: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.featureVariations = featureVariations
            self.name = name
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that defines a metric to be used to monitor performance of the variations during a launch.
    public struct MetricMonitor: Swift.Sendable {
        /// A structure that defines the metric.
        /// This member is required.
        public var metricDefinition: EvidentlyClientTypes.MetricDefinition?

        public init(
            metricDefinition: EvidentlyClientTypes.MetricDefinition? = nil
        )
        {
            self.metricDefinition = metricDefinition
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure defines the traffic allocation percentages among the feature variations during one step of a launch, and the start time of that step.
    public struct ScheduledSplit: Swift.Sendable {
        /// The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step. The values is expressed in thousandths of a percent, so assigning a weight of 50000 assigns 50% of traffic to that variation. If the sum of the weights for all the variations in a segment override does not add up to 100,000, then the remaining traffic that matches this segment is not assigned by this segment override, and instead moves on to the next segment override or the default traffic split.
        public var groupWeights: [Swift.String: Swift.Int]?
        /// Use this parameter to specify different traffic splits for one or more audience segments. A segment is a portion of your audience that share one or more characteristics. Examples could be Chrome browser users, users in Europe, or Firefox browser users in Europe who also fit other criteria that your application collects, such as age. This parameter is an array of up to six segment override objects. Each of these objects specifies a segment that you have already created, and defines the traffic split for that segment.
        public var segmentOverrides: [EvidentlyClientTypes.SegmentOverride]?
        /// The date and time that this step of the launch starts.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            groupWeights: [Swift.String: Swift.Int]? = nil,
            segmentOverrides: [EvidentlyClientTypes.SegmentOverride]? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.groupWeights = groupWeights
            self.segmentOverrides = segmentOverrides
            self.startTime = startTime
        }
    }
}

extension EvidentlyClientTypes {

    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of a launch. This also defines the start time of each step.
    public struct ScheduledSplitsLaunchDefinition: Swift.Sendable {
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step.
        public var steps: [EvidentlyClientTypes.ScheduledSplit]?

        public init(
            steps: [EvidentlyClientTypes.ScheduledSplit]? = nil
        )
        {
            self.steps = steps
        }
    }
}

extension EvidentlyClientTypes {

    public enum LaunchStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case created
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .cancelled,
                .completed,
                .created,
                .running,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    public enum LaunchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case scheduledSplitsLaunch
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchType] {
            return [
                .scheduledSplitsLaunch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .scheduledSplitsLaunch: return "aws.evidently.splits"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure contains the configuration details of one Evidently launch.
    public struct Launch: Swift.Sendable {
        /// The ARN of the launch.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the launch is created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the launch.
        public var description: Swift.String?
        /// A structure that contains information about the start and end times of the launch.
        public var execution: EvidentlyClientTypes.LaunchExecution?
        /// An array of structures that define the feature variations that are being used in the launch.
        public var groups: [EvidentlyClientTypes.LaunchGroup]?
        /// The date and time that the launch was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// An array of structures that define the metrics that are being used to monitor the launch performance.
        public var metricMonitors: [EvidentlyClientTypes.MetricMonitor]?
        /// The name of the launch.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the launch.
        public var project: Swift.String?
        /// This value is used when Evidently assigns a particular user session to the launch, to help create a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt.
        public var randomizationSalt: Swift.String?
        /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
        public var scheduledSplitsDefinition: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition?
        /// The current state of the launch.
        /// This member is required.
        public var status: EvidentlyClientTypes.LaunchStatus?
        /// If the launch was stopped, this is the string that was entered by the person who stopped the launch, to explain why it was stopped.
        public var statusReason: Swift.String?
        /// The list of tag keys and values associated with this launch.
        public var tags: [Swift.String: Swift.String]?
        /// The type of launch.
        /// This member is required.
        public var type: EvidentlyClientTypes.LaunchType?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            execution: EvidentlyClientTypes.LaunchExecution? = nil,
            groups: [EvidentlyClientTypes.LaunchGroup]? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            metricMonitors: [EvidentlyClientTypes.MetricMonitor]? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            randomizationSalt: Swift.String? = nil,
            scheduledSplitsDefinition: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition? = nil,
            status: EvidentlyClientTypes.LaunchStatus? = nil,
            statusReason: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: EvidentlyClientTypes.LaunchType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.execution = execution
            self.groups = groups
            self.lastUpdatedTime = lastUpdatedTime
            self.metricMonitors = metricMonitors
            self.name = name
            self.project = project
            self.randomizationSalt = randomizationSalt
            self.scheduledSplitsDefinition = scheduledSplitsDefinition
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }
    }
}

public struct CreateLaunchOutput: Swift.Sendable {
    /// A structure that contains the configuration of the launch that was created.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

extension EvidentlyClientTypes {

    /// Use this parameter to configure client-side evaluation for your project. Client-side evaluation allows your application to assign variations to user sessions locally instead of by calling the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation to assign the variations. This mitigates the latency and availability risks that come with an API call. ProjectAppConfigResource is a structure that defines the configuration of how your application integrates with AppConfig to run client-side evaluation.
    public struct ProjectAppConfigResourceConfig: Swift.Sendable {
        /// The ID of the AppConfig application to use for client-side evaluation.
        public var applicationId: Swift.String?
        /// The ID of the AppConfig environment to use for client-side evaluation. This must be an environment that is within the application that you specify for applicationId.
        public var environmentId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            environmentId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.environmentId = environmentId
        }
    }
}

extension EvidentlyClientTypes {

    /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
    public struct S3DestinationConfig: Swift.Sendable {
        /// The name of the bucket in which Evidently stores evaluation events.
        public var bucket: Swift.String?
        /// The bucket prefix in which Evidently stores evaluation events.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
    public struct ProjectDataDeliveryConfig: Swift.Sendable {
        /// If the project stores evaluation events in CloudWatch Logs, this structure stores the log group name.
        public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
        /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
        public var s3Destination: EvidentlyClientTypes.S3DestinationConfig?

        public init(
            cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig? = nil,
            s3Destination: EvidentlyClientTypes.S3DestinationConfig? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Destination = s3Destination
        }
    }
}

public struct CreateProjectInput: Swift.Sendable {
    /// Use this parameter if the project will use client-side evaluation powered by AppConfig. Client-side evaluation allows your application to assign variations to user sessions locally instead of by calling the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation. This mitigates the latency and availability risks that come with an API call. For more information, see [ Client-side evaluation - powered by AppConfig.](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-client-side-evaluation.html) This parameter is a structure that contains information about the AppConfig application and environment that will be used as for client-side evaluation. To create a project that uses client-side evaluation, you must have the evidently:ExportProjectAsConfiguration permission.
    public var appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig?
    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage, if you choose to do so. If you choose not to store these events, Evidently deletes them after using them to produce metrics and other experiment results that you can view.
    public var dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig?
    /// An optional description of the project.
    public var description: Swift.String?
    /// The name for the project.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the project. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a project. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig? = nil,
        dataDelivery: EvidentlyClientTypes.ProjectDataDeliveryConfig? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.appConfigResource = appConfigResource
        self.dataDelivery = dataDelivery
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension EvidentlyClientTypes {

    /// This is a structure that defines the configuration of how your application integrates with AppConfig to run client-side evaluation.
    public struct ProjectAppConfigResource: Swift.Sendable {
        /// The ID of the AppConfig application to use for client-side evaluation.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The ID of the AppConfig profile to use for client-side evaluation.
        /// This member is required.
        public var configurationProfileId: Swift.String?
        /// The ID of the AppConfig environment to use for client-side evaluation. This must be an environment that is within the application that you specify for applicationId.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            configurationProfileId: Swift.String? = nil,
            environmentId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.environmentId = environmentId
        }
    }
}

extension EvidentlyClientTypes {

    /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
    public struct S3Destination: Swift.Sendable {
        /// The name of the bucket in which Evidently stores evaluation events.
        public var bucket: Swift.String?
        /// The bucket prefix in which Evidently stores evaluation events.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
    public struct ProjectDataDelivery: Swift.Sendable {
        /// If the project stores evaluation events in CloudWatch Logs, this structure stores the log group name.
        public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestination?
        /// If the project stores evaluation events in an Amazon S3 bucket, this structure stores the bucket name and bucket prefix.
        public var s3Destination: EvidentlyClientTypes.S3Destination?

        public init(
            cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestination? = nil,
            s3Destination: EvidentlyClientTypes.S3Destination? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Destination = s3Destination
        }
    }
}

extension EvidentlyClientTypes {

    public enum ProjectStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectStatus] {
            return [
                .available,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// This structure defines a project, which is the logical object in Evidently that can contain features, launches, and experiments. Use projects to group similar features together.
    public struct Project: Swift.Sendable {
        /// The number of ongoing experiments currently in the project.
        public var activeExperimentCount: Swift.Int?
        /// The number of ongoing launches currently in the project.
        public var activeLaunchCount: Swift.Int?
        /// This structure defines the configuration of how your application integrates with AppConfig to run client-side evaluation.
        public var appConfigResource: EvidentlyClientTypes.ProjectAppConfigResource?
        /// The name or ARN of the project.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the project is created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// A structure that contains information about where Evidently is to store evaluation events for longer term storage.
        public var dataDelivery: EvidentlyClientTypes.ProjectDataDelivery?
        /// The user-entered description of the project.
        public var description: Swift.String?
        /// The number of experiments currently in the project. This includes all experiments that have been created and not deleted, whether they are ongoing or not.
        public var experimentCount: Swift.Int?
        /// The number of features currently in the project.
        public var featureCount: Swift.Int?
        /// The date and time that the project was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The number of launches currently in the project. This includes all launches that have been created and not deleted, whether they are ongoing or not.
        public var launchCount: Swift.Int?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the project.
        /// This member is required.
        public var status: EvidentlyClientTypes.ProjectStatus?
        /// The list of tag keys and values associated with this project.
        public var tags: [Swift.String: Swift.String]?

        public init(
            activeExperimentCount: Swift.Int? = nil,
            activeLaunchCount: Swift.Int? = nil,
            appConfigResource: EvidentlyClientTypes.ProjectAppConfigResource? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dataDelivery: EvidentlyClientTypes.ProjectDataDelivery? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            featureCount: Swift.Int? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: EvidentlyClientTypes.ProjectStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.activeExperimentCount = activeExperimentCount
            self.activeLaunchCount = activeLaunchCount
            self.appConfigResource = appConfigResource
            self.arn = arn
            self.createdTime = createdTime
            self.dataDelivery = dataDelivery
            self.description = description
            self.experimentCount = experimentCount
            self.featureCount = featureCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.status = status
            self.tags = tags
        }
    }
}

public struct CreateProjectOutput: Swift.Sendable {
    /// A structure that contains information about the created project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

public struct CreateSegmentInput: Swift.Sendable {
    /// An optional description for this segment.
    public var description: Swift.String?
    /// A name for the segment.
    /// This member is required.
    public var name: Swift.String?
    /// The pattern to use for the segment. For more information about pattern syntax, see [ Segment rule pattern syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-segments.html#CloudWatch-Evidently-segments-syntax.html).
    /// This member is required.
    public var pattern: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the segment. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with a segment. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pattern: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.pattern = pattern
        self.tags = tags
    }
}

extension EvidentlyClientTypes {

    /// This structure contains information about one audience segment. You can use segments in your experiments and launches to narrow the user sessions used for experiment or launch to only the user sessions that match one or more criteria.
    public struct Segment: Swift.Sendable {
        /// The ARN of the segment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that this segment was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The customer-created description for this segment.
        public var description: Swift.String?
        /// The number of experiments that this segment is used in. This count includes all current experiments, not just those that are currently running.
        public var experimentCount: Swift.Int?
        /// The date and time that this segment was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The number of launches that this segment is used in. This count includes all current launches, not just those that are currently running.
        public var launchCount: Swift.Int?
        /// The name of the segment.
        /// This member is required.
        public var name: Swift.String?
        /// The pattern that defines the attributes to use to evalute whether a user session will be in the segment. For more information about the pattern syntax, see [Segment rule pattern syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-segments.html).
        /// This member is required.
        public var pattern: Swift.String?
        /// The list of tag keys and values associated with this launch.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.experimentCount = experimentCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.pattern = pattern
            self.tags = tags
        }
    }
}

public struct CreateSegmentOutput: Swift.Sendable {
    /// A structure that contains the complete information about the segment that was just created.
    /// This member is required.
    public var segment: EvidentlyClientTypes.Segment?

    public init(
        segment: EvidentlyClientTypes.Segment? = nil
    )
    {
        self.segment = segment
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service was unavailable. Retry the request.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteExperimentInput: Swift.Sendable {
    /// The name of the experiment to delete.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.experiment = experiment
        self.project = project
    }
}

public struct DeleteExperimentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFeatureInput: Swift.Sendable {
    /// The name of the feature to delete.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.feature = feature
        self.project = project
    }
}

public struct DeleteFeatureOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLaunchInput: Swift.Sendable {
    /// The name of the launch to delete.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

public struct DeleteLaunchOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProjectInput: Swift.Sendable {
    /// The name or ARN of the project to delete.
    /// This member is required.
    public var project: Swift.String?

    public init(
        project: Swift.String? = nil
    )
    {
        self.project = project
    }
}

public struct DeleteProjectOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSegmentInput: Swift.Sendable {
    /// Specifies the segment to delete.
    /// This member is required.
    public var segment: Swift.String?

    public init(
        segment: Swift.String? = nil
    )
    {
        self.segment = segment
    }
}

public struct DeleteSegmentOutput: Swift.Sendable {

    public init() { }
}

public struct EvaluateFeatureInput: Swift.Sendable {
    /// An internal ID that represents a unique user of the application. This entityID is checked against any override rules assigned for this feature.
    /// This member is required.
    public var entityId: Swift.String?
    /// A JSON object of attributes that you can optionally pass in as part of the evaluation event sent to Evidently from the user session. Evidently can use this value to match user sessions with defined audience segments. For more information, see [Use segments to focus your audience](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Evidently-segments.html). If you include this parameter, the value must be a JSON object. A JSON array is not supported.
    public var evaluationContext: Swift.String?
    /// The name of the feature being evaluated.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains this feature.
    /// This member is required.
    public var project: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        evaluationContext: Swift.String? = nil,
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.evaluationContext = evaluationContext
        self.feature = feature
        self.project = project
    }
}

public struct EvaluateFeatureOutput: Swift.Sendable {
    /// If this user was assigned to a launch or experiment, this field lists the launch or experiment name.
    public var details: Swift.String?
    /// Specifies the reason that the user session was assigned this variation. Possible values include DEFAULT, meaning the user was served the default variation; LAUNCH_RULE_MATCH, if the user session was enrolled in a launch; EXPERIMENT_RULE_MATCH, if the user session was enrolled in an experiment; or ENTITY_OVERRIDES_MATCH, if the user's entityId matches an override rule.
    public var reason: Swift.String?
    /// The value assigned to this variation to differentiate it from the other variations of this feature.
    public var value: EvidentlyClientTypes.VariableValue?
    /// The name of the variation that was served to the user session.
    public var variation: Swift.String?

    public init(
        details: Swift.String? = nil,
        reason: Swift.String? = nil,
        value: EvidentlyClientTypes.VariableValue? = nil,
        variation: Swift.String? = nil
    )
    {
        self.details = details
        self.reason = reason
        self.value = value
        self.variation = variation
    }
}

extension EvidentlyClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case evaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .custom,
                .evaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "aws.evidently.custom"
            case .evaluation: return "aws.evidently.evaluation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains the information about one evaluation event or custom event sent to Evidently. This is a JSON payload. If this event specifies a pre-defined event type, the payload must follow the defined event schema.
    public struct Event: Swift.Sendable {
        /// The event data.
        /// This member is required.
        public var data: Swift.String?
        /// The timestamp of the event.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// aws.evidently.evaluation specifies an evaluation event, which determines which feature variation that a user sees. aws.evidently.custom specifies a custom event, which generates metrics from user actions such as clicks and checkouts.
        /// This member is required.
        public var type: EvidentlyClientTypes.EventType?

        public init(
            data: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            type: EvidentlyClientTypes.EventType? = nil
        )
        {
            self.data = data
            self.timestamp = timestamp
            self.type = type
        }
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource that you want to see the tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tag keys and values associated with the resource you specified.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct GetExperimentInput: Swift.Sendable {
    /// The name of the experiment that you want to see the details of.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment.
    /// This member is required.
    public var project: Swift.String?

    public init(
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.experiment = experiment
        self.project = project
    }
}

public struct GetExperimentOutput: Swift.Sendable {
    /// A structure containing the configuration details of the experiment.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init(
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentBaseStat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mean
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentBaseStat] {
            return [
                .mean
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mean: return "Mean"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentReportName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bayesianInference
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentReportName] {
            return [
                .bayesianInference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bayesianInference: return "BayesianInference"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentResultRequestType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case baseStat
        case confidenceInterval
        case pValue
        case treatmentEffect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentResultRequestType] {
            return [
                .baseStat,
                .confidenceInterval,
                .pValue,
                .treatmentEffect
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .baseStat: return "BaseStat"
            case .confidenceInterval: return "ConfidenceInterval"
            case .pValue: return "PValue"
            case .treatmentEffect: return "TreatmentEffect"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetExperimentResultsInput: Swift.Sendable {
    /// The statistic used to calculate experiment results. Currently the only valid value is mean, which uses the mean of the collected values as the statistic.
    public var baseStat: EvidentlyClientTypes.ExperimentBaseStat?
    /// The date and time that the experiment ended, if it is completed. This must be no longer than 30 days after the experiment start time.
    public var endTime: Foundation.Date?
    /// The name of the experiment to retrieve the results of.
    /// This member is required.
    public var experiment: Swift.String?
    /// The names of the experiment metrics that you want to see the results of.
    /// This member is required.
    public var metricNames: [Swift.String]?
    /// In seconds, the amount of time to aggregate results together.
    public var period: Swift.Int
    /// The name or ARN of the project that contains the experiment that you want to see the results of.
    /// This member is required.
    public var project: Swift.String?
    /// The names of the report types that you want to see. Currently, BayesianInference is the only valid value.
    public var reportNames: [EvidentlyClientTypes.ExperimentReportName]?
    /// The statistics that you want to see in the returned results.
    ///
    /// * PValue specifies to use p-values for the results. A p-value is used in hypothesis testing to measure how often you are willing to make a mistake in rejecting the null hypothesis. A general practice is to reject the null hypothesis and declare that the results are statistically significant when the p-value is less than 0.05.
    ///
    /// * ConfidenceInterval specifies a confidence interval for the results. The confidence interval represents the range of values for the chosen metric that is likely to contain the true difference between the baseStat of a variation and the baseline. Evidently returns the 95% confidence interval.
    ///
    /// * TreatmentEffect is the difference in the statistic specified by the baseStat parameter between each variation and the default variation.
    ///
    /// * BaseStat returns the statistical values collected for the metric for each variation. The statistic uses the same statistic specified in the baseStat parameter. Therefore, if baseStat is mean, this returns the mean of the values collected for each variation.
    public var resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]?
    /// The date and time that the experiment started.
    public var startTime: Foundation.Date?
    /// The names of the experiment treatments that you want to see the results for.
    /// This member is required.
    public var treatmentNames: [Swift.String]?

    public init(
        baseStat: EvidentlyClientTypes.ExperimentBaseStat? = nil,
        endTime: Foundation.Date? = nil,
        experiment: Swift.String? = nil,
        metricNames: [Swift.String]? = nil,
        period: Swift.Int = 0,
        project: Swift.String? = nil,
        reportNames: [EvidentlyClientTypes.ExperimentReportName]? = nil,
        resultStats: [EvidentlyClientTypes.ExperimentResultRequestType]? = nil,
        startTime: Foundation.Date? = nil,
        treatmentNames: [Swift.String]? = nil
    )
    {
        self.baseStat = baseStat
        self.endTime = endTime
        self.experiment = experiment
        self.metricNames = metricNames
        self.period = period
        self.project = project
        self.reportNames = reportNames
        self.resultStats = resultStats
        self.startTime = startTime
        self.treatmentNames = treatmentNames
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains results of an experiment.
    public struct ExperimentReport: Swift.Sendable {
        /// The content of the report.
        public var content: Swift.String?
        /// The name of the metric that is analyzed in this experiment report.
        public var metricName: Swift.String?
        /// The type of analysis used for this report.
        public var reportName: EvidentlyClientTypes.ExperimentReportName?
        /// The name of the variation that this report pertains to.
        public var treatmentName: Swift.String?

        public init(
            content: Swift.String? = nil,
            metricName: Swift.String? = nil,
            reportName: EvidentlyClientTypes.ExperimentReportName? = nil,
            treatmentName: Swift.String? = nil
        )
        {
            self.content = content
            self.metricName = metricName
            self.reportName = reportName
            self.treatmentName = treatmentName
        }
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentResultResponseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confidenceIntervalLowerbound
        case confidenceIntervalUpperbound
        case mean
        case pValue
        case treatmentEffect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentResultResponseType] {
            return [
                .confidenceIntervalLowerbound,
                .confidenceIntervalUpperbound,
                .mean,
                .pValue,
                .treatmentEffect
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confidenceIntervalLowerbound: return "ConfidenceIntervalLowerBound"
            case .confidenceIntervalUpperbound: return "ConfidenceIntervalUpperBound"
            case .mean: return "Mean"
            case .pValue: return "PValue"
            case .treatmentEffect: return "TreatmentEffect"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains experiment results for one metric that is monitored in the experiment.
    public struct ExperimentResultsData: Swift.Sendable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The experiment statistic that these results pertain to.
        public var resultStat: EvidentlyClientTypes.ExperimentResultResponseType?
        /// The treatment, or variation, that returned the values in this structure.
        public var treatmentName: Swift.String?
        /// The values for the metricName that were recorded in the experiment.
        public var values: [Swift.Double]?

        public init(
            metricName: Swift.String? = nil,
            resultStat: EvidentlyClientTypes.ExperimentResultResponseType? = nil,
            treatmentName: Swift.String? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.metricName = metricName
            self.resultStat = resultStat
            self.treatmentName = treatmentName
            self.values = values
        }
    }
}

public struct GetExperimentResultsOutput: Swift.Sendable {
    /// If the experiment doesn't yet have enough events to provide valid results, this field is returned with the message Not enough events to generate results. If there are enough events to provide valid results, this field is not returned.
    public var details: Swift.String?
    /// An array of structures that include the reports that you requested.
    public var reports: [EvidentlyClientTypes.ExperimentReport]?
    /// An array of structures that include experiment results including metric names and values.
    public var resultsData: [EvidentlyClientTypes.ExperimentResultsData]?
    /// The timestamps of each result returned.
    public var timestamps: [Foundation.Date]?

    public init(
        details: Swift.String? = nil,
        reports: [EvidentlyClientTypes.ExperimentReport]? = nil,
        resultsData: [EvidentlyClientTypes.ExperimentResultsData]? = nil,
        timestamps: [Foundation.Date]? = nil
    )
    {
        self.details = details
        self.reports = reports
        self.resultsData = resultsData
        self.timestamps = timestamps
    }
}

public struct ListExperimentsInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListExperiments operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the experiment list from.
    /// This member is required.
    public var project: Swift.String?
    /// Use this optional parameter to limit the returned results to only the experiments with the status that you specify here.
    public var status: EvidentlyClientTypes.ExperimentStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil,
        status: EvidentlyClientTypes.ExperimentStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
        self.status = status
    }
}

public struct ListExperimentsOutput: Swift.Sendable {
    /// An array of structures that contain the configuration details of the experiments in the specified project.
    public var experiments: [EvidentlyClientTypes.Experiment]?
    /// The token to use in a subsequent ListExperiments operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        experiments: [EvidentlyClientTypes.Experiment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

public struct StartExperimentInput: Swift.Sendable {
    /// The date and time to end the experiment. This must be no more than 30 days after the experiment starts.
    /// This member is required.
    public var analysisCompleteTime: Foundation.Date?
    /// The name of the experiment to start.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to start.
    /// This member is required.
    public var project: Swift.String?

    public init(
        analysisCompleteTime: Foundation.Date? = nil,
        experiment: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.analysisCompleteTime = analysisCompleteTime
        self.experiment = experiment
        self.project = project
    }
}

public struct StartExperimentOutput: Swift.Sendable {
    /// A timestamp that indicates when the experiment started.
    public var startedTime: Foundation.Date?

    public init(
        startedTime: Foundation.Date? = nil
    )
    {
        self.startedTime = startedTime
    }
}

extension EvidentlyClientTypes {

    public enum ExperimentStopDesiredState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStopDesiredState] {
            return [
                .cancelled,
                .completed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StopExperimentInput: Swift.Sendable {
    /// Specify whether the experiment is to be considered COMPLETED or CANCELLED after it stops.
    public var desiredState: EvidentlyClientTypes.ExperimentStopDesiredState?
    /// The name of the experiment to stop.
    /// This member is required.
    public var experiment: Swift.String?
    /// The name or ARN of the project that contains the experiment to stop.
    /// This member is required.
    public var project: Swift.String?
    /// A string that describes why you are stopping the experiment.
    public var reason: Swift.String?

    public init(
        desiredState: EvidentlyClientTypes.ExperimentStopDesiredState? = nil,
        experiment: Swift.String? = nil,
        project: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.desiredState = desiredState
        self.experiment = experiment
        self.project = project
        self.reason = reason
    }
}

public struct StopExperimentOutput: Swift.Sendable {
    /// The date and time that the experiment stopped.
    public var endedTime: Foundation.Date?

    public init(
        endedTime: Foundation.Date? = nil
    )
    {
        self.endedTime = endedTime
    }
}

public struct UpdateExperimentInput: Swift.Sendable {
    /// An optional description of the experiment.
    public var description: Swift.String?
    /// The name of the experiment to update.
    /// This member is required.
    public var experiment: Swift.String?
    /// An array of structures that defines the metrics used for the experiment, and whether a higher or lower value for each metric is the goal.
    public var metricGoals: [EvidentlyClientTypes.MetricGoalConfig]?
    /// A structure that contains the configuration of which variation o use as the "control" version. The "control" version is used for comparison with other variations. This structure also specifies how much experiment traffic is allocated to each variation.
    public var onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig?
    /// The name or ARN of the project that contains the experiment that you want to update.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to an experiment, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the experiment name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// Removes a segment from being used in an experiment. You can't use this parameter if the experiment is currently running.
    public var removeSegment: Swift.Bool
    /// The portion of the available audience that you want to allocate to this experiment, in thousandths of a percent. The available audience is the total audience minus the audience that you have allocated to overrides or current launches of this feature. This is represented in thousandths of a percent. For example, specify 20,000 to allocate 20% of the available audience.
    public var samplingRate: Swift.Int?
    /// Adds an audience segment to an experiment. When a segment is used in an experiment, only user sessions that match the segment pattern are used in the experiment. You can't use this parameter if the experiment is currently running.
    public var segment: Swift.String?
    /// An array of structures that define the variations being tested in the experiment.
    public var treatments: [EvidentlyClientTypes.TreatmentConfig]?

    public init(
        description: Swift.String? = nil,
        experiment: Swift.String? = nil,
        metricGoals: [EvidentlyClientTypes.MetricGoalConfig]? = nil,
        onlineAbConfig: EvidentlyClientTypes.OnlineAbConfig? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        removeSegment: Swift.Bool = false,
        samplingRate: Swift.Int? = 0,
        segment: Swift.String? = nil,
        treatments: [EvidentlyClientTypes.TreatmentConfig]? = nil
    )
    {
        self.description = description
        self.experiment = experiment
        self.metricGoals = metricGoals
        self.onlineAbConfig = onlineAbConfig
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.removeSegment = removeSegment
        self.samplingRate = samplingRate
        self.segment = segment
        self.treatments = treatments
    }
}

public struct UpdateExperimentOutput: Swift.Sendable {
    /// A structure containing the configuration details of the experiment that was updated.
    /// This member is required.
    public var experiment: EvidentlyClientTypes.Experiment?

    public init(
        experiment: EvidentlyClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

public struct GetFeatureInput: Swift.Sendable {
    /// The name of the feature that you want to retrieve information for.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature.
    /// This member is required.
    public var project: Swift.String?

    public init(
        feature: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.feature = feature
        self.project = project
    }
}

public struct GetFeatureOutput: Swift.Sendable {
    /// A structure containing the configuration details of the feature.
    /// This member is required.
    public var feature: EvidentlyClientTypes.Feature?

    public init(
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

public struct ListFeaturesInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListFeatures operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the feature list from.
    /// This member is required.
    public var project: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
    }
}

extension EvidentlyClientTypes {

    /// This structure contains information about one Evidently feature in your account.
    public struct FeatureSummary: Swift.Sendable {
        /// The ARN of the feature.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the feature is created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The name of the variation that is used as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature.
        public var defaultVariation: Swift.String?
        /// An array of structures that define
        public var evaluationRules: [EvidentlyClientTypes.EvaluationRule]?
        /// If this value is ALL_RULES, the traffic allocation specified by any ongoing launches or experiments is being used. If this is DEFAULT_VARIATION, the default variation is being served to all users.
        /// This member is required.
        public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
        /// The date and time that the feature was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the feature.
        /// This member is required.
        public var name: Swift.String?
        /// The name or ARN of the project that contains the feature.
        public var project: Swift.String?
        /// The current state of the feature.
        /// This member is required.
        public var status: EvidentlyClientTypes.FeatureStatus?
        /// The list of tag keys and values associated with this feature.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            defaultVariation: Swift.String? = nil,
            evaluationRules: [EvidentlyClientTypes.EvaluationRule]? = nil,
            evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            project: Swift.String? = nil,
            status: EvidentlyClientTypes.FeatureStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.defaultVariation = defaultVariation
            self.evaluationRules = evaluationRules
            self.evaluationStrategy = evaluationStrategy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.project = project
            self.status = status
            self.tags = tags
        }
    }
}

public struct ListFeaturesOutput: Swift.Sendable {
    /// An array of structures that contain the configuration details of the features in the specified project.
    public var features: [EvidentlyClientTypes.FeatureSummary]?
    /// The token to use in a subsequent ListFeatures operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        features: [EvidentlyClientTypes.FeatureSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.features = features
        self.nextToken = nextToken
    }
}

public struct UpdateFeatureInput: Swift.Sendable {
    /// To update variation configurations for this feature, or add new ones, specify this structure. In this array, include any variations that you want to add or update. If the array includes a variation name that already exists for this feature, it is updated. If it includes a new variation name, it is added as a new variation.
    public var addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]?
    /// The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature.
    public var defaultVariation: Swift.String?
    /// An optional description of the feature.
    public var description: Swift.String?
    /// Specified users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served. This parameter is limited to 2500 overrides or a total of 40KB. The 40KB limit includes an overhead of 6 bytes per override.
    public var entityOverrides: [Swift.String: Swift.String]?
    /// Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
    public var evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy?
    /// The name of the feature to be updated.
    /// This member is required.
    public var feature: Swift.String?
    /// The name or ARN of the project that contains the feature to be updated.
    /// This member is required.
    public var project: Swift.String?
    /// Removes a variation from the feature. If the variation you specify doesn't exist, then this makes no change and does not report an error. This operation fails if you try to remove a variation that is part of an ongoing launch or experiment.
    public var removeVariations: [Swift.String]?

    public init(
        addOrUpdateVariations: [EvidentlyClientTypes.VariationConfig]? = nil,
        defaultVariation: Swift.String? = nil,
        description: Swift.String? = nil,
        entityOverrides: [Swift.String: Swift.String]? = nil,
        evaluationStrategy: EvidentlyClientTypes.FeatureEvaluationStrategy? = nil,
        feature: Swift.String? = nil,
        project: Swift.String? = nil,
        removeVariations: [Swift.String]? = nil
    )
    {
        self.addOrUpdateVariations = addOrUpdateVariations
        self.defaultVariation = defaultVariation
        self.description = description
        self.entityOverrides = entityOverrides
        self.evaluationStrategy = evaluationStrategy
        self.feature = feature
        self.project = project
        self.removeVariations = removeVariations
    }
}

public struct UpdateFeatureOutput: Swift.Sendable {
    /// A structure that contains information about the updated feature.
    /// This member is required.
    public var feature: EvidentlyClientTypes.Feature?

    public init(
        feature: EvidentlyClientTypes.Feature? = nil
    )
    {
        self.feature = feature
    }
}

public struct GetProjectInput: Swift.Sendable {
    /// The name or ARN of the project that you want to see the details of.
    /// This member is required.
    public var project: Swift.String?

    public init(
        project: Swift.String? = nil
    )
    {
        self.project = project
    }
}

public struct GetProjectOutput: Swift.Sendable {
    /// A structure containing the configuration details of the project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

public struct GetLaunchInput: Swift.Sendable {
    /// The name of the launch that you want to see the details of.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch.
    /// This member is required.
    public var project: Swift.String?

    public init(
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

public struct GetLaunchOutput: Swift.Sendable {
    /// A structure containing the configuration details of the launch.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

public struct ListLaunchesInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListLaunches operation.
    public var nextToken: Swift.String?
    /// The name or ARN of the project to return the launch list from.
    /// This member is required.
    public var project: Swift.String?
    /// Use this optional parameter to limit the returned results to only the launches with the status that you specify here.
    public var status: EvidentlyClientTypes.LaunchStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        project: Swift.String? = nil,
        status: EvidentlyClientTypes.LaunchStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.project = project
        self.status = status
    }
}

public struct ListLaunchesOutput: Swift.Sendable {
    /// An array of structures that contain the configuration details of the launches in the specified project.
    public var launches: [EvidentlyClientTypes.Launch]?
    /// The token to use in a subsequent ListLaunches operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        launches: [EvidentlyClientTypes.Launch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launches = launches
        self.nextToken = nextToken
    }
}

public struct StartLaunchInput: Swift.Sendable {
    /// The name of the launch to start.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch to start.
    /// This member is required.
    public var project: Swift.String?

    public init(
        launch: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.launch = launch
        self.project = project
    }
}

public struct StartLaunchOutput: Swift.Sendable {
    /// A structure that contains information about the launch that was started.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

extension EvidentlyClientTypes {

    public enum LaunchStopDesiredState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStopDesiredState] {
            return [
                .cancelled,
                .completed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StopLaunchInput: Swift.Sendable {
    /// Specify whether to consider the launch as COMPLETED or CANCELLED after it stops.
    public var desiredState: EvidentlyClientTypes.LaunchStopDesiredState?
    /// The name of the launch to stop.
    /// This member is required.
    public var launch: Swift.String?
    /// The name or ARN of the project that contains the launch that you want to stop.
    /// This member is required.
    public var project: Swift.String?
    /// A string that describes why you are stopping the launch.
    public var reason: Swift.String?

    public init(
        desiredState: EvidentlyClientTypes.LaunchStopDesiredState? = nil,
        launch: Swift.String? = nil,
        project: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.desiredState = desiredState
        self.launch = launch
        self.project = project
        self.reason = reason
    }
}

public struct StopLaunchOutput: Swift.Sendable {
    /// The date and time that the launch stopped.
    public var endedTime: Foundation.Date?

    public init(
        endedTime: Foundation.Date? = nil
    )
    {
        self.endedTime = endedTime
    }
}

public struct UpdateLaunchInput: Swift.Sendable {
    /// An optional description for the launch.
    public var description: Swift.String?
    /// An array of structures that contains the feature and variations that are to be used for the launch.
    public var groups: [EvidentlyClientTypes.LaunchGroupConfig]?
    /// The name of the launch that is to be updated.
    /// This member is required.
    public var launch: Swift.String?
    /// An array of structures that define the metrics that will be used to monitor the launch performance.
    public var metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]?
    /// The name or ARN of the project that contains the launch that you want to update.
    /// This member is required.
    public var project: Swift.String?
    /// When Evidently assigns a particular user session to a launch, it must use a randomization ID to determine which variation the user session is served. This randomization ID is a combination of the entity ID and randomizationSalt. If you omit randomizationSalt, Evidently uses the launch name as the randomizationSalt.
    public var randomizationSalt: Swift.String?
    /// An array of structures that define the traffic allocation percentages among the feature variations during each step of the launch.
    public var scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?

    public init(
        description: Swift.String? = nil,
        groups: [EvidentlyClientTypes.LaunchGroupConfig]? = nil,
        launch: Swift.String? = nil,
        metricMonitors: [EvidentlyClientTypes.MetricMonitorConfig]? = nil,
        project: Swift.String? = nil,
        randomizationSalt: Swift.String? = nil,
        scheduledSplitsConfig: EvidentlyClientTypes.ScheduledSplitsLaunchConfig? = nil
    )
    {
        self.description = description
        self.groups = groups
        self.launch = launch
        self.metricMonitors = metricMonitors
        self.project = project
        self.randomizationSalt = randomizationSalt
        self.scheduledSplitsConfig = scheduledSplitsConfig
    }
}

public struct UpdateLaunchOutput: Swift.Sendable {
    /// A structure that contains the new configuration of the launch that was updated.
    /// This member is required.
    public var launch: EvidentlyClientTypes.Launch?

    public init(
        launch: EvidentlyClientTypes.Launch? = nil
    )
    {
        self.launch = launch
    }
}

public struct ListProjectsInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListProjects operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains configuration information about an Evidently project.
    public struct ProjectSummary: Swift.Sendable {
        /// The number of experiments currently in the project.
        public var activeExperimentCount: Swift.Int?
        /// The number of ongoing launches currently in the project.
        public var activeLaunchCount: Swift.Int?
        /// The name or ARN of the project.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the project is created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the project.
        public var description: Swift.String?
        /// The number of experiments currently in the project.
        public var experimentCount: Swift.Int?
        /// The number of features currently in the project.
        public var featureCount: Swift.Int?
        /// The date and time that the project was most recently updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The number of launches currently in the project, including launches that are ongoing, completed, and not started yet.
        public var launchCount: Swift.Int?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?
        /// The current state of the project.
        /// This member is required.
        public var status: EvidentlyClientTypes.ProjectStatus?
        /// The list of tag keys and values associated with this project.
        public var tags: [Swift.String: Swift.String]?

        public init(
            activeExperimentCount: Swift.Int? = nil,
            activeLaunchCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            experimentCount: Swift.Int? = nil,
            featureCount: Swift.Int? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            launchCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: EvidentlyClientTypes.ProjectStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.activeExperimentCount = activeExperimentCount
            self.activeLaunchCount = activeLaunchCount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.experimentCount = experimentCount
            self.featureCount = featureCount
            self.lastUpdatedTime = lastUpdatedTime
            self.launchCount = launchCount
            self.name = name
            self.status = status
            self.tags = tags
        }
    }
}

public struct ListProjectsOutput: Swift.Sendable {
    /// The token to use in a subsequent ListProjects operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures that contain the configuration details of the projects in the Region.
    public var projects: [EvidentlyClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [EvidentlyClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

public struct PutProjectEventsInput: Swift.Sendable {
    /// An array of event structures that contain the performance data that is being sent to Evidently.
    /// This member is required.
    public var events: [EvidentlyClientTypes.Event]?
    /// The name or ARN of the project to write the events to.
    /// This member is required.
    public var project: Swift.String?

    public init(
        events: [EvidentlyClientTypes.Event]? = nil,
        project: Swift.String? = nil
    )
    {
        self.events = events
        self.project = project
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains Evidently's response to the sent events, including an event ID and error codes, if any.
    public struct PutProjectEventsResultEntry: Swift.Sendable {
        /// If the PutProjectEvents operation has an error, the error code is returned here.
        public var errorCode: Swift.String?
        /// If the PutProjectEvents operation has an error, the error message is returned here.
        public var errorMessage: Swift.String?
        /// A unique ID assigned to this PutProjectEvents operation.
        public var eventId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }
}

public struct PutProjectEventsOutput: Swift.Sendable {
    /// A structure that contains Evidently's response to the sent events, including an event ID and error codes, if any.
    public var eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]?
    /// The number of events in the operation that could not be used by Evidently.
    public var failedEventCount: Swift.Int?

    public init(
        eventResults: [EvidentlyClientTypes.PutProjectEventsResultEntry]? = nil,
        failedEventCount: Swift.Int? = nil
    )
    {
        self.eventResults = eventResults
        self.failedEventCount = failedEventCount
    }
}

public struct UpdateProjectInput: Swift.Sendable {
    /// Use this parameter if the project will use client-side evaluation powered by AppConfig. Client-side evaluation allows your application to assign variations to user sessions locally instead of by calling the [EvaluateFeature](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_EvaluateFeature.html) operation. This mitigates the latency and availability risks that come with an API call. allows you to This parameter is a structure that contains information about the AppConfig application that will be used for client-side evaluation.
    public var appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig?
    /// An optional description of the project.
    public var description: Swift.String?
    /// The name or ARN of the project to update.
    /// This member is required.
    public var project: Swift.String?

    public init(
        appConfigResource: EvidentlyClientTypes.ProjectAppConfigResourceConfig? = nil,
        description: Swift.String? = nil,
        project: Swift.String? = nil
    )
    {
        self.appConfigResource = appConfigResource
        self.description = description
        self.project = project
    }
}

public struct UpdateProjectOutput: Swift.Sendable {
    /// A structure containing information about the updated project.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

public struct UpdateProjectDataDeliveryInput: Swift.Sendable {
    /// A structure containing the CloudWatch Logs log group where you want to store evaluation events.
    public var cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?
    /// The name or ARN of the project that you want to modify the data storage options for.
    /// This member is required.
    public var project: Swift.String?
    /// A structure containing the S3 bucket name and bucket prefix where you want to store evaluation events.
    public var s3Destination: EvidentlyClientTypes.S3DestinationConfig?

    public init(
        cloudWatchLogs: EvidentlyClientTypes.CloudWatchLogsDestinationConfig? = nil,
        project: Swift.String? = nil,
        s3Destination: EvidentlyClientTypes.S3DestinationConfig? = nil
    )
    {
        self.cloudWatchLogs = cloudWatchLogs
        self.project = project
        self.s3Destination = s3Destination
    }
}

public struct UpdateProjectDataDeliveryOutput: Swift.Sendable {
    /// A structure containing details about the project that you updated.
    /// This member is required.
    public var project: EvidentlyClientTypes.Project?

    public init(
        project: EvidentlyClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

public struct GetSegmentInput: Swift.Sendable {
    /// The ARN of the segment to return information for.
    /// This member is required.
    public var segment: Swift.String?

    public init(
        segment: Swift.String? = nil
    )
    {
        self.segment = segment
    }
}

public struct GetSegmentOutput: Swift.Sendable {
    /// A structure that contains the complete information about the segment.
    /// This member is required.
    public var segment: EvidentlyClientTypes.Segment?

    public init(
        segment: EvidentlyClientTypes.Segment? = nil
    )
    {
        self.segment = segment
    }
}

extension EvidentlyClientTypes {

    public enum SegmentReferenceResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case experiment
        case launch
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentReferenceResourceType] {
            return [
                .experiment,
                .launch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .experiment: return "EXPERIMENT"
            case .launch: return "LAUNCH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSegmentReferencesInput: Swift.Sendable {
    /// The maximum number of results to include in the response. If you omit this, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListSegmentReferences operation.
    public var nextToken: Swift.String?
    /// The ARN of the segment that you want to view information for.
    /// This member is required.
    public var segment: Swift.String?
    /// Specifies whether to return information about launches or experiments that use this segment.
    /// This member is required.
    public var type: EvidentlyClientTypes.SegmentReferenceResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        segment: Swift.String? = nil,
        type: EvidentlyClientTypes.SegmentReferenceResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.segment = segment
        self.type = type
    }
}

extension EvidentlyClientTypes {

    /// A structure that contains information about one experiment or launch that uses the specified segment.
    public struct RefResource: Swift.Sendable {
        /// The ARN of the experiment or launch.
        public var arn: Swift.String?
        /// The day and time that this experiment or launch ended.
        public var endTime: Swift.String?
        /// The day and time that this experiment or launch was most recently updated.
        public var lastUpdatedOn: Swift.String?
        /// The name of the experiment or launch.
        /// This member is required.
        public var name: Swift.String?
        /// The day and time that this experiment or launch started.
        public var startTime: Swift.String?
        /// The status of the experiment or launch.
        public var status: Swift.String?
        /// Specifies whether the resource that this structure contains information about is an experiment or a launch.
        /// This member is required.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            endTime: Swift.String? = nil,
            lastUpdatedOn: Swift.String? = nil,
            name: Swift.String? = nil,
            startTime: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.endTime = endTime
            self.lastUpdatedOn = lastUpdatedOn
            self.name = name
            self.startTime = startTime
            self.status = status
            self.type = type
        }
    }
}

public struct ListSegmentReferencesOutput: Swift.Sendable {
    /// The token to use in a subsequent ListSegmentReferences operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures, where each structure contains information about one experiment or launch that uses this segment.
    public var referencedBy: [EvidentlyClientTypes.RefResource]?

    public init(
        nextToken: Swift.String? = nil,
        referencedBy: [EvidentlyClientTypes.RefResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.referencedBy = referencedBy
    }
}

public struct ListSegmentsInput: Swift.Sendable {
    /// The maximum number of results to include in the response. If you omit this, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListSegments operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSegmentsOutput: Swift.Sendable {
    /// The token to use in a subsequent ListSegments operation to return the next set of results.
    public var nextToken: Swift.String?
    /// An array of structures that contain information about the segments in this Region.
    public var segments: [EvidentlyClientTypes.Segment]?

    public init(
        nextToken: Swift.String? = nil,
        segments: [EvidentlyClientTypes.Segment]? = nil
    )
    {
        self.nextToken = nextToken
        self.segments = segments
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the CloudWatch Evidently resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct TestSegmentPatternInput: Swift.Sendable {
    /// The pattern to test.
    /// This member is required.
    public var pattern: Swift.String?
    /// A sample evaluationContext JSON block to test against the specified pattern.
    /// This member is required.
    public var payload: Swift.String?

    public init(
        pattern: Swift.String? = nil,
        payload: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.payload = payload
    }
}

public struct TestSegmentPatternOutput: Swift.Sendable {
    /// Returns true if the pattern matches the payload.
    /// This member is required.
    public var match: Swift.Bool?

    public init(
        match: Swift.Bool? = nil
    )
    {
        self.match = match
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the CloudWatch Evidently resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension BatchEvaluateFeatureInput {

    static func urlPathProvider(_ value: BatchEvaluateFeatureInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/evaluations"
    }
}

extension CreateExperimentInput {

    static func urlPathProvider(_ value: CreateExperimentInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments"
    }
}

extension CreateFeatureInput {

    static func urlPathProvider(_ value: CreateFeatureInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features"
    }
}

extension CreateLaunchInput {

    static func urlPathProvider(_ value: CreateLaunchInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches"
    }
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        return "/projects"
    }
}

extension CreateSegmentInput {

    static func urlPathProvider(_ value: CreateSegmentInput) -> Swift.String? {
        return "/segments"
    }
}

extension DeleteExperimentInput {

    static func urlPathProvider(_ value: DeleteExperimentInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let experiment = value.experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

extension DeleteFeatureInput {

    static func urlPathProvider(_ value: DeleteFeatureInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let feature = value.feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

extension DeleteLaunchInput {

    static func urlPathProvider(_ value: DeleteLaunchInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let launch = value.launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

extension DeleteSegmentInput {

    static func urlPathProvider(_ value: DeleteSegmentInput) -> Swift.String? {
        guard let segment = value.segment else {
            return nil
        }
        return "/segments/\(segment.urlPercentEncoding())"
    }
}

extension EvaluateFeatureInput {

    static func urlPathProvider(_ value: EvaluateFeatureInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let feature = value.feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/evaluations/\(feature.urlPercentEncoding())"
    }
}

extension GetExperimentInput {

    static func urlPathProvider(_ value: GetExperimentInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let experiment = value.experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

extension GetExperimentResultsInput {

    static func urlPathProvider(_ value: GetExperimentResultsInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let experiment = value.experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/results"
    }
}

extension GetFeatureInput {

    static func urlPathProvider(_ value: GetFeatureInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let feature = value.feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

extension GetLaunchInput {

    static func urlPathProvider(_ value: GetLaunchInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let launch = value.launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

extension GetProjectInput {

    static func urlPathProvider(_ value: GetProjectInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

extension GetSegmentInput {

    static func urlPathProvider(_ value: GetSegmentInput) -> Swift.String? {
        guard let segment = value.segment else {
            return nil
        }
        return "/segments/\(segment.urlPercentEncoding())"
    }
}

extension ListExperimentsInput {

    static func urlPathProvider(_ value: ListExperimentsInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments"
    }
}

extension ListExperimentsInput {

    static func queryItemProvider(_ value: ListExperimentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListFeaturesInput {

    static func urlPathProvider(_ value: ListFeaturesInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features"
    }
}

extension ListFeaturesInput {

    static func queryItemProvider(_ value: ListFeaturesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLaunchesInput {

    static func urlPathProvider(_ value: ListLaunchesInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches"
    }
}

extension ListLaunchesInput {

    static func queryItemProvider(_ value: ListLaunchesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        return "/projects"
    }
}

extension ListProjectsInput {

    static func queryItemProvider(_ value: ListProjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSegmentReferencesInput {

    static func urlPathProvider(_ value: ListSegmentReferencesInput) -> Swift.String? {
        guard let segment = value.segment else {
            return nil
        }
        return "/segments/\(segment.urlPercentEncoding())/references"
    }
}

extension ListSegmentReferencesInput {

    static func queryItemProvider(_ value: ListSegmentReferencesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let type = value.type else {
            let message = "Creating a URL Query Item failed. type is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
        items.append(typeQueryItem)
        return items
    }
}

extension ListSegmentsInput {

    static func urlPathProvider(_ value: ListSegmentsInput) -> Swift.String? {
        return "/segments"
    }
}

extension ListSegmentsInput {

    static func queryItemProvider(_ value: ListSegmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutProjectEventsInput {

    static func urlPathProvider(_ value: PutProjectEventsInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/events/projects/\(project.urlPercentEncoding())"
    }
}

extension StartExperimentInput {

    static func urlPathProvider(_ value: StartExperimentInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let experiment = value.experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/start"
    }
}

extension StartLaunchInput {

    static func urlPathProvider(_ value: StartLaunchInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let launch = value.launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())/start"
    }
}

extension StopExperimentInput {

    static func urlPathProvider(_ value: StopExperimentInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let experiment = value.experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())/cancel"
    }
}

extension StopLaunchInput {

    static func urlPathProvider(_ value: StopLaunchInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let launch = value.launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())/cancel"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TestSegmentPatternInput {

    static func urlPathProvider(_ value: TestSegmentPatternInput) -> Swift.String? {
        return "/test-segment-pattern"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateExperimentInput {

    static func urlPathProvider(_ value: UpdateExperimentInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let experiment = value.experiment else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/experiments/\(experiment.urlPercentEncoding())"
    }
}

extension UpdateFeatureInput {

    static func urlPathProvider(_ value: UpdateFeatureInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let feature = value.feature else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/features/\(feature.urlPercentEncoding())"
    }
}

extension UpdateLaunchInput {

    static func urlPathProvider(_ value: UpdateLaunchInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        guard let launch = value.launch else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/launches/\(launch.urlPercentEncoding())"
    }
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())"
    }
}

extension UpdateProjectDataDeliveryInput {

    static func urlPathProvider(_ value: UpdateProjectDataDeliveryInput) -> Swift.String? {
        guard let project = value.project else {
            return nil
        }
        return "/projects/\(project.urlPercentEncoding())/data-delivery"
    }
}

extension BatchEvaluateFeatureInput {

    static func write(value: BatchEvaluateFeatureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["requests"].writeList(value.requests, memberWritingClosure: EvidentlyClientTypes.EvaluationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateExperimentInput {

    static func write(value: CreateExperimentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["metricGoals"].writeList(value.metricGoals, memberWritingClosure: EvidentlyClientTypes.MetricGoalConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["onlineAbConfig"].write(value.onlineAbConfig, with: EvidentlyClientTypes.OnlineAbConfig.write(value:to:))
        try writer["randomizationSalt"].write(value.randomizationSalt)
        try writer["samplingRate"].write(value.samplingRate)
        try writer["segment"].write(value.segment)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["treatments"].writeList(value.treatments, memberWritingClosure: EvidentlyClientTypes.TreatmentConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFeatureInput {

    static func write(value: CreateFeatureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultVariation"].write(value.defaultVariation)
        try writer["description"].write(value.description)
        try writer["entityOverrides"].writeMap(value.entityOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["evaluationStrategy"].write(value.evaluationStrategy)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["variations"].writeList(value.variations, memberWritingClosure: EvidentlyClientTypes.VariationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLaunchInput {

    static func write(value: CreateLaunchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["groups"].writeList(value.groups, memberWritingClosure: EvidentlyClientTypes.LaunchGroupConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metricMonitors"].writeList(value.metricMonitors, memberWritingClosure: EvidentlyClientTypes.MetricMonitorConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["randomizationSalt"].write(value.randomizationSalt)
        try writer["scheduledSplitsConfig"].write(value.scheduledSplitsConfig, with: EvidentlyClientTypes.ScheduledSplitsLaunchConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appConfigResource"].write(value.appConfigResource, with: EvidentlyClientTypes.ProjectAppConfigResourceConfig.write(value:to:))
        try writer["dataDelivery"].write(value.dataDelivery, with: EvidentlyClientTypes.ProjectDataDeliveryConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSegmentInput {

    static func write(value: CreateSegmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["pattern"].write(value.pattern)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension EvaluateFeatureInput {

    static func write(value: EvaluateFeatureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
        try writer["evaluationContext"].write(value.evaluationContext)
    }
}

extension GetExperimentResultsInput {

    static func write(value: GetExperimentResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseStat"].write(value.baseStat)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["metricNames"].writeList(value.metricNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["period"].write(value.period)
        try writer["reportNames"].writeList(value.reportNames, memberWritingClosure: SmithyReadWrite.WritingClosureBox<EvidentlyClientTypes.ExperimentReportName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resultStats"].writeList(value.resultStats, memberWritingClosure: SmithyReadWrite.WritingClosureBox<EvidentlyClientTypes.ExperimentResultRequestType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["treatmentNames"].writeList(value.treatmentNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutProjectEventsInput {

    static func write(value: PutProjectEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["events"].writeList(value.events, memberWritingClosure: EvidentlyClientTypes.Event.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartExperimentInput {

    static func write(value: StartExperimentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisCompleteTime"].writeTimestamp(value.analysisCompleteTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension StopExperimentInput {

    static func write(value: StopExperimentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredState"].write(value.desiredState)
        try writer["reason"].write(value.reason)
    }
}

extension StopLaunchInput {

    static func write(value: StopLaunchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredState"].write(value.desiredState)
        try writer["reason"].write(value.reason)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TestSegmentPatternInput {

    static func write(value: TestSegmentPatternInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pattern"].write(value.pattern)
        try writer["payload"].write(value.payload)
    }
}

extension UpdateExperimentInput {

    static func write(value: UpdateExperimentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["metricGoals"].writeList(value.metricGoals, memberWritingClosure: EvidentlyClientTypes.MetricGoalConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["onlineAbConfig"].write(value.onlineAbConfig, with: EvidentlyClientTypes.OnlineAbConfig.write(value:to:))
        try writer["randomizationSalt"].write(value.randomizationSalt)
        try writer["removeSegment"].write(value.removeSegment)
        try writer["samplingRate"].write(value.samplingRate)
        try writer["segment"].write(value.segment)
        try writer["treatments"].writeList(value.treatments, memberWritingClosure: EvidentlyClientTypes.TreatmentConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFeatureInput {

    static func write(value: UpdateFeatureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addOrUpdateVariations"].writeList(value.addOrUpdateVariations, memberWritingClosure: EvidentlyClientTypes.VariationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["defaultVariation"].write(value.defaultVariation)
        try writer["description"].write(value.description)
        try writer["entityOverrides"].writeMap(value.entityOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["evaluationStrategy"].write(value.evaluationStrategy)
        try writer["removeVariations"].writeList(value.removeVariations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLaunchInput {

    static func write(value: UpdateLaunchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["groups"].writeList(value.groups, memberWritingClosure: EvidentlyClientTypes.LaunchGroupConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metricMonitors"].writeList(value.metricMonitors, memberWritingClosure: EvidentlyClientTypes.MetricMonitorConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["randomizationSalt"].write(value.randomizationSalt)
        try writer["scheduledSplitsConfig"].write(value.scheduledSplitsConfig, with: EvidentlyClientTypes.ScheduledSplitsLaunchConfig.write(value:to:))
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appConfigResource"].write(value.appConfigResource, with: EvidentlyClientTypes.ProjectAppConfigResourceConfig.write(value:to:))
        try writer["description"].write(value.description)
    }
}

extension UpdateProjectDataDeliveryInput {

    static func write(value: UpdateProjectDataDeliveryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogs"].write(value.cloudWatchLogs, with: EvidentlyClientTypes.CloudWatchLogsDestinationConfig.write(value:to:))
        try writer["s3Destination"].write(value.s3Destination, with: EvidentlyClientTypes.S3DestinationConfig.write(value:to:))
    }
}

extension BatchEvaluateFeatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchEvaluateFeatureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchEvaluateFeatureOutput()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: EvidentlyClientTypes.Experiment.read(from:))
        return value
    }
}

extension CreateFeatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFeatureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFeatureOutput()
        value.feature = try reader["feature"].readIfPresent(with: EvidentlyClientTypes.Feature.read(from:))
        return value
    }
}

extension CreateLaunchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLaunchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLaunchOutput()
        value.launch = try reader["launch"].readIfPresent(with: EvidentlyClientTypes.Launch.read(from:))
        return value
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.project = try reader["project"].readIfPresent(with: EvidentlyClientTypes.Project.read(from:))
        return value
    }
}

extension CreateSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSegmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSegmentOutput()
        value.segment = try reader["segment"].readIfPresent(with: EvidentlyClientTypes.Segment.read(from:))
        return value
    }
}

extension DeleteExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExperimentOutput {
        return DeleteExperimentOutput()
    }
}

extension DeleteFeatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFeatureOutput {
        return DeleteFeatureOutput()
    }
}

extension DeleteLaunchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLaunchOutput {
        return DeleteLaunchOutput()
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectOutput {
        return DeleteProjectOutput()
    }
}

extension DeleteSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSegmentOutput {
        return DeleteSegmentOutput()
    }
}

extension EvaluateFeatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EvaluateFeatureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EvaluateFeatureOutput()
        value.details = try reader["details"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.value = try reader["value"].readIfPresent(with: EvidentlyClientTypes.VariableValue.read(from:))
        value.variation = try reader["variation"].readIfPresent()
        return value
    }
}

extension GetExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: EvidentlyClientTypes.Experiment.read(from:))
        return value
    }
}

extension GetExperimentResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExperimentResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExperimentResultsOutput()
        value.details = try reader["details"].readIfPresent()
        value.reports = try reader["reports"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.ExperimentReport.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resultsData = try reader["resultsData"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.ExperimentResultsData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timestamps = try reader["timestamps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFeatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFeatureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFeatureOutput()
        value.feature = try reader["feature"].readIfPresent(with: EvidentlyClientTypes.Feature.read(from:))
        return value
    }
}

extension GetLaunchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLaunchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLaunchOutput()
        value.launch = try reader["launch"].readIfPresent(with: EvidentlyClientTypes.Launch.read(from:))
        return value
    }
}

extension GetProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProjectOutput()
        value.project = try reader["project"].readIfPresent(with: EvidentlyClientTypes.Project.read(from:))
        return value
    }
}

extension GetSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentOutput()
        value.segment = try reader["segment"].readIfPresent(with: EvidentlyClientTypes.Segment.read(from:))
        return value
    }
}

extension ListExperimentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExperimentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExperimentsOutput()
        value.experiments = try reader["experiments"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.Experiment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFeaturesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFeaturesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFeaturesOutput()
        value.features = try reader["features"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.FeatureSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLaunchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLaunchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLaunchesOutput()
        value.launches = try reader["launches"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.Launch.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projects = try reader["projects"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.ProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSegmentReferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSegmentReferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSegmentReferencesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.referencedBy = try reader["referencedBy"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.RefResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSegmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSegmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSegmentsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.segments = try reader["segments"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.Segment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutProjectEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProjectEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProjectEventsOutput()
        value.eventResults = try reader["eventResults"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.PutProjectEventsResultEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedEventCount = try reader["failedEventCount"].readIfPresent()
        return value
    }
}

extension StartExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExperimentOutput()
        value.startedTime = try reader["startedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StartLaunchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartLaunchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartLaunchOutput()
        value.launch = try reader["launch"].readIfPresent(with: EvidentlyClientTypes.Launch.read(from:))
        return value
    }
}

extension StopExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopExperimentOutput()
        value.endedTime = try reader["endedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StopLaunchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopLaunchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopLaunchOutput()
        value.endedTime = try reader["endedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestSegmentPatternOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestSegmentPatternOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestSegmentPatternOutput()
        value.match = try reader["match"].readIfPresent() ?? false
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateExperimentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateExperimentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateExperimentOutput()
        value.experiment = try reader["experiment"].readIfPresent(with: EvidentlyClientTypes.Experiment.read(from:))
        return value
    }
}

extension UpdateFeatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFeatureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFeatureOutput()
        value.feature = try reader["feature"].readIfPresent(with: EvidentlyClientTypes.Feature.read(from:))
        return value
    }
}

extension UpdateLaunchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLaunchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLaunchOutput()
        value.launch = try reader["launch"].readIfPresent(with: EvidentlyClientTypes.Launch.read(from:))
        return value
    }
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProjectOutput()
        value.project = try reader["project"].readIfPresent(with: EvidentlyClientTypes.Project.read(from:))
        return value
    }
}

extension UpdateProjectDataDeliveryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProjectDataDeliveryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProjectDataDeliveryOutput()
        value.project = try reader["project"].readIfPresent(with: EvidentlyClientTypes.Project.read(from:))
        return value
    }
}

enum BatchEvaluateFeatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFeatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLaunchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFeatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLaunchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EvaluateFeatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExperimentResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFeatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLaunchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExperimentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFeaturesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLaunchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSegmentReferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSegmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProjectEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartLaunchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopLaunchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestSegmentPatternOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateExperimentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFeatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLaunchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProjectDataDeliveryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EvidentlyClientTypes.EvaluationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.EvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.EvaluationResult()
        value.project = try reader["project"].readIfPresent()
        value.feature = try reader["feature"].readIfPresent() ?? ""
        value.variation = try reader["variation"].readIfPresent()
        value.value = try reader["value"].readIfPresent(with: EvidentlyClientTypes.VariableValue.read(from:))
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        value.reason = try reader["reason"].readIfPresent()
        value.details = try reader["details"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.VariableValue {

    static func write(value: EvidentlyClientTypes.VariableValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .boolvalue(boolvalue):
                try writer["boolValue"].write(boolvalue)
            case let .doublevalue(doublevalue):
                try writer["doubleValue"].write(doublevalue)
            case let .longvalue(longvalue):
                try writer["longValue"].write(longvalue)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.VariableValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "boolValue":
                return .boolvalue(try reader["boolValue"].read())
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "longValue":
                return .longvalue(try reader["longValue"].read())
            case "doubleValue":
                return .doublevalue(try reader["doubleValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension EvidentlyClientTypes.Experiment {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Experiment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Experiment()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.project = try reader["project"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.schedule = try reader["schedule"].readIfPresent(with: EvidentlyClientTypes.ExperimentSchedule.read(from:))
        value.execution = try reader["execution"].readIfPresent(with: EvidentlyClientTypes.ExperimentExecution.read(from:))
        value.treatments = try reader["treatments"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.Treatment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.metricGoals = try reader["metricGoals"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.MetricGoal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.randomizationSalt = try reader["randomizationSalt"].readIfPresent()
        value.samplingRate = try reader["samplingRate"].readIfPresent() ?? 0
        value.segment = try reader["segment"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.onlineAbDefinition = try reader["onlineAbDefinition"].readIfPresent(with: EvidentlyClientTypes.OnlineAbDefinition.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.OnlineAbDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.OnlineAbDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.OnlineAbDefinition()
        value.controlTreatmentName = try reader["controlTreatmentName"].readIfPresent()
        value.treatmentWeights = try reader["treatmentWeights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.MetricGoal {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.MetricGoal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.MetricGoal()
        value.metricDefinition = try reader["metricDefinition"].readIfPresent(with: EvidentlyClientTypes.MetricDefinition.read(from:))
        value.desiredChange = try reader["desiredChange"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.MetricDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.MetricDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.MetricDefinition()
        value.name = try reader["name"].readIfPresent()
        value.entityIdKey = try reader["entityIdKey"].readIfPresent()
        value.valueKey = try reader["valueKey"].readIfPresent()
        value.eventPattern = try reader["eventPattern"].readIfPresent()
        value.unitLabel = try reader["unitLabel"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.Treatment {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Treatment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Treatment()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.featureVariations = try reader["featureVariations"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ExperimentExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ExperimentExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ExperimentExecution()
        value.startedTime = try reader["startedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedTime = try reader["endedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension EvidentlyClientTypes.ExperimentSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ExperimentSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ExperimentSchedule()
        value.analysisCompleteTime = try reader["analysisCompleteTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension EvidentlyClientTypes.Feature {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Feature {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Feature()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.project = try reader["project"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.evaluationStrategy = try reader["evaluationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.valueType = try reader["valueType"].readIfPresent() ?? .sdkUnknown("")
        value.variations = try reader["variations"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.Variation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultVariation = try reader["defaultVariation"].readIfPresent()
        value.evaluationRules = try reader["evaluationRules"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.EvaluationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.entityOverrides = try reader["entityOverrides"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.EvaluationRule {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.EvaluationRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.EvaluationRule()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? ""
        return value
    }
}

extension EvidentlyClientTypes.Variation {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Variation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Variation()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent(with: EvidentlyClientTypes.VariableValue.read(from:))
        return value
    }
}

extension EvidentlyClientTypes.Launch {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Launch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Launch()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.project = try reader["project"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.execution = try reader["execution"].readIfPresent(with: EvidentlyClientTypes.LaunchExecution.read(from:))
        value.groups = try reader["groups"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.LaunchGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.metricMonitors = try reader["metricMonitors"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.MetricMonitor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.randomizationSalt = try reader["randomizationSalt"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.scheduledSplitsDefinition = try reader["scheduledSplitsDefinition"].readIfPresent(with: EvidentlyClientTypes.ScheduledSplitsLaunchDefinition.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ScheduledSplitsLaunchDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ScheduledSplitsLaunchDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ScheduledSplitsLaunchDefinition()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.ScheduledSplit.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ScheduledSplit {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ScheduledSplit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ScheduledSplit()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.groupWeights = try reader["groupWeights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.segmentOverrides = try reader["segmentOverrides"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.SegmentOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.SegmentOverride {

    static func write(value: EvidentlyClientTypes.SegmentOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evaluationOrder"].write(value.evaluationOrder)
        try writer["segment"].write(value.segment)
        try writer["weights"].writeMap(value.weights, valueWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.SegmentOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.SegmentOverride()
        value.segment = try reader["segment"].readIfPresent() ?? ""
        value.evaluationOrder = try reader["evaluationOrder"].readIfPresent() ?? 0
        value.weights = try reader["weights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension EvidentlyClientTypes.MetricMonitor {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.MetricMonitor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.MetricMonitor()
        value.metricDefinition = try reader["metricDefinition"].readIfPresent(with: EvidentlyClientTypes.MetricDefinition.read(from:))
        return value
    }
}

extension EvidentlyClientTypes.LaunchGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.LaunchGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.LaunchGroup()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.featureVariations = try reader["featureVariations"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension EvidentlyClientTypes.LaunchExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.LaunchExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.LaunchExecution()
        value.startedTime = try reader["startedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedTime = try reader["endedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension EvidentlyClientTypes.Project {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Project {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Project()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.featureCount = try reader["featureCount"].readIfPresent()
        value.launchCount = try reader["launchCount"].readIfPresent()
        value.activeLaunchCount = try reader["activeLaunchCount"].readIfPresent()
        value.experimentCount = try reader["experimentCount"].readIfPresent()
        value.activeExperimentCount = try reader["activeExperimentCount"].readIfPresent()
        value.dataDelivery = try reader["dataDelivery"].readIfPresent(with: EvidentlyClientTypes.ProjectDataDelivery.read(from:))
        value.appConfigResource = try reader["appConfigResource"].readIfPresent(with: EvidentlyClientTypes.ProjectAppConfigResource.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ProjectAppConfigResource {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ProjectAppConfigResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ProjectAppConfigResource()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.configurationProfileId = try reader["configurationProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension EvidentlyClientTypes.ProjectDataDelivery {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ProjectDataDelivery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ProjectDataDelivery()
        value.s3Destination = try reader["s3Destination"].readIfPresent(with: EvidentlyClientTypes.S3Destination.read(from:))
        value.cloudWatchLogs = try reader["cloudWatchLogs"].readIfPresent(with: EvidentlyClientTypes.CloudWatchLogsDestination.read(from:))
        return value
    }
}

extension EvidentlyClientTypes.CloudWatchLogsDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.CloudWatchLogsDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.CloudWatchLogsDestination()
        value.logGroup = try reader["logGroup"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.S3Destination {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.S3Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.S3Destination()
        value.bucket = try reader["bucket"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.Segment {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.Segment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.Segment()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.pattern = try reader["pattern"].readIfPresent() ?? ""
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.experimentCount = try reader["experimentCount"].readIfPresent()
        value.launchCount = try reader["launchCount"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ExperimentResultsData {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ExperimentResultsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ExperimentResultsData()
        value.metricName = try reader["metricName"].readIfPresent()
        value.treatmentName = try reader["treatmentName"].readIfPresent()
        value.resultStat = try reader["resultStat"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ExperimentReport {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ExperimentReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ExperimentReport()
        value.metricName = try reader["metricName"].readIfPresent()
        value.treatmentName = try reader["treatmentName"].readIfPresent()
        value.reportName = try reader["reportName"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.FeatureSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.FeatureSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.FeatureSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.project = try reader["project"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.evaluationStrategy = try reader["evaluationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.evaluationRules = try reader["evaluationRules"].readListIfPresent(memberReadingClosure: EvidentlyClientTypes.EvaluationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultVariation = try reader["defaultVariation"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.ProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ProjectSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.featureCount = try reader["featureCount"].readIfPresent()
        value.launchCount = try reader["launchCount"].readIfPresent()
        value.activeLaunchCount = try reader["activeLaunchCount"].readIfPresent()
        value.experimentCount = try reader["experimentCount"].readIfPresent()
        value.activeExperimentCount = try reader["activeExperimentCount"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension EvidentlyClientTypes.RefResource {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.RefResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.RefResource()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.lastUpdatedOn = try reader["lastUpdatedOn"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.PutProjectEventsResultEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.PutProjectEventsResultEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.PutProjectEventsResultEntry()
        value.eventId = try reader["eventId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension EvidentlyClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> EvidentlyClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvidentlyClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension EvidentlyClientTypes.EvaluationRequest {

    static func write(value: EvidentlyClientTypes.EvaluationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
        try writer["evaluationContext"].write(value.evaluationContext)
        try writer["feature"].write(value.feature)
    }
}

extension EvidentlyClientTypes.TreatmentConfig {

    static func write(value: EvidentlyClientTypes.TreatmentConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["feature"].write(value.feature)
        try writer["name"].write(value.name)
        try writer["variation"].write(value.variation)
    }
}

extension EvidentlyClientTypes.MetricGoalConfig {

    static func write(value: EvidentlyClientTypes.MetricGoalConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredChange"].write(value.desiredChange)
        try writer["metricDefinition"].write(value.metricDefinition, with: EvidentlyClientTypes.MetricDefinitionConfig.write(value:to:))
    }
}

extension EvidentlyClientTypes.MetricDefinitionConfig {

    static func write(value: EvidentlyClientTypes.MetricDefinitionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityIdKey"].write(value.entityIdKey)
        try writer["eventPattern"].write(value.eventPattern)
        try writer["name"].write(value.name)
        try writer["unitLabel"].write(value.unitLabel)
        try writer["valueKey"].write(value.valueKey)
    }
}

extension EvidentlyClientTypes.OnlineAbConfig {

    static func write(value: EvidentlyClientTypes.OnlineAbConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["controlTreatmentName"].write(value.controlTreatmentName)
        try writer["treatmentWeights"].writeMap(value.treatmentWeights, valueWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension EvidentlyClientTypes.VariationConfig {

    static func write(value: EvidentlyClientTypes.VariationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value, with: EvidentlyClientTypes.VariableValue.write(value:to:))
    }
}

extension EvidentlyClientTypes.ScheduledSplitsLaunchConfig {

    static func write(value: EvidentlyClientTypes.ScheduledSplitsLaunchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["steps"].writeList(value.steps, memberWritingClosure: EvidentlyClientTypes.ScheduledSplitConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension EvidentlyClientTypes.ScheduledSplitConfig {

    static func write(value: EvidentlyClientTypes.ScheduledSplitConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupWeights"].writeMap(value.groupWeights, valueWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["segmentOverrides"].writeList(value.segmentOverrides, memberWritingClosure: EvidentlyClientTypes.SegmentOverride.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension EvidentlyClientTypes.MetricMonitorConfig {

    static func write(value: EvidentlyClientTypes.MetricMonitorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metricDefinition"].write(value.metricDefinition, with: EvidentlyClientTypes.MetricDefinitionConfig.write(value:to:))
    }
}

extension EvidentlyClientTypes.LaunchGroupConfig {

    static func write(value: EvidentlyClientTypes.LaunchGroupConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["feature"].write(value.feature)
        try writer["name"].write(value.name)
        try writer["variation"].write(value.variation)
    }
}

extension EvidentlyClientTypes.ProjectDataDeliveryConfig {

    static func write(value: EvidentlyClientTypes.ProjectDataDeliveryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogs"].write(value.cloudWatchLogs, with: EvidentlyClientTypes.CloudWatchLogsDestinationConfig.write(value:to:))
        try writer["s3Destination"].write(value.s3Destination, with: EvidentlyClientTypes.S3DestinationConfig.write(value:to:))
    }
}

extension EvidentlyClientTypes.CloudWatchLogsDestinationConfig {

    static func write(value: EvidentlyClientTypes.CloudWatchLogsDestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroup"].write(value.logGroup)
    }
}

extension EvidentlyClientTypes.S3DestinationConfig {

    static func write(value: EvidentlyClientTypes.S3DestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["prefix"].write(value.`prefix`)
    }
}

extension EvidentlyClientTypes.ProjectAppConfigResourceConfig {

    static func write(value: EvidentlyClientTypes.ProjectAppConfigResourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationId"].write(value.applicationId)
        try writer["environmentId"].write(value.environmentId)
    }
}

extension EvidentlyClientTypes.Event {

    static func write(value: EvidentlyClientTypes.Event?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["type"].write(value.type)
    }
}

public enum EvidentlyClientTypes {}
