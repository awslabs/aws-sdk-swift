//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension MediaLiveClient {
    /// Paginate over `[DescribeScheduleOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScheduleInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduleOutput`
    public func describeSchedulePaginated(input: DescribeScheduleInput) -> ClientRuntime.PaginatorSequence<DescribeScheduleInput, DescribeScheduleOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScheduleInput, DescribeScheduleOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSchedule(input:))
    }
}

extension DescribeScheduleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduleInput {
        return DescribeScheduleInput(
            channelId: self.channelId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScheduleInput, OperationStackOutput == DescribeScheduleOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSchedulePaginated`
    /// to access the nested member `[MediaLiveClientTypes.ScheduleAction]`
    /// - Returns: `[MediaLiveClientTypes.ScheduleAction]`
    public func scheduleActions() async throws -> [MediaLiveClientTypes.ScheduleAction] {
        return try await self.asyncCompactMap { item in item.scheduleActions }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListChannelPlacementGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListChannelPlacementGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListChannelPlacementGroupsOutput`
    public func listChannelPlacementGroupsPaginated(input: ListChannelPlacementGroupsInput) -> ClientRuntime.PaginatorSequence<ListChannelPlacementGroupsInput, ListChannelPlacementGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListChannelPlacementGroupsInput, ListChannelPlacementGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listChannelPlacementGroups(input:))
    }
}

extension ListChannelPlacementGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChannelPlacementGroupsInput {
        return ListChannelPlacementGroupsInput(
            clusterId: self.clusterId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListChannelPlacementGroupsInput, OperationStackOutput == ListChannelPlacementGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listChannelPlacementGroupsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.DescribeChannelPlacementGroupSummary]`
    /// - Returns: `[MediaLiveClientTypes.DescribeChannelPlacementGroupSummary]`
    public func channelPlacementGroups() async throws -> [MediaLiveClientTypes.DescribeChannelPlacementGroupSummary] {
        return try await self.asyncCompactMap { item in item.channelPlacementGroups }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListChannelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListChannelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListChannelsOutput`
    public func listChannelsPaginated(input: ListChannelsInput) -> ClientRuntime.PaginatorSequence<ListChannelsInput, ListChannelsOutput> {
        return ClientRuntime.PaginatorSequence<ListChannelsInput, ListChannelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listChannels(input:))
    }
}

extension ListChannelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChannelsInput {
        return ListChannelsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListChannelsInput, OperationStackOutput == ListChannelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listChannelsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.ChannelSummary]`
    /// - Returns: `[MediaLiveClientTypes.ChannelSummary]`
    public func channels() async throws -> [MediaLiveClientTypes.ChannelSummary] {
        return try await self.asyncCompactMap { item in item.channels }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListCloudWatchAlarmTemplateGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCloudWatchAlarmTemplateGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCloudWatchAlarmTemplateGroupsOutput`
    public func listCloudWatchAlarmTemplateGroupsPaginated(input: ListCloudWatchAlarmTemplateGroupsInput) -> ClientRuntime.PaginatorSequence<ListCloudWatchAlarmTemplateGroupsInput, ListCloudWatchAlarmTemplateGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListCloudWatchAlarmTemplateGroupsInput, ListCloudWatchAlarmTemplateGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCloudWatchAlarmTemplateGroups(input:))
    }
}

extension ListCloudWatchAlarmTemplateGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCloudWatchAlarmTemplateGroupsInput {
        return ListCloudWatchAlarmTemplateGroupsInput(
            maxResults: self.maxResults,
            nextToken: token,
            scope: self.scope,
            signalMapIdentifier: self.signalMapIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == ListCloudWatchAlarmTemplateGroupsInput, OperationStackOutput == ListCloudWatchAlarmTemplateGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCloudWatchAlarmTemplateGroupsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.CloudWatchAlarmTemplateGroupSummary]`
    /// - Returns: `[MediaLiveClientTypes.CloudWatchAlarmTemplateGroupSummary]`
    public func cloudWatchAlarmTemplateGroups() async throws -> [MediaLiveClientTypes.CloudWatchAlarmTemplateGroupSummary] {
        return try await self.asyncCompactMap { item in item.cloudWatchAlarmTemplateGroups }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListCloudWatchAlarmTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCloudWatchAlarmTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCloudWatchAlarmTemplatesOutput`
    public func listCloudWatchAlarmTemplatesPaginated(input: ListCloudWatchAlarmTemplatesInput) -> ClientRuntime.PaginatorSequence<ListCloudWatchAlarmTemplatesInput, ListCloudWatchAlarmTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListCloudWatchAlarmTemplatesInput, ListCloudWatchAlarmTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCloudWatchAlarmTemplates(input:))
    }
}

extension ListCloudWatchAlarmTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCloudWatchAlarmTemplatesInput {
        return ListCloudWatchAlarmTemplatesInput(
            groupIdentifier: self.groupIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            scope: self.scope,
            signalMapIdentifier: self.signalMapIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == ListCloudWatchAlarmTemplatesInput, OperationStackOutput == ListCloudWatchAlarmTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCloudWatchAlarmTemplatesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.CloudWatchAlarmTemplateSummary]`
    /// - Returns: `[MediaLiveClientTypes.CloudWatchAlarmTemplateSummary]`
    public func cloudWatchAlarmTemplates() async throws -> [MediaLiveClientTypes.CloudWatchAlarmTemplateSummary] {
        return try await self.asyncCompactMap { item in item.cloudWatchAlarmTemplates }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListClustersOutput`
    public func listClustersPaginated(input: ListClustersInput) -> ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutput> {
        return ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listClusters(input:))
    }
}

extension ListClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClustersInput {
        return ListClustersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListClustersInput, OperationStackOutput == ListClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listClustersPaginated`
    /// to access the nested member `[MediaLiveClientTypes.DescribeClusterSummary]`
    /// - Returns: `[MediaLiveClientTypes.DescribeClusterSummary]`
    public func clusters() async throws -> [MediaLiveClientTypes.DescribeClusterSummary] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListEventBridgeRuleTemplateGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventBridgeRuleTemplateGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventBridgeRuleTemplateGroupsOutput`
    public func listEventBridgeRuleTemplateGroupsPaginated(input: ListEventBridgeRuleTemplateGroupsInput) -> ClientRuntime.PaginatorSequence<ListEventBridgeRuleTemplateGroupsInput, ListEventBridgeRuleTemplateGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListEventBridgeRuleTemplateGroupsInput, ListEventBridgeRuleTemplateGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEventBridgeRuleTemplateGroups(input:))
    }
}

extension ListEventBridgeRuleTemplateGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventBridgeRuleTemplateGroupsInput {
        return ListEventBridgeRuleTemplateGroupsInput(
            maxResults: self.maxResults,
            nextToken: token,
            signalMapIdentifier: self.signalMapIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == ListEventBridgeRuleTemplateGroupsInput, OperationStackOutput == ListEventBridgeRuleTemplateGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEventBridgeRuleTemplateGroupsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.EventBridgeRuleTemplateGroupSummary]`
    /// - Returns: `[MediaLiveClientTypes.EventBridgeRuleTemplateGroupSummary]`
    public func eventBridgeRuleTemplateGroups() async throws -> [MediaLiveClientTypes.EventBridgeRuleTemplateGroupSummary] {
        return try await self.asyncCompactMap { item in item.eventBridgeRuleTemplateGroups }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListEventBridgeRuleTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventBridgeRuleTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventBridgeRuleTemplatesOutput`
    public func listEventBridgeRuleTemplatesPaginated(input: ListEventBridgeRuleTemplatesInput) -> ClientRuntime.PaginatorSequence<ListEventBridgeRuleTemplatesInput, ListEventBridgeRuleTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListEventBridgeRuleTemplatesInput, ListEventBridgeRuleTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEventBridgeRuleTemplates(input:))
    }
}

extension ListEventBridgeRuleTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventBridgeRuleTemplatesInput {
        return ListEventBridgeRuleTemplatesInput(
            groupIdentifier: self.groupIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            signalMapIdentifier: self.signalMapIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == ListEventBridgeRuleTemplatesInput, OperationStackOutput == ListEventBridgeRuleTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEventBridgeRuleTemplatesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.EventBridgeRuleTemplateSummary]`
    /// - Returns: `[MediaLiveClientTypes.EventBridgeRuleTemplateSummary]`
    public func eventBridgeRuleTemplates() async throws -> [MediaLiveClientTypes.EventBridgeRuleTemplateSummary] {
        return try await self.asyncCompactMap { item in item.eventBridgeRuleTemplates }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputDevicesOutput`
    public func listInputDevicesPaginated(input: ListInputDevicesInput) -> ClientRuntime.PaginatorSequence<ListInputDevicesInput, ListInputDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListInputDevicesInput, ListInputDevicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInputDevices(input:))
    }
}

extension ListInputDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputDevicesInput {
        return ListInputDevicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInputDevicesInput, OperationStackOutput == ListInputDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputDevicesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.InputDeviceSummary]`
    /// - Returns: `[MediaLiveClientTypes.InputDeviceSummary]`
    public func inputDevices() async throws -> [MediaLiveClientTypes.InputDeviceSummary] {
        return try await self.asyncCompactMap { item in item.inputDevices }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputDeviceTransfersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputDeviceTransfersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputDeviceTransfersOutput`
    public func listInputDeviceTransfersPaginated(input: ListInputDeviceTransfersInput) -> ClientRuntime.PaginatorSequence<ListInputDeviceTransfersInput, ListInputDeviceTransfersOutput> {
        return ClientRuntime.PaginatorSequence<ListInputDeviceTransfersInput, ListInputDeviceTransfersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInputDeviceTransfers(input:))
    }
}

extension ListInputDeviceTransfersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputDeviceTransfersInput {
        return ListInputDeviceTransfersInput(
            maxResults: self.maxResults,
            nextToken: token,
            transferType: self.transferType
        )}
}

extension PaginatorSequence where OperationStackInput == ListInputDeviceTransfersInput, OperationStackOutput == ListInputDeviceTransfersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputDeviceTransfersPaginated`
    /// to access the nested member `[MediaLiveClientTypes.TransferringInputDeviceSummary]`
    /// - Returns: `[MediaLiveClientTypes.TransferringInputDeviceSummary]`
    public func inputDeviceTransfers() async throws -> [MediaLiveClientTypes.TransferringInputDeviceSummary] {
        return try await self.asyncCompactMap { item in item.inputDeviceTransfers }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputsOutput`
    public func listInputsPaginated(input: ListInputsInput) -> ClientRuntime.PaginatorSequence<ListInputsInput, ListInputsOutput> {
        return ClientRuntime.PaginatorSequence<ListInputsInput, ListInputsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInputs(input:))
    }
}

extension ListInputsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputsInput {
        return ListInputsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInputsInput, OperationStackOutput == ListInputsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.Input]`
    /// - Returns: `[MediaLiveClientTypes.Input]`
    public func inputs() async throws -> [MediaLiveClientTypes.Input] {
        return try await self.asyncCompactMap { item in item.inputs }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputSecurityGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputSecurityGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputSecurityGroupsOutput`
    public func listInputSecurityGroupsPaginated(input: ListInputSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<ListInputSecurityGroupsInput, ListInputSecurityGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListInputSecurityGroupsInput, ListInputSecurityGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInputSecurityGroups(input:))
    }
}

extension ListInputSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputSecurityGroupsInput {
        return ListInputSecurityGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInputSecurityGroupsInput, OperationStackOutput == ListInputSecurityGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputSecurityGroupsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.InputSecurityGroup]`
    /// - Returns: `[MediaLiveClientTypes.InputSecurityGroup]`
    public func inputSecurityGroups() async throws -> [MediaLiveClientTypes.InputSecurityGroup] {
        return try await self.asyncCompactMap { item in item.inputSecurityGroups }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListMultiplexesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMultiplexesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMultiplexesOutput`
    public func listMultiplexesPaginated(input: ListMultiplexesInput) -> ClientRuntime.PaginatorSequence<ListMultiplexesInput, ListMultiplexesOutput> {
        return ClientRuntime.PaginatorSequence<ListMultiplexesInput, ListMultiplexesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMultiplexes(input:))
    }
}

extension ListMultiplexesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMultiplexesInput {
        return ListMultiplexesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMultiplexesInput, OperationStackOutput == ListMultiplexesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMultiplexesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.MultiplexSummary]`
    /// - Returns: `[MediaLiveClientTypes.MultiplexSummary]`
    public func multiplexes() async throws -> [MediaLiveClientTypes.MultiplexSummary] {
        return try await self.asyncCompactMap { item in item.multiplexes }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListMultiplexProgramsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMultiplexProgramsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMultiplexProgramsOutput`
    public func listMultiplexProgramsPaginated(input: ListMultiplexProgramsInput) -> ClientRuntime.PaginatorSequence<ListMultiplexProgramsInput, ListMultiplexProgramsOutput> {
        return ClientRuntime.PaginatorSequence<ListMultiplexProgramsInput, ListMultiplexProgramsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMultiplexPrograms(input:))
    }
}

extension ListMultiplexProgramsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMultiplexProgramsInput {
        return ListMultiplexProgramsInput(
            maxResults: self.maxResults,
            multiplexId: self.multiplexId,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMultiplexProgramsInput, OperationStackOutput == ListMultiplexProgramsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMultiplexProgramsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.MultiplexProgramSummary]`
    /// - Returns: `[MediaLiveClientTypes.MultiplexProgramSummary]`
    public func multiplexPrograms() async throws -> [MediaLiveClientTypes.MultiplexProgramSummary] {
        return try await self.asyncCompactMap { item in item.multiplexPrograms }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListNetworksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNetworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNetworksOutput`
    public func listNetworksPaginated(input: ListNetworksInput) -> ClientRuntime.PaginatorSequence<ListNetworksInput, ListNetworksOutput> {
        return ClientRuntime.PaginatorSequence<ListNetworksInput, ListNetworksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNetworks(input:))
    }
}

extension ListNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNetworksInput {
        return ListNetworksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListNetworksInput, OperationStackOutput == ListNetworksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNetworksPaginated`
    /// to access the nested member `[MediaLiveClientTypes.DescribeNetworkSummary]`
    /// - Returns: `[MediaLiveClientTypes.DescribeNetworkSummary]`
    public func networks() async throws -> [MediaLiveClientTypes.DescribeNetworkSummary] {
        return try await self.asyncCompactMap { item in item.networks }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListNodesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodesOutput`
    public func listNodesPaginated(input: ListNodesInput) -> ClientRuntime.PaginatorSequence<ListNodesInput, ListNodesOutput> {
        return ClientRuntime.PaginatorSequence<ListNodesInput, ListNodesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNodes(input:))
    }
}

extension ListNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodesInput {
        return ListNodesInput(
            clusterId: self.clusterId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListNodesInput, OperationStackOutput == ListNodesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNodesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.DescribeNodeSummary]`
    /// - Returns: `[MediaLiveClientTypes.DescribeNodeSummary]`
    public func nodes() async throws -> [MediaLiveClientTypes.DescribeNodeSummary] {
        return try await self.asyncCompactMap { item in item.nodes }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOfferingsOutput`
    public func listOfferingsPaginated(input: ListOfferingsInput) -> ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOfferings(input:))
    }
}

extension ListOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOfferingsInput {
        return ListOfferingsInput(
            channelClass: self.channelClass,
            channelConfiguration: self.channelConfiguration,
            codec: self.codec,
            duration: self.duration,
            maxResults: self.maxResults,
            maximumBitrate: self.maximumBitrate,
            maximumFramerate: self.maximumFramerate,
            nextToken: token,
            resolution: self.resolution,
            resourceType: self.resourceType,
            specialFeature: self.specialFeature,
            videoQuality: self.videoQuality
        )}
}

extension PaginatorSequence where OperationStackInput == ListOfferingsInput, OperationStackOutput == ListOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOfferingsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.Offering]`
    /// - Returns: `[MediaLiveClientTypes.Offering]`
    public func offerings() async throws -> [MediaLiveClientTypes.Offering] {
        return try await self.asyncCompactMap { item in item.offerings }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListReservationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReservationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReservationsOutput`
    public func listReservationsPaginated(input: ListReservationsInput) -> ClientRuntime.PaginatorSequence<ListReservationsInput, ListReservationsOutput> {
        return ClientRuntime.PaginatorSequence<ListReservationsInput, ListReservationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReservations(input:))
    }
}

extension ListReservationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReservationsInput {
        return ListReservationsInput(
            channelClass: self.channelClass,
            codec: self.codec,
            maxResults: self.maxResults,
            maximumBitrate: self.maximumBitrate,
            maximumFramerate: self.maximumFramerate,
            nextToken: token,
            resolution: self.resolution,
            resourceType: self.resourceType,
            specialFeature: self.specialFeature,
            videoQuality: self.videoQuality
        )}
}

extension PaginatorSequence where OperationStackInput == ListReservationsInput, OperationStackOutput == ListReservationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listReservationsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.Reservation]`
    /// - Returns: `[MediaLiveClientTypes.Reservation]`
    public func reservations() async throws -> [MediaLiveClientTypes.Reservation] {
        return try await self.asyncCompactMap { item in item.reservations }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListSignalMapsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSignalMapsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSignalMapsOutput`
    public func listSignalMapsPaginated(input: ListSignalMapsInput) -> ClientRuntime.PaginatorSequence<ListSignalMapsInput, ListSignalMapsOutput> {
        return ClientRuntime.PaginatorSequence<ListSignalMapsInput, ListSignalMapsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSignalMaps(input:))
    }
}

extension ListSignalMapsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSignalMapsInput {
        return ListSignalMapsInput(
            cloudWatchAlarmTemplateGroupIdentifier: self.cloudWatchAlarmTemplateGroupIdentifier,
            eventBridgeRuleTemplateGroupIdentifier: self.eventBridgeRuleTemplateGroupIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSignalMapsInput, OperationStackOutput == ListSignalMapsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSignalMapsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.SignalMapSummary]`
    /// - Returns: `[MediaLiveClientTypes.SignalMapSummary]`
    public func signalMaps() async throws -> [MediaLiveClientTypes.SignalMapSummary] {
        return try await self.asyncCompactMap { item in item.signalMaps }
    }
}
