// Code generated by smithy-swift-codegen. DO NOT EDIT!

import class ClientRuntime.Waiter
import enum ClientRuntime.JMESUtils
import protocol ClientRuntime.ServiceError
import struct ClientRuntime.WaiterConfiguration
import struct ClientRuntime.WaiterOptions
import struct ClientRuntime.WaiterOutcome

extension MediaLiveClient {

    static func channelCreatedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
            .init(state: .failure, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "CREATE_FAILED")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelCreated event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelCreated(options: ClientRuntime.WaiterOptions, input: DescribeChannelInput) async throws -> ClientRuntime.WaiterOutcome<DescribeChannelOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.channelCreatedWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelDeletedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelDeleted event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelDeleted(options: ClientRuntime.WaiterOptions, input: DescribeChannelInput) async throws -> ClientRuntime.WaiterOutcome<DescribeChannelOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.channelDeletedWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelRunningWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "RUNNING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "RUNNING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STARTING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "STARTING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelRunning event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelRunning(options: ClientRuntime.WaiterOptions, input: DescribeChannelInput) async throws -> ClientRuntime.WaiterOutcome<DescribeChannelOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.channelRunningWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelStoppedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STOPPING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "STOPPING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelStopped event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelStopped(options: ClientRuntime.WaiterOptions, input: DescribeChannelInput) async throws -> ClientRuntime.WaiterOutcome<DescribeChannelOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.channelStoppedWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputAttachedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ATTACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "ATTACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DETACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DETACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputAttached event on the describeInput operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInputInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputAttached(options: ClientRuntime.WaiterOptions, input: DescribeInputInput) async throws -> ClientRuntime.WaiterOutcome<DescribeInputOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.inputAttachedWaiterConfig(), operation: self.describeInput(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputDeletedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputDeleted event on the describeInput operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInputInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputDeleted(options: ClientRuntime.WaiterOptions, input: DescribeInputInput) async throws -> ClientRuntime.WaiterOutcome<DescribeInputOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.inputDeletedWaiterConfig(), operation: self.describeInput(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputDetachedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DETACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DETACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ATTACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "ATTACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputDetached event on the describeInput operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInputInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputDetached(options: ClientRuntime.WaiterOptions, input: DescribeInputInput) async throws -> ClientRuntime.WaiterOutcome<DescribeInputOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.inputDetachedWaiterConfig(), operation: self.describeInput(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexCreatedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
            .init(state: .failure, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "CREATE_FAILED")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexCreated event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexCreated(options: ClientRuntime.WaiterOptions, input: DescribeMultiplexInput) async throws -> ClientRuntime.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.multiplexCreatedWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexDeletedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexDeleted event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexDeleted(options: ClientRuntime.WaiterOptions, input: DescribeMultiplexInput) async throws -> ClientRuntime.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.multiplexDeletedWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexRunningWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "RUNNING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "RUNNING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STARTING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "STARTING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexRunning event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexRunning(options: ClientRuntime.WaiterOptions, input: DescribeMultiplexInput) async throws -> ClientRuntime.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.multiplexRunningWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexStoppedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STOPPING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return ClientRuntime.JMESUtils.compare(state, ==, "STOPPING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexStopped event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexStopped(options: ClientRuntime.WaiterOptions, input: DescribeMultiplexInput) async throws -> ClientRuntime.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.multiplexStoppedWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapCreatedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_COMPLETE"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "CREATE_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "CREATE_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "CREATE_FAILED")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapCreated event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapCreated(options: ClientRuntime.WaiterOptions, input: GetSignalMapInput) async throws -> ClientRuntime.WaiterOutcome<GetSignalMapOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.signalMapCreatedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapMonitorDeletedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_COMPLETE"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DELETE_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DELETE_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_FAILED"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DELETE_FAILED")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapMonitorDeleted event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapMonitorDeleted(options: ClientRuntime.WaiterOptions, input: GetSignalMapInput) async throws -> ClientRuntime.WaiterOutcome<GetSignalMapOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.signalMapMonitorDeletedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapMonitorDeployedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRY_RUN_DEPLOYMENT_COMPLETE"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DRY_RUN_DEPLOYMENT_COMPLETE")
            }),
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEPLOYMENT_COMPLETE"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DEPLOYMENT_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRY_RUN_DEPLOYMENT_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DRY_RUN_DEPLOYMENT_IN_PROGRESS")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEPLOYMENT_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DEPLOYMENT_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRY_RUN_DEPLOYMENT_FAILED"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DRY_RUN_DEPLOYMENT_FAILED")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEPLOYMENT_FAILED"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return ClientRuntime.JMESUtils.compare(status, ==, "DEPLOYMENT_FAILED")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapMonitorDeployed event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapMonitorDeployed(options: ClientRuntime.WaiterOptions, input: GetSignalMapInput) async throws -> ClientRuntime.WaiterOutcome<GetSignalMapOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.signalMapMonitorDeployedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapUpdatedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_COMPLETE"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "UPDATE_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "UPDATE_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_FAILED"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "UPDATE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_REVERTED"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return ClientRuntime.JMESUtils.compare(status, ==, "UPDATE_REVERTED")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapUpdated event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapUpdated(options: ClientRuntime.WaiterOptions, input: GetSignalMapInput) async throws -> ClientRuntime.WaiterOutcome<GetSignalMapOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.signalMapUpdatedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
