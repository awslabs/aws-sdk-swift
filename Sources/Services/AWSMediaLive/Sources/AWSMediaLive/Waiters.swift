//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import class SmithyWaitersAPI.Waiter
import enum SmithyWaitersAPI.JMESUtils
import protocol ClientRuntime.ServiceError
import struct SmithyWaitersAPI.WaiterConfiguration
import struct SmithyWaitersAPI.WaiterOptions
import struct SmithyWaitersAPI.WaiterOutcome

extension MediaLiveClient {

    static func channelCreatedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
            .init(state: .failure, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATE_FAILED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelCreated event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelCreated(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelCreatedWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelDeletedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelDeleted event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelDeleted(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelDeletedWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelRunningWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "RUNNING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "RUNNING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STARTING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "STARTING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelRunning event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelRunning(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelRunningWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelStoppedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STOPPING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "STOPPING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelInput, result: Swift.Result<DescribeChannelOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelInput, DescribeChannelOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelStopped event on the describeChannel operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelStopped(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelStoppedWaiterConfig(), operation: self.describeChannel(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelPlacementGroupAssignedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ASSIGNED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "ASSIGNED")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ASSIGNING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "ASSIGNING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelPlacementGroupAssigned event on the describeChannelPlacementGroup operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelPlacementGroupInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelPlacementGroupAssigned(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelPlacementGroupInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelPlacementGroupOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelPlacementGroupAssignedWaiterConfig(), operation: self.describeChannelPlacementGroup(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelPlacementGroupDeletedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelPlacementGroupDeleted event on the describeChannelPlacementGroup operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelPlacementGroupInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelPlacementGroupDeleted(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelPlacementGroupInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelPlacementGroupOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelPlacementGroupDeletedWaiterConfig(), operation: self.describeChannelPlacementGroup(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func channelPlacementGroupUnassignedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UNASSIGNED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "UNASSIGNED")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UNASSIGNING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "UNASSIGNING")
            }),
            .init(state: .retry, matcher: { (input: DescribeChannelPlacementGroupInput, result: Swift.Result<DescribeChannelPlacementGroupOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeChannelPlacementGroupInput, DescribeChannelPlacementGroupOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ChannelPlacementGroupUnassigned event on the describeChannelPlacementGroup operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeChannelPlacementGroupInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilChannelPlacementGroupUnassigned(options: SmithyWaitersAPI.WaiterOptions, input: DescribeChannelPlacementGroupInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeChannelPlacementGroupOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.channelPlacementGroupUnassignedWaiterConfig(), operation: self.describeChannelPlacementGroup(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func clusterCreatedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeClusterInput, DescribeClusterOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeClusterInput, DescribeClusterOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ACTIVE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "ACTIVE")
            }),
            .init(state: .retry, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
            .init(state: .failure, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATE_FAILED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeClusterInput, DescribeClusterOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ClusterCreated event on the describeCluster operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeClusterInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilClusterCreated(options: SmithyWaitersAPI.WaiterOptions, input: DescribeClusterInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeClusterOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.clusterCreatedWaiterConfig(), operation: self.describeCluster(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func clusterDeletedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeClusterInput, DescribeClusterOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeClusterInput, DescribeClusterOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeClusterInput, result: Swift.Result<DescribeClusterOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeClusterInput, DescribeClusterOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ClusterDeleted event on the describeCluster operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeClusterInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilClusterDeleted(options: SmithyWaitersAPI.WaiterOptions, input: DescribeClusterInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeClusterOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.clusterDeletedWaiterConfig(), operation: self.describeCluster(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputAttachedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ATTACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "ATTACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DETACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DETACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputAttached event on the describeInput operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInputInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputAttached(options: SmithyWaitersAPI.WaiterOptions, input: DescribeInputInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeInputOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.inputAttachedWaiterConfig(), operation: self.describeInput(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputDeletedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputDeleted event on the describeInput operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInputInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputDeleted(options: SmithyWaitersAPI.WaiterOptions, input: DescribeInputInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeInputOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.inputDeletedWaiterConfig(), operation: self.describeInput(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputDetachedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DETACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DETACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ATTACHED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "ATTACHED")
            }),
            .init(state: .retry, matcher: { (input: DescribeInputInput, result: Swift.Result<DescribeInputOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeInputInput, DescribeInputOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputDetached event on the describeInput operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInputInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputDetached(options: SmithyWaitersAPI.WaiterOptions, input: DescribeInputInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeInputOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.inputDetachedWaiterConfig(), operation: self.describeInput(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexCreatedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
            .init(state: .failure, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "CREATE_FAILED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexCreated event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexCreated(options: SmithyWaitersAPI.WaiterOptions, input: DescribeMultiplexInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.multiplexCreatedWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexDeletedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETED")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DELETING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexDeleted event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexDeleted(options: SmithyWaitersAPI.WaiterOptions, input: DescribeMultiplexInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.multiplexDeletedWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexRunningWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "RUNNING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "RUNNING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STARTING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "STARTING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexRunning event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexRunning(options: SmithyWaitersAPI.WaiterOptions, input: DescribeMultiplexInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.multiplexRunningWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func multiplexStoppedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "IDLE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "IDLE")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "STOPPING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "STOPPING")
            }),
            .init(state: .retry, matcher: { (input: DescribeMultiplexInput, result: Swift.Result<DescribeMultiplexOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeMultiplexInput, DescribeMultiplexOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the MultiplexStopped event on the describeMultiplex operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeMultiplexInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilMultiplexStopped(options: SmithyWaitersAPI.WaiterOptions, input: DescribeMultiplexInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeMultiplexOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.multiplexStoppedWaiterConfig(), operation: self.describeMultiplex(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func nodeDeregisteredWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeNodeInput, DescribeNodeOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeNodeInput, DescribeNodeOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEREGISTERED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DEREGISTERED")
            }),
            .init(state: .retry, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEREGISTERING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DEREGISTERING")
            }),
            .init(state: .retry, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRAINING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "DRAINING")
            }),
            .init(state: .retry, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeNodeInput, DescribeNodeOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NodeDeregistered event on the describeNode operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNodeInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNodeDeregistered(options: SmithyWaitersAPI.WaiterOptions, input: DescribeNodeInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeNodeOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.nodeDeregisteredWaiterConfig(), operation: self.describeNode(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func nodeRegisteredWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<DescribeNodeInput, DescribeNodeOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<DescribeNodeInput, DescribeNodeOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ACTIVE"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "ACTIVE")
            }),
            .init(state: .retry, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "REGISTERING"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "REGISTERING")
            }),
            .init(state: .retry, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "NotFoundException"
            }),
            .init(state: .failure, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "State"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "REGISTRATION_FAILED"
                guard case .success(let output) = result else { return false }
                let state = output.state
                return SmithyWaitersAPI.JMESUtils.compare(state, ==, "REGISTRATION_FAILED")
            }),
            .init(state: .retry, matcher: { (input: DescribeNodeInput, result: Swift.Result<DescribeNodeOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "InternalServerErrorException"
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<DescribeNodeInput, DescribeNodeOutput>(acceptors: acceptors, minDelay: 3.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NodeRegistered event on the describeNode operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNodeInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNodeRegistered(options: SmithyWaitersAPI.WaiterOptions, input: DescribeNodeInput) async throws -> SmithyWaitersAPI.WaiterOutcome<DescribeNodeOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.nodeRegisteredWaiterConfig(), operation: self.describeNode(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapCreatedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_COMPLETE"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "CREATE_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "CREATE_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "CREATE_FAILED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapCreated event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapCreated(options: SmithyWaitersAPI.WaiterOptions, input: GetSignalMapInput) async throws -> SmithyWaitersAPI.WaiterOutcome<GetSignalMapOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.signalMapCreatedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapMonitorDeletedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_COMPLETE"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DELETE_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DELETE_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_FAILED"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DELETE_FAILED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapMonitorDeleted event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapMonitorDeleted(options: SmithyWaitersAPI.WaiterOptions, input: GetSignalMapInput) async throws -> SmithyWaitersAPI.WaiterOutcome<GetSignalMapOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.signalMapMonitorDeletedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapMonitorDeployedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRY_RUN_DEPLOYMENT_COMPLETE"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DRY_RUN_DEPLOYMENT_COMPLETE")
            }),
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEPLOYMENT_COMPLETE"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DEPLOYMENT_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRY_RUN_DEPLOYMENT_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DRY_RUN_DEPLOYMENT_IN_PROGRESS")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEPLOYMENT_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DEPLOYMENT_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DRY_RUN_DEPLOYMENT_FAILED"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DRY_RUN_DEPLOYMENT_FAILED")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "MonitorDeployment.Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DEPLOYMENT_FAILED"
                guard case .success(let output) = result else { return false }
                let monitorDeployment = output.monitorDeployment
                let status = monitorDeployment?.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "DEPLOYMENT_FAILED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapMonitorDeployed event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapMonitorDeployed(options: SmithyWaitersAPI.WaiterOptions, input: GetSignalMapInput) async throws -> SmithyWaitersAPI.WaiterOutcome<GetSignalMapOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.signalMapMonitorDeployedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func signalMapUpdatedWaiterConfig() throws -> SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput> {
        let acceptors: [SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_COMPLETE"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "UPDATE_COMPLETE")
            }),
            .init(state: .retry, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_IN_PROGRESS"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "UPDATE_IN_PROGRESS")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_FAILED"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "UPDATE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: GetSignalMapInput, result: Swift.Result<GetSignalMapOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "Status"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_REVERTED"
                guard case .success(let output) = result else { return false }
                let status = output.status
                return SmithyWaitersAPI.JMESUtils.compare(status, ==, "UPDATE_REVERTED")
            }),
        ]
        return try SmithyWaitersAPI.WaiterConfiguration<GetSignalMapInput, GetSignalMapOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SignalMapUpdated event on the getSignalMap operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetSignalMapInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSignalMapUpdated(options: SmithyWaitersAPI.WaiterOptions, input: GetSignalMapInput) async throws -> SmithyWaitersAPI.WaiterOutcome<GetSignalMapOutput> {
        let waiter = SmithyWaitersAPI.Waiter(config: try Self.signalMapUpdatedWaiterConfig(), operation: self.getSignalMap(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
