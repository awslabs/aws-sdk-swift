// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MediaLiveClient {
    /// Paginate over `[DescribeScheduleOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScheduleInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduleOutput`
    public func describeSchedulePaginated(input: DescribeScheduleInput) -> ClientRuntime.PaginatorSequence<DescribeScheduleInput, DescribeScheduleOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScheduleInput, DescribeScheduleOutput>(input: input, inputKey: \DescribeScheduleInput.nextToken, outputKey: \DescribeScheduleOutput.nextToken, paginationFunction: self.describeSchedule(input:))
    }
}

extension DescribeScheduleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduleInput {
        return DescribeScheduleInput(
            channelId: self.channelId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeScheduleInput, Output == DescribeScheduleOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSchedulePaginated`
    /// to access the nested member `[MediaLiveClientTypes.ScheduleAction]`
    /// - Returns: `[MediaLiveClientTypes.ScheduleAction]`
    public func scheduleActions() async throws -> [MediaLiveClientTypes.ScheduleAction] {
        return try await self.asyncCompactMap { item in item.scheduleActions }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListChannelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListChannelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListChannelsOutput`
    public func listChannelsPaginated(input: ListChannelsInput) -> ClientRuntime.PaginatorSequence<ListChannelsInput, ListChannelsOutput> {
        return ClientRuntime.PaginatorSequence<ListChannelsInput, ListChannelsOutput>(input: input, inputKey: \ListChannelsInput.nextToken, outputKey: \ListChannelsOutput.nextToken, paginationFunction: self.listChannels(input:))
    }
}

extension ListChannelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChannelsInput {
        return ListChannelsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListChannelsInput, Output == ListChannelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listChannelsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.ChannelSummary]`
    /// - Returns: `[MediaLiveClientTypes.ChannelSummary]`
    public func channels() async throws -> [MediaLiveClientTypes.ChannelSummary] {
        return try await self.asyncCompactMap { item in item.channels }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputDevicesOutput`
    public func listInputDevicesPaginated(input: ListInputDevicesInput) -> ClientRuntime.PaginatorSequence<ListInputDevicesInput, ListInputDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListInputDevicesInput, ListInputDevicesOutput>(input: input, inputKey: \ListInputDevicesInput.nextToken, outputKey: \ListInputDevicesOutput.nextToken, paginationFunction: self.listInputDevices(input:))
    }
}

extension ListInputDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputDevicesInput {
        return ListInputDevicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListInputDevicesInput, Output == ListInputDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputDevicesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.InputDeviceSummary]`
    /// - Returns: `[MediaLiveClientTypes.InputDeviceSummary]`
    public func inputDevices() async throws -> [MediaLiveClientTypes.InputDeviceSummary] {
        return try await self.asyncCompactMap { item in item.inputDevices }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputDeviceTransfersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputDeviceTransfersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputDeviceTransfersOutput`
    public func listInputDeviceTransfersPaginated(input: ListInputDeviceTransfersInput) -> ClientRuntime.PaginatorSequence<ListInputDeviceTransfersInput, ListInputDeviceTransfersOutput> {
        return ClientRuntime.PaginatorSequence<ListInputDeviceTransfersInput, ListInputDeviceTransfersOutput>(input: input, inputKey: \ListInputDeviceTransfersInput.nextToken, outputKey: \ListInputDeviceTransfersOutput.nextToken, paginationFunction: self.listInputDeviceTransfers(input:))
    }
}

extension ListInputDeviceTransfersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputDeviceTransfersInput {
        return ListInputDeviceTransfersInput(
            maxResults: self.maxResults,
            nextToken: token,
            transferType: self.transferType
        )}
}

extension PaginatorSequence where Input == ListInputDeviceTransfersInput, Output == ListInputDeviceTransfersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputDeviceTransfersPaginated`
    /// to access the nested member `[MediaLiveClientTypes.TransferringInputDeviceSummary]`
    /// - Returns: `[MediaLiveClientTypes.TransferringInputDeviceSummary]`
    public func inputDeviceTransfers() async throws -> [MediaLiveClientTypes.TransferringInputDeviceSummary] {
        return try await self.asyncCompactMap { item in item.inputDeviceTransfers }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputsOutput`
    public func listInputsPaginated(input: ListInputsInput) -> ClientRuntime.PaginatorSequence<ListInputsInput, ListInputsOutput> {
        return ClientRuntime.PaginatorSequence<ListInputsInput, ListInputsOutput>(input: input, inputKey: \ListInputsInput.nextToken, outputKey: \ListInputsOutput.nextToken, paginationFunction: self.listInputs(input:))
    }
}

extension ListInputsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputsInput {
        return ListInputsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListInputsInput, Output == ListInputsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.Input]`
    /// - Returns: `[MediaLiveClientTypes.Input]`
    public func inputs() async throws -> [MediaLiveClientTypes.Input] {
        return try await self.asyncCompactMap { item in item.inputs }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListInputSecurityGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInputSecurityGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInputSecurityGroupsOutput`
    public func listInputSecurityGroupsPaginated(input: ListInputSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<ListInputSecurityGroupsInput, ListInputSecurityGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListInputSecurityGroupsInput, ListInputSecurityGroupsOutput>(input: input, inputKey: \ListInputSecurityGroupsInput.nextToken, outputKey: \ListInputSecurityGroupsOutput.nextToken, paginationFunction: self.listInputSecurityGroups(input:))
    }
}

extension ListInputSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInputSecurityGroupsInput {
        return ListInputSecurityGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListInputSecurityGroupsInput, Output == ListInputSecurityGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInputSecurityGroupsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.InputSecurityGroup]`
    /// - Returns: `[MediaLiveClientTypes.InputSecurityGroup]`
    public func inputSecurityGroups() async throws -> [MediaLiveClientTypes.InputSecurityGroup] {
        return try await self.asyncCompactMap { item in item.inputSecurityGroups }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListMultiplexesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMultiplexesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMultiplexesOutput`
    public func listMultiplexesPaginated(input: ListMultiplexesInput) -> ClientRuntime.PaginatorSequence<ListMultiplexesInput, ListMultiplexesOutput> {
        return ClientRuntime.PaginatorSequence<ListMultiplexesInput, ListMultiplexesOutput>(input: input, inputKey: \ListMultiplexesInput.nextToken, outputKey: \ListMultiplexesOutput.nextToken, paginationFunction: self.listMultiplexes(input:))
    }
}

extension ListMultiplexesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMultiplexesInput {
        return ListMultiplexesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListMultiplexesInput, Output == ListMultiplexesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMultiplexesPaginated`
    /// to access the nested member `[MediaLiveClientTypes.MultiplexSummary]`
    /// - Returns: `[MediaLiveClientTypes.MultiplexSummary]`
    public func multiplexes() async throws -> [MediaLiveClientTypes.MultiplexSummary] {
        return try await self.asyncCompactMap { item in item.multiplexes }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListMultiplexProgramsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMultiplexProgramsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMultiplexProgramsOutput`
    public func listMultiplexProgramsPaginated(input: ListMultiplexProgramsInput) -> ClientRuntime.PaginatorSequence<ListMultiplexProgramsInput, ListMultiplexProgramsOutput> {
        return ClientRuntime.PaginatorSequence<ListMultiplexProgramsInput, ListMultiplexProgramsOutput>(input: input, inputKey: \ListMultiplexProgramsInput.nextToken, outputKey: \ListMultiplexProgramsOutput.nextToken, paginationFunction: self.listMultiplexPrograms(input:))
    }
}

extension ListMultiplexProgramsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMultiplexProgramsInput {
        return ListMultiplexProgramsInput(
            maxResults: self.maxResults,
            multiplexId: self.multiplexId,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListMultiplexProgramsInput, Output == ListMultiplexProgramsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMultiplexProgramsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.MultiplexProgramSummary]`
    /// - Returns: `[MediaLiveClientTypes.MultiplexProgramSummary]`
    public func multiplexPrograms() async throws -> [MediaLiveClientTypes.MultiplexProgramSummary] {
        return try await self.asyncCompactMap { item in item.multiplexPrograms }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOfferingsOutput`
    public func listOfferingsPaginated(input: ListOfferingsInput) -> ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput>(input: input, inputKey: \ListOfferingsInput.nextToken, outputKey: \ListOfferingsOutput.nextToken, paginationFunction: self.listOfferings(input:))
    }
}

extension ListOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOfferingsInput {
        return ListOfferingsInput(
            channelClass: self.channelClass,
            channelConfiguration: self.channelConfiguration,
            codec: self.codec,
            duration: self.duration,
            maxResults: self.maxResults,
            maximumBitrate: self.maximumBitrate,
            maximumFramerate: self.maximumFramerate,
            nextToken: token,
            resolution: self.resolution,
            resourceType: self.resourceType,
            specialFeature: self.specialFeature,
            videoQuality: self.videoQuality
        )}
}

extension PaginatorSequence where Input == ListOfferingsInput, Output == ListOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOfferingsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.Offering]`
    /// - Returns: `[MediaLiveClientTypes.Offering]`
    public func offerings() async throws -> [MediaLiveClientTypes.Offering] {
        return try await self.asyncCompactMap { item in item.offerings }
    }
}
extension MediaLiveClient {
    /// Paginate over `[ListReservationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReservationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReservationsOutput`
    public func listReservationsPaginated(input: ListReservationsInput) -> ClientRuntime.PaginatorSequence<ListReservationsInput, ListReservationsOutput> {
        return ClientRuntime.PaginatorSequence<ListReservationsInput, ListReservationsOutput>(input: input, inputKey: \ListReservationsInput.nextToken, outputKey: \ListReservationsOutput.nextToken, paginationFunction: self.listReservations(input:))
    }
}

extension ListReservationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReservationsInput {
        return ListReservationsInput(
            channelClass: self.channelClass,
            codec: self.codec,
            maxResults: self.maxResults,
            maximumBitrate: self.maximumBitrate,
            maximumFramerate: self.maximumFramerate,
            nextToken: token,
            resolution: self.resolution,
            resourceType: self.resourceType,
            specialFeature: self.specialFeature,
            videoQuality: self.videoQuality
        )}
}

extension PaginatorSequence where Input == ListReservationsInput, Output == ListReservationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listReservationsPaginated`
    /// to access the nested member `[MediaLiveClientTypes.Reservation]`
    /// - Returns: `[MediaLiveClientTypes.Reservation]`
    public func reservations() async throws -> [MediaLiveClientTypes.Reservation] {
        return try await self.asyncCompactMap { item in item.reservations }
    }
}
