// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case enabled
        case managedPolicyArns
        case name
        case requireInstanceProperties
        case roleArns
        case sessionPolicy
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let managedPolicyArns = managedPolicyArns {
            var managedPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedPolicyArns)
            for string0 in managedPolicyArns {
                try managedPolicyArnsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireInstanceProperties = self.requireInstanceProperties {
            try encodeContainer.encode(requireInstanceProperties, forKey: .requireInstanceProperties)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for rolearn0 in roleArns {
                try roleArnsContainer.encode(rolearn0)
            }
        }
        if let sessionPolicy = self.sessionPolicy {
            try encodeContainer.encode(sessionPolicy, forKey: .sessionPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profiles"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// The number of seconds the vended session credentials are valid for.
    public var durationSeconds: Swift.Int?
    /// Specifies whether the profile is enabled.
    public var enabled: Swift.Bool?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether instance properties are required in temporary credential requests with this profile.
    public var requireInstanceProperties: Swift.Bool?
    /// A list of IAM roles that this profile can assume in a temporary credential request.
    /// This member is required.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?
    /// The tags to attach to the profile.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        durationSeconds: Swift.Int? = nil,
        enabled: Swift.Bool? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        requireInstanceProperties: Swift.Bool? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.enabled = enabled
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.requireInstanceProperties = requireInstanceProperties
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
        self.tags = tags
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let requireInstanceProperties: Swift.Bool?
    let sessionPolicy: Swift.String?
    let roleArns: [Swift.String]?
    let managedPolicyArns: [Swift.String]?
    let durationSeconds: Swift.Int?
    let enabled: Swift.Bool?
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case enabled
        case managedPolicyArns
        case name
        case requireInstanceProperties
        case roleArns
        case sessionPolicy
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireInstancePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireInstanceProperties)
        requireInstanceProperties = requireInstancePropertiesDecoded
        let sessionPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionPolicy)
        sessionPolicy = sessionPolicyDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let managedPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedPolicyArns)
        var managedPolicyArnsDecoded0:[Swift.String]? = nil
        if let managedPolicyArnsContainer = managedPolicyArnsContainer {
            managedPolicyArnsDecoded0 = [Swift.String]()
            for string0 in managedPolicyArnsContainer {
                if let string0 = string0 {
                    managedPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        managedPolicyArns = managedPolicyArnsDecoded0
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct CreateProfileOutput: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct CreateProfileOutputBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension CreateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum CreateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrustAnchorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case notificationSettings
        case source
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationSettings = notificationSettings {
            var notificationSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationSettings)
            for notificationsetting0 in notificationSettings {
                try notificationSettingsContainer.encode(notificationsetting0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustanchors"
    }
}

public struct CreateTrustAnchorInput: Swift.Equatable {
    /// Specifies whether the trust anchor is enabled.
    public var enabled: Swift.Bool?
    /// The name of the trust anchor.
    /// This member is required.
    public var name: Swift.String?
    /// A list of notification settings to be associated to the trust anchor.
    public var notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
    /// The trust anchor type and its related certificate data.
    /// This member is required.
    public var source: RolesAnywhereClientTypes.Source?
    /// The tags to attach to the trust anchor.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.name = name
        self.notificationSettings = notificationSettings
        self.source = source
        self.tags = tags
    }
}

struct CreateTrustAnchorInputBody: Swift.Equatable {
    let name: Swift.String?
    let source: RolesAnywhereClientTypes.Source?
    let enabled: Swift.Bool?
    let tags: [RolesAnywhereClientTypes.Tag]?
    let notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
}

extension CreateTrustAnchorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case notificationSettings
        case source
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationSettingsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.NotificationSetting?].self, forKey: .notificationSettings)
        var notificationSettingsDecoded0:[RolesAnywhereClientTypes.NotificationSetting]? = nil
        if let notificationSettingsContainer = notificationSettingsContainer {
            notificationSettingsDecoded0 = [RolesAnywhereClientTypes.NotificationSetting]()
            for structure0 in notificationSettingsContainer {
                if let structure0 = structure0 {
                    notificationSettingsDecoded0?.append(structure0)
                }
            }
        }
        notificationSettings = notificationSettingsDecoded0
    }
}

extension CreateTrustAnchorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrustAnchorOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct CreateTrustAnchorOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct CreateTrustAnchorOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension CreateTrustAnchorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum CreateTrustAnchorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RolesAnywhereClientTypes.CredentialSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case failed
        case issuer
        case seenAt
        case serialNumber
        case x509CertificateData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let seenAt = self.seenAt {
            try encodeContainer.encodeTimestamp(seenAt, format: .dateTime, forKey: .seenAt)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let x509CertificateData = self.x509CertificateData {
            try encodeContainer.encode(x509CertificateData, forKey: .x509CertificateData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .seenAt)
        seenAt = seenAtDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let x509CertificateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .x509CertificateData)
        x509CertificateData = x509CertificateDataDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A record of a presented X509 credential from a temporary credential request.
    public struct CredentialSummary: Swift.Equatable {
        /// Indicates whether the credential is enabled.
        public var enabled: Swift.Bool?
        /// Indicates whether the temporary credential request was successful.
        public var failed: Swift.Bool?
        /// The fully qualified domain name of the issuing certificate for the presented end-entity certificate.
        public var issuer: Swift.String?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var seenAt: ClientRuntime.Date?
        /// The serial number of the certificate.
        public var serialNumber: Swift.String?
        /// The PEM-encoded data of the certificate.
        public var x509CertificateData: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            failed: Swift.Bool? = nil,
            issuer: Swift.String? = nil,
            seenAt: ClientRuntime.Date? = nil,
            serialNumber: Swift.String? = nil,
            x509CertificateData: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.failed = failed
            self.issuer = issuer
            self.seenAt = seenAt
            self.serialNumber = serialNumber
            self.x509CertificateData = x509CertificateData
        }
    }

}

extension RolesAnywhereClientTypes.CrlDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case crlArn
        case crlData
        case crlId
        case enabled
        case name
        case trustAnchorArn
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let crlArn = self.crlArn {
            try encodeContainer.encode(crlArn, forKey: .crlArn)
        }
        if let crlData = self.crlData {
            try encodeContainer.encode(crlData.base64EncodedString(), forKey: .crlData)
        }
        if let crlId = self.crlId {
            try encodeContainer.encode(crlId, forKey: .crlId)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trustAnchorArn = self.trustAnchorArn {
            try encodeContainer.encode(trustAnchorArn, forKey: .trustAnchorArn)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crlId)
        crlId = crlIdDecoded
        let crlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crlArn)
        crlArn = crlArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let crlDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .crlData)
        crlData = crlDataDecoded
        let trustAnchorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorArn)
        trustAnchorArn = trustAnchorArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    public struct CrlDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was created.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the certificate revocation list (CRL).
        public var crlArn: Swift.String?
        /// The state of the certificate revocation list (CRL) after a read or write operation.
        public var crlData: ClientRuntime.Data?
        /// The unique identifier of the certificate revocation list (CRL).
        public var crlId: Swift.String?
        /// Indicates whether the certificate revocation list (CRL) is enabled.
        public var enabled: Swift.Bool?
        /// The name of the certificate revocation list (CRL).
        public var name: Swift.String?
        /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
        public var trustAnchorArn: Swift.String?
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            crlArn: Swift.String? = nil,
            crlData: ClientRuntime.Data? = nil,
            crlId: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            trustAnchorArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.crlArn = crlArn
            self.crlData = crlData
            self.crlId = crlId
            self.enabled = enabled
            self.name = name
            self.trustAnchorArn = trustAnchorArn
            self.updatedAt = updatedAt
        }
    }

}

extension DeleteCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct DeleteCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct DeleteCrlInputBody: Swift.Equatable {
}

extension DeleteCrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct DeleteCrlOutput: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct DeleteCrlOutputBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension DeleteCrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

enum DeleteCrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
}

extension DeleteProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct DeleteProfileOutput: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct DeleteProfileOutputBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension DeleteProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum DeleteProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct DeleteTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct DeleteTrustAnchorInputBody: Swift.Equatable {
}

extension DeleteTrustAnchorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrustAnchorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTrustAnchorOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct DeleteTrustAnchorOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct DeleteTrustAnchorOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension DeleteTrustAnchorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum DeleteTrustAnchorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/disable"
    }
}

public struct DisableCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct DisableCrlInputBody: Swift.Equatable {
}

extension DisableCrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableCrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableCrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct DisableCrlOutput: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct DisableCrlOutputBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension DisableCrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

enum DisableCrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/disable"
    }
}

public struct DisableProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DisableProfileInputBody: Swift.Equatable {
}

extension DisableProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct DisableProfileOutput: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct DisableProfileOutputBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension DisableProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum DisableProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/disable"
    }
}

public struct DisableTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct DisableTrustAnchorInputBody: Swift.Equatable {
}

extension DisableTrustAnchorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableTrustAnchorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableTrustAnchorOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct DisableTrustAnchorOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct DisableTrustAnchorOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension DisableTrustAnchorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum DisableTrustAnchorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/enable"
    }
}

public struct EnableCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct EnableCrlInputBody: Swift.Equatable {
}

extension EnableCrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableCrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableCrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct EnableCrlOutput: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct EnableCrlOutputBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension EnableCrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

enum EnableCrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/enable"
    }
}

public struct EnableProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct EnableProfileInputBody: Swift.Equatable {
}

extension EnableProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct EnableProfileOutput: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct EnableProfileOutputBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension EnableProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum EnableProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/enable"
    }
}

public struct EnableTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct EnableTrustAnchorInputBody: Swift.Equatable {
}

extension EnableTrustAnchorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableTrustAnchorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableTrustAnchorOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct EnableTrustAnchorOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct EnableTrustAnchorOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension EnableTrustAnchorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum EnableTrustAnchorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct GetCrlInput: Swift.Equatable {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

struct GetCrlInputBody: Swift.Equatable {
}

extension GetCrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct GetCrlOutput: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct GetCrlOutputBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension GetCrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

enum GetCrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct GetProfileInput: Swift.Equatable {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct GetProfileInputBody: Swift.Equatable {
}

extension GetProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct GetProfileOutput: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct GetProfileOutputBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension GetProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum GetProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subjectId = subjectId else {
            return nil
        }
        return "/subject/\(subjectId.urlPercentEncoding())"
    }
}

public struct GetSubjectInput: Swift.Equatable {
    /// The unique identifier of the subject.
    /// This member is required.
    public var subjectId: Swift.String?

    public init(
        subjectId: Swift.String? = nil
    )
    {
        self.subjectId = subjectId
    }
}

struct GetSubjectInputBody: Swift.Equatable {
}

extension GetSubjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.subject = output.subject
        } else {
            self.subject = nil
        }
    }
}

public struct GetSubjectOutput: Swift.Equatable {
    /// The state of the subject after a read or write operation.
    public var subject: RolesAnywhereClientTypes.SubjectDetail?

    public init(
        subject: RolesAnywhereClientTypes.SubjectDetail? = nil
    )
    {
        self.subject = subject
    }
}

struct GetSubjectOutputBody: Swift.Equatable {
    let subject: RolesAnywhereClientTypes.SubjectDetail?
}

extension GetSubjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subject
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.SubjectDetail.self, forKey: .subject)
        subject = subjectDecoded
    }
}

enum GetSubjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct GetTrustAnchorInput: Swift.Equatable {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

struct GetTrustAnchorInputBody: Swift.Equatable {
}

extension GetTrustAnchorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustAnchorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrustAnchorOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct GetTrustAnchorOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct GetTrustAnchorOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension GetTrustAnchorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum GetTrustAnchorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportCrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case enabled
        case name
        case tags
        case trustAnchorArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crlData = self.crlData {
            try encodeContainer.encode(crlData.base64EncodedString(), forKey: .crlData)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trustAnchorArn = self.trustAnchorArn {
            try encodeContainer.encode(trustAnchorArn, forKey: .trustAnchorArn)
        }
    }
}

extension ImportCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crls"
    }
}

public struct ImportCrlInput: Swift.Equatable {
    /// The x509 v3 specified certificate revocation list (CRL).
    /// This member is required.
    public var crlData: ClientRuntime.Data?
    /// Specifies whether the certificate revocation list (CRL) is enabled.
    public var enabled: Swift.Bool?
    /// The name of the certificate revocation list (CRL).
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags to attach to the certificate revocation list (CRL).
    public var tags: [RolesAnywhereClientTypes.Tag]?
    /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
    /// This member is required.
    public var trustAnchorArn: Swift.String?

    public init(
        crlData: ClientRuntime.Data? = nil,
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil,
        trustAnchorArn: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.enabled = enabled
        self.name = name
        self.tags = tags
        self.trustAnchorArn = trustAnchorArn
    }
}

struct ImportCrlInputBody: Swift.Equatable {
    let name: Swift.String?
    let crlData: ClientRuntime.Data?
    let enabled: Swift.Bool?
    let tags: [RolesAnywhereClientTypes.Tag]?
    let trustAnchorArn: Swift.String?
}

extension ImportCrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case enabled
        case name
        case tags
        case trustAnchorArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let crlDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .crlData)
        crlData = crlDataDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let trustAnchorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorArn)
        trustAnchorArn = trustAnchorArnDecoded
    }
}

extension ImportCrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportCrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct ImportCrlOutput: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct ImportCrlOutputBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension ImportCrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

enum ImportCrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RolesAnywhereClientTypes.InstanceProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
        case properties
        case seenAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, instancePropertyMap0) in properties {
                try propertiesContainer.encode(instancePropertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let seenAt = self.seenAt {
            try encodeContainer.encodeTimestamp(seenAt, format: .dateTime, forKey: .seenAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .seenAt)
        seenAt = seenAtDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in propertiesContainer {
                if let string0 = string0 {
                    propertiesDecoded0?[key0] = string0
                }
            }
        }
        properties = propertiesDecoded0
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A key-value pair you set that identifies a property of the authenticating instance.
    public struct InstanceProperty: Swift.Equatable {
        /// Indicates whether the temporary credential request was successful.
        public var failed: Swift.Bool?
        /// A list of instanceProperty objects.
        public var properties: [Swift.String:Swift.String]?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var seenAt: ClientRuntime.Date?

        public init(
            failed: Swift.Bool? = nil,
            properties: [Swift.String:Swift.String]? = nil,
            seenAt: ClientRuntime.Date? = nil
        )
        {
            self.failed = failed
            self.properties = properties
            self.seenAt = seenAt
        }
    }

}

extension ListCrlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListCrlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crls"
    }
}

public struct ListCrlsInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListCrlsInputBody: Swift.Equatable {
}

extension ListCrlsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCrlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCrlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.crls = output.crls
            self.nextToken = output.nextToken
        } else {
            self.crls = nil
            self.nextToken = nil
        }
    }
}

public struct ListCrlsOutput: Swift.Equatable {
    /// A list of certificate revocation lists (CRL).
    public var crls: [RolesAnywhereClientTypes.CrlDetail]?
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?

    public init(
        crls: [RolesAnywhereClientTypes.CrlDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crls = crls
        self.nextToken = nextToken
    }
}

struct ListCrlsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let crls: [RolesAnywhereClientTypes.CrlDetail]?
}

extension ListCrlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crls
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let crlsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.CrlDetail?].self, forKey: .crls)
        var crlsDecoded0:[RolesAnywhereClientTypes.CrlDetail]? = nil
        if let crlsContainer = crlsContainer {
            crlsDecoded0 = [RolesAnywhereClientTypes.CrlDetail]()
            for structure0 in crlsContainer {
                if let structure0 = structure0 {
                    crlsDecoded0?.append(structure0)
                }
            }
        }
        crls = crlsDecoded0
    }
}

enum ListCrlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profiles"
    }
}

public struct ListProfilesInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListProfilesInputBody: Swift.Equatable {
}

extension ListProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListProfilesOutput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of profiles.
    public var profiles: [RolesAnywhereClientTypes.ProfileDetail]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [RolesAnywhereClientTypes.ProfileDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListProfilesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let profiles: [RolesAnywhereClientTypes.ProfileDetail]?
}

extension ListProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profilesContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.ProfileDetail?].self, forKey: .profiles)
        var profilesDecoded0:[RolesAnywhereClientTypes.ProfileDetail]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [RolesAnywhereClientTypes.ProfileDetail]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
    }
}

enum ListProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListSubjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subjects"
    }
}

public struct ListSubjectsInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListSubjectsInputBody: Swift.Equatable {
}

extension ListSubjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subjects = output.subjects
        } else {
            self.nextToken = nil
            self.subjects = nil
        }
    }
}

public struct ListSubjectsOutput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of subjects.
    public var subjects: [RolesAnywhereClientTypes.SubjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        subjects: [RolesAnywhereClientTypes.SubjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.subjects = subjects
    }
}

struct ListSubjectsOutputBody: Swift.Equatable {
    let subjects: [RolesAnywhereClientTypes.SubjectSummary]?
    let nextToken: Swift.String?
}

extension ListSubjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case subjects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.SubjectSummary?].self, forKey: .subjects)
        var subjectsDecoded0:[RolesAnywhereClientTypes.SubjectSummary]? = nil
        if let subjectsContainer = subjectsContainer {
            subjectsDecoded0 = [RolesAnywhereClientTypes.SubjectSummary]()
            for structure0 in subjectsContainer {
                if let structure0 = structure0 {
                    subjectsDecoded0?.append(structure0)
                }
            }
        }
        subjects = subjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags attached to the resource.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrustAnchorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListTrustAnchorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/trustanchors"
    }
}

public struct ListTrustAnchorsInput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListTrustAnchorsInputBody: Swift.Equatable {
}

extension ListTrustAnchorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustAnchorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrustAnchorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustAnchors = output.trustAnchors
        } else {
            self.nextToken = nil
            self.trustAnchors = nil
        }
    }
}

public struct ListTrustAnchorsOutput: Swift.Equatable {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of trust anchors.
    public var trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]?

    public init(
        nextToken: Swift.String? = nil,
        trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustAnchors = trustAnchors
    }
}

struct ListTrustAnchorsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]?
}

extension ListTrustAnchorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trustAnchors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.TrustAnchorDetail?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[RolesAnywhereClientTypes.TrustAnchorDetail]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [RolesAnywhereClientTypes.TrustAnchorDetail]()
            for structure0 in trustAnchorsContainer {
                if let structure0 = structure0 {
                    trustAnchorsDecoded0?.append(structure0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

enum ListTrustAnchorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RolesAnywhereClientTypes {
    public enum NotificationChannel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationChannel] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationChannel(rawValue: rawValue) ?? NotificationChannel.sdkUnknown(rawValue)
        }
    }
}

extension RolesAnywhereClientTypes {
    public enum NotificationEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case caCertificateExpiry
        case endEntityCertificateExpiry
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationEvent] {
            return [
                .caCertificateExpiry,
                .endEntityCertificateExpiry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .caCertificateExpiry: return "CA_CERTIFICATE_EXPIRY"
            case .endEntityCertificateExpiry: return "END_ENTITY_CERTIFICATE_EXPIRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationEvent(rawValue: rawValue) ?? NotificationEvent.sdkUnknown(rawValue)
        }
    }
}

extension RolesAnywhereClientTypes.NotificationSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case enabled
        case event
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.NotificationEvent.self, forKey: .event)
        event = eventDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .threshold)
        threshold = thresholdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.NotificationChannel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// Customizable notification settings that will be applied to notification events. IAM Roles Anywhere consumes these settings while notifying across multiple channels - CloudWatch metrics, EventBridge, and Health Dashboard.
    public struct NotificationSetting: Swift.Equatable {
        /// The specified channel of notification. IAM Roles Anywhere uses CloudWatch metrics, EventBridge, and Health Dashboard to notify for an event. In the absence of a specific channel, IAM Roles Anywhere applies this setting to 'ALL' channels.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// Indicates whether the notification setting is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The event to which this notification setting is applied.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?
        /// The number of days before a notification event. This value is required for a notification setting that is enabled.
        public var threshold: Swift.Int?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            enabled: Swift.Bool? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.channel = channel
            self.enabled = enabled
            self.event = event
            self.threshold = threshold
        }
    }

}

extension RolesAnywhereClientTypes.NotificationSettingDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case configuredBy
        case enabled
        case event
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let configuredBy = self.configuredBy {
            try encodeContainer.encode(configuredBy, forKey: .configuredBy)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.NotificationEvent.self, forKey: .event)
        event = eventDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .threshold)
        threshold = thresholdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.NotificationChannel.self, forKey: .channel)
        channel = channelDecoded
        let configuredByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredBy)
        configuredBy = configuredByDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The state of a notification setting. A notification setting includes information such as event name, threshold, status of the notification setting, and the channel to notify.
    public struct NotificationSettingDetail: Swift.Equatable {
        /// The specified channel of notification. IAM Roles Anywhere uses CloudWatch metrics, EventBridge, and Health Dashboard to notify for an event. In the absence of a specific channel, IAM Roles Anywhere applies this setting to 'ALL' channels.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// The principal that configured the notification setting. For default settings configured by IAM Roles Anywhere, the value is rolesanywhere.amazonaws.com, and for customized notifications settings, it is the respective account ID.
        public var configuredBy: Swift.String?
        /// Indicates whether the notification setting is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The event to which this notification setting is applied.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?
        /// The number of days before a notification event.
        public var threshold: Swift.Int?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            configuredBy: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.channel = channel
            self.configuredBy = configuredBy
            self.enabled = enabled
            self.event = event
            self.threshold = threshold
        }
    }

}

extension RolesAnywhereClientTypes.NotificationSettingKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case event
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.NotificationEvent.self, forKey: .event)
        event = eventDecoded
        let channelDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.NotificationChannel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A notification setting key to reset. A notification setting key includes the event and the channel.
    public struct NotificationSettingKey: Swift.Equatable {
        /// The specified channel of notification.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// The notification setting event to reset.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil
        )
        {
            self.channel = channel
            self.event = event
        }
    }

}

extension RolesAnywhereClientTypes.ProfileDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case durationSeconds
        case enabled
        case managedPolicyArns
        case name
        case profileArn
        case profileId
        case requireInstanceProperties
        case roleArns
        case sessionPolicy
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let managedPolicyArns = managedPolicyArns {
            var managedPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedPolicyArns)
            for string0 in managedPolicyArns {
                try managedPolicyArnsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let requireInstanceProperties = self.requireInstanceProperties {
            try encodeContainer.encode(requireInstanceProperties, forKey: .requireInstanceProperties)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for rolearn0 in roleArns {
                try roleArnsContainer.encode(rolearn0)
            }
        }
        if let sessionPolicy = self.sessionPolicy {
            try encodeContainer.encode(sessionPolicy, forKey: .sessionPolicy)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireInstancePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireInstanceProperties)
        requireInstanceProperties = requireInstancePropertiesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let sessionPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionPolicy)
        sessionPolicy = sessionPolicyDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let managedPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedPolicyArns)
        var managedPolicyArnsDecoded0:[Swift.String]? = nil
        if let managedPolicyArnsContainer = managedPolicyArnsContainer {
            managedPolicyArnsDecoded0 = [Swift.String]()
            for string0 in managedPolicyArnsContainer {
                if let string0 = string0 {
                    managedPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        managedPolicyArns = managedPolicyArnsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the profile after a read or write operation.
    public struct ProfileDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Web Services account that created the profile.
        public var createdBy: Swift.String?
        /// The number of seconds the vended session credentials are valid for.
        public var durationSeconds: Swift.Int?
        /// Indicates whether the profile is enabled.
        public var enabled: Swift.Bool?
        /// A list of managed policy ARNs that apply to the vended session credentials.
        public var managedPolicyArns: [Swift.String]?
        /// The name of the profile.
        public var name: Swift.String?
        /// The ARN of the profile.
        public var profileArn: Swift.String?
        /// The unique identifier of the profile.
        public var profileId: Swift.String?
        /// Specifies whether instance properties are required in temporary credential requests with this profile.
        public var requireInstanceProperties: Swift.Bool?
        /// A list of IAM roles that this profile can assume in a temporary credential request.
        public var roleArns: [Swift.String]?
        /// A session policy that applies to the trust boundary of the vended session credentials.
        public var sessionPolicy: Swift.String?
        /// The ISO-8601 timestamp when the profile was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            durationSeconds: Swift.Int? = nil,
            enabled: Swift.Bool? = nil,
            managedPolicyArns: [Swift.String]? = nil,
            name: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileId: Swift.String? = nil,
            requireInstanceProperties: Swift.Bool? = nil,
            roleArns: [Swift.String]? = nil,
            sessionPolicy: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.durationSeconds = durationSeconds
            self.enabled = enabled
            self.managedPolicyArns = managedPolicyArns
            self.name = name
            self.profileArn = profileArn
            self.profileId = profileId
            self.requireInstanceProperties = requireInstanceProperties
            self.roleArns = roleArns
            self.sessionPolicy = sessionPolicy
            self.updatedAt = updatedAt
        }
    }

}

extension PutNotificationSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSettings
        case trustAnchorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationSettings = notificationSettings {
            var notificationSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationSettings)
            for notificationsetting0 in notificationSettings {
                try notificationSettingsContainer.encode(notificationsetting0)
            }
        }
        if let trustAnchorId = self.trustAnchorId {
            try encodeContainer.encode(trustAnchorId, forKey: .trustAnchorId)
        }
    }
}

extension PutNotificationSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-notifications-settings"
    }
}

public struct PutNotificationSettingsInput: Swift.Equatable {
    /// A list of notification settings to be associated to the trust anchor.
    /// This member is required.
    public var notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.notificationSettings = notificationSettings
        self.trustAnchorId = trustAnchorId
    }
}

struct PutNotificationSettingsInputBody: Swift.Equatable {
    let trustAnchorId: Swift.String?
    let notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
}

extension PutNotificationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSettings
        case trustAnchorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorId)
        trustAnchorId = trustAnchorIdDecoded
        let notificationSettingsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.NotificationSetting?].self, forKey: .notificationSettings)
        var notificationSettingsDecoded0:[RolesAnywhereClientTypes.NotificationSetting]? = nil
        if let notificationSettingsContainer = notificationSettingsContainer {
            notificationSettingsDecoded0 = [RolesAnywhereClientTypes.NotificationSetting]()
            for structure0 in notificationSettingsContainer {
                if let structure0 = structure0 {
                    notificationSettingsDecoded0?.append(structure0)
                }
            }
        }
        notificationSettings = notificationSettingsDecoded0
    }
}

extension PutNotificationSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutNotificationSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct PutNotificationSettingsOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct PutNotificationSettingsOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension PutNotificationSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum PutNotificationSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResetNotificationSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSettingKeys
        case trustAnchorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationSettingKeys = notificationSettingKeys {
            var notificationSettingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationSettingKeys)
            for notificationsettingkey0 in notificationSettingKeys {
                try notificationSettingKeysContainer.encode(notificationsettingkey0)
            }
        }
        if let trustAnchorId = self.trustAnchorId {
            try encodeContainer.encode(trustAnchorId, forKey: .trustAnchorId)
        }
    }
}

extension ResetNotificationSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reset-notifications-settings"
    }
}

public struct ResetNotificationSettingsInput: Swift.Equatable {
    /// A list of notification setting keys to reset. A notification setting key includes the event and the channel.
    /// This member is required.
    public var notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.notificationSettingKeys = notificationSettingKeys
        self.trustAnchorId = trustAnchorId
    }
}

struct ResetNotificationSettingsInputBody: Swift.Equatable {
    let trustAnchorId: Swift.String?
    let notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]?
}

extension ResetNotificationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSettingKeys
        case trustAnchorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorId)
        trustAnchorId = trustAnchorIdDecoded
        let notificationSettingKeysContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.NotificationSettingKey?].self, forKey: .notificationSettingKeys)
        var notificationSettingKeysDecoded0:[RolesAnywhereClientTypes.NotificationSettingKey]? = nil
        if let notificationSettingKeysContainer = notificationSettingKeysContainer {
            notificationSettingKeysDecoded0 = [RolesAnywhereClientTypes.NotificationSettingKey]()
            for structure0 in notificationSettingKeysContainer {
                if let structure0 = structure0 {
                    notificationSettingKeysDecoded0?.append(structure0)
                }
            }
        }
        notificationSettingKeys = notificationSettingKeysDecoded0
    }
}

extension ResetNotificationSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetNotificationSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct ResetNotificationSettingsOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct ResetNotificationSettingsOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension ResetNotificationSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum ResetNotificationSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RolesAnywhereClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceData
        case sourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceData = self.sourceData {
            try encodeContainer.encode(sourceData, forKey: .sourceData)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceDataDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.SourceData.self, forKey: .sourceData)
        sourceData = sourceDataDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// The trust anchor type and its related certificate data.
    public struct Source: Swift.Equatable {
        /// The data field of the trust anchor depending on its type.
        public var sourceData: RolesAnywhereClientTypes.SourceData?
        /// The type of the trust anchor.
        public var sourceType: RolesAnywhereClientTypes.TrustAnchorType?

        public init(
            sourceData: RolesAnywhereClientTypes.SourceData? = nil,
            sourceType: RolesAnywhereClientTypes.TrustAnchorType? = nil
        )
        {
            self.sourceData = sourceData
            self.sourceType = sourceType
        }
    }

}

extension RolesAnywhereClientTypes.SourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmpcaarn = "acmPcaArn"
        case sdkUnknown
        case x509certificatedata = "x509CertificateData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acmpcaarn(acmpcaarn):
                try container.encode(acmpcaarn, forKey: .acmpcaarn)
            case let .x509certificatedata(x509certificatedata):
                try container.encode(x509certificatedata, forKey: .x509certificatedata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let x509certificatedataDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .x509certificatedata)
        if let x509certificatedata = x509certificatedataDecoded {
            self = .x509certificatedata(x509certificatedata)
            return
        }
        let acmpcaarnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .acmpcaarn)
        if let acmpcaarn = acmpcaarnDecoded {
            self = .acmpcaarn(acmpcaarn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RolesAnywhereClientTypes {
    /// The data field of the trust anchor depending on its type.
    public enum SourceData: Swift.Equatable {
        /// The PEM-encoded data for the certificate anchor. Included for trust anchors of type CERTIFICATE_BUNDLE.
        case x509certificatedata(Swift.String)
        /// The root certificate of the Private Certificate Authority specified by this ARN is used in trust validation for temporary credential requests. Included for trust anchors of type AWS_ACM_PCA.
        case acmpcaarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension RolesAnywhereClientTypes.SubjectDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case credentials
        case enabled
        case instanceProperties
        case lastSeenAt
        case subjectArn
        case subjectId
        case updatedAt
        case x509Subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credentialsummary0 in credentials {
                try credentialsContainer.encode(credentialsummary0)
            }
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let instanceProperties = instanceProperties {
            var instancePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceProperties)
            for instanceproperty0 in instanceProperties {
                try instancePropertiesContainer.encode(instanceproperty0)
            }
        }
        if let lastSeenAt = self.lastSeenAt {
            try encodeContainer.encodeTimestamp(lastSeenAt, format: .dateTime, forKey: .lastSeenAt)
        }
        if let subjectArn = self.subjectArn {
            try encodeContainer.encode(subjectArn, forKey: .subjectArn)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let x509Subject = self.x509Subject {
            try encodeContainer.encode(x509Subject, forKey: .x509Subject)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectArn)
        subjectArn = subjectArnDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let x509SubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .x509Subject)
        x509Subject = x509SubjectDecoded
        let lastSeenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastSeenAt)
        lastSeenAt = lastSeenAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let credentialsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.CredentialSummary?].self, forKey: .credentials)
        var credentialsDecoded0:[RolesAnywhereClientTypes.CredentialSummary]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [RolesAnywhereClientTypes.CredentialSummary]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
        let instancePropertiesContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.InstanceProperty?].self, forKey: .instanceProperties)
        var instancePropertiesDecoded0:[RolesAnywhereClientTypes.InstanceProperty]? = nil
        if let instancePropertiesContainer = instancePropertiesContainer {
            instancePropertiesDecoded0 = [RolesAnywhereClientTypes.InstanceProperty]()
            for structure0 in instancePropertiesContainer {
                if let structure0 = structure0 {
                    instancePropertiesDecoded0?.append(structure0)
                }
            }
        }
        instanceProperties = instancePropertiesDecoded0
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the subject after a read or write operation.
    public struct SubjectDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the subject was created.
        public var createdAt: ClientRuntime.Date?
        /// The temporary session credentials vended at the last authenticating call with this subject.
        public var credentials: [RolesAnywhereClientTypes.CredentialSummary]?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The specified instance properties associated with the request.
        public var instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]?
        /// The ISO-8601 timestamp of the last time this subject requested temporary session credentials.
        public var lastSeenAt: ClientRuntime.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            credentials: [RolesAnywhereClientTypes.CredentialSummary]? = nil,
            enabled: Swift.Bool? = nil,
            instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]? = nil,
            lastSeenAt: ClientRuntime.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.credentials = credentials
            self.enabled = enabled
            self.instanceProperties = instanceProperties
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

extension RolesAnywhereClientTypes.SubjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case enabled
        case lastSeenAt
        case subjectArn
        case subjectId
        case updatedAt
        case x509Subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let lastSeenAt = self.lastSeenAt {
            try encodeContainer.encodeTimestamp(lastSeenAt, format: .dateTime, forKey: .lastSeenAt)
        }
        if let subjectArn = self.subjectArn {
            try encodeContainer.encode(subjectArn, forKey: .subjectArn)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let x509Subject = self.x509Subject {
            try encodeContainer.encode(x509Subject, forKey: .x509Subject)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectArn)
        subjectArn = subjectArnDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let x509SubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .x509Subject)
        x509Subject = x509SubjectDecoded
        let lastSeenAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastSeenAt)
        lastSeenAt = lastSeenAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension RolesAnywhereClientTypes {
    /// A summary representation of subjects.
    public struct SubjectSummary: Swift.Equatable {
        /// The ISO-8601 time stamp of when the certificate was first used in a temporary credential request.
        public var createdAt: ClientRuntime.Date?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var lastSeenAt: ClientRuntime.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource.
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            lastSeenAt: ClientRuntime.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

extension RolesAnywhereClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RolesAnywhereClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension RolesAnywhereClientTypes {
    /// A label that consists of a key and value you define.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to attach to the resource.
    /// This member is required.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [RolesAnywhereClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RolesAnywhereClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RolesAnywhereClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Too many tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RolesAnywhereClientTypes.TrustAnchorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case enabled
        case name
        case notificationSettings
        case source
        case trustAnchorArn
        case trustAnchorId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationSettings = notificationSettings {
            var notificationSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationSettings)
            for notificationsettingdetail0 in notificationSettings {
                try notificationSettingsContainer.encode(notificationsettingdetail0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let trustAnchorArn = self.trustAnchorArn {
            try encodeContainer.encode(trustAnchorArn, forKey: .trustAnchorArn)
        }
        if let trustAnchorId = self.trustAnchorId {
            try encodeContainer.encode(trustAnchorId, forKey: .trustAnchorId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorId)
        trustAnchorId = trustAnchorIdDecoded
        let trustAnchorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustAnchorArn)
        trustAnchorArn = trustAnchorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let notificationSettingsContainer = try containerValues.decodeIfPresent([RolesAnywhereClientTypes.NotificationSettingDetail?].self, forKey: .notificationSettings)
        var notificationSettingsDecoded0:[RolesAnywhereClientTypes.NotificationSettingDetail]? = nil
        if let notificationSettingsContainer = notificationSettingsContainer {
            notificationSettingsDecoded0 = [RolesAnywhereClientTypes.NotificationSettingDetail]()
            for structure0 in notificationSettingsContainer {
                if let structure0 = structure0 {
                    notificationSettingsDecoded0?.append(structure0)
                }
            }
        }
        notificationSettings = notificationSettingsDecoded0
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the trust anchor after a read or write operation.
    public struct TrustAnchorDetail: Swift.Equatable {
        /// The ISO-8601 timestamp when the trust anchor was created.
        public var createdAt: ClientRuntime.Date?
        /// Indicates whether the trust anchor is enabled.
        public var enabled: Swift.Bool?
        /// The name of the trust anchor.
        public var name: Swift.String?
        /// A list of notification settings to be associated to the trust anchor.
        public var notificationSettings: [RolesAnywhereClientTypes.NotificationSettingDetail]?
        /// The trust anchor type and its related certificate data.
        public var source: RolesAnywhereClientTypes.Source?
        /// The ARN of the trust anchor.
        public var trustAnchorArn: Swift.String?
        /// The unique identifier of the trust anchor.
        public var trustAnchorId: Swift.String?
        /// The ISO-8601 timestamp when the trust anchor was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            notificationSettings: [RolesAnywhereClientTypes.NotificationSettingDetail]? = nil,
            source: RolesAnywhereClientTypes.Source? = nil,
            trustAnchorArn: Swift.String? = nil,
            trustAnchorId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.name = name
            self.notificationSettings = notificationSettings
            self.source = source
            self.trustAnchorArn = trustAnchorArn
            self.trustAnchorId = trustAnchorId
            self.updatedAt = updatedAt
        }
    }

}

extension RolesAnywhereClientTypes {
    public enum TrustAnchorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAcmPca
        case certificateBundle
        case selfSignedRepository
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustAnchorType] {
            return [
                .awsAcmPca,
                .certificateBundle,
                .selfSignedRepository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAcmPca: return "AWS_ACM_PCA"
            case .certificateBundle: return "CERTIFICATE_BUNDLE"
            case .selfSignedRepository: return "SELF_SIGNED_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustAnchorType(rawValue: rawValue) ?? TrustAnchorType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys. Tag keys are the unique identifiers of tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crlData = self.crlData {
            try encodeContainer.encode(crlData.base64EncodedString(), forKey: .crlData)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crlId = crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct UpdateCrlInput: Swift.Equatable {
    /// The x509 v3 specified certificate revocation list (CRL).
    public var crlData: ClientRuntime.Data?
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?
    /// The name of the Crl.
    public var name: Swift.String?

    public init(
        crlData: ClientRuntime.Data? = nil,
        crlId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.crlId = crlId
        self.name = name
    }
}

struct UpdateCrlInputBody: Swift.Equatable {
    let name: Swift.String?
    let crlData: ClientRuntime.Data?
}

extension UpdateCrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlData
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let crlDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .crlData)
        crlData = crlDataDecoded
    }
}

extension UpdateCrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.crl = output.crl
        } else {
            self.crl = nil
        }
    }
}

public struct UpdateCrlOutput: Swift.Equatable {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

struct UpdateCrlOutputBody: Swift.Equatable {
    let crl: RolesAnywhereClientTypes.CrlDetail?
}

extension UpdateCrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.CrlDetail.self, forKey: .crl)
        crl = crlDecoded
    }
}

enum UpdateCrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case managedPolicyArns
        case name
        case roleArns
        case sessionPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let managedPolicyArns = managedPolicyArns {
            var managedPolicyArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedPolicyArns)
            for string0 in managedPolicyArns {
                try managedPolicyArnsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for rolearn0 in roleArns {
                try roleArnsContainer.encode(rolearn0)
            }
        }
        if let sessionPolicy = self.sessionPolicy {
            try encodeContainer.encode(sessionPolicy, forKey: .sessionPolicy)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileId = profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// The number of seconds the vended session credentials are valid for.
    public var durationSeconds: Swift.Int?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    public var name: Swift.String?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of IAM roles that this profile can assume in a temporary credential request.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?

    public init(
        durationSeconds: Swift.Int? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        profileId: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.profileId = profileId
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let sessionPolicy: Swift.String?
    let roleArns: [Swift.String]?
    let managedPolicyArns: [Swift.String]?
    let durationSeconds: Swift.Int?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds
        case managedPolicyArns
        case name
        case roleArns
        case sessionPolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sessionPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionPolicy)
        sessionPolicy = sessionPolicyDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let managedPolicyArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managedPolicyArns)
        var managedPolicyArnsDecoded0:[Swift.String]? = nil
        if let managedPolicyArnsContainer = managedPolicyArnsContainer {
            managedPolicyArnsDecoded0 = [Swift.String]()
            for string0 in managedPolicyArnsContainer {
                if let string0 = string0 {
                    managedPolicyArnsDecoded0?.append(string0)
                }
            }
        }
        managedPolicyArns = managedPolicyArnsDecoded0
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension UpdateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct UpdateProfileOutput: Swift.Equatable {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

struct UpdateProfileOutputBody: Swift.Equatable {
    let profile: RolesAnywhereClientTypes.ProfileDetail?
}

extension UpdateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.ProfileDetail.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum UpdateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrustAnchorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension UpdateTrustAnchorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trustAnchorId = trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct UpdateTrustAnchorInput: Swift.Equatable {
    /// The name of the trust anchor.
    public var name: Swift.String?
    /// The trust anchor type and its related certificate data.
    public var source: RolesAnywhereClientTypes.Source?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.name = name
        self.source = source
        self.trustAnchorId = trustAnchorId
    }
}

struct UpdateTrustAnchorInputBody: Swift.Equatable {
    let name: Swift.String?
    let source: RolesAnywhereClientTypes.Source?
}

extension UpdateTrustAnchorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case source
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
    }
}

extension UpdateTrustAnchorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTrustAnchorOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustAnchor = output.trustAnchor
        } else {
            self.trustAnchor = nil
        }
    }
}

public struct UpdateTrustAnchorOutput: Swift.Equatable {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

struct UpdateTrustAnchorOutputBody: Swift.Equatable {
    let trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?
}

extension UpdateTrustAnchorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustAnchor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustAnchorDecoded = try containerValues.decodeIfPresent(RolesAnywhereClientTypes.TrustAnchorDetail.self, forKey: .trustAnchor)
        trustAnchor = trustAnchorDecoded
    }
}

enum UpdateTrustAnchorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Validation exception error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
