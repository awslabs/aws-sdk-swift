// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RolesAnywhereClientTypes.AttributeMapping {

    static func write(value: RolesAnywhereClientTypes.AttributeMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateField"].write(value.certificateField)
        try writer["mappingRules"].writeList(value.mappingRules, memberWritingClosure: RolesAnywhereClientTypes.MappingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.AttributeMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.AttributeMapping()
        value.certificateField = try reader["certificateField"].readIfPresent()
        value.mappingRules = try reader["mappingRules"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.MappingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A mapping applied to the authenticating end-entity certificate.
    public struct AttributeMapping {
        /// Fields (x509Subject, x509Issuer and x509SAN) within X.509 certificates.
        public var certificateField: RolesAnywhereClientTypes.CertificateField?
        /// A list of mapping entries for every supported specifier or sub-field.
        public var mappingRules: [RolesAnywhereClientTypes.MappingRule]?

        public init(
            certificateField: RolesAnywhereClientTypes.CertificateField? = nil,
            mappingRules: [RolesAnywhereClientTypes.MappingRule]? = nil
        )
        {
            self.certificateField = certificateField
            self.mappingRules = mappingRules
        }
    }

}

extension RolesAnywhereClientTypes {

    public enum CertificateField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x509issuer
        case x509san
        case x509subject
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateField] {
            return [
                .x509issuer,
                .x509san,
                .x509subject,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x509issuer: return "x509Issuer"
            case .x509san: return "x509SAN"
            case .x509subject: return "x509Subject"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/profiles"
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["enabled"].write(value.enabled)
        try writer["managedPolicyArns"].writeList(value.managedPolicyArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["requireInstanceProperties"].write(value.requireInstanceProperties)
        try writer["roleArns"].writeList(value.roleArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionPolicy"].write(value.sessionPolicy)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateProfileInput {
    /// Used to determine how long sessions vended using this profile are valid for. See the Expiration section of the [CreateSession API documentation](https://docs.aws.amazon.com/rolesanywhere/latest/userguide/authentication-create-session.html#credentials-object) page for more details. In requests, if this value is not provided, the default value will be 3600.
    public var durationSeconds: Swift.Int?
    /// Specifies whether the profile is enabled.
    public var enabled: Swift.Bool?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether instance properties are required in temporary credential requests with this profile.
    public var requireInstanceProperties: Swift.Bool?
    /// A list of IAM roles that this profile can assume in a temporary credential request.
    /// This member is required.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?
    /// The tags to attach to the profile.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        durationSeconds: Swift.Int? = nil,
        enabled: Swift.Bool? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        requireInstanceProperties: Swift.Bool? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.enabled = enabled
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.requireInstanceProperties = requireInstanceProperties
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
        self.tags = tags
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct CreateProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateTrustAnchorInput {

    static func urlPathProvider(_ value: CreateTrustAnchorInput) -> Swift.String? {
        return "/trustanchors"
    }
}

extension CreateTrustAnchorInput {

    static func write(value: CreateTrustAnchorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["notificationSettings"].writeList(value.notificationSettings, memberWritingClosure: RolesAnywhereClientTypes.NotificationSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source, with: RolesAnywhereClientTypes.Source.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateTrustAnchorInput {
    /// Specifies whether the trust anchor is enabled.
    public var enabled: Swift.Bool?
    /// The name of the trust anchor.
    /// This member is required.
    public var name: Swift.String?
    /// A list of notification settings to be associated to the trust anchor.
    public var notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
    /// The trust anchor type and its related certificate data.
    /// This member is required.
    public var source: RolesAnywhereClientTypes.Source?
    /// The tags to attach to the trust anchor.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.name = name
        self.notificationSettings = notificationSettings
        self.source = source
        self.tags = tags
    }
}

extension CreateTrustAnchorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct CreateTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum CreateTrustAnchorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RolesAnywhereClientTypes.CredentialSummary {

    static func write(value: RolesAnywhereClientTypes.CredentialSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["failed"].write(value.failed)
        try writer["issuer"].write(value.issuer)
        try writer["seenAt"].writeTimestamp(value.seenAt, format: .dateTime)
        try writer["serialNumber"].write(value.serialNumber)
        try writer["x509CertificateData"].write(value.x509CertificateData)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.CredentialSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.CredentialSummary()
        value.seenAt = try reader["seenAt"].readTimestampIfPresent(format: .dateTime)
        value.serialNumber = try reader["serialNumber"].readIfPresent()
        value.issuer = try reader["issuer"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.x509CertificateData = try reader["x509CertificateData"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A record of a presented X509 credential from a temporary credential request.
    public struct CredentialSummary {
        /// Indicates whether the credential is enabled.
        public var enabled: Swift.Bool?
        /// Indicates whether the temporary credential request was successful.
        public var failed: Swift.Bool?
        /// The fully qualified domain name of the issuing certificate for the presented end-entity certificate.
        public var issuer: Swift.String?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var seenAt: ClientRuntime.Date?
        /// The serial number of the certificate.
        public var serialNumber: Swift.String?
        /// The PEM-encoded data of the certificate.
        public var x509CertificateData: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            failed: Swift.Bool? = nil,
            issuer: Swift.String? = nil,
            seenAt: ClientRuntime.Date? = nil,
            serialNumber: Swift.String? = nil,
            x509CertificateData: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.failed = failed
            self.issuer = issuer
            self.seenAt = seenAt
            self.serialNumber = serialNumber
            self.x509CertificateData = x509CertificateData
        }
    }

}

extension RolesAnywhereClientTypes.CrlDetail {

    static func write(value: RolesAnywhereClientTypes.CrlDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["crlArn"].write(value.crlArn)
        try writer["crlData"].write(value.crlData)
        try writer["crlId"].write(value.crlId)
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["trustAnchorArn"].write(value.trustAnchorArn)
        try writer["updatedAt"].writeTimestamp(value.updatedAt, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.CrlDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.CrlDetail()
        value.crlId = try reader["crlId"].readIfPresent()
        value.crlArn = try reader["crlArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.crlData = try reader["crlData"].readIfPresent()
        value.trustAnchorArn = try reader["trustAnchorArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    public struct CrlDetail {
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was created.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the certificate revocation list (CRL).
        public var crlArn: Swift.String?
        /// The state of the certificate revocation list (CRL) after a read or write operation.
        public var crlData: ClientRuntime.Data?
        /// The unique identifier of the certificate revocation list (CRL).
        public var crlId: Swift.String?
        /// Indicates whether the certificate revocation list (CRL) is enabled.
        public var enabled: Swift.Bool?
        /// The name of the certificate revocation list (CRL).
        public var name: Swift.String?
        /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
        public var trustAnchorArn: Swift.String?
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            crlArn: Swift.String? = nil,
            crlData: ClientRuntime.Data? = nil,
            crlId: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            trustAnchorArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.crlArn = crlArn
            self.crlData = crlData
            self.crlId = crlId
            self.enabled = enabled
            self.name = name
            self.trustAnchorArn = trustAnchorArn
            self.updatedAt = updatedAt
        }
    }

}

extension DeleteAttributeMappingInput {

    static func queryItemProvider(_ value: DeleteAttributeMappingInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let certificateField = value.certificateField else {
            let message = "Creating a URL Query Item failed. certificateField is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let certificateFieldQueryItem = ClientRuntime.SDKURLQueryItem(name: "certificateField".urlPercentEncoding(), value: Swift.String(certificateField.rawValue).urlPercentEncoding())
        items.append(certificateFieldQueryItem)
        if let specifiers = value.specifiers {
            specifiers.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "specifiers".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteAttributeMappingInput {

    static func urlPathProvider(_ value: DeleteAttributeMappingInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profiles/\(profileId.urlPercentEncoding())/mappings"
    }
}

public struct DeleteAttributeMappingInput {
    /// Fields (x509Subject, x509Issuer and x509SAN) within X.509 certificates.
    /// This member is required.
    public var certificateField: RolesAnywhereClientTypes.CertificateField?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of specifiers of a certificate field; for example, CN, OU, UID from a Subject.
    public var specifiers: [Swift.String]?

    public init(
        certificateField: RolesAnywhereClientTypes.CertificateField? = nil,
        profileId: Swift.String? = nil,
        specifiers: [Swift.String]? = nil
    )
    {
        self.certificateField = certificateField
        self.profileId = profileId
        self.specifiers = specifiers
    }
}

extension DeleteAttributeMappingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAttributeMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAttributeMappingOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct DeleteAttributeMappingOutput {
    /// The state of the profile after a read or write operation.
    /// This member is required.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum DeleteAttributeMappingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteCrlInput {

    static func urlPathProvider(_ value: DeleteCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct DeleteCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

extension DeleteCrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

public struct DeleteCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

enum DeleteCrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct DeleteProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct DeleteProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteTrustAnchorInput {

    static func urlPathProvider(_ value: DeleteTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct DeleteTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

extension DeleteTrustAnchorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct DeleteTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum DeleteTrustAnchorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisableCrlInput {

    static func urlPathProvider(_ value: DisableCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/disable"
    }
}

public struct DisableCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

extension DisableCrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisableCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

public struct DisableCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

enum DisableCrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisableProfileInput {

    static func urlPathProvider(_ value: DisableProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/disable"
    }
}

public struct DisableProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

extension DisableProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisableProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct DisableProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum DisableProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisableTrustAnchorInput {

    static func urlPathProvider(_ value: DisableTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/disable"
    }
}

public struct DisableTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

extension DisableTrustAnchorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisableTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct DisableTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum DisableTrustAnchorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension EnableCrlInput {

    static func urlPathProvider(_ value: EnableCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/enable"
    }
}

public struct EnableCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

extension EnableCrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> EnableCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

public struct EnableCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

enum EnableCrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension EnableProfileInput {

    static func urlPathProvider(_ value: EnableProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/enable"
    }
}

public struct EnableProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

extension EnableProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> EnableProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct EnableProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum EnableProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension EnableTrustAnchorInput {

    static func urlPathProvider(_ value: EnableTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/enable"
    }
}

public struct EnableTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

extension EnableTrustAnchorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> EnableTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct EnableTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum EnableTrustAnchorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCrlInput {

    static func urlPathProvider(_ value: GetCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

public struct GetCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

extension GetCrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

public struct GetCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

enum GetCrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

public struct GetProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

extension GetProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct GetProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum GetProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubjectInput {

    static func urlPathProvider(_ value: GetSubjectInput) -> Swift.String? {
        guard let subjectId = value.subjectId else {
            return nil
        }
        return "/subject/\(subjectId.urlPercentEncoding())"
    }
}

public struct GetSubjectInput {
    /// The unique identifier of the subject.
    /// This member is required.
    public var subjectId: Swift.String?

    public init(
        subjectId: Swift.String? = nil
    )
    {
        self.subjectId = subjectId
    }
}

extension GetSubjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubjectOutput()
        value.subject = try reader["subject"].readIfPresent(with: RolesAnywhereClientTypes.SubjectDetail.read(from:))
        return value
    }
}

public struct GetSubjectOutput {
    /// The state of the subject after a read or write operation.
    public var subject: RolesAnywhereClientTypes.SubjectDetail?

    public init(
        subject: RolesAnywhereClientTypes.SubjectDetail? = nil
    )
    {
        self.subject = subject
    }
}

enum GetSubjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetTrustAnchorInput {

    static func urlPathProvider(_ value: GetTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

public struct GetTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

extension GetTrustAnchorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct GetTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum GetTrustAnchorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ImportCrlInput {

    static func urlPathProvider(_ value: ImportCrlInput) -> Swift.String? {
        return "/crls"
    }
}

extension ImportCrlInput {

    static func write(value: ImportCrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crlData"].write(value.crlData)
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trustAnchorArn"].write(value.trustAnchorArn)
    }
}

public struct ImportCrlInput {
    /// The x509 v3 specified certificate revocation list (CRL).
    /// This member is required.
    public var crlData: ClientRuntime.Data?
    /// Specifies whether the certificate revocation list (CRL) is enabled.
    public var enabled: Swift.Bool?
    /// The name of the certificate revocation list (CRL).
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags to attach to the certificate revocation list (CRL).
    public var tags: [RolesAnywhereClientTypes.Tag]?
    /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
    /// This member is required.
    public var trustAnchorArn: Swift.String?

    public init(
        crlData: ClientRuntime.Data? = nil,
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil,
        trustAnchorArn: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.enabled = enabled
        self.name = name
        self.tags = tags
        self.trustAnchorArn = trustAnchorArn
    }
}

extension ImportCrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ImportCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

public struct ImportCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

enum ImportCrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RolesAnywhereClientTypes.InstanceProperty {

    static func write(value: RolesAnywhereClientTypes.InstanceProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failed"].write(value.failed)
        try writer["properties"].writeMap(value.properties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["seenAt"].writeTimestamp(value.seenAt, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.InstanceProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.InstanceProperty()
        value.seenAt = try reader["seenAt"].readTimestampIfPresent(format: .dateTime)
        value.properties = try reader["properties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A key-value pair you set that identifies a property of the authenticating instance.
    public struct InstanceProperty {
        /// Indicates whether the temporary credential request was successful.
        public var failed: Swift.Bool?
        /// A list of instanceProperty objects.
        public var properties: [Swift.String:Swift.String]?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var seenAt: ClientRuntime.Date?

        public init(
            failed: Swift.Bool? = nil,
            properties: [Swift.String:Swift.String]? = nil,
            seenAt: ClientRuntime.Date? = nil
        )
        {
            self.failed = failed
            self.properties = properties
            self.seenAt = seenAt
        }
    }

}

extension ListCrlsInput {

    static func queryItemProvider(_ value: ListCrlsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = ClientRuntime.SDKURLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListCrlsInput {

    static func urlPathProvider(_ value: ListCrlsInput) -> Swift.String? {
        return "/crls"
    }
}

public struct ListCrlsInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension ListCrlsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCrlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrlsOutput()
        value.crls = try reader["crls"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.CrlDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListCrlsOutput {
    /// A list of certificate revocation lists (CRL).
    public var crls: [RolesAnywhereClientTypes.CrlDetail]?
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?

    public init(
        crls: [RolesAnywhereClientTypes.CrlDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crls = crls
        self.nextToken = nextToken
    }
}

enum ListCrlsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListProfilesInput {

    static func queryItemProvider(_ value: ListProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = ClientRuntime.SDKURLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/profiles"
    }
}

public struct ListProfilesInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension ListProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.profiles = try reader["profiles"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.ProfileDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListProfilesOutput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of profiles.
    public var profiles: [RolesAnywhereClientTypes.ProfileDetail]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [RolesAnywhereClientTypes.ProfileDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

enum ListProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubjectsInput {

    static func queryItemProvider(_ value: ListSubjectsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = ClientRuntime.SDKURLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListSubjectsInput {

    static func urlPathProvider(_ value: ListSubjectsInput) -> Swift.String? {
        return "/subjects"
    }
}

public struct ListSubjectsInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension ListSubjectsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.subjects = try reader["subjects"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.SubjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSubjectsOutput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of subjects.
    public var subjects: [RolesAnywhereClientTypes.SubjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        subjects: [RolesAnywhereClientTypes.SubjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.subjects = subjects
    }
}

enum ListSubjectsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// A list of tags attached to the resource.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTrustAnchorsInput {

    static func queryItemProvider(_ value: ListTrustAnchorsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = ClientRuntime.SDKURLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListTrustAnchorsInput {

    static func urlPathProvider(_ value: ListTrustAnchorsInput) -> Swift.String? {
        return "/trustanchors"
    }
}

public struct ListTrustAnchorsInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension ListTrustAnchorsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTrustAnchorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrustAnchorsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.trustAnchors = try reader["trustAnchors"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTrustAnchorsOutput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of trust anchors.
    public var trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]?

    public init(
        nextToken: Swift.String? = nil,
        trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustAnchors = trustAnchors
    }
}

enum ListTrustAnchorsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RolesAnywhereClientTypes.MappingRule {

    static func write(value: RolesAnywhereClientTypes.MappingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["specifier"].write(value.specifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.MappingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.MappingRule()
        value.specifier = try reader["specifier"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A single mapping entry for each supported specifier or sub-field.
    public struct MappingRule {
        /// Specifier within a certificate field, such as CN, OU, or UID from the Subject field.
        /// This member is required.
        public var specifier: Swift.String?

        public init(
            specifier: Swift.String? = nil
        )
        {
            self.specifier = specifier
        }
    }

}

extension RolesAnywhereClientTypes {

    public enum NotificationChannel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationChannel] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RolesAnywhereClientTypes {

    public enum NotificationEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case caCertificateExpiry
        case endEntityCertificateExpiry
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationEvent] {
            return [
                .caCertificateExpiry,
                .endEntityCertificateExpiry,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .caCertificateExpiry: return "CA_CERTIFICATE_EXPIRY"
            case .endEntityCertificateExpiry: return "END_ENTITY_CERTIFICATE_EXPIRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RolesAnywhereClientTypes.NotificationSetting {

    static func write(value: RolesAnywhereClientTypes.NotificationSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel)
        try writer["enabled"].write(value.enabled)
        try writer["event"].write(value.event)
        try writer["threshold"].write(value.threshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.NotificationSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.NotificationSetting()
        value.enabled = try reader["enabled"].readIfPresent()
        value.event = try reader["event"].readIfPresent()
        value.threshold = try reader["threshold"].readIfPresent()
        value.channel = try reader["channel"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// Customizable notification settings that will be applied to notification events. IAM Roles Anywhere consumes these settings while notifying across multiple channels - CloudWatch metrics, EventBridge, and Health Dashboard.
    public struct NotificationSetting {
        /// The specified channel of notification. IAM Roles Anywhere uses CloudWatch metrics, EventBridge, and Health Dashboard to notify for an event. In the absence of a specific channel, IAM Roles Anywhere applies this setting to 'ALL' channels.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// Indicates whether the notification setting is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The event to which this notification setting is applied.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?
        /// The number of days before a notification event. This value is required for a notification setting that is enabled.
        public var threshold: Swift.Int?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            enabled: Swift.Bool? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.channel = channel
            self.enabled = enabled
            self.event = event
            self.threshold = threshold
        }
    }

}

extension RolesAnywhereClientTypes.NotificationSettingDetail {

    static func write(value: RolesAnywhereClientTypes.NotificationSettingDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel)
        try writer["configuredBy"].write(value.configuredBy)
        try writer["enabled"].write(value.enabled)
        try writer["event"].write(value.event)
        try writer["threshold"].write(value.threshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.NotificationSettingDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.NotificationSettingDetail()
        value.enabled = try reader["enabled"].readIfPresent()
        value.event = try reader["event"].readIfPresent()
        value.threshold = try reader["threshold"].readIfPresent()
        value.channel = try reader["channel"].readIfPresent()
        value.configuredBy = try reader["configuredBy"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// The state of a notification setting. A notification setting includes information such as event name, threshold, status of the notification setting, and the channel to notify.
    public struct NotificationSettingDetail {
        /// The specified channel of notification. IAM Roles Anywhere uses CloudWatch metrics, EventBridge, and Health Dashboard to notify for an event. In the absence of a specific channel, IAM Roles Anywhere applies this setting to 'ALL' channels.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// The principal that configured the notification setting. For default settings configured by IAM Roles Anywhere, the value is rolesanywhere.amazonaws.com, and for customized notifications settings, it is the respective account ID.
        public var configuredBy: Swift.String?
        /// Indicates whether the notification setting is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The event to which this notification setting is applied.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?
        /// The number of days before a notification event.
        public var threshold: Swift.Int?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            configuredBy: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.channel = channel
            self.configuredBy = configuredBy
            self.enabled = enabled
            self.event = event
            self.threshold = threshold
        }
    }

}

extension RolesAnywhereClientTypes.NotificationSettingKey {

    static func write(value: RolesAnywhereClientTypes.NotificationSettingKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel)
        try writer["event"].write(value.event)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.NotificationSettingKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.NotificationSettingKey()
        value.event = try reader["event"].readIfPresent()
        value.channel = try reader["channel"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A notification setting key to reset. A notification setting key includes the event and the channel.
    public struct NotificationSettingKey {
        /// The specified channel of notification.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// The notification setting event to reset.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil
        )
        {
            self.channel = channel
            self.event = event
        }
    }

}

extension RolesAnywhereClientTypes.ProfileDetail {

    static func write(value: RolesAnywhereClientTypes.ProfileDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeMappings"].writeList(value.attributeMappings, memberWritingClosure: RolesAnywhereClientTypes.AttributeMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["createdBy"].write(value.createdBy)
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["enabled"].write(value.enabled)
        try writer["managedPolicyArns"].writeList(value.managedPolicyArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["profileArn"].write(value.profileArn)
        try writer["profileId"].write(value.profileId)
        try writer["requireInstanceProperties"].write(value.requireInstanceProperties)
        try writer["roleArns"].writeList(value.roleArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionPolicy"].write(value.sessionPolicy)
        try writer["updatedAt"].writeTimestamp(value.updatedAt, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.ProfileDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.ProfileDetail()
        value.profileId = try reader["profileId"].readIfPresent()
        value.profileArn = try reader["profileArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.requireInstanceProperties = try reader["requireInstanceProperties"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.sessionPolicy = try reader["sessionPolicy"].readIfPresent()
        value.roleArns = try reader["roleArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedPolicyArns = try reader["managedPolicyArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.durationSeconds = try reader["durationSeconds"].readIfPresent()
        value.attributeMappings = try reader["attributeMappings"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.AttributeMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the profile after a read or write operation.
    public struct ProfileDetail {
        /// A mapping applied to the authenticating end-entity certificate.
        public var attributeMappings: [RolesAnywhereClientTypes.AttributeMapping]?
        /// The ISO-8601 timestamp when the profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Web Services account that created the profile.
        public var createdBy: Swift.String?
        /// Used to determine how long sessions vended using this profile are valid for. See the Expiration section of the [CreateSession API documentation](https://docs.aws.amazon.com/rolesanywhere/latest/userguide/authentication-create-session.html#credentials-object) page for more details. In requests, if this value is not provided, the default value will be 3600.
        public var durationSeconds: Swift.Int?
        /// Indicates whether the profile is enabled.
        public var enabled: Swift.Bool?
        /// A list of managed policy ARNs that apply to the vended session credentials.
        public var managedPolicyArns: [Swift.String]?
        /// The name of the profile.
        public var name: Swift.String?
        /// The ARN of the profile.
        public var profileArn: Swift.String?
        /// The unique identifier of the profile.
        public var profileId: Swift.String?
        /// Specifies whether instance properties are required in temporary credential requests with this profile.
        public var requireInstanceProperties: Swift.Bool?
        /// A list of IAM roles that this profile can assume in a temporary credential request.
        public var roleArns: [Swift.String]?
        /// A session policy that applies to the trust boundary of the vended session credentials.
        public var sessionPolicy: Swift.String?
        /// The ISO-8601 timestamp when the profile was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            attributeMappings: [RolesAnywhereClientTypes.AttributeMapping]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            durationSeconds: Swift.Int? = nil,
            enabled: Swift.Bool? = nil,
            managedPolicyArns: [Swift.String]? = nil,
            name: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileId: Swift.String? = nil,
            requireInstanceProperties: Swift.Bool? = nil,
            roleArns: [Swift.String]? = nil,
            sessionPolicy: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.attributeMappings = attributeMappings
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.durationSeconds = durationSeconds
            self.enabled = enabled
            self.managedPolicyArns = managedPolicyArns
            self.name = name
            self.profileArn = profileArn
            self.profileId = profileId
            self.requireInstanceProperties = requireInstanceProperties
            self.roleArns = roleArns
            self.sessionPolicy = sessionPolicy
            self.updatedAt = updatedAt
        }
    }

}

extension PutAttributeMappingInput {

    static func urlPathProvider(_ value: PutAttributeMappingInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profiles/\(profileId.urlPercentEncoding())/mappings"
    }
}

extension PutAttributeMappingInput {

    static func write(value: PutAttributeMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateField"].write(value.certificateField)
        try writer["mappingRules"].writeList(value.mappingRules, memberWritingClosure: RolesAnywhereClientTypes.MappingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct PutAttributeMappingInput {
    /// Fields (x509Subject, x509Issuer and x509SAN) within X.509 certificates.
    /// This member is required.
    public var certificateField: RolesAnywhereClientTypes.CertificateField?
    /// A list of mapping entries for every supported specifier or sub-field.
    /// This member is required.
    public var mappingRules: [RolesAnywhereClientTypes.MappingRule]?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        certificateField: RolesAnywhereClientTypes.CertificateField? = nil,
        mappingRules: [RolesAnywhereClientTypes.MappingRule]? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.certificateField = certificateField
        self.mappingRules = mappingRules
        self.profileId = profileId
    }
}

extension PutAttributeMappingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutAttributeMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAttributeMappingOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct PutAttributeMappingOutput {
    /// The state of the profile after a read or write operation.
    /// This member is required.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum PutAttributeMappingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutNotificationSettingsInput {

    static func urlPathProvider(_ value: PutNotificationSettingsInput) -> Swift.String? {
        return "/put-notifications-settings"
    }
}

extension PutNotificationSettingsInput {

    static func write(value: PutNotificationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationSettings"].writeList(value.notificationSettings, memberWritingClosure: RolesAnywhereClientTypes.NotificationSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trustAnchorId"].write(value.trustAnchorId)
    }
}

public struct PutNotificationSettingsInput {
    /// A list of notification settings to be associated to the trust anchor.
    /// This member is required.
    public var notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.notificationSettings = notificationSettings
        self.trustAnchorId = trustAnchorId
    }
}

extension PutNotificationSettingsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutNotificationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutNotificationSettingsOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct PutNotificationSettingsOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum PutNotificationSettingsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResetNotificationSettingsInput {

    static func urlPathProvider(_ value: ResetNotificationSettingsInput) -> Swift.String? {
        return "/reset-notifications-settings"
    }
}

extension ResetNotificationSettingsInput {

    static func write(value: ResetNotificationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationSettingKeys"].writeList(value.notificationSettingKeys, memberWritingClosure: RolesAnywhereClientTypes.NotificationSettingKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trustAnchorId"].write(value.trustAnchorId)
    }
}

public struct ResetNotificationSettingsInput {
    /// A list of notification setting keys to reset. A notification setting key includes the event and the channel.
    /// This member is required.
    public var notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.notificationSettingKeys = notificationSettingKeys
        self.trustAnchorId = trustAnchorId
    }
}

extension ResetNotificationSettingsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ResetNotificationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetNotificationSettingsOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct ResetNotificationSettingsOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum ResetNotificationSettingsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum RolesAnywhereClientTypes {}

extension RolesAnywhereClientTypes.Source {

    static func write(value: RolesAnywhereClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceData"].write(value.sourceData, with: RolesAnywhereClientTypes.SourceData.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.Source()
        value.sourceType = try reader["sourceType"].readIfPresent()
        value.sourceData = try reader["sourceData"].readIfPresent(with: RolesAnywhereClientTypes.SourceData.read(from:))
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// The trust anchor type and its related certificate data.
    public struct Source {
        /// The data field of the trust anchor depending on its type.
        public var sourceData: RolesAnywhereClientTypes.SourceData?
        /// The type of the trust anchor.
        public var sourceType: RolesAnywhereClientTypes.TrustAnchorType?

        public init(
            sourceData: RolesAnywhereClientTypes.SourceData? = nil,
            sourceType: RolesAnywhereClientTypes.TrustAnchorType? = nil
        )
        {
            self.sourceData = sourceData
            self.sourceType = sourceType
        }
    }

}

extension RolesAnywhereClientTypes.SourceData {

    static func write(value: RolesAnywhereClientTypes.SourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .acmpcaarn(acmpcaarn):
                try writer["acmPcaArn"].write(acmpcaarn)
            case let .x509certificatedata(x509certificatedata):
                try writer["x509CertificateData"].write(x509certificatedata)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.SourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "x509CertificateData":
                return .x509certificatedata(try reader["x509CertificateData"].read())
            case "acmPcaArn":
                return .acmpcaarn(try reader["acmPcaArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RolesAnywhereClientTypes {
    /// The data field of the trust anchor depending on its type.
    public enum SourceData {
        /// The PEM-encoded data for the certificate anchor. Included for trust anchors of type CERTIFICATE_BUNDLE.
        case x509certificatedata(Swift.String)
        /// The root certificate of the Private Certificate Authority specified by this ARN is used in trust validation for temporary credential requests. Included for trust anchors of type AWS_ACM_PCA.
        case acmpcaarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension RolesAnywhereClientTypes.SubjectDetail {

    static func write(value: RolesAnywhereClientTypes.SubjectDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["credentials"].writeList(value.credentials, memberWritingClosure: RolesAnywhereClientTypes.CredentialSummary.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["enabled"].write(value.enabled)
        try writer["instanceProperties"].writeList(value.instanceProperties, memberWritingClosure: RolesAnywhereClientTypes.InstanceProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastSeenAt"].writeTimestamp(value.lastSeenAt, format: .dateTime)
        try writer["subjectArn"].write(value.subjectArn)
        try writer["subjectId"].write(value.subjectId)
        try writer["updatedAt"].writeTimestamp(value.updatedAt, format: .dateTime)
        try writer["x509Subject"].write(value.x509Subject)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.SubjectDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.SubjectDetail()
        value.subjectArn = try reader["subjectArn"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.x509Subject = try reader["x509Subject"].readIfPresent()
        value.lastSeenAt = try reader["lastSeenAt"].readTimestampIfPresent(format: .dateTime)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.credentials = try reader["credentials"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.CredentialSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceProperties = try reader["instanceProperties"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.InstanceProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the subject after a read or write operation.
    public struct SubjectDetail {
        /// The ISO-8601 timestamp when the subject was created.
        public var createdAt: ClientRuntime.Date?
        /// The temporary session credentials vended at the last authenticating call with this subject.
        public var credentials: [RolesAnywhereClientTypes.CredentialSummary]?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The specified instance properties associated with the request.
        public var instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]?
        /// The ISO-8601 timestamp of the last time this subject requested temporary session credentials.
        public var lastSeenAt: ClientRuntime.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            credentials: [RolesAnywhereClientTypes.CredentialSummary]? = nil,
            enabled: Swift.Bool? = nil,
            instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]? = nil,
            lastSeenAt: ClientRuntime.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.credentials = credentials
            self.enabled = enabled
            self.instanceProperties = instanceProperties
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

extension RolesAnywhereClientTypes.SubjectSummary {

    static func write(value: RolesAnywhereClientTypes.SubjectSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["enabled"].write(value.enabled)
        try writer["lastSeenAt"].writeTimestamp(value.lastSeenAt, format: .dateTime)
        try writer["subjectArn"].write(value.subjectArn)
        try writer["subjectId"].write(value.subjectId)
        try writer["updatedAt"].writeTimestamp(value.updatedAt, format: .dateTime)
        try writer["x509Subject"].write(value.x509Subject)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.SubjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.SubjectSummary()
        value.subjectArn = try reader["subjectArn"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.x509Subject = try reader["x509Subject"].readIfPresent()
        value.lastSeenAt = try reader["lastSeenAt"].readTimestampIfPresent(format: .dateTime)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A summary representation of subjects.
    public struct SubjectSummary {
        /// The ISO-8601 time stamp of when the certificate was first used in a temporary credential request.
        public var createdAt: ClientRuntime.Date?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var lastSeenAt: ClientRuntime.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource.
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            lastSeenAt: ClientRuntime.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

extension RolesAnywhereClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension RolesAnywhereClientTypes.Tag {

    static func write(value: RolesAnywhereClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.Tag()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// A label that consists of a key and value you define.
    public struct Tag {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to attach to the resource.
    /// This member is required.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Too many tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RolesAnywhereClientTypes.TrustAnchorDetail {

    static func write(value: RolesAnywhereClientTypes.TrustAnchorDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["notificationSettings"].writeList(value.notificationSettings, memberWritingClosure: RolesAnywhereClientTypes.NotificationSettingDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source, with: RolesAnywhereClientTypes.Source.write(value:to:))
        try writer["trustAnchorArn"].write(value.trustAnchorArn)
        try writer["trustAnchorId"].write(value.trustAnchorId)
        try writer["updatedAt"].writeTimestamp(value.updatedAt, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.TrustAnchorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.TrustAnchorDetail()
        value.trustAnchorId = try reader["trustAnchorId"].readIfPresent()
        value.trustAnchorArn = try reader["trustAnchorArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: RolesAnywhereClientTypes.Source.read(from:))
        value.enabled = try reader["enabled"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.notificationSettings = try reader["notificationSettings"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.NotificationSettingDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the trust anchor after a read or write operation.
    public struct TrustAnchorDetail {
        /// The ISO-8601 timestamp when the trust anchor was created.
        public var createdAt: ClientRuntime.Date?
        /// Indicates whether the trust anchor is enabled.
        public var enabled: Swift.Bool?
        /// The name of the trust anchor.
        public var name: Swift.String?
        /// A list of notification settings to be associated to the trust anchor.
        public var notificationSettings: [RolesAnywhereClientTypes.NotificationSettingDetail]?
        /// The trust anchor type and its related certificate data.
        public var source: RolesAnywhereClientTypes.Source?
        /// The ARN of the trust anchor.
        public var trustAnchorArn: Swift.String?
        /// The unique identifier of the trust anchor.
        public var trustAnchorId: Swift.String?
        /// The ISO-8601 timestamp when the trust anchor was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            notificationSettings: [RolesAnywhereClientTypes.NotificationSettingDetail]? = nil,
            source: RolesAnywhereClientTypes.Source? = nil,
            trustAnchorArn: Swift.String? = nil,
            trustAnchorId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.name = name
            self.notificationSettings = notificationSettings
            self.source = source
            self.trustAnchorArn = trustAnchorArn
            self.trustAnchorId = trustAnchorId
            self.updatedAt = updatedAt
        }
    }

}

extension RolesAnywhereClientTypes {

    public enum TrustAnchorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAcmPca
        case certificateBundle
        case selfSignedRepository
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustAnchorType] {
            return [
                .awsAcmPca,
                .certificateBundle,
                .selfSignedRepository,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAcmPca: return "AWS_ACM_PCA"
            case .certificateBundle: return "CERTIFICATE_BUNDLE"
            case .selfSignedRepository: return "SELF_SIGNED_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys. Tag keys are the unique identifiers of tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateCrlInput {

    static func urlPathProvider(_ value: UpdateCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

extension UpdateCrlInput {

    static func write(value: UpdateCrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crlData"].write(value.crlData)
        try writer["name"].write(value.name)
    }
}

public struct UpdateCrlInput {
    /// The x509 v3 specified certificate revocation list (CRL).
    public var crlData: ClientRuntime.Data?
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?
    /// The name of the Crl.
    public var name: Swift.String?

    public init(
        crlData: ClientRuntime.Data? = nil,
        crlId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.crlId = crlId
        self.name = name
    }
}

extension UpdateCrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

public struct UpdateCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

enum UpdateCrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["managedPolicyArns"].writeList(value.managedPolicyArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["roleArns"].writeList(value.roleArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionPolicy"].write(value.sessionPolicy)
    }
}

public struct UpdateProfileInput {
    /// Used to determine how long sessions vended using this profile are valid for. See the Expiration section of the [CreateSession API documentation](https://docs.aws.amazon.com/rolesanywhere/latest/userguide/authentication-create-session.html#credentials-object) page for more details. In requests, if this value is not provided, the default value will be 3600.
    public var durationSeconds: Swift.Int?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    public var name: Swift.String?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of IAM roles that this profile can assume in a temporary credential request.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?

    public init(
        durationSeconds: Swift.Int? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        profileId: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.profileId = profileId
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

public struct UpdateProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateTrustAnchorInput {

    static func urlPathProvider(_ value: UpdateTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

extension UpdateTrustAnchorInput {

    static func write(value: UpdateTrustAnchorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["source"].write(value.source, with: RolesAnywhereClientTypes.Source.write(value:to:))
    }
}

public struct UpdateTrustAnchorInput {
    /// The name of the trust anchor.
    public var name: Swift.String?
    /// The trust anchor type and its related certificate data.
    public var source: RolesAnywhereClientTypes.Source?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.name = name
        self.source = source
        self.trustAnchorId = trustAnchorId
    }
}

extension UpdateTrustAnchorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

public struct UpdateTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

enum UpdateTrustAnchorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Validation exception error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
