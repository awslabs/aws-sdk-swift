//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RolesAnywhereClientTypes {

    public enum CertificateField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x509issuer
        case x509san
        case x509subject
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateField] {
            return [
                .x509issuer,
                .x509san,
                .x509subject
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x509issuer: return "x509Issuer"
            case .x509san: return "x509SAN"
            case .x509subject: return "x509Subject"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RolesAnywhereClientTypes {
    /// A single mapping entry for each supported specifier or sub-field.
    public struct MappingRule {
        /// Specifier within a certificate field, such as CN, OU, or UID from the Subject field.
        /// This member is required.
        public var specifier: Swift.String?

        public init(
            specifier: Swift.String? = nil
        )
        {
            self.specifier = specifier
        }
    }

}

extension RolesAnywhereClientTypes {
    /// A mapping applied to the authenticating end-entity certificate.
    public struct AttributeMapping {
        /// Fields (x509Subject, x509Issuer and x509SAN) within X.509 certificates.
        public var certificateField: RolesAnywhereClientTypes.CertificateField?
        /// A list of mapping entries for every supported specifier or sub-field.
        public var mappingRules: [RolesAnywhereClientTypes.MappingRule]?

        public init(
            certificateField: RolesAnywhereClientTypes.CertificateField? = nil,
            mappingRules: [RolesAnywhereClientTypes.MappingRule]? = nil
        )
        {
            self.certificateField = certificateField
            self.mappingRules = mappingRules
        }
    }

}

/// Validation exception error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RolesAnywhereClientTypes {
    /// A label that consists of a key and value you define.
    public struct Tag {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RolesAnywhereClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

public struct CreateProfileInput {
    /// Used to determine how long sessions vended using this profile are valid for. See the Expiration section of the [CreateSession API documentation](https://docs.aws.amazon.com/rolesanywhere/latest/userguide/authentication-create-session.html#credentials-object) page for more details. In requests, if this value is not provided, the default value will be 3600.
    public var durationSeconds: Swift.Int?
    /// Specifies whether the profile is enabled.
    public var enabled: Swift.Bool?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether instance properties are required in temporary credential requests with this profile.
    public var requireInstanceProperties: Swift.Bool?
    /// A list of IAM roles that this profile can assume in a temporary credential request.
    /// This member is required.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?
    /// The tags to attach to the profile.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        durationSeconds: Swift.Int? = nil,
        enabled: Swift.Bool? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        requireInstanceProperties: Swift.Bool? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.enabled = enabled
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.requireInstanceProperties = requireInstanceProperties
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
        self.tags = tags
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the profile after a read or write operation.
    public struct ProfileDetail {
        /// A mapping applied to the authenticating end-entity certificate.
        public var attributeMappings: [RolesAnywhereClientTypes.AttributeMapping]?
        /// The ISO-8601 timestamp when the profile was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Web Services account that created the profile.
        public var createdBy: Swift.String?
        /// Used to determine how long sessions vended using this profile are valid for. See the Expiration section of the [CreateSession API documentation](https://docs.aws.amazon.com/rolesanywhere/latest/userguide/authentication-create-session.html#credentials-object) page for more details. In requests, if this value is not provided, the default value will be 3600.
        public var durationSeconds: Swift.Int?
        /// Indicates whether the profile is enabled.
        public var enabled: Swift.Bool?
        /// A list of managed policy ARNs that apply to the vended session credentials.
        public var managedPolicyArns: [Swift.String]?
        /// The name of the profile.
        public var name: Swift.String?
        /// The ARN of the profile.
        public var profileArn: Swift.String?
        /// The unique identifier of the profile.
        public var profileId: Swift.String?
        /// Specifies whether instance properties are required in temporary credential requests with this profile.
        public var requireInstanceProperties: Swift.Bool?
        /// A list of IAM roles that this profile can assume in a temporary credential request.
        public var roleArns: [Swift.String]?
        /// A session policy that applies to the trust boundary of the vended session credentials.
        public var sessionPolicy: Swift.String?
        /// The ISO-8601 timestamp when the profile was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            attributeMappings: [RolesAnywhereClientTypes.AttributeMapping]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            durationSeconds: Swift.Int? = nil,
            enabled: Swift.Bool? = nil,
            managedPolicyArns: [Swift.String]? = nil,
            name: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileId: Swift.String? = nil,
            requireInstanceProperties: Swift.Bool? = nil,
            roleArns: [Swift.String]? = nil,
            sessionPolicy: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.attributeMappings = attributeMappings
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.durationSeconds = durationSeconds
            self.enabled = enabled
            self.managedPolicyArns = managedPolicyArns
            self.name = name
            self.profileArn = profileArn
            self.profileId = profileId
            self.requireInstanceProperties = requireInstanceProperties
            self.roleArns = roleArns
            self.sessionPolicy = sessionPolicy
            self.updatedAt = updatedAt
        }
    }

}

public struct CreateProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

extension RolesAnywhereClientTypes {

    public enum NotificationChannel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationChannel] {
            return [
                .all
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RolesAnywhereClientTypes {

    public enum NotificationEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case caCertificateExpiry
        case endEntityCertificateExpiry
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationEvent] {
            return [
                .caCertificateExpiry,
                .endEntityCertificateExpiry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .caCertificateExpiry: return "CA_CERTIFICATE_EXPIRY"
            case .endEntityCertificateExpiry: return "END_ENTITY_CERTIFICATE_EXPIRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RolesAnywhereClientTypes {
    /// Customizable notification settings that will be applied to notification events. IAM Roles Anywhere consumes these settings while notifying across multiple channels - CloudWatch metrics, EventBridge, and Health Dashboard.
    public struct NotificationSetting {
        /// The specified channel of notification. IAM Roles Anywhere uses CloudWatch metrics, EventBridge, and Health Dashboard to notify for an event. In the absence of a specific channel, IAM Roles Anywhere applies this setting to 'ALL' channels.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// Indicates whether the notification setting is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The event to which this notification setting is applied.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?
        /// The number of days before a notification event. This value is required for a notification setting that is enabled.
        public var threshold: Swift.Int?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            enabled: Swift.Bool? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.channel = channel
            self.enabled = enabled
            self.event = event
            self.threshold = threshold
        }
    }

}

extension RolesAnywhereClientTypes {
    /// The data field of the trust anchor depending on its type.
    public enum SourceData {
        /// The PEM-encoded data for the certificate anchor. Included for trust anchors of type CERTIFICATE_BUNDLE.
        case x509certificatedata(Swift.String)
        /// The root certificate of the Private Certificate Authority specified by this ARN is used in trust validation for temporary credential requests. Included for trust anchors of type AWS_ACM_PCA.
        case acmpcaarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension RolesAnywhereClientTypes {

    public enum TrustAnchorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAcmPca
        case certificateBundle
        case selfSignedRepository
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustAnchorType] {
            return [
                .awsAcmPca,
                .certificateBundle,
                .selfSignedRepository
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAcmPca: return "AWS_ACM_PCA"
            case .certificateBundle: return "CERTIFICATE_BUNDLE"
            case .selfSignedRepository: return "SELF_SIGNED_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RolesAnywhereClientTypes {
    /// The trust anchor type and its related certificate data.
    public struct Source {
        /// The data field of the trust anchor depending on its type.
        public var sourceData: RolesAnywhereClientTypes.SourceData?
        /// The type of the trust anchor.
        public var sourceType: RolesAnywhereClientTypes.TrustAnchorType?

        public init(
            sourceData: RolesAnywhereClientTypes.SourceData? = nil,
            sourceType: RolesAnywhereClientTypes.TrustAnchorType? = nil
        )
        {
            self.sourceData = sourceData
            self.sourceType = sourceType
        }
    }

}

public struct CreateTrustAnchorInput {
    /// Specifies whether the trust anchor is enabled.
    public var enabled: Swift.Bool?
    /// The name of the trust anchor.
    /// This member is required.
    public var name: Swift.String?
    /// A list of notification settings to be associated to the trust anchor.
    public var notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
    /// The trust anchor type and its related certificate data.
    /// This member is required.
    public var source: RolesAnywhereClientTypes.Source?
    /// The tags to attach to the trust anchor.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.name = name
        self.notificationSettings = notificationSettings
        self.source = source
        self.tags = tags
    }
}

extension RolesAnywhereClientTypes {
    /// The state of a notification setting. A notification setting includes information such as event name, threshold, status of the notification setting, and the channel to notify.
    public struct NotificationSettingDetail {
        /// The specified channel of notification. IAM Roles Anywhere uses CloudWatch metrics, EventBridge, and Health Dashboard to notify for an event. In the absence of a specific channel, IAM Roles Anywhere applies this setting to 'ALL' channels.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// The principal that configured the notification setting. For default settings configured by IAM Roles Anywhere, the value is rolesanywhere.amazonaws.com, and for customized notifications settings, it is the respective account ID.
        public var configuredBy: Swift.String?
        /// Indicates whether the notification setting is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The event to which this notification setting is applied.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?
        /// The number of days before a notification event.
        public var threshold: Swift.Int?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            configuredBy: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil,
            threshold: Swift.Int? = nil
        )
        {
            self.channel = channel
            self.configuredBy = configuredBy
            self.enabled = enabled
            self.event = event
            self.threshold = threshold
        }
    }

}

extension RolesAnywhereClientTypes {
    /// The state of the trust anchor after a read or write operation.
    public struct TrustAnchorDetail {
        /// The ISO-8601 timestamp when the trust anchor was created.
        public var createdAt: Foundation.Date?
        /// Indicates whether the trust anchor is enabled.
        public var enabled: Swift.Bool?
        /// The name of the trust anchor.
        public var name: Swift.String?
        /// A list of notification settings to be associated to the trust anchor.
        public var notificationSettings: [RolesAnywhereClientTypes.NotificationSettingDetail]?
        /// The trust anchor type and its related certificate data.
        public var source: RolesAnywhereClientTypes.Source?
        /// The ARN of the trust anchor.
        public var trustAnchorArn: Swift.String?
        /// The unique identifier of the trust anchor.
        public var trustAnchorId: Swift.String?
        /// The ISO-8601 timestamp when the trust anchor was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            notificationSettings: [RolesAnywhereClientTypes.NotificationSettingDetail]? = nil,
            source: RolesAnywhereClientTypes.Source? = nil,
            trustAnchorArn: Swift.String? = nil,
            trustAnchorId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.name = name
            self.notificationSettings = notificationSettings
            self.source = source
            self.trustAnchorArn = trustAnchorArn
            self.trustAnchorId = trustAnchorId
            self.updatedAt = updatedAt
        }
    }

}

public struct CreateTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

extension RolesAnywhereClientTypes {
    /// A record of a presented X509 credential from a temporary credential request.
    public struct CredentialSummary {
        /// Indicates whether the credential is enabled.
        public var enabled: Swift.Bool?
        /// Indicates whether the temporary credential request was successful.
        public var failed: Swift.Bool?
        /// The fully qualified domain name of the issuing certificate for the presented end-entity certificate.
        public var issuer: Swift.String?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var seenAt: Foundation.Date?
        /// The serial number of the certificate.
        public var serialNumber: Swift.String?
        /// The PEM-encoded data of the certificate.
        public var x509CertificateData: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            failed: Swift.Bool? = nil,
            issuer: Swift.String? = nil,
            seenAt: Foundation.Date? = nil,
            serialNumber: Swift.String? = nil,
            x509CertificateData: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.failed = failed
            self.issuer = issuer
            self.seenAt = seenAt
            self.serialNumber = serialNumber
            self.x509CertificateData = x509CertificateData
        }
    }

}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

extension RolesAnywhereClientTypes {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    public struct CrlDetail {
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was created.
        public var createdAt: Foundation.Date?
        /// The ARN of the certificate revocation list (CRL).
        public var crlArn: Swift.String?
        /// The state of the certificate revocation list (CRL) after a read or write operation.
        public var crlData: Foundation.Data?
        /// The unique identifier of the certificate revocation list (CRL).
        public var crlId: Swift.String?
        /// Indicates whether the certificate revocation list (CRL) is enabled.
        public var enabled: Swift.Bool?
        /// The name of the certificate revocation list (CRL).
        public var name: Swift.String?
        /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
        public var trustAnchorArn: Swift.String?
        /// The ISO-8601 timestamp when the certificate revocation list (CRL) was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            crlArn: Swift.String? = nil,
            crlData: Foundation.Data? = nil,
            crlId: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            trustAnchorArn: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.crlArn = crlArn
            self.crlData = crlData
            self.crlId = crlId
            self.enabled = enabled
            self.name = name
            self.trustAnchorArn = trustAnchorArn
            self.updatedAt = updatedAt
        }
    }

}

public struct DeleteCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

public struct DisableCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

public struct DisableCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

public struct EnableCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

public struct EnableCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

public struct GetCrlInput {
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?

    public init(
        crlId: Swift.String? = nil
    )
    {
        self.crlId = crlId
    }
}

public struct GetCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

public struct ImportCrlInput {
    /// The x509 v3 specified certificate revocation list (CRL).
    /// This member is required.
    public var crlData: Foundation.Data?
    /// Specifies whether the certificate revocation list (CRL) is enabled.
    public var enabled: Swift.Bool?
    /// The name of the certificate revocation list (CRL).
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags to attach to the certificate revocation list (CRL).
    public var tags: [RolesAnywhereClientTypes.Tag]?
    /// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
    /// This member is required.
    public var trustAnchorArn: Swift.String?

    public init(
        crlData: Foundation.Data? = nil,
        enabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil,
        trustAnchorArn: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.enabled = enabled
        self.name = name
        self.tags = tags
        self.trustAnchorArn = trustAnchorArn
    }
}

public struct ImportCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

public struct ListCrlsInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

public struct ListCrlsOutput {
    /// A list of certificate revocation lists (CRL).
    public var crls: [RolesAnywhereClientTypes.CrlDetail]?
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?

    public init(
        crls: [RolesAnywhereClientTypes.CrlDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crls = crls
        self.nextToken = nextToken
    }
}

public struct UpdateCrlInput {
    /// The x509 v3 specified certificate revocation list (CRL).
    public var crlData: Foundation.Data?
    /// The unique identifier of the certificate revocation list (CRL).
    /// This member is required.
    public var crlId: Swift.String?
    /// The name of the Crl.
    public var name: Swift.String?

    public init(
        crlData: Foundation.Data? = nil,
        crlId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.crlData = crlData
        self.crlId = crlId
        self.name = name
    }
}

public struct UpdateCrlOutput {
    /// The state of the certificate revocation list (CRL) after a read or write operation.
    /// This member is required.
    public var crl: RolesAnywhereClientTypes.CrlDetail?

    public init(
        crl: RolesAnywhereClientTypes.CrlDetail? = nil
    )
    {
        self.crl = crl
    }
}

public struct DeleteAttributeMappingInput {
    /// Fields (x509Subject, x509Issuer and x509SAN) within X.509 certificates.
    /// This member is required.
    public var certificateField: RolesAnywhereClientTypes.CertificateField?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of specifiers of a certificate field; for example, CN, OU, UID from a Subject.
    public var specifiers: [Swift.String]?

    public init(
        certificateField: RolesAnywhereClientTypes.CertificateField? = nil,
        profileId: Swift.String? = nil,
        specifiers: [Swift.String]? = nil
    )
    {
        self.certificateField = certificateField
        self.profileId = profileId
        self.specifiers = specifiers
    }
}

public struct DeleteAttributeMappingOutput {
    /// The state of the profile after a read or write operation.
    /// This member is required.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct DeleteProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct DeleteProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct DeleteTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

public struct DeleteTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

public struct DisableProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct DisableProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct DisableTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

public struct DisableTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

public struct EnableProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct EnableProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct EnableTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

public struct EnableTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

public struct GetProfileInput {
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct GetProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct GetSubjectInput {
    /// The unique identifier of the subject.
    /// This member is required.
    public var subjectId: Swift.String?

    public init(
        subjectId: Swift.String? = nil
    )
    {
        self.subjectId = subjectId
    }
}

extension RolesAnywhereClientTypes {
    /// A key-value pair you set that identifies a property of the authenticating instance.
    public struct InstanceProperty {
        /// Indicates whether the temporary credential request was successful.
        public var failed: Swift.Bool?
        /// A list of instanceProperty objects.
        public var properties: [Swift.String: Swift.String]?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var seenAt: Foundation.Date?

        public init(
            failed: Swift.Bool? = nil,
            properties: [Swift.String: Swift.String]? = nil,
            seenAt: Foundation.Date? = nil
        )
        {
            self.failed = failed
            self.properties = properties
            self.seenAt = seenAt
        }
    }

}

extension RolesAnywhereClientTypes {
    /// The state of the subject after a read or write operation.
    public struct SubjectDetail {
        /// The ISO-8601 timestamp when the subject was created.
        public var createdAt: Foundation.Date?
        /// The temporary session credentials vended at the last authenticating call with this subject.
        public var credentials: [RolesAnywhereClientTypes.CredentialSummary]?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The specified instance properties associated with the request.
        public var instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]?
        /// The ISO-8601 timestamp of the last time this subject requested temporary session credentials.
        public var lastSeenAt: Foundation.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: Foundation.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            credentials: [RolesAnywhereClientTypes.CredentialSummary]? = nil,
            enabled: Swift.Bool? = nil,
            instanceProperties: [RolesAnywhereClientTypes.InstanceProperty]? = nil,
            lastSeenAt: Foundation.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.credentials = credentials
            self.enabled = enabled
            self.instanceProperties = instanceProperties
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

public struct GetSubjectOutput {
    /// The state of the subject after a read or write operation.
    public var subject: RolesAnywhereClientTypes.SubjectDetail?

    public init(
        subject: RolesAnywhereClientTypes.SubjectDetail? = nil
    )
    {
        self.subject = subject
    }
}

public struct GetTrustAnchorInput {
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        trustAnchorId: Swift.String? = nil
    )
    {
        self.trustAnchorId = trustAnchorId
    }
}

public struct GetTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

public struct ListProfilesInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

public struct ListProfilesOutput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of profiles.
    public var profiles: [RolesAnywhereClientTypes.ProfileDetail]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [RolesAnywhereClientTypes.ProfileDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

public struct ListSubjectsInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension RolesAnywhereClientTypes {
    /// A summary representation of subjects.
    public struct SubjectSummary {
        /// The ISO-8601 time stamp of when the certificate was first used in a temporary credential request.
        public var createdAt: Foundation.Date?
        /// The enabled status of the subject.
        public var enabled: Swift.Bool?
        /// The ISO-8601 time stamp of when the certificate was last used in a temporary credential request.
        public var lastSeenAt: Foundation.Date?
        /// The ARN of the resource.
        public var subjectArn: Swift.String?
        /// The id of the resource.
        public var subjectId: Swift.String?
        /// The ISO-8601 timestamp when the subject was last updated.
        public var updatedAt: Foundation.Date?
        /// The x509 principal identifier of the authenticating certificate.
        public var x509Subject: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            enabled: Swift.Bool? = nil,
            lastSeenAt: Foundation.Date? = nil,
            subjectArn: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            x509Subject: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.enabled = enabled
            self.lastSeenAt = lastSeenAt
            self.subjectArn = subjectArn
            self.subjectId = subjectId
            self.updatedAt = updatedAt
            self.x509Subject = x509Subject
        }
    }

}

public struct ListSubjectsOutput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of subjects.
    public var subjects: [RolesAnywhereClientTypes.SubjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        subjects: [RolesAnywhereClientTypes.SubjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.subjects = subjects
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A list of tags attached to the resource.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTrustAnchorsInput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// The number of resources in the paginated list.
    public var pageSize: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

public struct ListTrustAnchorsOutput {
    /// A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.
    public var nextToken: Swift.String?
    /// A list of trust anchors.
    public var trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]?

    public init(
        nextToken: Swift.String? = nil,
        trustAnchors: [RolesAnywhereClientTypes.TrustAnchorDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustAnchors = trustAnchors
    }
}

extension RolesAnywhereClientTypes {
    /// A notification setting key to reset. A notification setting key includes the event and the channel.
    public struct NotificationSettingKey {
        /// The specified channel of notification.
        public var channel: RolesAnywhereClientTypes.NotificationChannel?
        /// The notification setting event to reset.
        /// This member is required.
        public var event: RolesAnywhereClientTypes.NotificationEvent?

        public init(
            channel: RolesAnywhereClientTypes.NotificationChannel? = nil,
            event: RolesAnywhereClientTypes.NotificationEvent? = nil
        )
        {
            self.channel = channel
            self.event = event
        }
    }

}

public struct PutAttributeMappingInput {
    /// Fields (x509Subject, x509Issuer and x509SAN) within X.509 certificates.
    /// This member is required.
    public var certificateField: RolesAnywhereClientTypes.CertificateField?
    /// A list of mapping entries for every supported specifier or sub-field.
    /// This member is required.
    public var mappingRules: [RolesAnywhereClientTypes.MappingRule]?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        certificateField: RolesAnywhereClientTypes.CertificateField? = nil,
        mappingRules: [RolesAnywhereClientTypes.MappingRule]? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.certificateField = certificateField
        self.mappingRules = mappingRules
        self.profileId = profileId
    }
}

public struct PutAttributeMappingOutput {
    /// The state of the profile after a read or write operation.
    /// This member is required.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct UpdateProfileInput {
    /// Used to determine how long sessions vended using this profile are valid for. See the Expiration section of the [CreateSession API documentation](https://docs.aws.amazon.com/rolesanywhere/latest/userguide/authentication-create-session.html#credentials-object) page for more details. In requests, if this value is not provided, the default value will be 3600.
    public var durationSeconds: Swift.Int?
    /// A list of managed policy ARNs that apply to the vended session credentials.
    public var managedPolicyArns: [Swift.String]?
    /// The name of the profile.
    public var name: Swift.String?
    /// The unique identifier of the profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// A list of IAM roles that this profile can assume in a temporary credential request.
    public var roleArns: [Swift.String]?
    /// A session policy that applies to the trust boundary of the vended session credentials.
    public var sessionPolicy: Swift.String?

    public init(
        durationSeconds: Swift.Int? = nil,
        managedPolicyArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        profileId: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        sessionPolicy: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.managedPolicyArns = managedPolicyArns
        self.name = name
        self.profileId = profileId
        self.roleArns = roleArns
        self.sessionPolicy = sessionPolicy
    }
}

public struct UpdateProfileOutput {
    /// The state of the profile after a read or write operation.
    public var profile: RolesAnywhereClientTypes.ProfileDetail?

    public init(
        profile: RolesAnywhereClientTypes.ProfileDetail? = nil
    )
    {
        self.profile = profile
    }
}

public struct PutNotificationSettingsInput {
    /// A list of notification settings to be associated to the trust anchor.
    /// This member is required.
    public var notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        notificationSettings: [RolesAnywhereClientTypes.NotificationSetting]? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.notificationSettings = notificationSettings
        self.trustAnchorId = trustAnchorId
    }
}

public struct PutNotificationSettingsOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

public struct ResetNotificationSettingsInput {
    /// A list of notification setting keys to reset. A notification setting key includes the event and the channel.
    /// This member is required.
    public var notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        notificationSettingKeys: [RolesAnywhereClientTypes.NotificationSettingKey]? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.notificationSettingKeys = notificationSettingKeys
        self.trustAnchorId = trustAnchorId
    }
}

public struct ResetNotificationSettingsOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

/// Too many tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to attach to the resource.
    /// This member is required.
    public var tags: [RolesAnywhereClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RolesAnywhereClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UpdateTrustAnchorInput {
    /// The name of the trust anchor.
    public var name: Swift.String?
    /// The trust anchor type and its related certificate data.
    public var source: RolesAnywhereClientTypes.Source?
    /// The unique identifier of the trust anchor.
    /// This member is required.
    public var trustAnchorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        source: RolesAnywhereClientTypes.Source? = nil,
        trustAnchorId: Swift.String? = nil
    )
    {
        self.name = name
        self.source = source
        self.trustAnchorId = trustAnchorId
    }
}

public struct UpdateTrustAnchorOutput {
    /// The state of the trust anchor after a read or write operation.
    /// This member is required.
    public var trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail?

    public init(
        trustAnchor: RolesAnywhereClientTypes.TrustAnchorDetail? = nil
    )
    {
        self.trustAnchor = trustAnchor
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys. Tag keys are the unique identifiers of tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput {

    public init() { }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/profiles"
    }
}

extension CreateTrustAnchorInput {

    static func urlPathProvider(_ value: CreateTrustAnchorInput) -> Swift.String? {
        return "/trustanchors"
    }
}

extension DeleteAttributeMappingInput {

    static func urlPathProvider(_ value: DeleteAttributeMappingInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profiles/\(profileId.urlPercentEncoding())/mappings"
    }
}

extension DeleteAttributeMappingInput {

    static func queryItemProvider(_ value: DeleteAttributeMappingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let certificateField = value.certificateField else {
            let message = "Creating a URL Query Item failed. certificateField is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let certificateFieldQueryItem = Smithy.URIQueryItem(name: "certificateField".urlPercentEncoding(), value: Swift.String(certificateField.rawValue).urlPercentEncoding())
        items.append(certificateFieldQueryItem)
        if let specifiers = value.specifiers {
            specifiers.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "specifiers".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteCrlInput {

    static func urlPathProvider(_ value: DeleteCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

extension DeleteTrustAnchorInput {

    static func urlPathProvider(_ value: DeleteTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

extension DisableCrlInput {

    static func urlPathProvider(_ value: DisableCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/disable"
    }
}

extension DisableProfileInput {

    static func urlPathProvider(_ value: DisableProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/disable"
    }
}

extension DisableTrustAnchorInput {

    static func urlPathProvider(_ value: DisableTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/disable"
    }
}

extension EnableCrlInput {

    static func urlPathProvider(_ value: EnableCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())/enable"
    }
}

extension EnableProfileInput {

    static func urlPathProvider(_ value: EnableProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())/enable"
    }
}

extension EnableTrustAnchorInput {

    static func urlPathProvider(_ value: EnableTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())/enable"
    }
}

extension GetCrlInput {

    static func urlPathProvider(_ value: GetCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

extension GetSubjectInput {

    static func urlPathProvider(_ value: GetSubjectInput) -> Swift.String? {
        guard let subjectId = value.subjectId else {
            return nil
        }
        return "/subject/\(subjectId.urlPercentEncoding())"
    }
}

extension GetTrustAnchorInput {

    static func urlPathProvider(_ value: GetTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

extension ImportCrlInput {

    static func urlPathProvider(_ value: ImportCrlInput) -> Swift.String? {
        return "/crls"
    }
}

extension ListCrlsInput {

    static func urlPathProvider(_ value: ListCrlsInput) -> Swift.String? {
        return "/crls"
    }
}

extension ListCrlsInput {

    static func queryItemProvider(_ value: ListCrlsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/profiles"
    }
}

extension ListProfilesInput {

    static func queryItemProvider(_ value: ListProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListSubjectsInput {

    static func urlPathProvider(_ value: ListSubjectsInput) -> Swift.String? {
        return "/subjects"
    }
}

extension ListSubjectsInput {

    static func queryItemProvider(_ value: ListSubjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListTrustAnchorsInput {

    static func urlPathProvider(_ value: ListTrustAnchorsInput) -> Swift.String? {
        return "/trustanchors"
    }
}

extension ListTrustAnchorsInput {

    static func queryItemProvider(_ value: ListTrustAnchorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension PutAttributeMappingInput {

    static func urlPathProvider(_ value: PutAttributeMappingInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profiles/\(profileId.urlPercentEncoding())/mappings"
    }
}

extension PutNotificationSettingsInput {

    static func urlPathProvider(_ value: PutNotificationSettingsInput) -> Swift.String? {
        return "/put-notifications-settings"
    }
}

extension ResetNotificationSettingsInput {

    static func urlPathProvider(_ value: ResetNotificationSettingsInput) -> Swift.String? {
        return "/reset-notifications-settings"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

extension UpdateCrlInput {

    static func urlPathProvider(_ value: UpdateCrlInput) -> Swift.String? {
        guard let crlId = value.crlId else {
            return nil
        }
        return "/crl/\(crlId.urlPercentEncoding())"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        guard let profileId = value.profileId else {
            return nil
        }
        return "/profile/\(profileId.urlPercentEncoding())"
    }
}

extension UpdateTrustAnchorInput {

    static func urlPathProvider(_ value: UpdateTrustAnchorInput) -> Swift.String? {
        guard let trustAnchorId = value.trustAnchorId else {
            return nil
        }
        return "/trustanchor/\(trustAnchorId.urlPercentEncoding())"
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["enabled"].write(value.enabled)
        try writer["managedPolicyArns"].writeList(value.managedPolicyArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["requireInstanceProperties"].write(value.requireInstanceProperties)
        try writer["roleArns"].writeList(value.roleArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionPolicy"].write(value.sessionPolicy)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTrustAnchorInput {

    static func write(value: CreateTrustAnchorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["notificationSettings"].writeList(value.notificationSettings, memberWritingClosure: RolesAnywhereClientTypes.NotificationSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source, with: RolesAnywhereClientTypes.Source.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImportCrlInput {

    static func write(value: ImportCrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crlData"].write(value.crlData)
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trustAnchorArn"].write(value.trustAnchorArn)
    }
}

extension PutAttributeMappingInput {

    static func write(value: PutAttributeMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateField"].write(value.certificateField)
        try writer["mappingRules"].writeList(value.mappingRules, memberWritingClosure: RolesAnywhereClientTypes.MappingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutNotificationSettingsInput {

    static func write(value: PutNotificationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationSettings"].writeList(value.notificationSettings, memberWritingClosure: RolesAnywhereClientTypes.NotificationSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trustAnchorId"].write(value.trustAnchorId)
    }
}

extension ResetNotificationSettingsInput {

    static func write(value: ResetNotificationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationSettingKeys"].writeList(value.notificationSettingKeys, memberWritingClosure: RolesAnywhereClientTypes.NotificationSettingKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trustAnchorId"].write(value.trustAnchorId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RolesAnywhereClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCrlInput {

    static func write(value: UpdateCrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crlData"].write(value.crlData)
        try writer["name"].write(value.name)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["managedPolicyArns"].writeList(value.managedPolicyArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["roleArns"].writeList(value.roleArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionPolicy"].write(value.sessionPolicy)
    }
}

extension UpdateTrustAnchorInput {

    static func write(value: UpdateTrustAnchorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["source"].write(value.source, with: RolesAnywhereClientTypes.Source.write(value:to:))
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension CreateTrustAnchorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension DeleteAttributeMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAttributeMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAttributeMappingOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension DeleteCrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension DeleteTrustAnchorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension DisableCrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

extension DisableProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension DisableTrustAnchorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension EnableCrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

extension EnableProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension EnableTrustAnchorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension GetCrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

extension GetProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension GetSubjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubjectOutput()
        value.subject = try reader["subject"].readIfPresent(with: RolesAnywhereClientTypes.SubjectDetail.read(from:))
        return value
    }
}

extension GetTrustAnchorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension ImportCrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

extension ListCrlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCrlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrlsOutput()
        value.crls = try reader["crls"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.CrlDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.profiles = try reader["profiles"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.ProfileDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSubjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.subjects = try reader["subjects"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.SubjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTrustAnchorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrustAnchorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrustAnchorsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.trustAnchors = try reader["trustAnchors"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutAttributeMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAttributeMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAttributeMappingOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension PutNotificationSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutNotificationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutNotificationSettingsOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension ResetNotificationSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetNotificationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetNotificationSettingsOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCrlOutput()
        value.crl = try reader["crl"].readIfPresent(with: RolesAnywhereClientTypes.CrlDetail.read(from:))
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.profile = try reader["profile"].readIfPresent(with: RolesAnywhereClientTypes.ProfileDetail.read(from:))
        return value
    }
}

extension UpdateTrustAnchorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTrustAnchorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTrustAnchorOutput()
        value.trustAnchor = try reader["trustAnchor"].readIfPresent(with: RolesAnywhereClientTypes.TrustAnchorDetail.read(from:))
        return value
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTrustAnchorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAttributeMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTrustAnchorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableCrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableTrustAnchorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableCrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableTrustAnchorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrustAnchorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportCrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCrlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrustAnchorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAttributeMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutNotificationSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetNotificationSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTrustAnchorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RolesAnywhereClientTypes.ProfileDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.ProfileDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.ProfileDetail()
        value.profileId = try reader["profileId"].readIfPresent()
        value.profileArn = try reader["profileArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.requireInstanceProperties = try reader["requireInstanceProperties"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.sessionPolicy = try reader["sessionPolicy"].readIfPresent()
        value.roleArns = try reader["roleArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedPolicyArns = try reader["managedPolicyArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.durationSeconds = try reader["durationSeconds"].readIfPresent()
        value.attributeMappings = try reader["attributeMappings"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.AttributeMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes.AttributeMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.AttributeMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.AttributeMapping()
        value.certificateField = try reader["certificateField"].readIfPresent()
        value.mappingRules = try reader["mappingRules"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.MappingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes.MappingRule {

    static func write(value: RolesAnywhereClientTypes.MappingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["specifier"].write(value.specifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.MappingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.MappingRule()
        value.specifier = try reader["specifier"].readIfPresent() ?? ""
        return value
    }
}

extension RolesAnywhereClientTypes.TrustAnchorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.TrustAnchorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.TrustAnchorDetail()
        value.trustAnchorId = try reader["trustAnchorId"].readIfPresent()
        value.trustAnchorArn = try reader["trustAnchorArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: RolesAnywhereClientTypes.Source.read(from:))
        value.enabled = try reader["enabled"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.notificationSettings = try reader["notificationSettings"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.NotificationSettingDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes.NotificationSettingDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.NotificationSettingDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.NotificationSettingDetail()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.event = try reader["event"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent()
        value.channel = try reader["channel"].readIfPresent()
        value.configuredBy = try reader["configuredBy"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes.Source {

    static func write(value: RolesAnywhereClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceData"].write(value.sourceData, with: RolesAnywhereClientTypes.SourceData.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.Source()
        value.sourceType = try reader["sourceType"].readIfPresent()
        value.sourceData = try reader["sourceData"].readIfPresent(with: RolesAnywhereClientTypes.SourceData.read(from:))
        return value
    }
}

extension RolesAnywhereClientTypes.SourceData {

    static func write(value: RolesAnywhereClientTypes.SourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .acmpcaarn(acmpcaarn):
                try writer["acmPcaArn"].write(acmpcaarn)
            case let .x509certificatedata(x509certificatedata):
                try writer["x509CertificateData"].write(x509certificatedata)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.SourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "x509CertificateData":
                return .x509certificatedata(try reader["x509CertificateData"].read())
            case "acmPcaArn":
                return .acmpcaarn(try reader["acmPcaArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RolesAnywhereClientTypes.CrlDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.CrlDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.CrlDetail()
        value.crlId = try reader["crlId"].readIfPresent()
        value.crlArn = try reader["crlArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.crlData = try reader["crlData"].readIfPresent()
        value.trustAnchorArn = try reader["trustAnchorArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension RolesAnywhereClientTypes.SubjectDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.SubjectDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.SubjectDetail()
        value.subjectArn = try reader["subjectArn"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.x509Subject = try reader["x509Subject"].readIfPresent()
        value.lastSeenAt = try reader["lastSeenAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.credentials = try reader["credentials"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.CredentialSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceProperties = try reader["instanceProperties"].readListIfPresent(memberReadingClosure: RolesAnywhereClientTypes.InstanceProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RolesAnywhereClientTypes.InstanceProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.InstanceProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.InstanceProperty()
        value.seenAt = try reader["seenAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.properties = try reader["properties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes.CredentialSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.CredentialSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.CredentialSummary()
        value.seenAt = try reader["seenAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serialNumber = try reader["serialNumber"].readIfPresent()
        value.issuer = try reader["issuer"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.x509CertificateData = try reader["x509CertificateData"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

extension RolesAnywhereClientTypes.SubjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.SubjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.SubjectSummary()
        value.subjectArn = try reader["subjectArn"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.x509Subject = try reader["x509Subject"].readIfPresent()
        value.lastSeenAt = try reader["lastSeenAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension RolesAnywhereClientTypes.Tag {

    static func write(value: RolesAnywhereClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RolesAnywhereClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RolesAnywhereClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension RolesAnywhereClientTypes.NotificationSetting {

    static func write(value: RolesAnywhereClientTypes.NotificationSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel)
        try writer["enabled"].write(value.enabled)
        try writer["event"].write(value.event)
        try writer["threshold"].write(value.threshold)
    }
}

extension RolesAnywhereClientTypes.NotificationSettingKey {

    static func write(value: RolesAnywhereClientTypes.NotificationSettingKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel)
        try writer["event"].write(value.event)
    }
}

public enum RolesAnywhereClientTypes {}
