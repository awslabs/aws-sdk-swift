//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension MemoryDBClientTypes {

    /// Returns the updates being applied to the ACL.
    public struct ACLPendingChanges: Swift.Sendable {
        /// A list of users being added to the ACL
        public var userNamesToAdd: [Swift.String]?
        /// A list of user names being removed from the ACL
        public var userNamesToRemove: [Swift.String]?

        public init(
            userNamesToAdd: [Swift.String]? = nil,
            userNamesToRemove: [Swift.String]? = nil
        )
        {
            self.userNamesToAdd = userNamesToAdd
            self.userNamesToRemove = userNamesToRemove
        }
    }
}

extension MemoryDBClientTypes {

    /// An Access Control List. You can authenticate users with Access Contol Lists. ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.
    public struct ACL: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the ACL
        public var arn: Swift.String?
        /// A list of clusters associated with the ACL.
        public var clusters: [Swift.String]?
        /// The minimum engine version supported for the ACL
        public var minimumEngineVersion: Swift.String?
        /// The name of the Access Control List
        public var name: Swift.String?
        /// A list of updates being applied to the ACL.
        public var pendingChanges: MemoryDBClientTypes.ACLPendingChanges?
        /// Indicates ACL status. Can be "creating", "active", "modifying", "deleting".
        public var status: Swift.String?
        /// The list of user names that belong to the ACL.
        public var userNames: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            clusters: [Swift.String]? = nil,
            minimumEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingChanges: MemoryDBClientTypes.ACLPendingChanges? = nil,
            status: Swift.String? = nil,
            userNames: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.clusters = clusters
            self.minimumEngineVersion = minimumEngineVersion
            self.name = name
            self.pendingChanges = pendingChanges
            self.status = status
            self.userNames = userNames
        }
    }
}

///
public struct ACLAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ACLAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ACLNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ACLNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ACLQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ACLQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MemoryDBClientTypes {

    /// The status of the ACL update
    public struct ACLsUpdateStatus: Swift.Sendable {
        /// A list of ACLs pending to be applied.
        public var aclToApply: Swift.String?

        public init(
            aclToApply: Swift.String? = nil
        )
        {
            self.aclToApply = aclToApply
        }
    }
}

///
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValue" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ServiceUpdateNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUpdateNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MemoryDBClientTypes {

    /// A request to apply a service update
    public struct ServiceUpdateRequest: Swift.Sendable {
        /// The unique ID of the service update
        public var serviceUpdateNameToApply: Swift.String?

        public init(
            serviceUpdateNameToApply: Swift.String? = nil
        )
        {
            self.serviceUpdateNameToApply = serviceUpdateNameToApply
        }
    }
}

public struct BatchUpdateClusterInput: Swift.Sendable {
    /// The cluster names to apply the updates.
    /// This member is required.
    public var clusterNames: [Swift.String]?
    /// The unique ID of the service update
    public var serviceUpdate: MemoryDBClientTypes.ServiceUpdateRequest?

    public init(
        clusterNames: [Swift.String]? = nil,
        serviceUpdate: MemoryDBClientTypes.ServiceUpdateRequest? = nil
    )
    {
        self.clusterNames = clusterNames
        self.serviceUpdate = serviceUpdate
    }
}

extension MemoryDBClientTypes {

    public enum AZStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiaz
        case singleaz
        case sdkUnknown(Swift.String)

        public static var allCases: [AZStatus] {
            return [
                .multiaz,
                .singleaz
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiaz: return "multiaz"
            case .singleaz: return "singleaz"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents the information required for client programs to connect to the cluster and its nodes.
    public struct Endpoint: Swift.Sendable {
        /// The DNS hostname of the node.
        public var address: Swift.String?
        /// The port number that the engine is listening on.
        public var port: Swift.Int

        public init(
            address: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.port = port
        }
    }
}

extension MemoryDBClientTypes {

    public enum DataTieringStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataTieringStatus] {
            return [
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .false: return "false"
            case .true: return "true"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents the progress of an online resharding operation.
    public struct SlotMigration: Swift.Sendable {
        /// The percentage of the slot migration that is complete.
        public var progressPercentage: Swift.Double

        public init(
            progressPercentage: Swift.Double = 0.0
        )
        {
            self.progressPercentage = progressPercentage
        }
    }
}

extension MemoryDBClientTypes {

    /// The status of the online resharding
    public struct ReshardingStatus: Swift.Sendable {
        /// The status of the online resharding slot migration
        public var slotMigration: MemoryDBClientTypes.SlotMigration?

        public init(
            slotMigration: MemoryDBClientTypes.SlotMigration? = nil
        )
        {
            self.slotMigration = slotMigration
        }
    }
}

extension MemoryDBClientTypes {

    public enum ServiceUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case inProgress
        case notApplied
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceUpdateStatus] {
            return [
                .complete,
                .inProgress,
                .notApplied,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "complete"
            case .inProgress: return "in-progress"
            case .notApplied: return "available"
            case .scheduled: return "scheduled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MemoryDBClientTypes {

    /// Update action that has yet to be processed for the corresponding apply/stop request
    public struct PendingModifiedServiceUpdate: Swift.Sendable {
        /// The unique ID of the service update
        public var serviceUpdateName: Swift.String?
        /// The status of the service update
        public var status: MemoryDBClientTypes.ServiceUpdateStatus?

        public init(
            serviceUpdateName: Swift.String? = nil,
            status: MemoryDBClientTypes.ServiceUpdateStatus? = nil
        )
        {
            self.serviceUpdateName = serviceUpdateName
            self.status = status
        }
    }
}

extension MemoryDBClientTypes {

    /// A list of updates being applied to the cluster
    public struct ClusterPendingUpdates: Swift.Sendable {
        /// A list of ACLs associated with the cluster that are being updated
        public var acLs: MemoryDBClientTypes.ACLsUpdateStatus?
        /// The status of an online resharding operation.
        public var resharding: MemoryDBClientTypes.ReshardingStatus?
        /// A list of service updates being applied to the cluster
        public var serviceUpdates: [MemoryDBClientTypes.PendingModifiedServiceUpdate]?

        public init(
            acLs: MemoryDBClientTypes.ACLsUpdateStatus? = nil,
            resharding: MemoryDBClientTypes.ReshardingStatus? = nil,
            serviceUpdates: [MemoryDBClientTypes.PendingModifiedServiceUpdate]? = nil
        )
        {
            self.acLs = acLs
            self.resharding = resharding
            self.serviceUpdates = serviceUpdates
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents a single security group and its status.
    public struct SecurityGroupMembership: Swift.Sendable {
        /// The identifier of the security group.
        public var securityGroupId: Swift.String?
        /// The status of the security group membership. The status changes whenever a security group is modified, or when the security groups assigned to a cluster are modified.
        public var status: Swift.String?

        public init(
            securityGroupId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.securityGroupId = securityGroupId
            self.status = status
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents an individual node within a cluster. Each node runs its own instance of the cluster's protocol-compliant caching software.
    public struct Node: Swift.Sendable {
        /// The Availability Zone in which the node resides
        public var availabilityZone: Swift.String?
        /// The date and time when the node was created.
        public var createTime: Foundation.Date?
        /// The hostname for connecting to this node.
        public var endpoint: MemoryDBClientTypes.Endpoint?
        /// The node identifier. A node name is a numeric identifier (0001, 0002, etc.). The combination of cluster name, shard name and node name uniquely identifies every node used in a customer's Amazon account.
        public var name: Swift.String?
        /// The status of the service update on the node
        public var status: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            endpoint: MemoryDBClientTypes.Endpoint? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.createTime = createTime
            self.endpoint = endpoint
            self.name = name
            self.status = status
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents a collection of nodes in a cluster. One node in the node group is the read/write primary node. All the other nodes are read-only Replica nodes.
    public struct Shard: Swift.Sendable {
        /// The name of the shard
        public var name: Swift.String?
        /// A list containing information about individual nodes within the shard
        public var nodes: [MemoryDBClientTypes.Node]?
        /// The number of nodes in the shard
        public var numberOfNodes: Swift.Int?
        /// The keyspace for this shard.
        public var slots: Swift.String?
        /// The current state of this replication group - creating, available, modifying, deleting.
        public var status: Swift.String?

        public init(
            name: Swift.String? = nil,
            nodes: [MemoryDBClientTypes.Node]? = nil,
            numberOfNodes: Swift.Int? = nil,
            slots: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.name = name
            self.nodes = nodes
            self.numberOfNodes = numberOfNodes
            self.slots = slots
            self.status = status
        }
    }
}

extension MemoryDBClientTypes {

    /// Contains all of the attributes of a specific cluster.
    public struct Cluster: Swift.Sendable {
        /// The name of the Access Control List associated with this cluster.
        public var aclName: Swift.String?
        /// The Amazon Resource Name (ARN) of the cluster.
        public var arn: Swift.String?
        /// When set to true, the cluster will automatically receive minor engine version upgrades after launch.
        public var autoMinorVersionUpgrade: Swift.Bool?
        /// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
        public var availabilityMode: MemoryDBClientTypes.AZStatus?
        /// The cluster's configuration endpoint
        public var clusterEndpoint: MemoryDBClientTypes.Endpoint?
        /// Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see [Data tiering](https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html).
        public var dataTiering: MemoryDBClientTypes.DataTieringStatus?
        /// A description of the cluster
        public var description: Swift.String?
        /// The Redis OSS or Valkey engine used by the cluster.
        public var engine: Swift.String?
        /// The engine patch version used by the cluster
        public var enginePatchVersion: Swift.String?
        /// The Redis engine version used by the cluster
        public var engineVersion: Swift.String?
        /// The ID of the KMS key used to encrypt the cluster
        public var kmsKeyId: Swift.String?
        /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.
        public var maintenanceWindow: Swift.String?
        /// The user-supplied name of the cluster. This identifier is a unique key that identifies a cluster.
        public var name: Swift.String?
        /// The cluster's node type
        public var nodeType: Swift.String?
        /// The number of shards in the cluster
        public var numberOfShards: Swift.Int?
        /// The name of the parameter group used by the cluster
        public var parameterGroupName: Swift.String?
        /// The status of the parameter group used by the cluster, for example 'active' or 'applying'.
        public var parameterGroupStatus: Swift.String?
        /// A group of settings that are currently being applied.
        public var pendingUpdates: MemoryDBClientTypes.ClusterPendingUpdates?
        /// A list of security groups used by the cluster
        public var securityGroups: [MemoryDBClientTypes.SecurityGroupMembership]?
        /// A list of shards that are members of the cluster.
        public var shards: [MemoryDBClientTypes.Shard]?
        /// The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
        public var snapshotRetentionLimit: Swift.Int?
        /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard. Example: 05:00-09:00 If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.
        public var snapshotWindow: Swift.String?
        /// The Amazon Resource Name (ARN) of the SNS notification topic
        public var snsTopicArn: Swift.String?
        /// The SNS topic must be in Active status to receive notifications
        public var snsTopicStatus: Swift.String?
        /// The status of the cluster. For example, Available, Updating, Creating.
        public var status: Swift.String?
        /// The name of the subnet group used by the cluster
        public var subnetGroupName: Swift.String?
        /// A flag to indicate if In-transit encryption is enabled
        public var tlsEnabled: Swift.Bool?

        public init(
            aclName: Swift.String? = nil,
            arn: Swift.String? = nil,
            autoMinorVersionUpgrade: Swift.Bool? = nil,
            availabilityMode: MemoryDBClientTypes.AZStatus? = nil,
            clusterEndpoint: MemoryDBClientTypes.Endpoint? = nil,
            dataTiering: MemoryDBClientTypes.DataTieringStatus? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            enginePatchVersion: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfShards: Swift.Int? = nil,
            parameterGroupName: Swift.String? = nil,
            parameterGroupStatus: Swift.String? = nil,
            pendingUpdates: MemoryDBClientTypes.ClusterPendingUpdates? = nil,
            securityGroups: [MemoryDBClientTypes.SecurityGroupMembership]? = nil,
            shards: [MemoryDBClientTypes.Shard]? = nil,
            snapshotRetentionLimit: Swift.Int? = nil,
            snapshotWindow: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            snsTopicStatus: Swift.String? = nil,
            status: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            tlsEnabled: Swift.Bool? = nil
        )
        {
            self.aclName = aclName
            self.arn = arn
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityMode = availabilityMode
            self.clusterEndpoint = clusterEndpoint
            self.dataTiering = dataTiering
            self.description = description
            self.engine = engine
            self.enginePatchVersion = enginePatchVersion
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.nodeType = nodeType
            self.numberOfShards = numberOfShards
            self.parameterGroupName = parameterGroupName
            self.parameterGroupStatus = parameterGroupStatus
            self.pendingUpdates = pendingUpdates
            self.securityGroups = securityGroups
            self.shards = shards
            self.snapshotRetentionLimit = snapshotRetentionLimit
            self.snapshotWindow = snapshotWindow
            self.snsTopicArn = snsTopicArn
            self.snsTopicStatus = snsTopicStatus
            self.status = status
            self.subnetGroupName = subnetGroupName
            self.tlsEnabled = tlsEnabled
        }
    }
}

extension MemoryDBClientTypes {

    /// A cluster whose updates have failed
    public struct UnprocessedCluster: Swift.Sendable {
        /// The name of the cluster
        public var clusterName: Swift.String?
        /// The error message associated with the update failure
        public var errorMessage: Swift.String?
        /// The error type associated with the update failure
        public var errorType: Swift.String?

        public init(
            clusterName: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil
        )
        {
            self.clusterName = clusterName
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }
}

public struct BatchUpdateClusterOutput: Swift.Sendable {
    /// The list of clusters that have been updated.
    public var processedClusters: [MemoryDBClientTypes.Cluster]?
    /// The list of clusters where updates have not been applied.
    public var unprocessedClusters: [MemoryDBClientTypes.UnprocessedCluster]?

    public init(
        processedClusters: [MemoryDBClientTypes.Cluster]? = nil,
        unprocessedClusters: [MemoryDBClientTypes.UnprocessedCluster]? = nil
    )
    {
        self.processedClusters = processedClusters
        self.unprocessedClusters = unprocessedClusters
    }
}

///
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombination" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidSnapshotStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSnapshotState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ServiceLinkedRoleNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLinkedRoleNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SnapshotAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotAlreadyExistsFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SnapshotNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SnapshotQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotQuotaExceededFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct TagQuotaPerResourceExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagQuotaPerResourceExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MemoryDBClientTypes {

    /// A tag that can be added to an MemoryDB resource. Tags are composed of a Key/Value pair. You can use tags to categorize and track all your MemoryDB resources. When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. A tag with a null Value is permitted. For more information, see [Tagging your MemoryDB resources](https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging-resources.html)
    public struct Tag: Swift.Sendable {
        /// The key for the tag. May not be null.
        public var key: Swift.String?
        /// The tag's value. May be null.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CopySnapshotInput: Swift.Sendable {
    /// The ID of the KMS key used to encrypt the target snapshot.
    public var kmsKeyId: Swift.String?
    /// The name of an existing snapshot from which to make a copy.
    /// This member is required.
    public var sourceSnapshotName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// The Amazon S3 bucket to which the snapshot is exported. This parameter is used only when exporting a snapshot for external access. When using this parameter to export a snapshot, be sure MemoryDB has the needed permissions to this S3 bucket. For more information, see [Step 2: Grant MemoryDB Access to Your Amazon S3 Bucket](https://docs.aws.amazon.com/MemoryDB/latest/devguide/snapshots-exporting.html).
    public var targetBucket: Swift.String?
    /// A name for the snapshot copy. MemoryDB does not permit overwriting a snapshot, therefore this name must be unique within its context - MemoryDB or an Amazon S3 bucket if exporting.
    /// This member is required.
    public var targetSnapshotName: Swift.String?

    public init(
        kmsKeyId: Swift.String? = nil,
        sourceSnapshotName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        targetBucket: Swift.String? = nil,
        targetSnapshotName: Swift.String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.sourceSnapshotName = sourceSnapshotName
        self.tags = tags
        self.targetBucket = targetBucket
        self.targetSnapshotName = targetSnapshotName
    }
}

extension MemoryDBClientTypes {

    /// Shard configuration options. Each shard configuration has the following: Slots and ReplicaCount.
    public struct ShardConfiguration: Swift.Sendable {
        /// The number of read replica nodes in this shard.
        public var replicaCount: Swift.Int?
        /// A string that specifies the keyspace for a particular node group. Keyspaces range from 0 to 16,383. The string is in the format startkey-endkey.
        public var slots: Swift.String?

        public init(
            replicaCount: Swift.Int? = nil,
            slots: Swift.String? = nil
        )
        {
            self.replicaCount = replicaCount
            self.slots = slots
        }
    }
}

extension MemoryDBClientTypes {

    /// Provides details of a shard in a snapshot
    public struct ShardDetail: Swift.Sendable {
        /// The configuration details of the shard
        public var configuration: MemoryDBClientTypes.ShardConfiguration?
        /// The name of the shard
        public var name: Swift.String?
        /// The size of the shard's snapshot
        public var size: Swift.String?
        /// The date and time that the shard's snapshot was created
        public var snapshotCreationTime: Foundation.Date?

        public init(
            configuration: MemoryDBClientTypes.ShardConfiguration? = nil,
            name: Swift.String? = nil,
            size: Swift.String? = nil,
            snapshotCreationTime: Foundation.Date? = nil
        )
        {
            self.configuration = configuration
            self.name = name
            self.size = size
            self.snapshotCreationTime = snapshotCreationTime
        }
    }
}

extension MemoryDBClientTypes {

    /// A list of cluster configuration options.
    public struct ClusterConfiguration: Swift.Sendable {
        /// The description of the cluster configuration
        public var description: Swift.String?
        /// The configuration for the Redis OSS or Valkey engine used by the cluster.
        public var engine: Swift.String?
        /// The engine version used by the cluster
        public var engineVersion: Swift.String?
        /// The specified maintenance window for the cluster
        public var maintenanceWindow: Swift.String?
        /// The name of the cluster
        public var name: Swift.String?
        /// The node type used for the cluster
        public var nodeType: Swift.String?
        /// The number of shards in the cluster
        public var numShards: Swift.Int?
        /// The name of parameter group used by the cluster
        public var parameterGroupName: Swift.String?
        /// The port used by the cluster
        public var port: Swift.Int?
        /// The list of shards in the cluster
        public var shards: [MemoryDBClientTypes.ShardDetail]?
        /// The snapshot retention limit set by the cluster
        public var snapshotRetentionLimit: Swift.Int?
        /// The snapshot window set by the cluster
        public var snapshotWindow: Swift.String?
        /// The name of the subnet group used by the cluster
        public var subnetGroupName: Swift.String?
        /// The Amazon Resource Name (ARN) of the SNS notification topic for the cluster
        public var topicArn: Swift.String?
        /// The ID of the VPC the cluster belongs to
        public var vpcId: Swift.String?

        public init(
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numShards: Swift.Int? = nil,
            parameterGroupName: Swift.String? = nil,
            port: Swift.Int? = nil,
            shards: [MemoryDBClientTypes.ShardDetail]? = nil,
            snapshotRetentionLimit: Swift.Int? = nil,
            snapshotWindow: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            topicArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.nodeType = nodeType
            self.numShards = numShards
            self.parameterGroupName = parameterGroupName
            self.port = port
            self.shards = shards
            self.snapshotRetentionLimit = snapshotRetentionLimit
            self.snapshotWindow = snapshotWindow
            self.subnetGroupName = subnetGroupName
            self.topicArn = topicArn
            self.vpcId = vpcId
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
    public struct Snapshot: Swift.Sendable {
        /// The ARN (Amazon Resource Name) of the snapshot.
        public var arn: Swift.String?
        /// The configuration of the cluster from which the snapshot was taken
        public var clusterConfiguration: MemoryDBClientTypes.ClusterConfiguration?
        /// Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see [Data tiering](https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html).
        public var dataTiering: MemoryDBClientTypes.DataTieringStatus?
        /// The ID of the KMS key used to encrypt the snapshot.
        public var kmsKeyId: Swift.String?
        /// The name of the snapshot
        public var name: Swift.String?
        /// Indicates whether the snapshot is from an automatic backup (automated) or was created manually (manual).
        public var source: Swift.String?
        /// The status of the snapshot. Valid values: creating | available | restoring | copying | deleting.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            clusterConfiguration: MemoryDBClientTypes.ClusterConfiguration? = nil,
            dataTiering: MemoryDBClientTypes.DataTieringStatus? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            source: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.clusterConfiguration = clusterConfiguration
            self.dataTiering = dataTiering
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.source = source
            self.status = status
        }
    }
}

public struct CopySnapshotOutput: Swift.Sendable {
    /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
    public var snapshot: MemoryDBClientTypes.Snapshot?

    public init(
        snapshot: MemoryDBClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

///
public struct DefaultUserRequired: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DefaultUserRequired" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct DuplicateUserNameFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateUserName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct UserNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateACLInput: Swift.Sendable {
    /// The name of the Access Control List.
    /// This member is required.
    public var aclName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// The list of users that belong to the Access Control List.
    public var userNames: [Swift.String]?

    public init(
        aclName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        userNames: [Swift.String]? = nil
    )
    {
        self.aclName = aclName
        self.tags = tags
        self.userNames = userNames
    }
}

public struct CreateACLOutput: Swift.Sendable {
    /// The newly-created Access Control List.
    public var acl: MemoryDBClientTypes.ACL?

    public init(
        acl: MemoryDBClientTypes.ACL? = nil
    )
    {
        self.acl = acl
    }
}

///
public struct ClusterAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ClusterQuotaForCustomerExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterQuotaForCustomerExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InsufficientClusterCapacityFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientClusterCapacity" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidACLStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidACLState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidCredentialsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCredentialsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidVPCNetworkStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidVPCNetworkStateFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct NodeQuotaForClusterExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NodeQuotaForClusterExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct NodeQuotaForCustomerExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NodeQuotaForCustomerExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ParameterGroupNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterGroupNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ShardsPerClusterQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ShardsPerClusterQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SubnetGroupNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateClusterInput: Swift.Sendable {
    /// The name of the Access Control List to associate with the cluster.
    /// This member is required.
    public var aclName: Swift.String?
    /// When set to true, the cluster will automatically receive minor engine version upgrades after launch.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The name of the cluster. This value must be unique as it also serves as the cluster identifier.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see [Data tiering](https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html).
    public var dataTiering: Swift.Bool?
    /// An optional description of the cluster.
    public var description: Swift.String?
    /// The name of the engine to be used for the nodes in this cluster. The value must be set to either Redis or Valkey.
    public var engine: Swift.String?
    /// The version number of the engine to be used for the cluster.
    public var engineVersion: Swift.String?
    /// The ID of the KMS key used to encrypt the cluster.
    public var kmsKeyId: Swift.String?
    /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:
    ///
    /// * sun
    ///
    /// * mon
    ///
    /// * tue
    ///
    /// * wed
    ///
    /// * thu
    ///
    /// * fri
    ///
    /// * sat
    ///
    ///
    /// Example: sun:23:00-mon:01:30
    public var maintenanceWindow: Swift.String?
    /// The compute and memory capacity of the nodes in the cluster.
    /// This member is required.
    public var nodeType: Swift.String?
    /// The number of replicas to apply to each shard. The default value is 1. The maximum is 5.
    public var numReplicasPerShard: Swift.Int?
    /// The number of shards the cluster will contain. The default value is 1.
    public var numShards: Swift.Int?
    /// The name of the parameter group associated with the cluster.
    public var parameterGroupName: Swift.String?
    /// The port number on which each of the nodes accepts connections.
    public var port: Swift.Int?
    /// A list of security group names to associate with this cluster.
    public var securityGroupIds: [Swift.String]?
    /// A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.
    public var snapshotArns: [Swift.String]?
    /// The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.
    public var snapshotName: Swift.String?
    /// The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
    public var snapshotRetentionLimit: Swift.Int?
    /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard. Example: 05:00-09:00 If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.
    public var snapshotWindow: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.
    public var snsTopicArn: Swift.String?
    /// The name of the subnet group to be used for the cluster.
    public var subnetGroupName: Swift.String?
    /// A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// A flag to enable in-transit encryption on the cluster.
    public var tlsEnabled: Swift.Bool?

    public init(
        aclName: Swift.String? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        clusterName: Swift.String? = nil,
        dataTiering: Swift.Bool? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        maintenanceWindow: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        numReplicasPerShard: Swift.Int? = nil,
        numShards: Swift.Int? = nil,
        parameterGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snapshotArns: [Swift.String]? = nil,
        snapshotName: Swift.String? = nil,
        snapshotRetentionLimit: Swift.Int? = nil,
        snapshotWindow: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        tlsEnabled: Swift.Bool? = nil
    )
    {
        self.aclName = aclName
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.clusterName = clusterName
        self.dataTiering = dataTiering
        self.description = description
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.maintenanceWindow = maintenanceWindow
        self.nodeType = nodeType
        self.numReplicasPerShard = numReplicasPerShard
        self.numShards = numShards
        self.parameterGroupName = parameterGroupName
        self.port = port
        self.securityGroupIds = securityGroupIds
        self.snapshotArns = snapshotArns
        self.snapshotName = snapshotName
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.snapshotWindow = snapshotWindow
        self.snsTopicArn = snsTopicArn
        self.subnetGroupName = subnetGroupName
        self.tags = tags
        self.tlsEnabled = tlsEnabled
    }
}

public struct CreateClusterOutput: Swift.Sendable {
    /// The newly-created cluster.
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

///
public struct InvalidParameterGroupStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterGroupState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ParameterGroupAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterGroupAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ParameterGroupQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterGroupQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateParameterGroupInput: Swift.Sendable {
    /// An optional description of the parameter group.
    public var description: Swift.String?
    /// The name of the parameter group family that the parameter group can be used with.
    /// This member is required.
    public var family: Swift.String?
    /// The name of the parameter group.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        family: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.family = family
        self.parameterGroupName = parameterGroupName
        self.tags = tags
    }
}

extension MemoryDBClientTypes {

    /// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
    public struct ParameterGroup: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the parameter group
        public var arn: Swift.String?
        /// A description of the parameter group
        public var description: Swift.String?
        /// The name of the parameter group family that this parameter group is compatible with.
        public var family: Swift.String?
        /// The name of the parameter group
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            family: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.family = family
            self.name = name
        }
    }
}

public struct CreateParameterGroupOutput: Swift.Sendable {
    /// The newly-created parameter group.
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

///
public struct ClusterNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidClusterStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClusterState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateSnapshotInput: Swift.Sendable {
    /// The snapshot is created from this cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The ID of the KMS key used to encrypt the snapshot.
    public var kmsKeyId: Swift.String?
    /// A name for the snapshot being created.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        clusterName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.clusterName = clusterName
        self.kmsKeyId = kmsKeyId
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

public struct CreateSnapshotOutput: Swift.Sendable {
    /// The newly-created snapshot.
    public var snapshot: MemoryDBClientTypes.Snapshot?

    public init(
        snapshot: MemoryDBClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

///
public struct InvalidSubnet: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnet" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SubnetGroupAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SubnetGroupQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SubnetNotAllowedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetNotAllowedFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct SubnetQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetQuotaExceededFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateSubnetGroupInput: Swift.Sendable {
    /// A description for the subnet group.
    public var description: Swift.String?
    /// The name of the subnet group.
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// A list of VPC subnet IDs for the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension MemoryDBClientTypes {

    /// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
    public struct AvailabilityZone: Swift.Sendable {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents the subnet associated with a cluster. This parameter refers to subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with MemoryDB.
    public struct Subnet: Swift.Sendable {
        /// The Availability Zone where the subnet resides
        public var availabilityZone: MemoryDBClientTypes.AvailabilityZone?
        /// The unique identifier for the subnet.
        public var identifier: Swift.String?

        public init(
            availabilityZone: MemoryDBClientTypes.AvailabilityZone? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.identifier = identifier
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents the output of one of the following operations:
    ///
    /// * CreateSubnetGroup
    ///
    /// * UpdateSubnetGroup
    ///
    ///
    /// A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.
    public struct SubnetGroup: Swift.Sendable {
        /// The ARN (Amazon Resource Name) of the subnet group.
        public var arn: Swift.String?
        /// A description of the subnet group
        public var description: Swift.String?
        /// The name of the subnet group
        public var name: Swift.String?
        /// A list of subnets associated with the subnet group.
        public var subnets: [MemoryDBClientTypes.Subnet]?
        /// The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            subnets: [MemoryDBClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }
}

public struct CreateSubnetGroupOutput: Swift.Sendable {
    /// The newly-created subnet group
    public var subnetGroup: MemoryDBClientTypes.SubnetGroup?

    public init(
        subnetGroup: MemoryDBClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

///
public struct UserAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct UserQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MemoryDBClientTypes {

    public enum InputAuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [InputAuthenticationType] {
            return [
                .iam,
                .password
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "iam"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MemoryDBClientTypes {

    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
    public struct AuthenticationMode: Swift.Sendable {
        /// The password(s) used for authentication
        public var passwords: [Swift.String]?
        /// Indicates whether the user requires a password to authenticate. All newly-created users require a password.
        public var type: MemoryDBClientTypes.InputAuthenticationType?

        public init(
            passwords: [Swift.String]? = nil,
            type: MemoryDBClientTypes.InputAuthenticationType? = nil
        )
        {
            self.passwords = passwords
            self.type = type
        }
    }
}

public struct CreateUserInput: Swift.Sendable {
    /// Access permissions string used for this user.
    /// This member is required.
    public var accessString: Swift.String?
    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate.
    /// This member is required.
    public var authenticationMode: MemoryDBClientTypes.AuthenticationMode?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// The name of the user. This value must be unique as it also serves as the user identifier.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        accessString: Swift.String? = nil,
        authenticationMode: MemoryDBClientTypes.AuthenticationMode? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessString = accessString
        self.authenticationMode = authenticationMode
        self.tags = tags
        self.userName = userName
    }
}

extension MemoryDBClientTypes {

    public enum AuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case noPassword
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .iam,
                .noPassword,
                .password
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "iam"
            case .noPassword: return "no-password"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MemoryDBClientTypes {

    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
    public struct Authentication: Swift.Sendable {
        /// The number of passwords belonging to the user. The maximum is two.
        public var passwordCount: Swift.Int?
        /// Indicates whether the user requires a password to authenticate.
        public var type: MemoryDBClientTypes.AuthenticationType?

        public init(
            passwordCount: Swift.Int? = nil,
            type: MemoryDBClientTypes.AuthenticationType? = nil
        )
        {
            self.passwordCount = passwordCount
            self.type = type
        }
    }
}

extension MemoryDBClientTypes {

    /// You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.
    public struct User: Swift.Sendable {
        /// Access permissions string used for this user.
        public var accessString: Swift.String?
        /// The names of the Access Control Lists to which the user belongs
        public var aclNames: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the user.
        public var arn: Swift.String?
        /// Denotes whether the user requires a password to authenticate.
        public var authentication: MemoryDBClientTypes.Authentication?
        /// The minimum engine version supported for the user
        public var minimumEngineVersion: Swift.String?
        /// The name of the user
        public var name: Swift.String?
        /// Indicates the user status. Can be "active", "modifying" or "deleting".
        public var status: Swift.String?

        public init(
            accessString: Swift.String? = nil,
            aclNames: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            authentication: MemoryDBClientTypes.Authentication? = nil,
            minimumEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.accessString = accessString
            self.aclNames = aclNames
            self.arn = arn
            self.authentication = authentication
            self.minimumEngineVersion = minimumEngineVersion
            self.name = name
            self.status = status
        }
    }
}

public struct CreateUserOutput: Swift.Sendable {
    /// The newly-created user.
    public var user: MemoryDBClientTypes.User?

    public init(
        user: MemoryDBClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct DeleteACLInput: Swift.Sendable {
    /// The name of the Access Control List to delete
    /// This member is required.
    public var aclName: Swift.String?

    public init(
        aclName: Swift.String? = nil
    )
    {
        self.aclName = aclName
    }
}

public struct DeleteACLOutput: Swift.Sendable {
    /// The Access Control List object that has been deleted.
    public var acl: MemoryDBClientTypes.ACL?

    public init(
        acl: MemoryDBClientTypes.ACL? = nil
    )
    {
        self.acl = acl
    }
}

public struct DeleteClusterInput: Swift.Sendable {
    /// The name of the cluster to be deleted
    /// This member is required.
    public var clusterName: Swift.String?
    /// The user-supplied name of a final cluster snapshot. This is the unique name that identifies the snapshot. MemoryDB creates the snapshot, and then deletes the cluster immediately afterward.
    public var finalSnapshotName: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        finalSnapshotName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.finalSnapshotName = finalSnapshotName
    }
}

public struct DeleteClusterOutput: Swift.Sendable {
    /// The cluster object that has been deleted
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

public struct DeleteParameterGroupInput: Swift.Sendable {
    /// The name of the parameter group to delete.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init(
        parameterGroupName: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

public struct DeleteParameterGroupOutput: Swift.Sendable {
    /// The parameter group that has been deleted.
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

public struct DeleteSnapshotInput: Swift.Sendable {
    /// The name of the snapshot to delete
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        snapshotName: Swift.String? = nil
    )
    {
        self.snapshotName = snapshotName
    }
}

public struct DeleteSnapshotOutput: Swift.Sendable {
    /// The snapshot object that has been deleted.
    public var snapshot: MemoryDBClientTypes.Snapshot?

    public init(
        snapshot: MemoryDBClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

///
public struct SubnetGroupInUseFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteSubnetGroupInput: Swift.Sendable {
    /// The name of the subnet group to delete
    /// This member is required.
    public var subnetGroupName: Swift.String?

    public init(
        subnetGroupName: Swift.String? = nil
    )
    {
        self.subnetGroupName = subnetGroupName
    }
}

public struct DeleteSubnetGroupOutput: Swift.Sendable {
    /// The subnet group object that has been deleted.
    public var subnetGroup: MemoryDBClientTypes.SubnetGroup?

    public init(
        subnetGroup: MemoryDBClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

///
public struct InvalidUserStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteUserInput: Swift.Sendable {
    /// The name of the user to delete
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

public struct DeleteUserOutput: Swift.Sendable {
    /// The user object that has been deleted.
    public var user: MemoryDBClientTypes.User?

    public init(
        user: MemoryDBClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct DescribeACLsInput: Swift.Sendable {
    /// The name of the ACL
    public var aclName: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        aclName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aclName = aclName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeACLsOutput: Swift.Sendable {
    /// The list of ACLs
    public var acLs: [MemoryDBClientTypes.ACL]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        acLs: [MemoryDBClientTypes.ACL]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acLs = acLs
        self.nextToken = nextToken
    }
}

public struct DescribeClustersInput: Swift.Sendable {
    /// The name of the cluster
    public var clusterName: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// An optional flag that can be included in the request to retrieve information about the individual shard(s).
    public var showShardDetails: Swift.Bool?

    public init(
        clusterName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        showShardDetails: Swift.Bool? = nil
    )
    {
        self.clusterName = clusterName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.showShardDetails = showShardDetails
    }
}

public struct DescribeClustersOutput: Swift.Sendable {
    /// A list of clusters
    public var clusters: [MemoryDBClientTypes.Cluster]?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        clusters: [MemoryDBClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

public struct DescribeEngineVersionsInput: Swift.Sendable {
    /// If true, specifies that only the default version of the specified engine or engine and major version combination is to be returned.
    public var defaultOnly: Swift.Bool?
    /// The engine version to return. Valid values are either valkey or redis.
    public var engine: Swift.String?
    /// The engine version.
    public var engineVersion: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of a specific parameter group family to return details for.
    public var parameterGroupFamily: Swift.String?

    public init(
        defaultOnly: Swift.Bool? = false,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupFamily: Swift.String? = nil
    )
    {
        self.defaultOnly = defaultOnly
        self.engine = engine
        self.engineVersion = engineVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupFamily = parameterGroupFamily
    }
}

extension MemoryDBClientTypes {

    /// Provides details of the engine version.
    public struct EngineVersionInfo: Swift.Sendable {
        /// The version of the Redis OSS or Valkey engine used by the cluster.
        public var engine: Swift.String?
        /// The patched engine version
        public var enginePatchVersion: Swift.String?
        /// The engine version
        public var engineVersion: Swift.String?
        /// Specifies the name of the parameter group family to which the engine default parameters apply.
        public var parameterGroupFamily: Swift.String?

        public init(
            engine: Swift.String? = nil,
            enginePatchVersion: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            parameterGroupFamily: Swift.String? = nil
        )
        {
            self.engine = engine
            self.enginePatchVersion = enginePatchVersion
            self.engineVersion = engineVersion
            self.parameterGroupFamily = parameterGroupFamily
        }
    }
}

public struct DescribeEngineVersionsOutput: Swift.Sendable {
    /// A list of engine version details. Each element in the list contains detailed information about one engine version.
    public var engineVersions: [MemoryDBClientTypes.EngineVersionInfo]?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        engineVersions: [MemoryDBClientTypes.EngineVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

extension MemoryDBClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acl
        case cluster
        case node
        case parameterGroup
        case subnetGroup
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .acl,
                .cluster,
                .node,
                .parameterGroup,
                .subnetGroup,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acl: return "acl"
            case .cluster: return "cluster"
            case .node: return "node"
            case .parameterGroup: return "parameter-group"
            case .subnetGroup: return "subnet-group"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeEventsInput: Swift.Sendable {
    /// The number of minutes worth of events to retrieve.
    public var duration: Swift.Int?
    /// The end of the time interval for which to retrieve events, specified in ISO 8601 format. Example: 2017-03-30T07:03:49.555Z
    public var endTime: Foundation.Date?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The identifier of the event source for which events are returned. If not specified, all sources are included in the response.
    public var sourceName: Swift.String?
    /// The event source to retrieve events for. If no value is specified, all events are returned.
    public var sourceType: MemoryDBClientTypes.SourceType?
    /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format. Example: 2017-03-30T07:03:49.555Z
    public var startTime: Foundation.Date?

    public init(
        duration: Swift.Int? = nil,
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceType: MemoryDBClientTypes.SourceType? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension MemoryDBClientTypes {

    /// Represents a single occurrence of something interesting within the system. Some examples of events are creating a cluster or adding or removing a node.
    public struct Event: Swift.Sendable {
        /// The date and time when the event occurred.
        public var date: Foundation.Date?
        /// The text of the event.
        public var message: Swift.String?
        /// The name for the source of the event. For example, if the event occurred at the cluster level, the identifier would be the name of the cluster.
        public var sourceName: Swift.String?
        /// Specifies the origin of this event - a cluster, a parameter group, a security group, etc.
        public var sourceType: MemoryDBClientTypes.SourceType?

        public init(
            date: Foundation.Date? = nil,
            message: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: MemoryDBClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.message = message
            self.sourceName = sourceName
            self.sourceType = sourceType
        }
    }
}

public struct DescribeEventsOutput: Swift.Sendable {
    /// A list of events. Each element in the list contains detailed information about one event.
    public var events: [MemoryDBClientTypes.Event]?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        events: [MemoryDBClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

public struct DescribeParameterGroupsInput: Swift.Sendable {
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of a specific parameter group to return details for.
    public var parameterGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
    }
}

public struct DescribeParameterGroupsOutput: Swift.Sendable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of parameter groups. Each element in the list contains detailed information about one parameter group.
    public var parameterGroups: [MemoryDBClientTypes.ParameterGroup]?

    public init(
        nextToken: Swift.String? = nil,
        parameterGroups: [MemoryDBClientTypes.ParameterGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }
}

public struct DescribeParametersInput: Swift.Sendable {
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// he name of a specific parameter group to return details for.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
    }
}

extension MemoryDBClientTypes {

    /// Describes an individual setting that controls some aspect of MemoryDB behavior.
    public struct Parameter: Swift.Sendable {
        /// The valid range of values for the parameter.
        public var allowedValues: Swift.String?
        /// The parameter's data type
        public var dataType: Swift.String?
        /// A description of the parameter
        public var description: Swift.String?
        /// The earliest engine version to which the parameter can apply.
        public var minimumEngineVersion: Swift.String?
        /// The name of the parameter
        public var name: Swift.String?
        /// The value of the parameter
        public var value: Swift.String?

        public init(
            allowedValues: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            minimumEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.dataType = dataType
            self.description = description
            self.minimumEngineVersion = minimumEngineVersion
            self.name = name
            self.value = value
        }
    }
}

public struct DescribeParametersOutput: Swift.Sendable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of parameters specific to a particular parameter group. Each element in the list contains detailed information about one parameter.
    public var parameters: [MemoryDBClientTypes.Parameter]?

    public init(
        nextToken: Swift.String? = nil,
        parameters: [MemoryDBClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

/// The requested node does not exist.
public struct ReservedNodeNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodeNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeReservedNodesInput: Swift.Sendable {
    /// The duration filter value, specified in years or seconds. Use this parameter to show only reservations for this duration.
    public var duration: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The node type filter value. Use this parameter to show only those reservations matching the specified node type. For more information, see [Supported node types](https://docs.aws.amazon.com/memorydb/latest/devguide/nodes.reserved.html#reserved-nodes-supported).
    public var nodeType: Swift.String?
    /// The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type. Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    public var offeringType: Swift.String?
    /// The reserved node identifier filter value. Use this parameter to show only the reservation that matches the specified reservation ID.
    public var reservationId: Swift.String?
    /// The offering identifier filter value. Use this parameter to show only purchased reservations matching the specified offering identifier.
    public var reservedNodesOfferingId: Swift.String?

    public init(
        duration: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        offeringType: Swift.String? = nil,
        reservationId: Swift.String? = nil,
        reservedNodesOfferingId: Swift.String? = nil
    )
    {
        self.duration = duration
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.nodeType = nodeType
        self.offeringType = offeringType
        self.reservationId = reservationId
        self.reservedNodesOfferingId = reservedNodesOfferingId
    }
}

extension MemoryDBClientTypes {

    /// The recurring charge to run this reserved node.
    public struct RecurringCharge: Swift.Sendable {
        /// The amount of the recurring charge to run this reserved node.
        public var recurringChargeAmount: Swift.Double
        /// The frequency of the recurring price charged to run this reserved node.
        public var recurringChargeFrequency: Swift.String?

        public init(
            recurringChargeAmount: Swift.Double = 0.0,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }
}

extension MemoryDBClientTypes {

    /// Represents the output of a PurchaseReservedNodesOffering operation.
    public struct ReservedNode: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the reserved node.
        public var arn: Swift.String?
        /// The duration of the reservation in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this reserved node.
        public var fixedPrice: Swift.Double
        /// The number of nodes that have been reserved.
        public var nodeCount: Swift.Int
        /// The node type for the reserved nodes.
        public var nodeType: Swift.String?
        /// The offering type of this reserved node.
        public var offeringType: Swift.String?
        /// The recurring price charged to run this reserved node.
        public var recurringCharges: [MemoryDBClientTypes.RecurringCharge]?
        /// A customer-specified identifier to track this reservation.
        public var reservationId: Swift.String?
        /// The ID of the reserved node offering to purchase.
        public var reservedNodesOfferingId: Swift.String?
        /// The time the reservation started.
        public var startTime: Foundation.Date?
        /// The state of the reserved node.
        public var state: Swift.String?

        public init(
            arn: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            nodeCount: Swift.Int = 0,
            nodeType: Swift.String? = nil,
            offeringType: Swift.String? = nil,
            recurringCharges: [MemoryDBClientTypes.RecurringCharge]? = nil,
            reservationId: Swift.String? = nil,
            reservedNodesOfferingId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: Swift.String? = nil
        )
        {
            self.arn = arn
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.nodeCount = nodeCount
            self.nodeType = nodeType
            self.offeringType = offeringType
            self.recurringCharges = recurringCharges
            self.reservationId = reservationId
            self.reservedNodesOfferingId = reservedNodesOfferingId
            self.startTime = startTime
            self.state = state
        }
    }
}

public struct DescribeReservedNodesOutput: Swift.Sendable {
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// Returns information about reserved nodes for this account, or about a specified reserved node.
    public var reservedNodes: [MemoryDBClientTypes.ReservedNode]?

    public init(
        nextToken: Swift.String? = nil,
        reservedNodes: [MemoryDBClientTypes.ReservedNode]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedNodes = reservedNodes
    }
}

/// The requested node offering does not exist.
public struct ReservedNodesOfferingNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodesOfferingNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeReservedNodesOfferingsInput: Swift.Sendable {
    /// Duration filter value, specified in years or seconds. Use this parameter to show only reservations for a given duration.
    public var duration: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The node type for the reserved nodes. For more information, see [Supported node types](https://docs.aws.amazon.com/memorydb/latest/devguide/nodes.reserved.html#reserved-nodes-supported).
    public var nodeType: Swift.String?
    /// The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type. Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    public var offeringType: Swift.String?
    /// The offering identifier filter value. Use this parameter to show only the available offering that matches the specified reservation identifier.
    public var reservedNodesOfferingId: Swift.String?

    public init(
        duration: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        offeringType: Swift.String? = nil,
        reservedNodesOfferingId: Swift.String? = nil
    )
    {
        self.duration = duration
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.nodeType = nodeType
        self.offeringType = offeringType
        self.reservedNodesOfferingId = reservedNodesOfferingId
    }
}

extension MemoryDBClientTypes {

    /// The offering type of this node.
    public struct ReservedNodesOffering: Swift.Sendable {
        /// The duration of the reservation in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this reserved node.
        public var fixedPrice: Swift.Double
        /// The node type for the reserved nodes. For more information, see [Supported node types](https://docs.aws.amazon.com/memorydb/latest/devguide/nodes.reserved.html#reserved-nodes-supported).
        public var nodeType: Swift.String?
        /// The offering type of this reserved node.
        public var offeringType: Swift.String?
        /// The recurring price charged to run this reserved node.
        public var recurringCharges: [MemoryDBClientTypes.RecurringCharge]?
        /// The offering identifier.
        public var reservedNodesOfferingId: Swift.String?

        public init(
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            nodeType: Swift.String? = nil,
            offeringType: Swift.String? = nil,
            recurringCharges: [MemoryDBClientTypes.RecurringCharge]? = nil,
            reservedNodesOfferingId: Swift.String? = nil
        )
        {
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.nodeType = nodeType
            self.offeringType = offeringType
            self.recurringCharges = recurringCharges
            self.reservedNodesOfferingId = reservedNodesOfferingId
        }
    }
}

public struct DescribeReservedNodesOfferingsOutput: Swift.Sendable {
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// Lists available reserved node offerings.
    public var reservedNodesOfferings: [MemoryDBClientTypes.ReservedNodesOffering]?

    public init(
        nextToken: Swift.String? = nil,
        reservedNodesOfferings: [MemoryDBClientTypes.ReservedNodesOffering]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedNodesOfferings = reservedNodesOfferings
    }
}

public struct DescribeServiceUpdatesInput: Swift.Sendable {
    /// The list of cluster names to identify service updates to apply
    public var clusterNames: [Swift.String]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The unique ID of the service update to describe.
    public var serviceUpdateName: Swift.String?
    /// The status(es) of the service updates to filter on
    public var status: [MemoryDBClientTypes.ServiceUpdateStatus]?

    public init(
        clusterNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceUpdateName: Swift.String? = nil,
        status: [MemoryDBClientTypes.ServiceUpdateStatus]? = nil
    )
    {
        self.clusterNames = clusterNames
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceUpdateName = serviceUpdateName
        self.status = status
    }
}

extension MemoryDBClientTypes {

    public enum ServiceUpdateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case securityUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceUpdateType] {
            return [
                .securityUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .securityUpdate: return "security-update"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MemoryDBClientTypes {

    /// An update that you can apply to your MemoryDB clusters.
    public struct ServiceUpdate: Swift.Sendable {
        /// The date at which the service update will be automatically applied
        public var autoUpdateStartDate: Foundation.Date?
        /// The name of the cluster to which the service update applies
        public var clusterName: Swift.String?
        /// Provides details of the service update
        public var description: Swift.String?
        /// The MemoryDB engine to which the update applies. The values are either Redis or Valkey.
        public var engine: Swift.String?
        /// A list of nodes updated by the service update
        public var nodesUpdated: Swift.String?
        /// The date when the service update is initially available
        public var releaseDate: Foundation.Date?
        /// The unique ID of the service update
        public var serviceUpdateName: Swift.String?
        /// The status of the service update
        public var status: MemoryDBClientTypes.ServiceUpdateStatus?
        /// Reflects the nature of the service update
        public var type: MemoryDBClientTypes.ServiceUpdateType?

        public init(
            autoUpdateStartDate: Foundation.Date? = nil,
            clusterName: Swift.String? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            nodesUpdated: Swift.String? = nil,
            releaseDate: Foundation.Date? = nil,
            serviceUpdateName: Swift.String? = nil,
            status: MemoryDBClientTypes.ServiceUpdateStatus? = nil,
            type: MemoryDBClientTypes.ServiceUpdateType? = nil
        )
        {
            self.autoUpdateStartDate = autoUpdateStartDate
            self.clusterName = clusterName
            self.description = description
            self.engine = engine
            self.nodesUpdated = nodesUpdated
            self.releaseDate = releaseDate
            self.serviceUpdateName = serviceUpdateName
            self.status = status
            self.type = type
        }
    }
}

public struct DescribeServiceUpdatesOutput: Swift.Sendable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of service updates
    public var serviceUpdates: [MemoryDBClientTypes.ServiceUpdate]?

    public init(
        nextToken: Swift.String? = nil,
        serviceUpdates: [MemoryDBClientTypes.ServiceUpdate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceUpdates = serviceUpdates
    }
}

public struct DescribeSnapshotsInput: Swift.Sendable {
    /// A user-supplied cluster identifier. If this parameter is specified, only snapshots associated with that specific cluster are described.
    public var clusterName: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A Boolean value which if true, the shard configuration is included in the snapshot description.
    public var showDetail: Swift.Bool?
    /// A user-supplied name of the snapshot. If this parameter is specified, only this named snapshot is described.
    public var snapshotName: Swift.String?
    /// If set to system, the output shows snapshots that were automatically created by MemoryDB. If set to user the output shows snapshots that were manually created. If omitted, the output shows both automatically and manually created snapshots.
    public var source: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        showDetail: Swift.Bool? = nil,
        snapshotName: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.showDetail = showDetail
        self.snapshotName = snapshotName
        self.source = source
    }
}

public struct DescribeSnapshotsOutput: Swift.Sendable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of snapshots. Each item in the list contains detailed information about one snapshot.
    public var snapshots: [MemoryDBClientTypes.Snapshot]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [MemoryDBClientTypes.Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

public struct DescribeSubnetGroupsInput: Swift.Sendable {
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of the subnet group to return details for.
    public var subnetGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetGroupName = subnetGroupName
    }
}

public struct DescribeSubnetGroupsOutput: Swift.Sendable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of subnet groups. Each element in the list contains detailed information about one group.
    public var subnetGroups: [MemoryDBClientTypes.SubnetGroup]?

    public init(
        nextToken: Swift.String? = nil,
        subnetGroups: [MemoryDBClientTypes.SubnetGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }
}

extension MemoryDBClientTypes {

    /// Used to streamline results of a search based on the property being filtered.
    public struct Filter: Swift.Sendable {
        /// The property being filtered. For example, UserName.
        /// This member is required.
        public var name: Swift.String?
        /// The property values to filter on. For example, "user-123".
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeUsersInput: Swift.Sendable {
    /// Filter to determine the list of users to return.
    public var filters: [MemoryDBClientTypes.Filter]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of the user
    public var userName: Swift.String?

    public init(
        filters: [MemoryDBClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userName = userName
    }
}

public struct DescribeUsersOutput: Swift.Sendable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of users.
    public var users: [MemoryDBClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [MemoryDBClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

///
public struct APICallRateForCustomerExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "APICallRateForCustomerExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidKMSKeyFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidKMSKeyFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ShardNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ShardNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct TestFailoverNotAvailableFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TestFailoverNotAvailableFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct FailoverShardInput: Swift.Sendable {
    /// The cluster being failed over
    /// This member is required.
    public var clusterName: Swift.String?
    /// The name of the shard
    /// This member is required.
    public var shardName: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        shardName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.shardName = shardName
    }
}

public struct FailoverShardOutput: Swift.Sendable {
    /// The cluster being failed over
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

public struct ListAllowedNodeTypeUpdatesInput: Swift.Sendable {
    /// The name of the cluster you want to scale. MemoryDB uses the cluster name to identify the current node type being used by this cluster, and from that to create a list of node types you can scale up to.
    /// This member is required.
    public var clusterName: Swift.String?

    public init(
        clusterName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
    }
}

public struct ListAllowedNodeTypeUpdatesOutput: Swift.Sendable {
    /// A list node types which you can use to scale down your cluster.
    public var scaleDownNodeTypes: [Swift.String]?
    /// A list node types which you can use to scale up your cluster.
    public var scaleUpNodeTypes: [Swift.String]?

    public init(
        scaleDownNodeTypes: [Swift.String]? = nil,
        scaleUpNodeTypes: [Swift.String]? = nil
    )
    {
        self.scaleDownNodeTypes = scaleDownNodeTypes
        self.scaleUpNodeTypes = scaleUpNodeTypes
    }
}

///
public struct InvalidARNFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidARN" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which you want the list of tags
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsOutput: Swift.Sendable {
    /// A list of tags as key-value pairs.
    public var tagList: [MemoryDBClientTypes.Tag]?

    public init(
        tagList: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

/// You already have a reservation with the given identifier.
public struct ReservedNodeAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodeAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request cannot be processed because it would exceed the user's node quota.
public struct ReservedNodeQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodeQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PurchaseReservedNodesOfferingInput: Swift.Sendable {
    /// The number of node instances to reserve.
    public var nodeCount: Swift.Int?
    /// A customer-specified identifier to track this reservation.
    public var reservationId: Swift.String?
    /// The ID of the reserved node offering to purchase.
    /// This member is required.
    public var reservedNodesOfferingId: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        nodeCount: Swift.Int? = nil,
        reservationId: Swift.String? = nil,
        reservedNodesOfferingId: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.nodeCount = nodeCount
        self.reservationId = reservationId
        self.reservedNodesOfferingId = reservedNodesOfferingId
        self.tags = tags
    }
}

public struct PurchaseReservedNodesOfferingOutput: Swift.Sendable {
    /// Represents the output of a PurchaseReservedNodesOffering operation.
    public var reservedNode: MemoryDBClientTypes.ReservedNode?

    public init(
        reservedNode: MemoryDBClientTypes.ReservedNode? = nil
    )
    {
        self.reservedNode = reservedNode
    }
}

public struct ResetParameterGroupInput: Swift.Sendable {
    /// If true, all parameters in the parameter group are reset to their default values. If false, only the parameters listed by ParameterNames are reset to their default values.
    public var allParameters: Swift.Bool?
    /// The name of the parameter group to reset.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// An array of parameter names to reset to their default values. If AllParameters is true, do not use ParameterNames. If AllParameters is false, you must specify the name of at least one parameter to reset.
    public var parameterNames: [Swift.String]?

    public init(
        allParameters: Swift.Bool? = false,
        parameterGroupName: Swift.String? = nil,
        parameterNames: [Swift.String]? = nil
    )
    {
        self.allParameters = allParameters
        self.parameterGroupName = parameterGroupName
        self.parameterNames = parameterNames
    }
}

public struct ResetParameterGroupOutput: Swift.Sendable {
    /// The parameter group being reset.
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to which the tags are to be added
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    /// This member is required.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {
    /// A list of tags as key-value pairs.
    public var tagList: [MemoryDBClientTypes.Tag]?

    public init(
        tagList: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

///
public struct TagNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to which the tags are to be removed
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of keys of the tags that are to be removed
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {
    /// The list of tags removed
    public var tagList: [MemoryDBClientTypes.Tag]?

    public init(
        tagList: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

public struct UpdateACLInput: Swift.Sendable {
    /// The name of the Access Control List
    /// This member is required.
    public var aclName: Swift.String?
    /// The list of users to add to the Access Control List
    public var userNamesToAdd: [Swift.String]?
    /// The list of users to remove from the Access Control List
    public var userNamesToRemove: [Swift.String]?

    public init(
        aclName: Swift.String? = nil,
        userNamesToAdd: [Swift.String]? = nil,
        userNamesToRemove: [Swift.String]? = nil
    )
    {
        self.aclName = aclName
        self.userNamesToAdd = userNamesToAdd
        self.userNamesToRemove = userNamesToRemove
    }
}

public struct UpdateACLOutput: Swift.Sendable {
    /// The updated Access Control List
    public var acl: MemoryDBClientTypes.ACL?

    public init(
        acl: MemoryDBClientTypes.ACL? = nil
    )
    {
        self.acl = acl
    }
}

///
public struct InvalidNodeStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNodeState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct NoOperationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoOperationFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MemoryDBClientTypes {

    /// A request to configure the number of replicas in a shard
    public struct ReplicaConfigurationRequest: Swift.Sendable {
        /// The number of replicas to scale up or down to
        public var replicaCount: Swift.Int

        public init(
            replicaCount: Swift.Int = 0
        )
        {
            self.replicaCount = replicaCount
        }
    }
}

extension MemoryDBClientTypes {

    /// A request to configure the sharding properties of a cluster
    public struct ShardConfigurationRequest: Swift.Sendable {
        /// The number of shards in the cluster
        public var shardCount: Swift.Int

        public init(
            shardCount: Swift.Int = 0
        )
        {
            self.shardCount = shardCount
        }
    }
}

public struct UpdateClusterInput: Swift.Sendable {
    /// The Access Control List that is associated with the cluster
    public var aclName: Swift.String?
    /// The name of the cluster to update
    /// This member is required.
    public var clusterName: Swift.String?
    /// The description of the cluster to update
    public var description: Swift.String?
    /// The name of the engine to be used for the nodes in this cluster. The value must be set to either Redis or Valkey.
    public var engine: Swift.String?
    /// The upgraded version of the engine to be run on the nodes. You can upgrade to a newer engine version, but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster and create it anew with the earlier engine version.
    public var engineVersion: Swift.String?
    /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:
    ///
    /// * sun
    ///
    /// * mon
    ///
    /// * tue
    ///
    /// * wed
    ///
    /// * thu
    ///
    /// * fri
    ///
    /// * sat
    ///
    ///
    /// Example: sun:23:00-mon:01:30
    public var maintenanceWindow: Swift.String?
    /// A valid node type that you want to scale this cluster up or down to.
    public var nodeType: Swift.String?
    /// The name of the parameter group to update
    public var parameterGroupName: Swift.String?
    /// The number of replicas that will reside in each shard
    public var replicaConfiguration: MemoryDBClientTypes.ReplicaConfigurationRequest?
    /// The SecurityGroupIds to update
    public var securityGroupIds: [Swift.String]?
    /// The number of shards in the cluster
    public var shardConfiguration: MemoryDBClientTypes.ShardConfigurationRequest?
    /// The number of days for which MemoryDB retains automatic cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
    public var snapshotRetentionLimit: Swift.Int?
    /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your cluster.
    public var snapshotWindow: Swift.String?
    /// The SNS topic ARN to update
    public var snsTopicArn: Swift.String?
    /// The status of the Amazon SNS notification topic. Notifications are sent only if the status is active.
    public var snsTopicStatus: Swift.String?

    public init(
        aclName: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        maintenanceWindow: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        replicaConfiguration: MemoryDBClientTypes.ReplicaConfigurationRequest? = nil,
        securityGroupIds: [Swift.String]? = nil,
        shardConfiguration: MemoryDBClientTypes.ShardConfigurationRequest? = nil,
        snapshotRetentionLimit: Swift.Int? = nil,
        snapshotWindow: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        snsTopicStatus: Swift.String? = nil
    )
    {
        self.aclName = aclName
        self.clusterName = clusterName
        self.description = description
        self.engine = engine
        self.engineVersion = engineVersion
        self.maintenanceWindow = maintenanceWindow
        self.nodeType = nodeType
        self.parameterGroupName = parameterGroupName
        self.replicaConfiguration = replicaConfiguration
        self.securityGroupIds = securityGroupIds
        self.shardConfiguration = shardConfiguration
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.snapshotWindow = snapshotWindow
        self.snsTopicArn = snsTopicArn
        self.snsTopicStatus = snsTopicStatus
    }
}

public struct UpdateClusterOutput: Swift.Sendable {
    /// The updated cluster
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

extension MemoryDBClientTypes {

    /// Describes a name-value pair that is used to update the value of a parameter.
    public struct ParameterNameValue: Swift.Sendable {
        /// The name of the parameter
        public var parameterName: Swift.String?
        /// The value of the parameter
        public var parameterValue: Swift.String?

        public init(
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }
}

public struct UpdateParameterGroupInput: Swift.Sendable {
    /// The name of the parameter group to update.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// An array of parameter names and values for the parameter update. You must supply at least one parameter name and value; subsequent arguments are optional. A maximum of 20 parameters may be updated per request.
    /// This member is required.
    public var parameterNameValues: [MemoryDBClientTypes.ParameterNameValue]?

    public init(
        parameterGroupName: Swift.String? = nil,
        parameterNameValues: [MemoryDBClientTypes.ParameterNameValue]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }
}

public struct UpdateParameterGroupOutput: Swift.Sendable {
    /// The updated parameter group
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

///
public struct SubnetInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateSubnetGroupInput: Swift.Sendable {
    /// A description of the subnet group
    public var description: Swift.String?
    /// The name of the subnet group
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// The EC2 subnet IDs for the subnet group.
    public var subnetIds: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

public struct UpdateSubnetGroupOutput: Swift.Sendable {
    /// The updated subnet group
    public var subnetGroup: MemoryDBClientTypes.SubnetGroup?

    public init(
        subnetGroup: MemoryDBClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

public struct UpdateUserInput: Swift.Sendable {
    /// Access permissions string used for this user.
    public var accessString: Swift.String?
    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate.
    public var authenticationMode: MemoryDBClientTypes.AuthenticationMode?
    /// The name of the user
    /// This member is required.
    public var userName: Swift.String?

    public init(
        accessString: Swift.String? = nil,
        authenticationMode: MemoryDBClientTypes.AuthenticationMode? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessString = accessString
        self.authenticationMode = authenticationMode
        self.userName = userName
    }
}

public struct UpdateUserOutput: Swift.Sendable {
    /// The updated user
    public var user: MemoryDBClientTypes.User?

    public init(
        user: MemoryDBClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

extension BatchUpdateClusterInput {

    static func urlPathProvider(_ value: BatchUpdateClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CopySnapshotInput {

    static func urlPathProvider(_ value: CopySnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension CreateACLInput {

    static func urlPathProvider(_ value: CreateACLInput) -> Swift.String? {
        return "/"
    }
}

extension CreateClusterInput {

    static func urlPathProvider(_ value: CreateClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateParameterGroupInput {

    static func urlPathProvider(_ value: CreateParameterGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSnapshotInput {

    static func urlPathProvider(_ value: CreateSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSubnetGroupInput {

    static func urlPathProvider(_ value: CreateSubnetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteACLInput {

    static func urlPathProvider(_ value: DeleteACLInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteClusterInput {

    static func urlPathProvider(_ value: DeleteClusterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteParameterGroupInput {

    static func urlPathProvider(_ value: DeleteParameterGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSnapshotInput {

    static func urlPathProvider(_ value: DeleteSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSubnetGroupInput {

    static func urlPathProvider(_ value: DeleteSubnetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeACLsInput {

    static func urlPathProvider(_ value: DescribeACLsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeClustersInput {

    static func urlPathProvider(_ value: DescribeClustersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEngineVersionsInput {

    static func urlPathProvider(_ value: DescribeEngineVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventsInput {

    static func urlPathProvider(_ value: DescribeEventsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeParameterGroupsInput {

    static func urlPathProvider(_ value: DescribeParameterGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeParametersInput {

    static func urlPathProvider(_ value: DescribeParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReservedNodesInput {

    static func urlPathProvider(_ value: DescribeReservedNodesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReservedNodesOfferingsInput {

    static func urlPathProvider(_ value: DescribeReservedNodesOfferingsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServiceUpdatesInput {

    static func urlPathProvider(_ value: DescribeServiceUpdatesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSnapshotsInput {

    static func urlPathProvider(_ value: DescribeSnapshotsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSubnetGroupsInput {

    static func urlPathProvider(_ value: DescribeSubnetGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUsersInput {

    static func urlPathProvider(_ value: DescribeUsersInput) -> Swift.String? {
        return "/"
    }
}

extension FailoverShardInput {

    static func urlPathProvider(_ value: FailoverShardInput) -> Swift.String? {
        return "/"
    }
}

extension ListAllowedNodeTypeUpdatesInput {

    static func urlPathProvider(_ value: ListAllowedNodeTypeUpdatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        return "/"
    }
}

extension PurchaseReservedNodesOfferingInput {

    static func urlPathProvider(_ value: PurchaseReservedNodesOfferingInput) -> Swift.String? {
        return "/"
    }
}

extension ResetParameterGroupInput {

    static func urlPathProvider(_ value: ResetParameterGroupInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateACLInput {

    static func urlPathProvider(_ value: UpdateACLInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateClusterInput {

    static func urlPathProvider(_ value: UpdateClusterInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateParameterGroupInput {

    static func urlPathProvider(_ value: UpdateParameterGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSubnetGroupInput {

    static func urlPathProvider(_ value: UpdateSubnetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        return "/"
    }
}

extension BatchUpdateClusterInput {

    static func write(value: BatchUpdateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterNames"].writeList(value.clusterNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceUpdate"].write(value.serviceUpdate, with: MemoryDBClientTypes.ServiceUpdateRequest.write(value:to:))
    }
}

extension CopySnapshotInput {

    static func write(value: CopySnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["SourceSnapshotName"].write(value.sourceSnapshotName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetBucket"].write(value.targetBucket)
        try writer["TargetSnapshotName"].write(value.targetSnapshotName)
    }
}

extension CreateACLInput {

    static func write(value: CreateACLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ACLName"].write(value.aclName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserNames"].writeList(value.userNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateClusterInput {

    static func write(value: CreateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ACLName"].write(value.aclName)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["ClusterName"].write(value.clusterName)
        try writer["DataTiering"].write(value.dataTiering)
        try writer["Description"].write(value.description)
        try writer["Engine"].write(value.engine)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MaintenanceWindow"].write(value.maintenanceWindow)
        try writer["NodeType"].write(value.nodeType)
        try writer["NumReplicasPerShard"].write(value.numReplicasPerShard)
        try writer["NumShards"].write(value.numShards)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
        try writer["Port"].write(value.port)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnapshotArns"].writeList(value.snapshotArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnapshotName"].write(value.snapshotName)
        try writer["SnapshotRetentionLimit"].write(value.snapshotRetentionLimit)
        try writer["SnapshotWindow"].write(value.snapshotWindow)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SubnetGroupName"].write(value.subnetGroupName)
        try writer["TLSEnabled"].write(value.tlsEnabled)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateParameterGroupInput {

    static func write(value: CreateParameterGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Family"].write(value.family)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSnapshotInput {

    static func write(value: CreateSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterName"].write(value.clusterName)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["SnapshotName"].write(value.snapshotName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSubnetGroupInput {

    static func write(value: CreateSubnetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["SubnetGroupName"].write(value.subnetGroupName)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessString"].write(value.accessString)
        try writer["AuthenticationMode"].write(value.authenticationMode, with: MemoryDBClientTypes.AuthenticationMode.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
    }
}

extension DeleteACLInput {

    static func write(value: DeleteACLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ACLName"].write(value.aclName)
    }
}

extension DeleteClusterInput {

    static func write(value: DeleteClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterName"].write(value.clusterName)
        try writer["FinalSnapshotName"].write(value.finalSnapshotName)
    }
}

extension DeleteParameterGroupInput {

    static func write(value: DeleteParameterGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterGroupName"].write(value.parameterGroupName)
    }
}

extension DeleteSnapshotInput {

    static func write(value: DeleteSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapshotName"].write(value.snapshotName)
    }
}

extension DeleteSubnetGroupInput {

    static func write(value: DeleteSubnetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubnetGroupName"].write(value.subnetGroupName)
    }
}

extension DeleteUserInput {

    static func write(value: DeleteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
    }
}

extension DescribeACLsInput {

    static func write(value: DescribeACLsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ACLName"].write(value.aclName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeClustersInput {

    static func write(value: DescribeClustersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterName"].write(value.clusterName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ShowShardDetails"].write(value.showShardDetails)
    }
}

extension DescribeEngineVersionsInput {

    static func write(value: DescribeEngineVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultOnly"].write(value.defaultOnly)
        try writer["Engine"].write(value.engine)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ParameterGroupFamily"].write(value.parameterGroupFamily)
    }
}

extension DescribeEventsInput {

    static func write(value: DescribeEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SourceName"].write(value.sourceName)
        try writer["SourceType"].write(value.sourceType)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DescribeParameterGroupsInput {

    static func write(value: DescribeParameterGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
    }
}

extension DescribeParametersInput {

    static func write(value: DescribeParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
    }
}

extension DescribeReservedNodesInput {

    static func write(value: DescribeReservedNodesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["NodeType"].write(value.nodeType)
        try writer["OfferingType"].write(value.offeringType)
        try writer["ReservationId"].write(value.reservationId)
        try writer["ReservedNodesOfferingId"].write(value.reservedNodesOfferingId)
    }
}

extension DescribeReservedNodesOfferingsInput {

    static func write(value: DescribeReservedNodesOfferingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["NodeType"].write(value.nodeType)
        try writer["OfferingType"].write(value.offeringType)
        try writer["ReservedNodesOfferingId"].write(value.reservedNodesOfferingId)
    }
}

extension DescribeServiceUpdatesInput {

    static func write(value: DescribeServiceUpdatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterNames"].writeList(value.clusterNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceUpdateName"].write(value.serviceUpdateName)
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MemoryDBClientTypes.ServiceUpdateStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSnapshotsInput {

    static func write(value: DescribeSnapshotsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterName"].write(value.clusterName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ShowDetail"].write(value.showDetail)
        try writer["SnapshotName"].write(value.snapshotName)
        try writer["Source"].write(value.source)
    }
}

extension DescribeSubnetGroupsInput {

    static func write(value: DescribeSubnetGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubnetGroupName"].write(value.subnetGroupName)
    }
}

extension DescribeUsersInput {

    static func write(value: DescribeUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: MemoryDBClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["UserName"].write(value.userName)
    }
}

extension FailoverShardInput {

    static func write(value: FailoverShardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterName"].write(value.clusterName)
        try writer["ShardName"].write(value.shardName)
    }
}

extension ListAllowedNodeTypeUpdatesInput {

    static func write(value: ListAllowedNodeTypeUpdatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterName"].write(value.clusterName)
    }
}

extension ListTagsInput {

    static func write(value: ListTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PurchaseReservedNodesOfferingInput {

    static func write(value: PurchaseReservedNodesOfferingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NodeCount"].write(value.nodeCount)
        try writer["ReservationId"].write(value.reservationId)
        try writer["ReservedNodesOfferingId"].write(value.reservedNodesOfferingId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ResetParameterGroupInput {

    static func write(value: ResetParameterGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllParameters"].write(value.allParameters)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
        try writer["ParameterNames"].writeList(value.parameterNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MemoryDBClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateACLInput {

    static func write(value: UpdateACLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ACLName"].write(value.aclName)
        try writer["UserNamesToAdd"].writeList(value.userNamesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserNamesToRemove"].writeList(value.userNamesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateClusterInput {

    static func write(value: UpdateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ACLName"].write(value.aclName)
        try writer["ClusterName"].write(value.clusterName)
        try writer["Description"].write(value.description)
        try writer["Engine"].write(value.engine)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["MaintenanceWindow"].write(value.maintenanceWindow)
        try writer["NodeType"].write(value.nodeType)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
        try writer["ReplicaConfiguration"].write(value.replicaConfiguration, with: MemoryDBClientTypes.ReplicaConfigurationRequest.write(value:to:))
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ShardConfiguration"].write(value.shardConfiguration, with: MemoryDBClientTypes.ShardConfigurationRequest.write(value:to:))
        try writer["SnapshotRetentionLimit"].write(value.snapshotRetentionLimit)
        try writer["SnapshotWindow"].write(value.snapshotWindow)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SnsTopicStatus"].write(value.snsTopicStatus)
    }
}

extension UpdateParameterGroupInput {

    static func write(value: UpdateParameterGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterGroupName"].write(value.parameterGroupName)
        try writer["ParameterNameValues"].writeList(value.parameterNameValues, memberWritingClosure: MemoryDBClientTypes.ParameterNameValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateSubnetGroupInput {

    static func write(value: UpdateSubnetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["SubnetGroupName"].write(value.subnetGroupName)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessString"].write(value.accessString)
        try writer["AuthenticationMode"].write(value.authenticationMode, with: MemoryDBClientTypes.AuthenticationMode.write(value:to:))
        try writer["UserName"].write(value.userName)
    }
}

extension BatchUpdateClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateClusterOutput()
        value.processedClusters = try reader["ProcessedClusters"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Cluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedClusters = try reader["UnprocessedClusters"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.UnprocessedCluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CopySnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopySnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopySnapshotOutput()
        value.snapshot = try reader["Snapshot"].readIfPresent(with: MemoryDBClientTypes.Snapshot.read(from:))
        return value
    }
}

extension CreateACLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateACLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateACLOutput()
        value.acl = try reader["ACL"].readIfPresent(with: MemoryDBClientTypes.ACL.read(from:))
        return value
    }
}

extension CreateClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: MemoryDBClientTypes.Cluster.read(from:))
        return value
    }
}

extension CreateParameterGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateParameterGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateParameterGroupOutput()
        value.parameterGroup = try reader["ParameterGroup"].readIfPresent(with: MemoryDBClientTypes.ParameterGroup.read(from:))
        return value
    }
}

extension CreateSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSnapshotOutput()
        value.snapshot = try reader["Snapshot"].readIfPresent(with: MemoryDBClientTypes.Snapshot.read(from:))
        return value
    }
}

extension CreateSubnetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubnetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubnetGroupOutput()
        value.subnetGroup = try reader["SubnetGroup"].readIfPresent(with: MemoryDBClientTypes.SubnetGroup.read(from:))
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.user = try reader["User"].readIfPresent(with: MemoryDBClientTypes.User.read(from:))
        return value
    }
}

extension DeleteACLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteACLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteACLOutput()
        value.acl = try reader["ACL"].readIfPresent(with: MemoryDBClientTypes.ACL.read(from:))
        return value
    }
}

extension DeleteClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: MemoryDBClientTypes.Cluster.read(from:))
        return value
    }
}

extension DeleteParameterGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteParameterGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteParameterGroupOutput()
        value.parameterGroup = try reader["ParameterGroup"].readIfPresent(with: MemoryDBClientTypes.ParameterGroup.read(from:))
        return value
    }
}

extension DeleteSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSnapshotOutput()
        value.snapshot = try reader["Snapshot"].readIfPresent(with: MemoryDBClientTypes.Snapshot.read(from:))
        return value
    }
}

extension DeleteSubnetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubnetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSubnetGroupOutput()
        value.subnetGroup = try reader["SubnetGroup"].readIfPresent(with: MemoryDBClientTypes.SubnetGroup.read(from:))
        return value
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteUserOutput()
        value.user = try reader["User"].readIfPresent(with: MemoryDBClientTypes.User.read(from:))
        return value
    }
}

extension DescribeACLsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeACLsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeACLsOutput()
        value.acLs = try reader["ACLs"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.ACL.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClustersOutput()
        value.clusters = try reader["Clusters"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Cluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeEngineVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEngineVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEngineVersionsOutput()
        value.engineVersions = try reader["EngineVersions"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.EngineVersionInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventsOutput()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeParameterGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeParameterGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeParameterGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.parameterGroups = try reader["ParameterGroups"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.ParameterGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeParametersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReservedNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReservedNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReservedNodesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reservedNodes = try reader["ReservedNodes"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.ReservedNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReservedNodesOfferingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReservedNodesOfferingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReservedNodesOfferingsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reservedNodesOfferings = try reader["ReservedNodesOfferings"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.ReservedNodesOffering.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeServiceUpdatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceUpdatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServiceUpdatesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceUpdates = try reader["ServiceUpdates"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.ServiceUpdate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSnapshotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSnapshotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSnapshotsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.snapshots = try reader["Snapshots"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Snapshot.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSubnetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSubnetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSubnetGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subnetGroups = try reader["SubnetGroups"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.SubnetGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FailoverShardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> FailoverShardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = FailoverShardOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: MemoryDBClientTypes.Cluster.read(from:))
        return value
    }
}

extension ListAllowedNodeTypeUpdatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAllowedNodeTypeUpdatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAllowedNodeTypeUpdatesOutput()
        value.scaleDownNodeTypes = try reader["ScaleDownNodeTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scaleUpNodeTypes = try reader["ScaleUpNodeTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PurchaseReservedNodesOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PurchaseReservedNodesOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PurchaseReservedNodesOfferingOutput()
        value.reservedNode = try reader["ReservedNode"].readIfPresent(with: MemoryDBClientTypes.ReservedNode.read(from:))
        return value
    }
}

extension ResetParameterGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetParameterGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetParameterGroupOutput()
        value.parameterGroup = try reader["ParameterGroup"].readIfPresent(with: MemoryDBClientTypes.ParameterGroup.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TagResourceOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UntagResourceOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateACLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateACLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateACLOutput()
        value.acl = try reader["ACL"].readIfPresent(with: MemoryDBClientTypes.ACL.read(from:))
        return value
    }
}

extension UpdateClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: MemoryDBClientTypes.Cluster.read(from:))
        return value
    }
}

extension UpdateParameterGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateParameterGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateParameterGroupOutput()
        value.parameterGroup = try reader["ParameterGroup"].readIfPresent(with: MemoryDBClientTypes.ParameterGroup.read(from:))
        return value
    }
}

extension UpdateSubnetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubnetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubnetGroupOutput()
        value.subnetGroup = try reader["SubnetGroup"].readIfPresent(with: MemoryDBClientTypes.SubnetGroup.read(from:))
        return value
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.user = try reader["User"].readIfPresent(with: MemoryDBClientTypes.User.read(from:))
        return value
    }
}

enum BatchUpdateClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceUpdateNotFoundFault": return try ServiceUpdateNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CopySnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidSnapshotState": return try InvalidSnapshotStateFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotAlreadyExistsFault": return try SnapshotAlreadyExistsFault.makeError(baseError: baseError)
            case "SnapshotNotFoundFault": return try SnapshotNotFoundFault.makeError(baseError: baseError)
            case "SnapshotQuotaExceededFault": return try SnapshotQuotaExceededFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateACLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLAlreadyExists": return try ACLAlreadyExistsFault.makeError(baseError: baseError)
            case "ACLQuotaExceeded": return try ACLQuotaExceededFault.makeError(baseError: baseError)
            case "DefaultUserRequired": return try DefaultUserRequired.makeError(baseError: baseError)
            case "DuplicateUserName": return try DuplicateUserNameFault.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "ClusterAlreadyExists": return try ClusterAlreadyExistsFault.makeError(baseError: baseError)
            case "ClusterQuotaForCustomerExceeded": return try ClusterQuotaForCustomerExceededFault.makeError(baseError: baseError)
            case "InsufficientClusterCapacity": return try InsufficientClusterCapacityFault.makeError(baseError: baseError)
            case "InvalidACLState": return try InvalidACLStateFault.makeError(baseError: baseError)
            case "InvalidCredentialsException": return try InvalidCredentialsException.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidVPCNetworkStateFault": return try InvalidVPCNetworkStateFault.makeError(baseError: baseError)
            case "NodeQuotaForClusterExceeded": return try NodeQuotaForClusterExceededFault.makeError(baseError: baseError)
            case "NodeQuotaForCustomerExceeded": return try NodeQuotaForCustomerExceededFault.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "ShardsPerClusterQuotaExceeded": return try ShardsPerClusterQuotaExceededFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateParameterGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterGroupState": return try InvalidParameterGroupStateFault.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ParameterGroupAlreadyExists": return try ParameterGroupAlreadyExistsFault.makeError(baseError: baseError)
            case "ParameterGroupQuotaExceeded": return try ParameterGroupQuotaExceededFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotAlreadyExistsFault": return try SnapshotAlreadyExistsFault.makeError(baseError: baseError)
            case "SnapshotQuotaExceededFault": return try SnapshotQuotaExceededFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubnetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupAlreadyExists": return try SubnetGroupAlreadyExistsFault.makeError(baseError: baseError)
            case "SubnetGroupQuotaExceeded": return try SubnetGroupQuotaExceededFault.makeError(baseError: baseError)
            case "SubnetNotAllowedFault": return try SubnetNotAllowedFault.makeError(baseError: baseError)
            case "SubnetQuotaExceededFault": return try SubnetQuotaExceededFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateUserName": return try DuplicateUserNameFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            case "UserAlreadyExists": return try UserAlreadyExistsFault.makeError(baseError: baseError)
            case "UserQuotaExceeded": return try UserQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteACLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "InvalidACLState": return try InvalidACLStateFault.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotAlreadyExistsFault": return try SnapshotAlreadyExistsFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteParameterGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterGroupState": return try InvalidParameterGroupStateFault.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidSnapshotState": return try InvalidSnapshotStateFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotNotFoundFault": return try SnapshotNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubnetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupInUse": return try SubnetGroupInUseFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidUserState": return try InvalidUserStateFault.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeACLsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEngineVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeParameterGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReservedNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ReservedNodeNotFound": return try ReservedNodeNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReservedNodesOfferingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ReservedNodesOfferingNotFound": return try ReservedNodesOfferingNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceUpdatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSnapshotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotNotFoundFault": return try SnapshotNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSubnetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum FailoverShardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "APICallRateForCustomerExceeded": return try APICallRateForCustomerExceededFault.makeError(baseError: baseError)
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "InvalidKMSKeyFault": return try InvalidKMSKeyFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ShardNotFoundFault": return try ShardNotFoundFault.makeError(baseError: baseError)
            case "TestFailoverNotAvailableFault": return try TestFailoverNotAvailableFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAllowedNodeTypeUpdatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidARN": return try InvalidARNFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotNotFoundFault": return try SnapshotNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PurchaseReservedNodesOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ReservedNodeAlreadyExists": return try ReservedNodeAlreadyExistsFault.makeError(baseError: baseError)
            case "ReservedNodeQuotaExceeded": return try ReservedNodeQuotaExceededFault.makeError(baseError: baseError)
            case "ReservedNodesOfferingNotFound": return try ReservedNodesOfferingNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetParameterGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterGroupState": return try InvalidParameterGroupStateFault.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidARN": return try InvalidARNFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotNotFoundFault": return try SnapshotNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            case "TagQuotaPerResourceExceeded": return try TagQuotaPerResourceExceeded.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "InvalidARN": return try InvalidARNFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SnapshotNotFoundFault": return try SnapshotNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            case "TagNotFound": return try TagNotFoundFault.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateACLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "DefaultUserRequired": return try DefaultUserRequired.makeError(baseError: baseError)
            case "DuplicateUserName": return try DuplicateUserNameFault.makeError(baseError: baseError)
            case "InvalidACLState": return try InvalidACLStateFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ACLNotFound": return try ACLNotFoundFault.makeError(baseError: baseError)
            case "ClusterNotFound": return try ClusterNotFoundFault.makeError(baseError: baseError)
            case "ClusterQuotaForCustomerExceeded": return try ClusterQuotaForCustomerExceededFault.makeError(baseError: baseError)
            case "InvalidACLState": return try InvalidACLStateFault.makeError(baseError: baseError)
            case "InvalidClusterState": return try InvalidClusterStateFault.makeError(baseError: baseError)
            case "InvalidKMSKeyFault": return try InvalidKMSKeyFault.makeError(baseError: baseError)
            case "InvalidNodeState": return try InvalidNodeStateFault.makeError(baseError: baseError)
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidVPCNetworkStateFault": return try InvalidVPCNetworkStateFault.makeError(baseError: baseError)
            case "NodeQuotaForClusterExceeded": return try NodeQuotaForClusterExceededFault.makeError(baseError: baseError)
            case "NodeQuotaForCustomerExceeded": return try NodeQuotaForCustomerExceededFault.makeError(baseError: baseError)
            case "NoOperationFault": return try NoOperationFault.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "ShardsPerClusterQuotaExceeded": return try ShardsPerClusterQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateParameterGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterGroupState": return try InvalidParameterGroupStateFault.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ParameterGroupNotFound": return try ParameterGroupNotFoundFault.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubnetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "ServiceLinkedRoleNotFoundFault": return try ServiceLinkedRoleNotFoundFault.makeError(baseError: baseError)
            case "SubnetGroupNotFoundFault": return try SubnetGroupNotFoundFault.makeError(baseError: baseError)
            case "SubnetInUse": return try SubnetInUse.makeError(baseError: baseError)
            case "SubnetNotAllowedFault": return try SubnetNotAllowedFault.makeError(baseError: baseError)
            case "SubnetQuotaExceededFault": return try SubnetQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombination": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameterValue": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidUserState": return try InvalidUserStateFault.makeError(baseError: baseError)
            case "UserNotFound": return try UserNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceUpdateNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceUpdateNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ServiceUpdateNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterCombinationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterCombinationException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterCombinationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapshotNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SnapshotNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = SnapshotNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagQuotaPerResourceExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagQuotaPerResourceExceeded {
        let reader = baseError.errorBodyReader
        var value = TagQuotaPerResourceExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapshotQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SnapshotQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = SnapshotQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceLinkedRoleNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceLinkedRoleNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ServiceLinkedRoleNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapshotAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SnapshotAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = SnapshotAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSnapshotStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSnapshotStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidSnapshotStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ACLQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ACLQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = ACLQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateUserNameFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateUserNameFault {
        let reader = baseError.errorBodyReader
        var value = DuplicateUserNameFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DefaultUserRequired {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DefaultUserRequired {
        let reader = baseError.errorBodyReader
        var value = DefaultUserRequired()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UserNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UserNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = UserNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ACLAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ACLAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = ACLAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClusterQuotaForCustomerExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ClusterQuotaForCustomerExceededFault {
        let reader = baseError.errorBodyReader
        var value = ClusterQuotaForCustomerExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ACLNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ACLNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ACLNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NodeQuotaForClusterExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NodeQuotaForClusterExceededFault {
        let reader = baseError.errorBodyReader
        var value = NodeQuotaForClusterExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetGroupNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetGroupNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = SubnetGroupNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCredentialsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCredentialsException {
        let reader = baseError.errorBodyReader
        var value = InvalidCredentialsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClusterAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ClusterAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = ClusterAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ShardsPerClusterQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ShardsPerClusterQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = ShardsPerClusterQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterGroupNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterGroupNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ParameterGroupNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidVPCNetworkStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidVPCNetworkStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidVPCNetworkStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NodeQuotaForCustomerExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NodeQuotaForCustomerExceededFault {
        let reader = baseError.errorBodyReader
        var value = NodeQuotaForCustomerExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientClusterCapacityFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientClusterCapacityFault {
        let reader = baseError.errorBodyReader
        var value = InsufficientClusterCapacityFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidACLStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidACLStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidACLStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterGroupAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterGroupAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = ParameterGroupAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterGroupStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterGroupStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterGroupStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterGroupQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterGroupQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = ParameterGroupQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClusterNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ClusterNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ClusterNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidClusterStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidClusterStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidClusterStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetNotAllowedFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetNotAllowedFault {
        let reader = baseError.errorBodyReader
        var value = SubnetNotAllowedFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetGroupQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetGroupQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = SubnetGroupQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSubnet {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSubnet {
        let reader = baseError.errorBodyReader
        var value = InvalidSubnet()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = SubnetQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetGroupAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetGroupAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = SubnetGroupAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UserQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UserQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = UserQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UserAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UserAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = UserAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetGroupInUseFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetGroupInUseFault {
        let reader = baseError.errorBodyReader
        var value = SubnetGroupInUseFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidUserStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidUserStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidUserStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReservedNodeNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReservedNodeNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ReservedNodeNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReservedNodesOfferingNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReservedNodesOfferingNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ReservedNodesOfferingNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidKMSKeyFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidKMSKeyFault {
        let reader = baseError.errorBodyReader
        var value = InvalidKMSKeyFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension APICallRateForCustomerExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> APICallRateForCustomerExceededFault {
        let reader = baseError.errorBodyReader
        var value = APICallRateForCustomerExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ShardNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ShardNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ShardNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TestFailoverNotAvailableFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TestFailoverNotAvailableFault {
        let reader = baseError.errorBodyReader
        var value = TestFailoverNotAvailableFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidARNFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidARNFault {
        let reader = baseError.errorBodyReader
        var value = InvalidARNFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReservedNodeAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReservedNodeAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = ReservedNodeAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReservedNodeQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReservedNodeQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = ReservedNodeQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = TagNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNodeStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNodeStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidNodeStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoOperationFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoOperationFault {
        let reader = baseError.errorBodyReader
        var value = NoOperationFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetInUse {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetInUse {
        let reader = baseError.errorBodyReader
        var value = SubnetInUse()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MemoryDBClientTypes.Cluster {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Cluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Cluster()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.pendingUpdates = try reader["PendingUpdates"].readIfPresent(with: MemoryDBClientTypes.ClusterPendingUpdates.read(from:))
        value.numberOfShards = try reader["NumberOfShards"].readIfPresent()
        value.shards = try reader["Shards"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Shard.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityMode = try reader["AvailabilityMode"].readIfPresent()
        value.clusterEndpoint = try reader["ClusterEndpoint"].readIfPresent(with: MemoryDBClientTypes.Endpoint.read(from:))
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.enginePatchVersion = try reader["EnginePatchVersion"].readIfPresent()
        value.parameterGroupName = try reader["ParameterGroupName"].readIfPresent()
        value.parameterGroupStatus = try reader["ParameterGroupStatus"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.SecurityGroupMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetGroupName = try reader["SubnetGroupName"].readIfPresent()
        value.tlsEnabled = try reader["TLSEnabled"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        value.snsTopicStatus = try reader["SnsTopicStatus"].readIfPresent()
        value.snapshotRetentionLimit = try reader["SnapshotRetentionLimit"].readIfPresent()
        value.maintenanceWindow = try reader["MaintenanceWindow"].readIfPresent()
        value.snapshotWindow = try reader["SnapshotWindow"].readIfPresent()
        value.aclName = try reader["ACLName"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["AutoMinorVersionUpgrade"].readIfPresent()
        value.dataTiering = try reader["DataTiering"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.SecurityGroupMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.SecurityGroupMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.SecurityGroupMembership()
        value.securityGroupId = try reader["SecurityGroupId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.Endpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Endpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Endpoint()
        value.address = try reader["Address"].readIfPresent()
        value.port = try reader["Port"].readIfPresent() ?? 0
        return value
    }
}

extension MemoryDBClientTypes.Shard {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Shard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Shard()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.slots = try reader["Slots"].readIfPresent()
        value.nodes = try reader["Nodes"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Node.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberOfNodes = try reader["NumberOfNodes"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.Node {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Node {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Node()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endpoint = try reader["Endpoint"].readIfPresent(with: MemoryDBClientTypes.Endpoint.read(from:))
        return value
    }
}

extension MemoryDBClientTypes.ClusterPendingUpdates {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ClusterPendingUpdates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ClusterPendingUpdates()
        value.resharding = try reader["Resharding"].readIfPresent(with: MemoryDBClientTypes.ReshardingStatus.read(from:))
        value.acLs = try reader["ACLs"].readIfPresent(with: MemoryDBClientTypes.ACLsUpdateStatus.read(from:))
        value.serviceUpdates = try reader["ServiceUpdates"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.PendingModifiedServiceUpdate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MemoryDBClientTypes.PendingModifiedServiceUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.PendingModifiedServiceUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.PendingModifiedServiceUpdate()
        value.serviceUpdateName = try reader["ServiceUpdateName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ACLsUpdateStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ACLsUpdateStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ACLsUpdateStatus()
        value.aclToApply = try reader["ACLToApply"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ReshardingStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ReshardingStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ReshardingStatus()
        value.slotMigration = try reader["SlotMigration"].readIfPresent(with: MemoryDBClientTypes.SlotMigration.read(from:))
        return value
    }
}

extension MemoryDBClientTypes.SlotMigration {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.SlotMigration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.SlotMigration()
        value.progressPercentage = try reader["ProgressPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension MemoryDBClientTypes.UnprocessedCluster {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.UnprocessedCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.UnprocessedCluster()
        value.clusterName = try reader["ClusterName"].readIfPresent()
        value.errorType = try reader["ErrorType"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.Snapshot {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Snapshot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Snapshot()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        value.clusterConfiguration = try reader["ClusterConfiguration"].readIfPresent(with: MemoryDBClientTypes.ClusterConfiguration.read(from:))
        value.dataTiering = try reader["DataTiering"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ClusterConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ClusterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ClusterConfiguration()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.maintenanceWindow = try reader["MaintenanceWindow"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.parameterGroupName = try reader["ParameterGroupName"].readIfPresent()
        value.subnetGroupName = try reader["SubnetGroupName"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.snapshotRetentionLimit = try reader["SnapshotRetentionLimit"].readIfPresent()
        value.snapshotWindow = try reader["SnapshotWindow"].readIfPresent()
        value.numShards = try reader["NumShards"].readIfPresent()
        value.shards = try reader["Shards"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.ShardDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MemoryDBClientTypes.ShardDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ShardDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ShardDetail()
        value.name = try reader["Name"].readIfPresent()
        value.configuration = try reader["Configuration"].readIfPresent(with: MemoryDBClientTypes.ShardConfiguration.read(from:))
        value.size = try reader["Size"].readIfPresent()
        value.snapshotCreationTime = try reader["SnapshotCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MemoryDBClientTypes.ShardConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ShardConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ShardConfiguration()
        value.slots = try reader["Slots"].readIfPresent()
        value.replicaCount = try reader["ReplicaCount"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ACL {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ACL {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ACL()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.userNames = try reader["UserNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumEngineVersion = try reader["MinimumEngineVersion"].readIfPresent()
        value.pendingChanges = try reader["PendingChanges"].readIfPresent(with: MemoryDBClientTypes.ACLPendingChanges.read(from:))
        value.clusters = try reader["Clusters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ACLPendingChanges {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ACLPendingChanges {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ACLPendingChanges()
        value.userNamesToRemove = try reader["UserNamesToRemove"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userNamesToAdd = try reader["UserNamesToAdd"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MemoryDBClientTypes.ParameterGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ParameterGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ParameterGroup()
        value.name = try reader["Name"].readIfPresent()
        value.family = try reader["Family"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.SubnetGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.SubnetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.SubnetGroup()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.Subnet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.Subnet {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Subnet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Subnet()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent(with: MemoryDBClientTypes.AvailabilityZone.read(from:))
        return value
    }
}

extension MemoryDBClientTypes.AvailabilityZone {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.AvailabilityZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.AvailabilityZone()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.User()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.accessString = try reader["AccessString"].readIfPresent()
        value.aclNames = try reader["ACLNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumEngineVersion = try reader["MinimumEngineVersion"].readIfPresent()
        value.authentication = try reader["Authentication"].readIfPresent(with: MemoryDBClientTypes.Authentication.read(from:))
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.Authentication {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Authentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Authentication()
        value.type = try reader["Type"].readIfPresent()
        value.passwordCount = try reader["PasswordCount"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.EngineVersionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.EngineVersionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.EngineVersionInfo()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.enginePatchVersion = try reader["EnginePatchVersion"].readIfPresent()
        value.parameterGroupFamily = try reader["ParameterGroupFamily"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Event()
        value.sourceName = try reader["SourceName"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MemoryDBClientTypes.Parameter {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Parameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Parameter()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.dataType = try reader["DataType"].readIfPresent()
        value.allowedValues = try reader["AllowedValues"].readIfPresent()
        value.minimumEngineVersion = try reader["MinimumEngineVersion"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ReservedNode {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ReservedNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ReservedNode()
        value.reservationId = try reader["ReservationId"].readIfPresent()
        value.reservedNodesOfferingId = try reader["ReservedNodesOfferingId"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.fixedPrice = try reader["FixedPrice"].readIfPresent() ?? 0
        value.nodeCount = try reader["NodeCount"].readIfPresent() ?? 0
        value.offeringType = try reader["OfferingType"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.recurringCharges = try reader["RecurringCharges"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.RecurringCharge.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.RecurringCharge {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.RecurringCharge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.RecurringCharge()
        value.recurringChargeAmount = try reader["RecurringChargeAmount"].readIfPresent() ?? 0
        value.recurringChargeFrequency = try reader["RecurringChargeFrequency"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ReservedNodesOffering {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ReservedNodesOffering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ReservedNodesOffering()
        value.reservedNodesOfferingId = try reader["ReservedNodesOfferingId"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.fixedPrice = try reader["FixedPrice"].readIfPresent() ?? 0
        value.offeringType = try reader["OfferingType"].readIfPresent()
        value.recurringCharges = try reader["RecurringCharges"].readListIfPresent(memberReadingClosure: MemoryDBClientTypes.RecurringCharge.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MemoryDBClientTypes.ServiceUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.ServiceUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.ServiceUpdate()
        value.clusterName = try reader["ClusterName"].readIfPresent()
        value.serviceUpdateName = try reader["ServiceUpdateName"].readIfPresent()
        value.releaseDate = try reader["ReleaseDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.nodesUpdated = try reader["NodesUpdated"].readIfPresent()
        value.autoUpdateStartDate = try reader["AutoUpdateStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MemoryDBClientTypes.Tag {

    static func write(value: MemoryDBClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MemoryDBClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MemoryDBClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension MemoryDBClientTypes.ServiceUpdateRequest {

    static func write(value: MemoryDBClientTypes.ServiceUpdateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceUpdateNameToApply"].write(value.serviceUpdateNameToApply)
    }
}

extension MemoryDBClientTypes.AuthenticationMode {

    static func write(value: MemoryDBClientTypes.AuthenticationMode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Passwords"].writeList(value.passwords, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension MemoryDBClientTypes.Filter {

    static func write(value: MemoryDBClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MemoryDBClientTypes.ReplicaConfigurationRequest {

    static func write(value: MemoryDBClientTypes.ReplicaConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicaCount"].write(value.replicaCount)
    }
}

extension MemoryDBClientTypes.ShardConfigurationRequest {

    static func write(value: MemoryDBClientTypes.ShardConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ShardCount"].write(value.shardCount)
    }
}

extension MemoryDBClientTypes.ParameterNameValue {

    static func write(value: MemoryDBClientTypes.ParameterNameValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterName"].write(value.parameterName)
        try writer["ParameterValue"].write(value.parameterValue)
    }
}

public enum MemoryDBClientTypes {}
