// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MemoryDBClient {
    /// Paginate over `[DescribeACLsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeACLsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeACLsOutput`
    public func describeACLsPaginated(input: DescribeACLsInput) -> ClientRuntime.PaginatorSequence<DescribeACLsInput, DescribeACLsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeACLsInput, DescribeACLsOutput>(input: input, inputKey: \DescribeACLsInput.nextToken, outputKey: \DescribeACLsOutput.nextToken, paginationFunction: self.describeACLs(input:))
    }
}

extension DescribeACLsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeACLsInput {
        return DescribeACLsInput(
            aclName: self.aclName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeACLsInput, Output == DescribeACLsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeACLsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ACL]`
    /// - Returns: `[MemoryDBClientTypes.ACL]`
    public func acLs() async throws -> [MemoryDBClientTypes.ACL] {
        return try await self.asyncCompactMap { item in item.acLs }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClustersOutput`
    public func describeClustersPaginated(input: DescribeClustersInput) -> ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutput>(input: input, inputKey: \DescribeClustersInput.nextToken, outputKey: \DescribeClustersOutput.nextToken, paginationFunction: self.describeClusters(input:))
    }
}

extension DescribeClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClustersInput {
        return DescribeClustersInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token,
            showShardDetails: self.showShardDetails
        )}
}

extension PaginatorSequence where Input == DescribeClustersInput, Output == DescribeClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClustersPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Cluster]`
    /// - Returns: `[MemoryDBClientTypes.Cluster]`
    public func clusters() async throws -> [MemoryDBClientTypes.Cluster] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeEngineVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEngineVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEngineVersionsOutput`
    public func describeEngineVersionsPaginated(input: DescribeEngineVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeEngineVersionsInput, DescribeEngineVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEngineVersionsInput, DescribeEngineVersionsOutput>(input: input, inputKey: \DescribeEngineVersionsInput.nextToken, outputKey: \DescribeEngineVersionsOutput.nextToken, paginationFunction: self.describeEngineVersions(input:))
    }
}

extension DescribeEngineVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEngineVersionsInput {
        return DescribeEngineVersionsInput(
            defaultOnly: self.defaultOnly,
            engineVersion: self.engineVersion,
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupFamily: self.parameterGroupFamily
        )}
}

extension PaginatorSequence where Input == DescribeEngineVersionsInput, Output == DescribeEngineVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEngineVersionsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.EngineVersionInfo]`
    /// - Returns: `[MemoryDBClientTypes.EngineVersionInfo]`
    public func engineVersions() async throws -> [MemoryDBClientTypes.EngineVersionInfo] {
        return try await self.asyncCompactMap { item in item.engineVersions }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutput`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput>(input: input, inputKey: \DescribeEventsInput.nextToken, outputKey: \DescribeEventsOutput.nextToken, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            sourceName: self.sourceName,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where Input == DescribeEventsInput, Output == DescribeEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Event]`
    /// - Returns: `[MemoryDBClientTypes.Event]`
    public func events() async throws -> [MemoryDBClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeParameterGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeParameterGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeParameterGroupsOutput`
    public func describeParameterGroupsPaginated(input: DescribeParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeParameterGroupsInput, DescribeParameterGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeParameterGroupsInput, DescribeParameterGroupsOutput>(input: input, inputKey: \DescribeParameterGroupsInput.nextToken, outputKey: \DescribeParameterGroupsOutput.nextToken, paginationFunction: self.describeParameterGroups(input:))
    }
}

extension DescribeParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeParameterGroupsInput {
        return DescribeParameterGroupsInput(
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupName: self.parameterGroupName
        )}
}

extension PaginatorSequence where Input == DescribeParameterGroupsInput, Output == DescribeParameterGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeParameterGroupsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ParameterGroup]`
    /// - Returns: `[MemoryDBClientTypes.ParameterGroup]`
    public func parameterGroups() async throws -> [MemoryDBClientTypes.ParameterGroup] {
        return try await self.asyncCompactMap { item in item.parameterGroups }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeParametersOutput`
    public func describeParametersPaginated(input: DescribeParametersInput) -> ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutput>(input: input, inputKey: \DescribeParametersInput.nextToken, outputKey: \DescribeParametersOutput.nextToken, paginationFunction: self.describeParameters(input:))
    }
}

extension DescribeParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeParametersInput {
        return DescribeParametersInput(
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupName: self.parameterGroupName
        )}
}

extension PaginatorSequence where Input == DescribeParametersInput, Output == DescribeParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeParametersPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Parameter]`
    /// - Returns: `[MemoryDBClientTypes.Parameter]`
    public func parameters() async throws -> [MemoryDBClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeReservedNodesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodesOutput`
    public func describeReservedNodesPaginated(input: DescribeReservedNodesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutput>(input: input, inputKey: \DescribeReservedNodesInput.nextToken, outputKey: \DescribeReservedNodesOutput.nextToken, paginationFunction: self.describeReservedNodes(input:))
    }
}

extension DescribeReservedNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodesInput {
        return DescribeReservedNodesInput(
            duration: self.duration,
            maxResults: self.maxResults,
            nextToken: token,
            nodeType: self.nodeType,
            offeringType: self.offeringType,
            reservationId: self.reservationId,
            reservedNodesOfferingId: self.reservedNodesOfferingId
        )}
}

extension PaginatorSequence where Input == DescribeReservedNodesInput, Output == DescribeReservedNodesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodesPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ReservedNode]`
    /// - Returns: `[MemoryDBClientTypes.ReservedNode]`
    public func reservedNodes() async throws -> [MemoryDBClientTypes.ReservedNode] {
        return try await self.asyncCompactMap { item in item.reservedNodes }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeReservedNodesOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodesOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodesOfferingsOutput`
    public func describeReservedNodesOfferingsPaginated(input: DescribeReservedNodesOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodesOfferingsInput, DescribeReservedNodesOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodesOfferingsInput, DescribeReservedNodesOfferingsOutput>(input: input, inputKey: \DescribeReservedNodesOfferingsInput.nextToken, outputKey: \DescribeReservedNodesOfferingsOutput.nextToken, paginationFunction: self.describeReservedNodesOfferings(input:))
    }
}

extension DescribeReservedNodesOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodesOfferingsInput {
        return DescribeReservedNodesOfferingsInput(
            duration: self.duration,
            maxResults: self.maxResults,
            nextToken: token,
            nodeType: self.nodeType,
            offeringType: self.offeringType,
            reservedNodesOfferingId: self.reservedNodesOfferingId
        )}
}

extension PaginatorSequence where Input == DescribeReservedNodesOfferingsInput, Output == DescribeReservedNodesOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodesOfferingsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ReservedNodesOffering]`
    /// - Returns: `[MemoryDBClientTypes.ReservedNodesOffering]`
    public func reservedNodesOfferings() async throws -> [MemoryDBClientTypes.ReservedNodesOffering] {
        return try await self.asyncCompactMap { item in item.reservedNodesOfferings }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeServiceUpdatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeServiceUpdatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeServiceUpdatesOutput`
    public func describeServiceUpdatesPaginated(input: DescribeServiceUpdatesInput) -> ClientRuntime.PaginatorSequence<DescribeServiceUpdatesInput, DescribeServiceUpdatesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeServiceUpdatesInput, DescribeServiceUpdatesOutput>(input: input, inputKey: \DescribeServiceUpdatesInput.nextToken, outputKey: \DescribeServiceUpdatesOutput.nextToken, paginationFunction: self.describeServiceUpdates(input:))
    }
}

extension DescribeServiceUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeServiceUpdatesInput {
        return DescribeServiceUpdatesInput(
            clusterNames: self.clusterNames,
            maxResults: self.maxResults,
            nextToken: token,
            serviceUpdateName: self.serviceUpdateName,
            status: self.status
        )}
}

extension PaginatorSequence where Input == DescribeServiceUpdatesInput, Output == DescribeServiceUpdatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeServiceUpdatesPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ServiceUpdate]`
    /// - Returns: `[MemoryDBClientTypes.ServiceUpdate]`
    public func serviceUpdates() async throws -> [MemoryDBClientTypes.ServiceUpdate] {
        return try await self.asyncCompactMap { item in item.serviceUpdates }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeSnapshotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotsOutput`
    public func describeSnapshotsPaginated(input: DescribeSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutput>(input: input, inputKey: \DescribeSnapshotsInput.nextToken, outputKey: \DescribeSnapshotsOutput.nextToken, paginationFunction: self.describeSnapshots(input:))
    }
}

extension DescribeSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotsInput {
        return DescribeSnapshotsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token,
            showDetail: self.showDetail,
            snapshotName: self.snapshotName,
            source: self.source
        )}
}

extension PaginatorSequence where Input == DescribeSnapshotsInput, Output == DescribeSnapshotsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Snapshot]`
    /// - Returns: `[MemoryDBClientTypes.Snapshot]`
    public func snapshots() async throws -> [MemoryDBClientTypes.Snapshot] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeSubnetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSubnetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSubnetGroupsOutput`
    public func describeSubnetGroupsPaginated(input: DescribeSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeSubnetGroupsInput, DescribeSubnetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSubnetGroupsInput, DescribeSubnetGroupsOutput>(input: input, inputKey: \DescribeSubnetGroupsInput.nextToken, outputKey: \DescribeSubnetGroupsOutput.nextToken, paginationFunction: self.describeSubnetGroups(input:))
    }
}

extension DescribeSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSubnetGroupsInput {
        return DescribeSubnetGroupsInput(
            maxResults: self.maxResults,
            nextToken: token,
            subnetGroupName: self.subnetGroupName
        )}
}

extension PaginatorSequence where Input == DescribeSubnetGroupsInput, Output == DescribeSubnetGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSubnetGroupsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.SubnetGroup]`
    /// - Returns: `[MemoryDBClientTypes.SubnetGroup]`
    public func subnetGroups() async throws -> [MemoryDBClientTypes.SubnetGroup] {
        return try await self.asyncCompactMap { item in item.subnetGroups }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeUsersOutput`
    public func describeUsersPaginated(input: DescribeUsersInput) -> ClientRuntime.PaginatorSequence<DescribeUsersInput, DescribeUsersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeUsersInput, DescribeUsersOutput>(input: input, inputKey: \DescribeUsersInput.nextToken, outputKey: \DescribeUsersOutput.nextToken, paginationFunction: self.describeUsers(input:))
    }
}

extension DescribeUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeUsersInput {
        return DescribeUsersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            userName: self.userName
        )}
}

extension PaginatorSequence where Input == DescribeUsersInput, Output == DescribeUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeUsersPaginated`
    /// to access the nested member `[MemoryDBClientTypes.User]`
    /// - Returns: `[MemoryDBClientTypes.User]`
    public func users() async throws -> [MemoryDBClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
