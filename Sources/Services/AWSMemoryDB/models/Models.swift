// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MemoryDBClientTypes.ACL: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case clusters = "Clusters"
        case minimumEngineVersion = "MinimumEngineVersion"
        case name = "Name"
        case pendingChanges = "PendingChanges"
        case status = "Status"
        case userNames = "UserNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clusters = clusters {
            var clustersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusters)
            for string0 in clusters {
                try clustersContainer.encode(string0)
            }
        }
        if let minimumEngineVersion = self.minimumEngineVersion {
            try encodeContainer.encode(minimumEngineVersion, forKey: .minimumEngineVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pendingChanges = self.pendingChanges {
            try encodeContainer.encode(pendingChanges, forKey: .pendingChanges)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let userNames = userNames {
            var userNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userNames)
            for username0 in userNames {
                try userNamesContainer.encode(username0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let userNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userNames)
        var userNamesDecoded0:[Swift.String]? = nil
        if let userNamesContainer = userNamesContainer {
            userNamesDecoded0 = [Swift.String]()
            for string0 in userNamesContainer {
                if let string0 = string0 {
                    userNamesDecoded0?.append(string0)
                }
            }
        }
        userNames = userNamesDecoded0
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let pendingChangesDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ACLPendingChanges.self, forKey: .pendingChanges)
        pendingChanges = pendingChangesDecoded
        let clustersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusters)
        var clustersDecoded0:[Swift.String]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [Swift.String]()
            for string0 in clustersContainer {
                if let string0 = string0 {
                    clustersDecoded0?.append(string0)
                }
            }
        }
        clusters = clustersDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MemoryDBClientTypes {
    /// An Access Control List. You can authenticate users with Access Contol Lists. ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.
    public struct ACL: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the ACL
        public var arn: Swift.String?
        /// A list of clusters associated with the ACL.
        public var clusters: [Swift.String]?
        /// The minimum engine version supported for the ACL
        public var minimumEngineVersion: Swift.String?
        /// The name of the Access Control List
        public var name: Swift.String?
        /// A list of updates being applied to the ACL.
        public var pendingChanges: MemoryDBClientTypes.ACLPendingChanges?
        /// Indicates ACL status. Can be "creating", "active", "modifying", "deleting".
        public var status: Swift.String?
        /// The list of user names that belong to the ACL.
        public var userNames: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            clusters: [Swift.String]? = nil,
            minimumEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingChanges: MemoryDBClientTypes.ACLPendingChanges? = nil,
            status: Swift.String? = nil,
            userNames: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.clusters = clusters
            self.minimumEngineVersion = minimumEngineVersion
            self.name = name
            self.pendingChanges = pendingChanges
            self.status = status
            self.userNames = userNames
        }
    }

}

extension ACLAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ACLAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ACLAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ACLAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ACLAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ACLAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ACLNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ACLNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ACLNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ACLNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ACLNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ACLNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ACLPendingChanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userNamesToAdd = "UserNamesToAdd"
        case userNamesToRemove = "UserNamesToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userNamesToAdd = userNamesToAdd {
            var userNamesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userNamesToAdd)
            for username0 in userNamesToAdd {
                try userNamesToAddContainer.encode(username0)
            }
        }
        if let userNamesToRemove = userNamesToRemove {
            var userNamesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userNamesToRemove)
            for username0 in userNamesToRemove {
                try userNamesToRemoveContainer.encode(username0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNamesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userNamesToRemove)
        var userNamesToRemoveDecoded0:[Swift.String]? = nil
        if let userNamesToRemoveContainer = userNamesToRemoveContainer {
            userNamesToRemoveDecoded0 = [Swift.String]()
            for string0 in userNamesToRemoveContainer {
                if let string0 = string0 {
                    userNamesToRemoveDecoded0?.append(string0)
                }
            }
        }
        userNamesToRemove = userNamesToRemoveDecoded0
        let userNamesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userNamesToAdd)
        var userNamesToAddDecoded0:[Swift.String]? = nil
        if let userNamesToAddContainer = userNamesToAddContainer {
            userNamesToAddDecoded0 = [Swift.String]()
            for string0 in userNamesToAddContainer {
                if let string0 = string0 {
                    userNamesToAddDecoded0?.append(string0)
                }
            }
        }
        userNamesToAdd = userNamesToAddDecoded0
    }
}

extension MemoryDBClientTypes {
    /// Returns the updates being applied to the ACL.
    public struct ACLPendingChanges: Swift.Equatable {
        /// A list of users being added to the ACL
        public var userNamesToAdd: [Swift.String]?
        /// A list of user names being removed from the ACL
        public var userNamesToRemove: [Swift.String]?

        public init(
            userNamesToAdd: [Swift.String]? = nil,
            userNamesToRemove: [Swift.String]? = nil
        )
        {
            self.userNamesToAdd = userNamesToAdd
            self.userNamesToRemove = userNamesToRemove
        }
    }

}

extension ACLQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ACLQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ACLQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ACLQuotaExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ACLQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ACLQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ACLsUpdateStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclToApply = "ACLToApply"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclToApply = self.aclToApply {
            try encodeContainer.encode(aclToApply, forKey: .aclToApply)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclToApplyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclToApply)
        aclToApply = aclToApplyDecoded
    }
}

extension MemoryDBClientTypes {
    /// The status of the ACL update
    public struct ACLsUpdateStatus: Swift.Equatable {
        /// A list of ACLs pending to be applied.
        public var aclToApply: Swift.String?

        public init(
            aclToApply: Swift.String? = nil
        )
        {
            self.aclToApply = aclToApply
        }
    }

}

extension APICallRateForCustomerExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: APICallRateForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct APICallRateForCustomerExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "APICallRateForCustomerExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct APICallRateForCustomerExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension APICallRateForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes {
    public enum AZStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiaz
        case singleaz
        case sdkUnknown(Swift.String)

        public static var allCases: [AZStatus] {
            return [
                .multiaz,
                .singleaz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiaz: return "multiaz"
            case .singleaz: return "singleaz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AZStatus(rawValue: rawValue) ?? AZStatus.sdkUnknown(rawValue)
        }
    }
}

extension MemoryDBClientTypes.Authentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case passwordCount = "PasswordCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let passwordCount = self.passwordCount {
            try encodeContainer.encode(passwordCount, forKey: .passwordCount)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.AuthenticationType.self, forKey: .type)
        type = typeDecoded
        let passwordCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passwordCount)
        passwordCount = passwordCountDecoded
    }
}

extension MemoryDBClientTypes {
    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
    public struct Authentication: Swift.Equatable {
        /// The number of passwords belonging to the user. The maximum is two.
        public var passwordCount: Swift.Int?
        /// Indicates whether the user requires a password to authenticate.
        public var type: MemoryDBClientTypes.AuthenticationType?

        public init(
            passwordCount: Swift.Int? = nil,
            type: MemoryDBClientTypes.AuthenticationType? = nil
        )
        {
            self.passwordCount = passwordCount
            self.type = type
        }
    }

}

extension MemoryDBClientTypes.AuthenticationMode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case passwords = "Passwords"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let passwords = passwords {
            var passwordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .passwords)
            for string0 in passwords {
                try passwordsContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.InputAuthenticationType.self, forKey: .type)
        type = typeDecoded
        let passwordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .passwords)
        var passwordsDecoded0:[Swift.String]? = nil
        if let passwordsContainer = passwordsContainer {
            passwordsDecoded0 = [Swift.String]()
            for string0 in passwordsContainer {
                if let string0 = string0 {
                    passwordsDecoded0?.append(string0)
                }
            }
        }
        passwords = passwordsDecoded0
    }
}

extension MemoryDBClientTypes {
    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
    public struct AuthenticationMode: Swift.Equatable {
        /// The password(s) used for authentication
        public var passwords: [Swift.String]?
        /// Indicates whether the user requires a password to authenticate. All newly-created users require a password.
        public var type: MemoryDBClientTypes.InputAuthenticationType?

        public init(
            passwords: [Swift.String]? = nil,
            type: MemoryDBClientTypes.InputAuthenticationType? = nil
        )
        {
            self.passwords = passwords
            self.type = type
        }
    }

}

extension MemoryDBClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case noPassword
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .iam,
                .noPassword,
                .password,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "iam"
            case .noPassword: return "no-password"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension MemoryDBClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MemoryDBClientTypes {
    /// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
    public struct AvailabilityZone: Swift.Equatable {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension BatchUpdateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case serviceUpdate = "ServiceUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterNames = clusterNames {
            var clusterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNames)
            for string0 in clusterNames {
                try clusterNamesContainer.encode(string0)
            }
        }
        if let serviceUpdate = self.serviceUpdate {
            try encodeContainer.encode(serviceUpdate, forKey: .serviceUpdate)
        }
    }
}

extension BatchUpdateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchUpdateClusterInput: Swift.Equatable {
    /// The cluster names to apply the updates.
    /// This member is required.
    public var clusterNames: [Swift.String]?
    /// The unique ID of the service update
    public var serviceUpdate: MemoryDBClientTypes.ServiceUpdateRequest?

    public init(
        clusterNames: [Swift.String]? = nil,
        serviceUpdate: MemoryDBClientTypes.ServiceUpdateRequest? = nil
    )
    {
        self.clusterNames = clusterNames
        self.serviceUpdate = serviceUpdate
    }
}

struct BatchUpdateClusterInputBody: Swift.Equatable {
    let clusterNames: [Swift.String]?
    let serviceUpdate: MemoryDBClientTypes.ServiceUpdateRequest?
}

extension BatchUpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case serviceUpdate = "ServiceUpdate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusterNames)
        var clusterNamesDecoded0:[Swift.String]? = nil
        if let clusterNamesContainer = clusterNamesContainer {
            clusterNamesDecoded0 = [Swift.String]()
            for string0 in clusterNamesContainer {
                if let string0 = string0 {
                    clusterNamesDecoded0?.append(string0)
                }
            }
        }
        clusterNames = clusterNamesDecoded0
        let serviceUpdateDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ServiceUpdateRequest.self, forKey: .serviceUpdate)
        serviceUpdate = serviceUpdateDecoded
    }
}

extension BatchUpdateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.processedClusters = output.processedClusters
            self.unprocessedClusters = output.unprocessedClusters
        } else {
            self.processedClusters = nil
            self.unprocessedClusters = nil
        }
    }
}

public struct BatchUpdateClusterOutput: Swift.Equatable {
    /// The list of clusters that have been updated.
    public var processedClusters: [MemoryDBClientTypes.Cluster]?
    /// The list of clusters where updates have not been applied.
    public var unprocessedClusters: [MemoryDBClientTypes.UnprocessedCluster]?

    public init(
        processedClusters: [MemoryDBClientTypes.Cluster]? = nil,
        unprocessedClusters: [MemoryDBClientTypes.UnprocessedCluster]? = nil
    )
    {
        self.processedClusters = processedClusters
        self.unprocessedClusters = unprocessedClusters
    }
}

struct BatchUpdateClusterOutputBody: Swift.Equatable {
    let processedClusters: [MemoryDBClientTypes.Cluster]?
    let unprocessedClusters: [MemoryDBClientTypes.UnprocessedCluster]?
}

extension BatchUpdateClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processedClusters = "ProcessedClusters"
        case unprocessedClusters = "UnprocessedClusters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processedClustersContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Cluster?].self, forKey: .processedClusters)
        var processedClustersDecoded0:[MemoryDBClientTypes.Cluster]? = nil
        if let processedClustersContainer = processedClustersContainer {
            processedClustersDecoded0 = [MemoryDBClientTypes.Cluster]()
            for structure0 in processedClustersContainer {
                if let structure0 = structure0 {
                    processedClustersDecoded0?.append(structure0)
                }
            }
        }
        processedClusters = processedClustersDecoded0
        let unprocessedClustersContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.UnprocessedCluster?].self, forKey: .unprocessedClusters)
        var unprocessedClustersDecoded0:[MemoryDBClientTypes.UnprocessedCluster]? = nil
        if let unprocessedClustersContainer = unprocessedClustersContainer {
            unprocessedClustersDecoded0 = [MemoryDBClientTypes.UnprocessedCluster]()
            for structure0 in unprocessedClustersContainer {
                if let structure0 = structure0 {
                    unprocessedClustersDecoded0?.append(structure0)
                }
            }
        }
        unprocessedClusters = unprocessedClustersDecoded0
    }
}

enum BatchUpdateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUpdateNotFoundFault": return try await ServiceUpdateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryDBClientTypes.Cluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case arn = "ARN"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityMode = "AvailabilityMode"
        case clusterEndpoint = "ClusterEndpoint"
        case dataTiering = "DataTiering"
        case description = "Description"
        case enginePatchVersion = "EnginePatchVersion"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceWindow = "MaintenanceWindow"
        case name = "Name"
        case nodeType = "NodeType"
        case numberOfShards = "NumberOfShards"
        case parameterGroupName = "ParameterGroupName"
        case parameterGroupStatus = "ParameterGroupStatus"
        case pendingUpdates = "PendingUpdates"
        case securityGroups = "SecurityGroups"
        case shards = "Shards"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicStatus = "SnsTopicStatus"
        case status = "Status"
        case subnetGroupName = "SubnetGroupName"
        case tlsEnabled = "TLSEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityMode = self.availabilityMode {
            try encodeContainer.encode(availabilityMode.rawValue, forKey: .availabilityMode)
        }
        if let clusterEndpoint = self.clusterEndpoint {
            try encodeContainer.encode(clusterEndpoint, forKey: .clusterEndpoint)
        }
        if let dataTiering = self.dataTiering {
            try encodeContainer.encode(dataTiering.rawValue, forKey: .dataTiering)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enginePatchVersion = self.enginePatchVersion {
            try encodeContainer.encode(enginePatchVersion, forKey: .enginePatchVersion)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let numberOfShards = self.numberOfShards {
            try encodeContainer.encode(numberOfShards, forKey: .numberOfShards)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterGroupStatus = self.parameterGroupStatus {
            try encodeContainer.encode(parameterGroupStatus, forKey: .parameterGroupStatus)
        }
        if let pendingUpdates = self.pendingUpdates {
            try encodeContainer.encode(pendingUpdates, forKey: .pendingUpdates)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupmembership0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupmembership0)
            }
        }
        if let shards = shards {
            var shardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shards)
            for shard0 in shards {
                try shardsContainer.encode(shard0)
            }
        }
        if let snapshotRetentionLimit = self.snapshotRetentionLimit {
            try encodeContainer.encode(snapshotRetentionLimit, forKey: .snapshotRetentionLimit)
        }
        if let snapshotWindow = self.snapshotWindow {
            try encodeContainer.encode(snapshotWindow, forKey: .snapshotWindow)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let snsTopicStatus = self.snsTopicStatus {
            try encodeContainer.encode(snsTopicStatus, forKey: .snsTopicStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let tlsEnabled = self.tlsEnabled {
            try encodeContainer.encode(tlsEnabled, forKey: .tlsEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let pendingUpdatesDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ClusterPendingUpdates.self, forKey: .pendingUpdates)
        pendingUpdates = pendingUpdatesDecoded
        let numberOfShardsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfShards)
        numberOfShards = numberOfShardsDecoded
        let shardsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Shard?].self, forKey: .shards)
        var shardsDecoded0:[MemoryDBClientTypes.Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [MemoryDBClientTypes.Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let availabilityModeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.AZStatus.self, forKey: .availabilityMode)
        availabilityMode = availabilityModeDecoded
        let clusterEndpointDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Endpoint.self, forKey: .clusterEndpoint)
        clusterEndpoint = clusterEndpointDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let enginePatchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enginePatchVersion)
        enginePatchVersion = enginePatchVersionDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.SecurityGroupMembership?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[MemoryDBClientTypes.SecurityGroupMembership]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [MemoryDBClientTypes.SecurityGroupMembership]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let tlsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tlsEnabled)
        tlsEnabled = tlsEnabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsTopicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicStatus)
        snsTopicStatus = snsTopicStatusDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let dataTieringDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.DataTieringStatus.self, forKey: .dataTiering)
        dataTiering = dataTieringDecoded
    }
}

extension MemoryDBClientTypes {
    /// Contains all of the attributes of a specific cluster.
    public struct Cluster: Swift.Equatable {
        /// The name of the Access Control List associated with this cluster.
        public var aclName: Swift.String?
        /// The Amazon Resource Name (ARN) of the cluster.
        public var arn: Swift.String?
        /// When set to true, the cluster will automatically receive minor engine version upgrades after launch.
        public var autoMinorVersionUpgrade: Swift.Bool?
        /// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
        public var availabilityMode: MemoryDBClientTypes.AZStatus?
        /// The cluster's configuration endpoint
        public var clusterEndpoint: MemoryDBClientTypes.Endpoint?
        /// Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see [Data tiering](https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html).
        public var dataTiering: MemoryDBClientTypes.DataTieringStatus?
        /// A description of the cluster
        public var description: Swift.String?
        /// The Redis engine patch version used by the cluster
        public var enginePatchVersion: Swift.String?
        /// The Redis engine version used by the cluster
        public var engineVersion: Swift.String?
        /// The ID of the KMS key used to encrypt the cluster
        public var kmsKeyId: Swift.String?
        /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.
        public var maintenanceWindow: Swift.String?
        /// The user-supplied name of the cluster. This identifier is a unique key that identifies a cluster.
        public var name: Swift.String?
        /// The cluster's node type
        public var nodeType: Swift.String?
        /// The number of shards in the cluster
        public var numberOfShards: Swift.Int?
        /// The name of the parameter group used by the cluster
        public var parameterGroupName: Swift.String?
        /// The status of the parameter group used by the cluster, for example 'active' or 'applying'.
        public var parameterGroupStatus: Swift.String?
        /// A group of settings that are currently being applied.
        public var pendingUpdates: MemoryDBClientTypes.ClusterPendingUpdates?
        /// A list of security groups used by the cluster
        public var securityGroups: [MemoryDBClientTypes.SecurityGroupMembership]?
        /// A list of shards that are members of the cluster.
        public var shards: [MemoryDBClientTypes.Shard]?
        /// The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
        public var snapshotRetentionLimit: Swift.Int?
        /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard. Example: 05:00-09:00 If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.
        public var snapshotWindow: Swift.String?
        /// The Amazon Resource Name (ARN) of the SNS notification topic
        public var snsTopicArn: Swift.String?
        /// The SNS topic must be in Active status to receive notifications
        public var snsTopicStatus: Swift.String?
        /// The status of the cluster. For example, Available, Updating, Creating.
        public var status: Swift.String?
        /// The name of the subnet group used by the cluster
        public var subnetGroupName: Swift.String?
        /// A flag to indicate if In-transit encryption is enabled
        public var tlsEnabled: Swift.Bool?

        public init(
            aclName: Swift.String? = nil,
            arn: Swift.String? = nil,
            autoMinorVersionUpgrade: Swift.Bool? = nil,
            availabilityMode: MemoryDBClientTypes.AZStatus? = nil,
            clusterEndpoint: MemoryDBClientTypes.Endpoint? = nil,
            dataTiering: MemoryDBClientTypes.DataTieringStatus? = nil,
            description: Swift.String? = nil,
            enginePatchVersion: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfShards: Swift.Int? = nil,
            parameterGroupName: Swift.String? = nil,
            parameterGroupStatus: Swift.String? = nil,
            pendingUpdates: MemoryDBClientTypes.ClusterPendingUpdates? = nil,
            securityGroups: [MemoryDBClientTypes.SecurityGroupMembership]? = nil,
            shards: [MemoryDBClientTypes.Shard]? = nil,
            snapshotRetentionLimit: Swift.Int? = nil,
            snapshotWindow: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            snsTopicStatus: Swift.String? = nil,
            status: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            tlsEnabled: Swift.Bool? = nil
        )
        {
            self.aclName = aclName
            self.arn = arn
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityMode = availabilityMode
            self.clusterEndpoint = clusterEndpoint
            self.dataTiering = dataTiering
            self.description = description
            self.enginePatchVersion = enginePatchVersion
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.nodeType = nodeType
            self.numberOfShards = numberOfShards
            self.parameterGroupName = parameterGroupName
            self.parameterGroupStatus = parameterGroupStatus
            self.pendingUpdates = pendingUpdates
            self.securityGroups = securityGroups
            self.shards = shards
            self.snapshotRetentionLimit = snapshotRetentionLimit
            self.snapshotWindow = snapshotWindow
            self.snsTopicArn = snsTopicArn
            self.snsTopicStatus = snsTopicStatus
            self.status = status
            self.subnetGroupName = subnetGroupName
            self.tlsEnabled = tlsEnabled
        }
    }

}

extension ClusterAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClusterAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ClusterAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ClusterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case engineVersion = "EngineVersion"
        case maintenanceWindow = "MaintenanceWindow"
        case name = "Name"
        case nodeType = "NodeType"
        case numShards = "NumShards"
        case parameterGroupName = "ParameterGroupName"
        case port = "Port"
        case shards = "Shards"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case subnetGroupName = "SubnetGroupName"
        case topicArn = "TopicArn"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let numShards = self.numShards {
            try encodeContainer.encode(numShards, forKey: .numShards)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let shards = shards {
            var shardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shards)
            for sharddetail0 in shards {
                try shardsContainer.encode(sharddetail0)
            }
        }
        if let snapshotRetentionLimit = self.snapshotRetentionLimit {
            try encodeContainer.encode(snapshotRetentionLimit, forKey: .snapshotRetentionLimit)
        }
        if let snapshotWindow = self.snapshotWindow {
            try encodeContainer.encode(snapshotWindow, forKey: .snapshotWindow)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let numShardsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numShards)
        numShards = numShardsDecoded
        let shardsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ShardDetail?].self, forKey: .shards)
        var shardsDecoded0:[MemoryDBClientTypes.ShardDetail]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [MemoryDBClientTypes.ShardDetail]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
    }
}

extension MemoryDBClientTypes {
    /// A list of cluster configuration options.
    public struct ClusterConfiguration: Swift.Equatable {
        /// The description of the cluster configuration
        public var description: Swift.String?
        /// The Redis engine version used by the cluster
        public var engineVersion: Swift.String?
        /// The specified maintenance window for the cluster
        public var maintenanceWindow: Swift.String?
        /// The name of the cluster
        public var name: Swift.String?
        /// The node type used for the cluster
        public var nodeType: Swift.String?
        /// The number of shards in the cluster
        public var numShards: Swift.Int?
        /// The name of parameter group used by the cluster
        public var parameterGroupName: Swift.String?
        /// The port used by the cluster
        public var port: Swift.Int?
        /// The list of shards in the cluster
        public var shards: [MemoryDBClientTypes.ShardDetail]?
        /// The snapshot retention limit set by the cluster
        public var snapshotRetentionLimit: Swift.Int?
        /// The snapshot window set by the cluster
        public var snapshotWindow: Swift.String?
        /// The name of the subnet group used by the cluster
        public var subnetGroupName: Swift.String?
        /// The Amazon Resource Name (ARN) of the SNS notification topic for the cluster
        public var topicArn: Swift.String?
        /// The ID of the VPC the cluster belongs to
        public var vpcId: Swift.String?

        public init(
            description: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numShards: Swift.Int? = nil,
            parameterGroupName: Swift.String? = nil,
            port: Swift.Int? = nil,
            shards: [MemoryDBClientTypes.ShardDetail]? = nil,
            snapshotRetentionLimit: Swift.Int? = nil,
            snapshotWindow: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            topicArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.description = description
            self.engineVersion = engineVersion
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.nodeType = nodeType
            self.numShards = numShards
            self.parameterGroupName = parameterGroupName
            self.port = port
            self.shards = shards
            self.snapshotRetentionLimit = snapshotRetentionLimit
            self.snapshotWindow = snapshotWindow
            self.subnetGroupName = subnetGroupName
            self.topicArn = topicArn
            self.vpcId = vpcId
        }
    }

}

extension ClusterNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClusterNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ClusterNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClusterNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ClusterPendingUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acLs = "ACLs"
        case resharding = "Resharding"
        case serviceUpdates = "ServiceUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acLs = self.acLs {
            try encodeContainer.encode(acLs, forKey: .acLs)
        }
        if let resharding = self.resharding {
            try encodeContainer.encode(resharding, forKey: .resharding)
        }
        if let serviceUpdates = serviceUpdates {
            var serviceUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceUpdates)
            for pendingmodifiedserviceupdate0 in serviceUpdates {
                try serviceUpdatesContainer.encode(pendingmodifiedserviceupdate0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reshardingDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ReshardingStatus.self, forKey: .resharding)
        resharding = reshardingDecoded
        let acLsDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ACLsUpdateStatus.self, forKey: .acLs)
        acLs = acLsDecoded
        let serviceUpdatesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.PendingModifiedServiceUpdate?].self, forKey: .serviceUpdates)
        var serviceUpdatesDecoded0:[MemoryDBClientTypes.PendingModifiedServiceUpdate]? = nil
        if let serviceUpdatesContainer = serviceUpdatesContainer {
            serviceUpdatesDecoded0 = [MemoryDBClientTypes.PendingModifiedServiceUpdate]()
            for structure0 in serviceUpdatesContainer {
                if let structure0 = structure0 {
                    serviceUpdatesDecoded0?.append(structure0)
                }
            }
        }
        serviceUpdates = serviceUpdatesDecoded0
    }
}

extension MemoryDBClientTypes {
    /// A list of updates being applied to the cluster
    public struct ClusterPendingUpdates: Swift.Equatable {
        /// A list of ACLs associated with the cluster that are being updated
        public var acLs: MemoryDBClientTypes.ACLsUpdateStatus?
        /// The status of an online resharding operation.
        public var resharding: MemoryDBClientTypes.ReshardingStatus?
        /// A list of service updates being applied to the cluster
        public var serviceUpdates: [MemoryDBClientTypes.PendingModifiedServiceUpdate]?

        public init(
            acLs: MemoryDBClientTypes.ACLsUpdateStatus? = nil,
            resharding: MemoryDBClientTypes.ReshardingStatus? = nil,
            serviceUpdates: [MemoryDBClientTypes.PendingModifiedServiceUpdate]? = nil
        )
        {
            self.acLs = acLs
            self.resharding = resharding
            self.serviceUpdates = serviceUpdates
        }
    }

}

extension ClusterQuotaForCustomerExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClusterQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ClusterQuotaForCustomerExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterQuotaForCustomerExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClusterQuotaForCustomerExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CopySnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case sourceSnapshotName = "SourceSnapshotName"
        case tags = "Tags"
        case targetBucket = "TargetBucket"
        case targetSnapshotName = "TargetSnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let sourceSnapshotName = self.sourceSnapshotName {
            try encodeContainer.encode(sourceSnapshotName, forKey: .sourceSnapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetBucket = self.targetBucket {
            try encodeContainer.encode(targetBucket, forKey: .targetBucket)
        }
        if let targetSnapshotName = self.targetSnapshotName {
            try encodeContainer.encode(targetSnapshotName, forKey: .targetSnapshotName)
        }
    }
}

extension CopySnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopySnapshotInput: Swift.Equatable {
    /// The ID of the KMS key used to encrypt the target snapshot.
    public var kmsKeyId: Swift.String?
    /// The name of an existing snapshot from which to make a copy.
    /// This member is required.
    public var sourceSnapshotName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// The Amazon S3 bucket to which the snapshot is exported. This parameter is used only when exporting a snapshot for external access. When using this parameter to export a snapshot, be sure MemoryDB has the needed permissions to this S3 bucket. For more information, see [Step 2: Grant MemoryDB Access to Your Amazon S3 Bucket](https://docs.aws.amazon.com/MemoryDB/latest/devguide/snapshots-exporting.html).
    public var targetBucket: Swift.String?
    /// A name for the snapshot copy. MemoryDB does not permit overwriting a snapshot, therefore this name must be unique within its context - MemoryDB or an Amazon S3 bucket if exporting.
    /// This member is required.
    public var targetSnapshotName: Swift.String?

    public init(
        kmsKeyId: Swift.String? = nil,
        sourceSnapshotName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        targetBucket: Swift.String? = nil,
        targetSnapshotName: Swift.String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.sourceSnapshotName = sourceSnapshotName
        self.tags = tags
        self.targetBucket = targetBucket
        self.targetSnapshotName = targetSnapshotName
    }
}

struct CopySnapshotInputBody: Swift.Equatable {
    let sourceSnapshotName: Swift.String?
    let targetSnapshotName: Swift.String?
    let targetBucket: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension CopySnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case sourceSnapshotName = "SourceSnapshotName"
        case tags = "Tags"
        case targetBucket = "TargetBucket"
        case targetSnapshotName = "TargetSnapshotName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceSnapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotName)
        sourceSnapshotName = sourceSnapshotNameDecoded
        let targetSnapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSnapshotName)
        targetSnapshotName = targetSnapshotNameDecoded
        let targetBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBucket)
        targetBucket = targetBucketDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopySnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopySnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CopySnapshotOutput: Swift.Equatable {
    /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
    public var snapshot: MemoryDBClientTypes.Snapshot?

    public init(
        snapshot: MemoryDBClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CopySnapshotOutputBody: Swift.Equatable {
    let snapshot: MemoryDBClientTypes.Snapshot?
}

extension CopySnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum CopySnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSnapshotState": return try await InvalidSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotAlreadyExistsFault": return try await SnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotNotFoundFault": return try await SnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotQuotaExceededFault": return try await SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateACLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case tags = "Tags"
        case userNames = "UserNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userNames = userNames {
            var userNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userNames)
            for username0 in userNames {
                try userNamesContainer.encode(username0)
            }
        }
    }
}

extension CreateACLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateACLInput: Swift.Equatable {
    /// The name of the Access Control List.
    /// This member is required.
    public var aclName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// The list of users that belong to the Access Control List.
    public var userNames: [Swift.String]?

    public init(
        aclName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        userNames: [Swift.String]? = nil
    )
    {
        self.aclName = aclName
        self.tags = tags
        self.userNames = userNames
    }
}

struct CreateACLInputBody: Swift.Equatable {
    let aclName: Swift.String?
    let userNames: [Swift.String]?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension CreateACLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case tags = "Tags"
        case userNames = "UserNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
        let userNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userNames)
        var userNamesDecoded0:[Swift.String]? = nil
        if let userNamesContainer = userNamesContainer {
            userNamesDecoded0 = [Swift.String]()
            for string0 in userNamesContainer {
                if let string0 = string0 {
                    userNamesDecoded0?.append(string0)
                }
            }
        }
        userNames = userNamesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateACLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateACLOutputBody = try responseDecoder.decode(responseBody: data)
            self.acl = output.acl
        } else {
            self.acl = nil
        }
    }
}

public struct CreateACLOutput: Swift.Equatable {
    /// The newly-created Access Control List.
    public var acl: MemoryDBClientTypes.ACL?

    public init(
        acl: MemoryDBClientTypes.ACL? = nil
    )
    {
        self.acl = acl
    }
}

struct CreateACLOutputBody: Swift.Equatable {
    let acl: MemoryDBClientTypes.ACL?
}

extension CreateACLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acl = "ACL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ACL.self, forKey: .acl)
        acl = aclDecoded
    }
}

enum CreateACLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLAlreadyExists": return try await ACLAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ACLQuotaExceeded": return try await ACLQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DefaultUserRequired": return try await DefaultUserRequired(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateUserName": return try await DuplicateUserNameFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case clusterName = "ClusterName"
        case dataTiering = "DataTiering"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceWindow = "MaintenanceWindow"
        case nodeType = "NodeType"
        case numReplicasPerShard = "NumReplicasPerShard"
        case numShards = "NumShards"
        case parameterGroupName = "ParameterGroupName"
        case port = "Port"
        case securityGroupIds = "SecurityGroupIds"
        case snapshotArns = "SnapshotArns"
        case snapshotName = "SnapshotName"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case snsTopicArn = "SnsTopicArn"
        case subnetGroupName = "SubnetGroupName"
        case tlsEnabled = "TLSEnabled"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let dataTiering = self.dataTiering {
            try encodeContainer.encode(dataTiering, forKey: .dataTiering)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let numReplicasPerShard = self.numReplicasPerShard {
            try encodeContainer.encode(numReplicasPerShard, forKey: .numReplicasPerShard)
        }
        if let numShards = self.numShards {
            try encodeContainer.encode(numShards, forKey: .numShards)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let snapshotArns = snapshotArns {
            var snapshotArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshotArns)
            for string0 in snapshotArns {
                try snapshotArnsContainer.encode(string0)
            }
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let snapshotRetentionLimit = self.snapshotRetentionLimit {
            try encodeContainer.encode(snapshotRetentionLimit, forKey: .snapshotRetentionLimit)
        }
        if let snapshotWindow = self.snapshotWindow {
            try encodeContainer.encode(snapshotWindow, forKey: .snapshotWindow)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let tlsEnabled = self.tlsEnabled {
            try encodeContainer.encode(tlsEnabled, forKey: .tlsEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// The name of the Access Control List to associate with the cluster.
    /// This member is required.
    public var aclName: Swift.String?
    /// When set to true, the cluster will automatically receive minor engine version upgrades after launch.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The name of the cluster. This value must be unique as it also serves as the cluster identifier.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see [Data tiering](https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html).
    public var dataTiering: Swift.Bool?
    /// An optional description of the cluster.
    public var description: Swift.String?
    /// The version number of the Redis engine to be used for the cluster.
    public var engineVersion: Swift.String?
    /// The ID of the KMS key used to encrypt the cluster.
    public var kmsKeyId: Swift.String?
    /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:
    ///
    /// * sun
    ///
    /// * mon
    ///
    /// * tue
    ///
    /// * wed
    ///
    /// * thu
    ///
    /// * fri
    ///
    /// * sat
    ///
    ///
    /// Example: sun:23:00-mon:01:30
    public var maintenanceWindow: Swift.String?
    /// The compute and memory capacity of the nodes in the cluster.
    /// This member is required.
    public var nodeType: Swift.String?
    /// The number of replicas to apply to each shard. The default value is 1. The maximum is 5.
    public var numReplicasPerShard: Swift.Int?
    /// The number of shards the cluster will contain. The default value is 1.
    public var numShards: Swift.Int?
    /// The name of the parameter group associated with the cluster.
    public var parameterGroupName: Swift.String?
    /// The port number on which each of the nodes accepts connections.
    public var port: Swift.Int?
    /// A list of security group names to associate with this cluster.
    public var securityGroupIds: [Swift.String]?
    /// A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.
    public var snapshotArns: [Swift.String]?
    /// The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.
    public var snapshotName: Swift.String?
    /// The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
    public var snapshotRetentionLimit: Swift.Int?
    /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard. Example: 05:00-09:00 If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.
    public var snapshotWindow: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.
    public var snsTopicArn: Swift.String?
    /// The name of the subnet group to be used for the cluster.
    public var subnetGroupName: Swift.String?
    /// A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// A flag to enable in-transit encryption on the cluster.
    public var tlsEnabled: Swift.Bool?

    public init(
        aclName: Swift.String? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        clusterName: Swift.String? = nil,
        dataTiering: Swift.Bool? = nil,
        description: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        maintenanceWindow: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        numReplicasPerShard: Swift.Int? = nil,
        numShards: Swift.Int? = nil,
        parameterGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snapshotArns: [Swift.String]? = nil,
        snapshotName: Swift.String? = nil,
        snapshotRetentionLimit: Swift.Int? = nil,
        snapshotWindow: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        tlsEnabled: Swift.Bool? = nil
    )
    {
        self.aclName = aclName
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.clusterName = clusterName
        self.dataTiering = dataTiering
        self.description = description
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.maintenanceWindow = maintenanceWindow
        self.nodeType = nodeType
        self.numReplicasPerShard = numReplicasPerShard
        self.numShards = numShards
        self.parameterGroupName = parameterGroupName
        self.port = port
        self.securityGroupIds = securityGroupIds
        self.snapshotArns = snapshotArns
        self.snapshotName = snapshotName
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.snapshotWindow = snapshotWindow
        self.snsTopicArn = snsTopicArn
        self.subnetGroupName = subnetGroupName
        self.tags = tags
        self.tlsEnabled = tlsEnabled
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let nodeType: Swift.String?
    let parameterGroupName: Swift.String?
    let description: Swift.String?
    let numShards: Swift.Int?
    let numReplicasPerShard: Swift.Int?
    let subnetGroupName: Swift.String?
    let securityGroupIds: [Swift.String]?
    let maintenanceWindow: Swift.String?
    let port: Swift.Int?
    let snsTopicArn: Swift.String?
    let tlsEnabled: Swift.Bool?
    let kmsKeyId: Swift.String?
    let snapshotArns: [Swift.String]?
    let snapshotName: Swift.String?
    let snapshotRetentionLimit: Swift.Int?
    let tags: [MemoryDBClientTypes.Tag]?
    let snapshotWindow: Swift.String?
    let aclName: Swift.String?
    let engineVersion: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let dataTiering: Swift.Bool?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case clusterName = "ClusterName"
        case dataTiering = "DataTiering"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceWindow = "MaintenanceWindow"
        case nodeType = "NodeType"
        case numReplicasPerShard = "NumReplicasPerShard"
        case numShards = "NumShards"
        case parameterGroupName = "ParameterGroupName"
        case port = "Port"
        case securityGroupIds = "SecurityGroupIds"
        case snapshotArns = "SnapshotArns"
        case snapshotName = "SnapshotName"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case snsTopicArn = "SnsTopicArn"
        case subnetGroupName = "SubnetGroupName"
        case tlsEnabled = "TLSEnabled"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let numShardsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numShards)
        numShards = numShardsDecoded
        let numReplicasPerShardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numReplicasPerShard)
        numReplicasPerShard = numReplicasPerShardDecoded
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let tlsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tlsEnabled)
        tlsEnabled = tlsEnabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let snapshotArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snapshotArns)
        var snapshotArnsDecoded0:[Swift.String]? = nil
        if let snapshotArnsContainer = snapshotArnsContainer {
            snapshotArnsDecoded0 = [Swift.String]()
            for string0 in snapshotArnsContainer {
                if let string0 = string0 {
                    snapshotArnsDecoded0?.append(string0)
                }
            }
        }
        snapshotArns = snapshotArnsDecoded0
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let dataTieringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTiering)
        dataTiering = dataTieringDecoded
    }
}

extension CreateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutput: Swift.Equatable {
    /// The newly-created cluster.
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputBody: Swift.Equatable {
    let cluster: MemoryDBClientTypes.Cluster?
}

extension CreateClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum CreateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterAlreadyExists": return try await ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterQuotaForCustomerExceeded": return try await ClusterQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientClusterCapacity": return try await InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidACLState": return try await InvalidACLStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCredentialsException": return try await InvalidCredentialsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidVPCNetworkStateFault": return try await InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NodeQuotaForClusterExceeded": return try await NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NodeQuotaForCustomerExceeded": return try await NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ShardsPerClusterQuotaExceeded": return try await ShardsPerClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case family = "Family"
        case parameterGroupName = "ParameterGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateParameterGroupInput: Swift.Equatable {
    /// An optional description of the parameter group.
    public var description: Swift.String?
    /// The name of the parameter group family that the parameter group can be used with.
    /// This member is required.
    public var family: Swift.String?
    /// The name of the parameter group.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        family: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.family = family
        self.parameterGroupName = parameterGroupName
        self.tags = tags
    }
}

struct CreateParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let family: Swift.String?
    let description: Swift.String?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension CreateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case family = "Family"
        case parameterGroupName = "ParameterGroupName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateParameterGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateParameterGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct CreateParameterGroupOutput: Swift.Equatable {
    /// The newly-created parameter group.
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct CreateParameterGroupOutputBody: Swift.Equatable {
    let parameterGroup: MemoryDBClientTypes.ParameterGroup?
}

extension CreateParameterGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

enum CreateParameterGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterGroupState": return try await InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupAlreadyExists": return try await ParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupQuotaExceeded": return try await ParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case kmsKeyId = "KmsKeyId"
        case snapshotName = "SnapshotName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSnapshotInput: Swift.Equatable {
    /// The snapshot is created from this cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The ID of the KMS key used to encrypt the snapshot.
    public var kmsKeyId: Swift.String?
    /// A name for the snapshot being created.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        clusterName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.clusterName = clusterName
        self.kmsKeyId = kmsKeyId
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let snapshotName: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case kmsKeyId = "KmsKeyId"
        case snapshotName = "SnapshotName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateSnapshotOutput: Swift.Equatable {
    /// The newly-created snapshot.
    public var snapshot: MemoryDBClientTypes.Snapshot?

    public init(
        snapshot: MemoryDBClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateSnapshotOutputBody: Swift.Equatable {
    let snapshot: MemoryDBClientTypes.Snapshot?
}

extension CreateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum CreateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotAlreadyExistsFault": return try await SnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotQuotaExceededFault": return try await SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSubnetGroupInput: Swift.Equatable {
    /// A description for the subnet group.
    public var description: Swift.String?
    /// The name of the subnet group.
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// A list of VPC subnet IDs for the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateSubnetGroupInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
    let description: Swift.String?
    let subnetIds: [Swift.String]?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension CreateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSubnetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubnetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct CreateSubnetGroupOutput: Swift.Equatable {
    /// The newly-created subnet group
    public var subnetGroup: MemoryDBClientTypes.SubnetGroup?

    public init(
        subnetGroup: MemoryDBClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct CreateSubnetGroupOutputBody: Swift.Equatable {
    let subnetGroup: MemoryDBClientTypes.SubnetGroup?
}

extension CreateSubnetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

enum CreateSubnetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupAlreadyExists": return try await SubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupQuotaExceeded": return try await SubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetNotAllowedFault": return try await SubnetNotAllowedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetQuotaExceededFault": return try await SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessString = "AccessString"
        case authenticationMode = "AuthenticationMode"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessString = self.accessString {
            try encodeContainer.encode(accessString, forKey: .accessString)
        }
        if let authenticationMode = self.authenticationMode {
            try encodeContainer.encode(authenticationMode, forKey: .authenticationMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// Access permissions string used for this user.
    /// This member is required.
    public var accessString: Swift.String?
    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate.
    /// This member is required.
    public var authenticationMode: MemoryDBClientTypes.AuthenticationMode?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?
    /// The name of the user. This value must be unique as it also serves as the user identifier.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        accessString: Swift.String? = nil,
        authenticationMode: MemoryDBClientTypes.AuthenticationMode? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessString = accessString
        self.authenticationMode = authenticationMode
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationMode: MemoryDBClientTypes.AuthenticationMode?
    let accessString: Swift.String?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessString = "AccessString"
        case authenticationMode = "AuthenticationMode"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationModeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.AuthenticationMode.self, forKey: .authenticationMode)
        authenticationMode = authenticationModeDecoded
        let accessStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessString)
        accessString = accessStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The newly-created user.
    public var user: MemoryDBClientTypes.User?

    public init(
        user: MemoryDBClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let user: MemoryDBClientTypes.User?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateUserName": return try await DuplicateUserNameFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserAlreadyExists": return try await UserAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserQuotaExceeded": return try await UserQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryDBClientTypes {
    public enum DataTieringStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataTieringStatus] {
            return [
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "false"
            case .true: return "true"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataTieringStatus(rawValue: rawValue) ?? DataTieringStatus.sdkUnknown(rawValue)
        }
    }
}

extension DefaultUserRequired {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DefaultUserRequiredBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct DefaultUserRequired: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DefaultUserRequired" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DefaultUserRequiredBody: Swift.Equatable {
    let message: Swift.String?
}

extension DefaultUserRequiredBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteACLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
    }
}

extension DeleteACLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteACLInput: Swift.Equatable {
    /// The name of the Access Control List to delete
    /// This member is required.
    public var aclName: Swift.String?

    public init(
        aclName: Swift.String? = nil
    )
    {
        self.aclName = aclName
    }
}

struct DeleteACLInputBody: Swift.Equatable {
    let aclName: Swift.String?
}

extension DeleteACLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
    }
}

extension DeleteACLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteACLOutputBody = try responseDecoder.decode(responseBody: data)
            self.acl = output.acl
        } else {
            self.acl = nil
        }
    }
}

public struct DeleteACLOutput: Swift.Equatable {
    /// The Access Control List object that has been deleted.
    public var acl: MemoryDBClientTypes.ACL?

    public init(
        acl: MemoryDBClientTypes.ACL? = nil
    )
    {
        self.acl = acl
    }
}

struct DeleteACLOutputBody: Swift.Equatable {
    let acl: MemoryDBClientTypes.ACL?
}

extension DeleteACLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acl = "ACL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ACL.self, forKey: .acl)
        acl = aclDecoded
    }
}

enum DeleteACLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidACLState": return try await InvalidACLStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case finalSnapshotName = "FinalSnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let finalSnapshotName = self.finalSnapshotName {
            try encodeContainer.encode(finalSnapshotName, forKey: .finalSnapshotName)
        }
    }
}

extension DeleteClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The name of the cluster to be deleted
    /// This member is required.
    public var clusterName: Swift.String?
    /// The user-supplied name of a final cluster snapshot. This is the unique name that identifies the snapshot. MemoryDB creates the snapshot, and then deletes the cluster immediately afterward.
    public var finalSnapshotName: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        finalSnapshotName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.finalSnapshotName = finalSnapshotName
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let finalSnapshotName: Swift.String?
}

extension DeleteClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case finalSnapshotName = "FinalSnapshotName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let finalSnapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalSnapshotName)
        finalSnapshotName = finalSnapshotNameDecoded
    }
}

extension DeleteClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutput: Swift.Equatable {
    /// The cluster object that has been deleted
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputBody: Swift.Equatable {
    let cluster: MemoryDBClientTypes.Cluster?
}

extension DeleteClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum DeleteClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotAlreadyExistsFault": return try await SnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

extension DeleteParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteParameterGroupInput: Swift.Equatable {
    /// The name of the parameter group to delete.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init(
        parameterGroupName: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

struct DeleteParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
}

extension DeleteParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension DeleteParameterGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteParameterGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct DeleteParameterGroupOutput: Swift.Equatable {
    /// The parameter group that has been deleted.
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct DeleteParameterGroupOutputBody: Swift.Equatable {
    let parameterGroup: MemoryDBClientTypes.ParameterGroup?
}

extension DeleteParameterGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

enum DeleteParameterGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterGroupState": return try await InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

extension DeleteSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSnapshotInput: Swift.Equatable {
    /// The name of the snapshot to delete
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        snapshotName: Swift.String? = nil
    )
    {
        self.snapshotName = snapshotName
    }
}

struct DeleteSnapshotInputBody: Swift.Equatable {
    let snapshotName: Swift.String?
}

extension DeleteSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotName = "SnapshotName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension DeleteSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct DeleteSnapshotOutput: Swift.Equatable {
    /// The snapshot object that has been deleted.
    public var snapshot: MemoryDBClientTypes.Snapshot?

    public init(
        snapshot: MemoryDBClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct DeleteSnapshotOutputBody: Swift.Equatable {
    let snapshot: MemoryDBClientTypes.Snapshot?
}

extension DeleteSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot = "Snapshot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Snapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

enum DeleteSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSnapshotState": return try await InvalidSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotNotFoundFault": return try await SnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
    }
}

extension DeleteSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSubnetGroupInput: Swift.Equatable {
    /// The name of the subnet group to delete
    /// This member is required.
    public var subnetGroupName: Swift.String?

    public init(
        subnetGroupName: Swift.String? = nil
    )
    {
        self.subnetGroupName = subnetGroupName
    }
}

struct DeleteSubnetGroupInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
}

extension DeleteSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
    }
}

extension DeleteSubnetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSubnetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct DeleteSubnetGroupOutput: Swift.Equatable {
    /// The subnet group object that has been deleted.
    public var subnetGroup: MemoryDBClientTypes.SubnetGroup?

    public init(
        subnetGroup: MemoryDBClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct DeleteSubnetGroupOutputBody: Swift.Equatable {
    let subnetGroup: MemoryDBClientTypes.SubnetGroup?
}

extension DeleteSubnetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

enum DeleteSubnetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupInUse": return try await SubnetGroupInUseFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The name of the user to delete
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct DeleteUserOutput: Swift.Equatable {
    /// The user object that has been deleted.
    public var user: MemoryDBClientTypes.User?

    public init(
        user: MemoryDBClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct DeleteUserOutputBody: Swift.Equatable {
    let user: MemoryDBClientTypes.User?
}

extension DeleteUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUserState": return try await InvalidUserStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeACLsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeACLsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeACLsInput: Swift.Equatable {
    /// The name of the ACL
    public var aclName: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        aclName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aclName = aclName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeACLsInputBody: Swift.Equatable {
    let aclName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeACLsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeACLsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeACLsOutputBody = try responseDecoder.decode(responseBody: data)
            self.acLs = output.acLs
            self.nextToken = output.nextToken
        } else {
            self.acLs = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeACLsOutput: Swift.Equatable {
    /// The list of ACLs
    public var acLs: [MemoryDBClientTypes.ACL]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        acLs: [MemoryDBClientTypes.ACL]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acLs = acLs
        self.nextToken = nextToken
    }
}

struct DescribeACLsOutputBody: Swift.Equatable {
    let acLs: [MemoryDBClientTypes.ACL]?
    let nextToken: Swift.String?
}

extension DescribeACLsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acLs = "ACLs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acLsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ACL?].self, forKey: .acLs)
        var acLsDecoded0:[MemoryDBClientTypes.ACL]? = nil
        if let acLsContainer = acLsContainer {
            acLsDecoded0 = [MemoryDBClientTypes.ACL]()
            for structure0 in acLsContainer {
                if let structure0 = structure0 {
                    acLsDecoded0?.append(structure0)
                }
            }
        }
        acLs = acLsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeACLsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClustersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case showShardDetails = "ShowShardDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let showShardDetails = self.showShardDetails {
            try encodeContainer.encode(showShardDetails, forKey: .showShardDetails)
        }
    }
}

extension DescribeClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClustersInput: Swift.Equatable {
    /// The name of the cluster
    public var clusterName: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// An optional flag that can be included in the request to retrieve information about the individual shard(s).
    public var showShardDetails: Swift.Bool?

    public init(
        clusterName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        showShardDetails: Swift.Bool? = nil
    )
    {
        self.clusterName = clusterName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.showShardDetails = showShardDetails
    }
}

struct DescribeClustersInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let showShardDetails: Swift.Bool?
}

extension DescribeClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case showShardDetails = "ShowShardDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let showShardDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showShardDetails)
        showShardDetails = showShardDetailsDecoded
    }
}

extension DescribeClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutput: Swift.Equatable {
    /// A list of clusters
    public var clusters: [MemoryDBClientTypes.Cluster]?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        clusters: [MemoryDBClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let clusters: [MemoryDBClientTypes.Cluster]?
}

extension DescribeClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let clustersContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[MemoryDBClientTypes.Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [MemoryDBClientTypes.Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
    }
}

enum DescribeClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEngineVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOnly = "DefaultOnly"
        case engineVersion = "EngineVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupFamily = "ParameterGroupFamily"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOnly = self.defaultOnly {
            try encodeContainer.encode(defaultOnly, forKey: .defaultOnly)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupFamily = self.parameterGroupFamily {
            try encodeContainer.encode(parameterGroupFamily, forKey: .parameterGroupFamily)
        }
    }
}

extension DescribeEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEngineVersionsInput: Swift.Equatable {
    /// If true, specifies that only the default version of the specified engine or engine and major version combination is to be returned.
    public var defaultOnly: Swift.Bool?
    /// The Redis engine version
    public var engineVersion: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of a specific parameter group family to return details for.
    public var parameterGroupFamily: Swift.String?

    public init(
        defaultOnly: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupFamily: Swift.String? = nil
    )
    {
        self.defaultOnly = defaultOnly
        self.engineVersion = engineVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupFamily = parameterGroupFamily
    }
}

struct DescribeEngineVersionsInputBody: Swift.Equatable {
    let engineVersion: Swift.String?
    let parameterGroupFamily: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let defaultOnly: Swift.Bool?
}

extension DescribeEngineVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOnly = "DefaultOnly"
        case engineVersion = "EngineVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupFamily = "ParameterGroupFamily"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let parameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupFamily)
        parameterGroupFamily = parameterGroupFamilyDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let defaultOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultOnly)
        defaultOnly = defaultOnlyDecoded
    }
}

extension DescribeEngineVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEngineVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.nextToken = output.nextToken
        } else {
            self.engineVersions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEngineVersionsOutput: Swift.Equatable {
    /// A list of engine version details. Each element in the list contains detailed information about one engine version.
    public var engineVersions: [MemoryDBClientTypes.EngineVersionInfo]?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        engineVersions: [MemoryDBClientTypes.EngineVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

struct DescribeEngineVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let engineVersions: [MemoryDBClientTypes.EngineVersionInfo]?
}

extension DescribeEngineVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersions = "EngineVersions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let engineVersionsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.EngineVersionInfo?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[MemoryDBClientTypes.EngineVersionInfo]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [MemoryDBClientTypes.EngineVersionInfo]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
    }
}

enum DescribeEngineVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsInput: Swift.Equatable {
    /// The number of minutes worth of events to retrieve.
    public var duration: Swift.Int?
    /// The end of the time interval for which to retrieve events, specified in ISO 8601 format. Example: 2017-03-30T07:03:49.555Z
    public var endTime: ClientRuntime.Date?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The identifier of the event source for which events are returned. If not specified, all sources are included in the response.
    public var sourceName: Swift.String?
    /// The event source to retrieve events for. If no value is specified, all events are returned.
    public var sourceType: MemoryDBClientTypes.SourceType?
    /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format. Example: 2017-03-30T07:03:49.555Z
    public var startTime: ClientRuntime.Date?

    public init(
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceType: MemoryDBClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let sourceName: Swift.String?
    let sourceType: MemoryDBClientTypes.SourceType?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let duration: Swift.Int?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutput: Swift.Equatable {
    /// A list of events. Each element in the list contains detailed information about one event.
    public var events: [MemoryDBClientTypes.Event]?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        events: [MemoryDBClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let events: [MemoryDBClientTypes.Event]?
}

extension DescribeEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[MemoryDBClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [MemoryDBClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

enum DescribeEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeParameterGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

extension DescribeParameterGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeParameterGroupsInput: Swift.Equatable {
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of a specific parameter group to return details for.
    public var parameterGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
    }
}

struct DescribeParameterGroupsInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParameterGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeParameterGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameterGroups = output.parameterGroups
        } else {
            self.nextToken = nil
            self.parameterGroups = nil
        }
    }
}

public struct DescribeParameterGroupsOutput: Swift.Equatable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of parameter groups. Each element in the list contains detailed information about one parameter group.
    public var parameterGroups: [MemoryDBClientTypes.ParameterGroup]?

    public init(
        nextToken: Swift.String? = nil,
        parameterGroups: [MemoryDBClientTypes.ParameterGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }
}

struct DescribeParameterGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let parameterGroups: [MemoryDBClientTypes.ParameterGroup]?
}

extension DescribeParameterGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameterGroups = "ParameterGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parameterGroupsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ParameterGroup?].self, forKey: .parameterGroups)
        var parameterGroupsDecoded0:[MemoryDBClientTypes.ParameterGroup]? = nil
        if let parameterGroupsContainer = parameterGroupsContainer {
            parameterGroupsDecoded0 = [MemoryDBClientTypes.ParameterGroup]()
            for structure0 in parameterGroupsContainer {
                if let structure0 = structure0 {
                    parameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        parameterGroups = parameterGroupsDecoded0
    }
}

enum DescribeParameterGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

extension DescribeParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeParametersInput: Swift.Equatable {
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// he name of a specific parameter group to return details for.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
    }
}

struct DescribeParametersInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeParametersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutput: Swift.Equatable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of parameters specific to a particular parameter group. Each element in the list contains detailed information about one parameter.
    public var parameters: [MemoryDBClientTypes.Parameter]?

    public init(
        nextToken: Swift.String? = nil,
        parameters: [MemoryDBClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let parameters: [MemoryDBClientTypes.Parameter]?
}

extension DescribeParametersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[MemoryDBClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [MemoryDBClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

enum DescribeParametersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReservedNodesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case reservationId = "ReservationId"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let offeringType = self.offeringType {
            try encodeContainer.encode(offeringType, forKey: .offeringType)
        }
        if let reservationId = self.reservationId {
            try encodeContainer.encode(reservationId, forKey: .reservationId)
        }
        if let reservedNodesOfferingId = self.reservedNodesOfferingId {
            try encodeContainer.encode(reservedNodesOfferingId, forKey: .reservedNodesOfferingId)
        }
    }
}

extension DescribeReservedNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReservedNodesInput: Swift.Equatable {
    /// The duration filter value, specified in years or seconds. Use this parameter to show only reservations for this duration.
    public var duration: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The node type filter value. Use this parameter to show only those reservations matching the specified node type. For more information, see [Supported node types](https://docs.aws.amazon.com/memorydb/latest/devguide/nodes.reserved.html#reserved-nodes-supported).
    public var nodeType: Swift.String?
    /// The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type. Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    public var offeringType: Swift.String?
    /// The reserved node identifier filter value. Use this parameter to show only the reservation that matches the specified reservation ID.
    public var reservationId: Swift.String?
    /// The offering identifier filter value. Use this parameter to show only purchased reservations matching the specified offering identifier.
    public var reservedNodesOfferingId: Swift.String?

    public init(
        duration: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        offeringType: Swift.String? = nil,
        reservationId: Swift.String? = nil,
        reservedNodesOfferingId: Swift.String? = nil
    )
    {
        self.duration = duration
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.nodeType = nodeType
        self.offeringType = offeringType
        self.reservationId = reservationId
        self.reservedNodesOfferingId = reservedNodesOfferingId
    }
}

struct DescribeReservedNodesInputBody: Swift.Equatable {
    let reservationId: Swift.String?
    let reservedNodesOfferingId: Swift.String?
    let nodeType: Swift.String?
    let duration: Swift.String?
    let offeringType: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeReservedNodesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case reservationId = "ReservationId"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationId)
        reservationId = reservationIdDecoded
        let reservedNodesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodesOfferingId)
        reservedNodesOfferingId = reservedNodesOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReservedNodesOfferingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let offeringType = self.offeringType {
            try encodeContainer.encode(offeringType, forKey: .offeringType)
        }
        if let reservedNodesOfferingId = self.reservedNodesOfferingId {
            try encodeContainer.encode(reservedNodesOfferingId, forKey: .reservedNodesOfferingId)
        }
    }
}

extension DescribeReservedNodesOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReservedNodesOfferingsInput: Swift.Equatable {
    /// Duration filter value, specified in years or seconds. Use this parameter to show only reservations for a given duration.
    public var duration: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The node type for the reserved nodes. For more information, see [Supported node types](https://docs.aws.amazon.com/memorydb/latest/devguide/nodes.reserved.html#reserved-nodes-supported).
    public var nodeType: Swift.String?
    /// The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type. Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    public var offeringType: Swift.String?
    /// The offering identifier filter value. Use this parameter to show only the available offering that matches the specified reservation identifier.
    public var reservedNodesOfferingId: Swift.String?

    public init(
        duration: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        offeringType: Swift.String? = nil,
        reservedNodesOfferingId: Swift.String? = nil
    )
    {
        self.duration = duration
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.nodeType = nodeType
        self.offeringType = offeringType
        self.reservedNodesOfferingId = reservedNodesOfferingId
    }
}

struct DescribeReservedNodesOfferingsInputBody: Swift.Equatable {
    let reservedNodesOfferingId: Swift.String?
    let nodeType: Swift.String?
    let duration: Swift.String?
    let offeringType: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeReservedNodesOfferingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodesOfferingId)
        reservedNodesOfferingId = reservedNodesOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReservedNodesOfferingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReservedNodesOfferingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reservedNodesOfferings = output.reservedNodesOfferings
        } else {
            self.nextToken = nil
            self.reservedNodesOfferings = nil
        }
    }
}

public struct DescribeReservedNodesOfferingsOutput: Swift.Equatable {
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// Lists available reserved node offerings.
    public var reservedNodesOfferings: [MemoryDBClientTypes.ReservedNodesOffering]?

    public init(
        nextToken: Swift.String? = nil,
        reservedNodesOfferings: [MemoryDBClientTypes.ReservedNodesOffering]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedNodesOfferings = reservedNodesOfferings
    }
}

struct DescribeReservedNodesOfferingsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reservedNodesOfferings: [MemoryDBClientTypes.ReservedNodesOffering]?
}

extension DescribeReservedNodesOfferingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reservedNodesOfferings = "ReservedNodesOfferings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservedNodesOfferingsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ReservedNodesOffering?].self, forKey: .reservedNodesOfferings)
        var reservedNodesOfferingsDecoded0:[MemoryDBClientTypes.ReservedNodesOffering]? = nil
        if let reservedNodesOfferingsContainer = reservedNodesOfferingsContainer {
            reservedNodesOfferingsDecoded0 = [MemoryDBClientTypes.ReservedNodesOffering]()
            for structure0 in reservedNodesOfferingsContainer {
                if let structure0 = structure0 {
                    reservedNodesOfferingsDecoded0?.append(structure0)
                }
            }
        }
        reservedNodesOfferings = reservedNodesOfferingsDecoded0
    }
}

enum DescribeReservedNodesOfferingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNodesOfferingNotFound": return try await ReservedNodesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReservedNodesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReservedNodesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reservedNodes = output.reservedNodes
        } else {
            self.nextToken = nil
            self.reservedNodes = nil
        }
    }
}

public struct DescribeReservedNodesOutput: Swift.Equatable {
    /// An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// Returns information about reserved nodes for this account, or about a specified reserved node.
    public var reservedNodes: [MemoryDBClientTypes.ReservedNode]?

    public init(
        nextToken: Swift.String? = nil,
        reservedNodes: [MemoryDBClientTypes.ReservedNode]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedNodes = reservedNodes
    }
}

struct DescribeReservedNodesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reservedNodes: [MemoryDBClientTypes.ReservedNode]?
}

extension DescribeReservedNodesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reservedNodes = "ReservedNodes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservedNodesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ReservedNode?].self, forKey: .reservedNodes)
        var reservedNodesDecoded0:[MemoryDBClientTypes.ReservedNode]? = nil
        if let reservedNodesContainer = reservedNodesContainer {
            reservedNodesDecoded0 = [MemoryDBClientTypes.ReservedNode]()
            for structure0 in reservedNodesContainer {
                if let structure0 = structure0 {
                    reservedNodesDecoded0?.append(structure0)
                }
            }
        }
        reservedNodes = reservedNodesDecoded0
    }
}

enum DescribeReservedNodesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNodeNotFound": return try await ReservedNodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServiceUpdatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceUpdateName = "ServiceUpdateName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterNames = clusterNames {
            var clusterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNames)
            for string0 in clusterNames {
                try clusterNamesContainer.encode(string0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceUpdateName = self.serviceUpdateName {
            try encodeContainer.encode(serviceUpdateName, forKey: .serviceUpdateName)
        }
        if let status = status {
            var statusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .status)
            for serviceupdatestatus0 in status {
                try statusContainer.encode(serviceupdatestatus0.rawValue)
            }
        }
    }
}

extension DescribeServiceUpdatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServiceUpdatesInput: Swift.Equatable {
    /// The list of cluster names to identify service updates to apply
    public var clusterNames: [Swift.String]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The unique ID of the service update to describe.
    public var serviceUpdateName: Swift.String?
    /// The status(es) of the service updates to filter on
    public var status: [MemoryDBClientTypes.ServiceUpdateStatus]?

    public init(
        clusterNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceUpdateName: Swift.String? = nil,
        status: [MemoryDBClientTypes.ServiceUpdateStatus]? = nil
    )
    {
        self.clusterNames = clusterNames
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceUpdateName = serviceUpdateName
        self.status = status
    }
}

struct DescribeServiceUpdatesInputBody: Swift.Equatable {
    let serviceUpdateName: Swift.String?
    let clusterNames: [Swift.String]?
    let status: [MemoryDBClientTypes.ServiceUpdateStatus]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeServiceUpdatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceUpdateName = "ServiceUpdateName"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceUpdateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateName)
        serviceUpdateName = serviceUpdateNameDecoded
        let clusterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusterNames)
        var clusterNamesDecoded0:[Swift.String]? = nil
        if let clusterNamesContainer = clusterNamesContainer {
            clusterNamesDecoded0 = [Swift.String]()
            for string0 in clusterNamesContainer {
                if let string0 = string0 {
                    clusterNamesDecoded0?.append(string0)
                }
            }
        }
        clusterNames = clusterNamesDecoded0
        let statusContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ServiceUpdateStatus?].self, forKey: .status)
        var statusDecoded0:[MemoryDBClientTypes.ServiceUpdateStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [MemoryDBClientTypes.ServiceUpdateStatus]()
            for enum0 in statusContainer {
                if let enum0 = enum0 {
                    statusDecoded0?.append(enum0)
                }
            }
        }
        status = statusDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeServiceUpdatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServiceUpdatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceUpdates = output.serviceUpdates
        } else {
            self.nextToken = nil
            self.serviceUpdates = nil
        }
    }
}

public struct DescribeServiceUpdatesOutput: Swift.Equatable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of service updates
    public var serviceUpdates: [MemoryDBClientTypes.ServiceUpdate]?

    public init(
        nextToken: Swift.String? = nil,
        serviceUpdates: [MemoryDBClientTypes.ServiceUpdate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceUpdates = serviceUpdates
    }
}

struct DescribeServiceUpdatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serviceUpdates: [MemoryDBClientTypes.ServiceUpdate]?
}

extension DescribeServiceUpdatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceUpdates = "ServiceUpdates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceUpdatesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ServiceUpdate?].self, forKey: .serviceUpdates)
        var serviceUpdatesDecoded0:[MemoryDBClientTypes.ServiceUpdate]? = nil
        if let serviceUpdatesContainer = serviceUpdatesContainer {
            serviceUpdatesDecoded0 = [MemoryDBClientTypes.ServiceUpdate]()
            for structure0 in serviceUpdatesContainer {
                if let structure0 = structure0 {
                    serviceUpdatesDecoded0?.append(structure0)
                }
            }
        }
        serviceUpdates = serviceUpdatesDecoded0
    }
}

enum DescribeServiceUpdatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case showDetail = "ShowDetail"
        case snapshotName = "SnapshotName"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let showDetail = self.showDetail {
            try encodeContainer.encode(showDetail, forKey: .showDetail)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension DescribeSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSnapshotsInput: Swift.Equatable {
    /// A user-supplied cluster identifier. If this parameter is specified, only snapshots associated with that specific cluster are described.
    public var clusterName: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A Boolean value which if true, the shard configuration is included in the snapshot description.
    public var showDetail: Swift.Bool?
    /// A user-supplied name of the snapshot. If this parameter is specified, only this named snapshot is described.
    public var snapshotName: Swift.String?
    /// If set to system, the output shows snapshots that were automatically created by MemoryDB. If set to user the output shows snapshots that were manually created. If omitted, the output shows both automatically and manually created snapshots.
    public var source: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        showDetail: Swift.Bool? = nil,
        snapshotName: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.showDetail = showDetail
        self.snapshotName = snapshotName
        self.source = source
    }
}

struct DescribeSnapshotsInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let snapshotName: Swift.String?
    let source: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let showDetail: Swift.Bool?
}

extension DescribeSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case showDetail = "ShowDetail"
        case snapshotName = "SnapshotName"
        case source = "Source"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let showDetailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showDetail)
        showDetail = showDetailDecoded
    }
}

extension DescribeSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

public struct DescribeSnapshotsOutput: Swift.Equatable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of snapshots. Each item in the list contains detailed information about one snapshot.
    public var snapshots: [MemoryDBClientTypes.Snapshot]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [MemoryDBClientTypes.Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct DescribeSnapshotsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let snapshots: [MemoryDBClientTypes.Snapshot]?
}

extension DescribeSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case snapshots = "Snapshots"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let snapshotsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Snapshot?].self, forKey: .snapshots)
        var snapshotsDecoded0:[MemoryDBClientTypes.Snapshot]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [MemoryDBClientTypes.Snapshot]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
    }
}

enum DescribeSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotNotFoundFault": return try await SnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSubnetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupName = "SubnetGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
    }
}

extension DescribeSubnetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSubnetGroupsInput: Swift.Equatable {
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of the subnet group to return details for.
    public var subnetGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetGroupName = subnetGroupName
    }
}

struct DescribeSubnetGroupsInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupName = "SubnetGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubnetGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSubnetGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subnetGroups = output.subnetGroups
        } else {
            self.nextToken = nil
            self.subnetGroups = nil
        }
    }
}

public struct DescribeSubnetGroupsOutput: Swift.Equatable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of subnet groups. Each element in the list contains detailed information about one group.
    public var subnetGroups: [MemoryDBClientTypes.SubnetGroup]?

    public init(
        nextToken: Swift.String? = nil,
        subnetGroups: [MemoryDBClientTypes.SubnetGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }
}

struct DescribeSubnetGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let subnetGroups: [MemoryDBClientTypes.SubnetGroup]?
}

extension DescribeSubnetGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subnetGroups = "SubnetGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let subnetGroupsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.SubnetGroup?].self, forKey: .subnetGroups)
        var subnetGroupsDecoded0:[MemoryDBClientTypes.SubnetGroup]? = nil
        if let subnetGroupsContainer = subnetGroupsContainer {
            subnetGroupsDecoded0 = [MemoryDBClientTypes.SubnetGroup]()
            for structure0 in subnetGroupsContainer {
                if let structure0 = structure0 {
                    subnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        subnetGroups = subnetGroupsDecoded0
    }
}

enum DescribeSubnetGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DescribeUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUsersInput: Swift.Equatable {
    /// Filter to determine the list of users to return.
    public var filters: [MemoryDBClientTypes.Filter]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The name of the user
    public var userName: Swift.String?

    public init(
        filters: [MemoryDBClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct DescribeUsersInputBody: Swift.Equatable {
    let userName: Swift.String?
    let filters: [MemoryDBClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[MemoryDBClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MemoryDBClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutput: Swift.Equatable {
    /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?
    /// A list of users.
    public var users: [MemoryDBClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [MemoryDBClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct DescribeUsersOutputBody: Swift.Equatable {
    let users: [MemoryDBClientTypes.User]?
    let nextToken: Swift.String?
}

extension DescribeUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[MemoryDBClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MemoryDBClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DuplicateUserNameFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateUserNameFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct DuplicateUserNameFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateUserName" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateUserNameFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateUserNameFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents the information required for client programs to connect to the cluster and its nodes.
    public struct Endpoint: Swift.Equatable {
        /// The DNS hostname of the node.
        public var address: Swift.String?
        /// The port number that the engine is listening on.
        public var port: Swift.Int

        public init(
            address: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.port = port
        }
    }

}

extension MemoryDBClientTypes.EngineVersionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enginePatchVersion = "EnginePatchVersion"
        case engineVersion = "EngineVersion"
        case parameterGroupFamily = "ParameterGroupFamily"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enginePatchVersion = self.enginePatchVersion {
            try encodeContainer.encode(enginePatchVersion, forKey: .enginePatchVersion)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let parameterGroupFamily = self.parameterGroupFamily {
            try encodeContainer.encode(parameterGroupFamily, forKey: .parameterGroupFamily)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let enginePatchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enginePatchVersion)
        enginePatchVersion = enginePatchVersionDecoded
        let parameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupFamily)
        parameterGroupFamily = parameterGroupFamilyDecoded
    }
}

extension MemoryDBClientTypes {
    /// Provides details of the Redis engine version
    public struct EngineVersionInfo: Swift.Equatable {
        /// The patched engine version
        public var enginePatchVersion: Swift.String?
        /// The engine version
        public var engineVersion: Swift.String?
        /// Specifies the name of the parameter group family to which the engine default parameters apply.
        public var parameterGroupFamily: Swift.String?

        public init(
            enginePatchVersion: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            parameterGroupFamily: Swift.String? = nil
        )
        {
            self.enginePatchVersion = enginePatchVersion
            self.engineVersion = engineVersion
            self.parameterGroupFamily = parameterGroupFamily
        }
    }

}

extension MemoryDBClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case message = "Message"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents a single occurrence of something interesting within the system. Some examples of events are creating a cluster or adding or removing a node.
    public struct Event: Swift.Equatable {
        /// The date and time when the event occurred.
        public var date: ClientRuntime.Date?
        /// The text of the event.
        public var message: Swift.String?
        /// The name for the source of the event. For example, if the event occurred at the cluster level, the identifier would be the name of the cluster.
        public var sourceName: Swift.String?
        /// Specifies the origin of this event - a cluster, a parameter group, a security group, etc.
        public var sourceType: MemoryDBClientTypes.SourceType?

        public init(
            date: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: MemoryDBClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.message = message
            self.sourceName = sourceName
            self.sourceType = sourceType
        }
    }

}

extension FailoverShardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case shardName = "ShardName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let shardName = self.shardName {
            try encodeContainer.encode(shardName, forKey: .shardName)
        }
    }
}

extension FailoverShardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct FailoverShardInput: Swift.Equatable {
    /// The cluster being failed over
    /// This member is required.
    public var clusterName: Swift.String?
    /// The name of the shard
    /// This member is required.
    public var shardName: Swift.String?

    public init(
        clusterName: Swift.String? = nil,
        shardName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.shardName = shardName
    }
}

struct FailoverShardInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let shardName: Swift.String?
}

extension FailoverShardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case shardName = "ShardName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let shardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardName)
        shardName = shardNameDecoded
    }
}

extension FailoverShardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FailoverShardOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct FailoverShardOutput: Swift.Equatable {
    /// The cluster being failed over
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct FailoverShardOutputBody: Swift.Equatable {
    let cluster: MemoryDBClientTypes.Cluster?
}

extension FailoverShardOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum FailoverShardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "APICallRateForCustomerExceeded": return try await APICallRateForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidKMSKeyFault": return try await InvalidKMSKeyFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ShardNotFoundFault": return try await ShardNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TestFailoverNotAvailableFault": return try await TestFailoverNotAvailableFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryDBClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension MemoryDBClientTypes {
    /// Used to streamline results of a search based on the property being filtered.
    public struct Filter: Swift.Equatable {
        /// The property being filtered. For example, UserName.
        /// This member is required.
        public var name: Swift.String?
        /// The property values to filter on. For example, "user-123".
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension MemoryDBClientTypes {
    public enum InputAuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [InputAuthenticationType] {
            return [
                .iam,
                .password,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "iam"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputAuthenticationType(rawValue: rawValue) ?? InputAuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension InsufficientClusterCapacityFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientClusterCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InsufficientClusterCapacityFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientClusterCapacity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidACLStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidACLStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidACLStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidACLState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidACLStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidACLStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidARNFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidARNFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidARNFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidARN" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidARNFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidARNFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClusterStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidClusterStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClusterState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidClusterStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCredentialsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCredentialsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidCredentialsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCredentialsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCredentialsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCredentialsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKMSKeyFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidKMSKeyFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidKMSKeyFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidKMSKeyFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidKMSKeyFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidKMSKeyFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNodeStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNodeStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidNodeStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNodeState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNodeStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNodeStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombination" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterGroupStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterGroupStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidParameterGroupStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterGroupState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterGroupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValue" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnapshotStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSnapshotStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidSnapshotStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSnapshotState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSnapshotStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidSubnet: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnet" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidUserStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidUserStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidUserStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUserStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidVPCNetworkStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidVPCNetworkStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidVPCNetworkStateFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAllowedNodeTypeUpdatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
    }
}

extension ListAllowedNodeTypeUpdatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAllowedNodeTypeUpdatesInput: Swift.Equatable {
    /// The name of the cluster you want to scale. MemoryDB uses the cluster name to identify the current node type being used by this cluster, and from that to create a list of node types you can scale up to.
    /// This member is required.
    public var clusterName: Swift.String?

    public init(
        clusterName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
    }
}

struct ListAllowedNodeTypeUpdatesInputBody: Swift.Equatable {
    let clusterName: Swift.String?
}

extension ListAllowedNodeTypeUpdatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
    }
}

extension ListAllowedNodeTypeUpdatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAllowedNodeTypeUpdatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.scaleDownNodeTypes = output.scaleDownNodeTypes
            self.scaleUpNodeTypes = output.scaleUpNodeTypes
        } else {
            self.scaleDownNodeTypes = nil
            self.scaleUpNodeTypes = nil
        }
    }
}

public struct ListAllowedNodeTypeUpdatesOutput: Swift.Equatable {
    /// A list node types which you can use to scale down your cluster.
    public var scaleDownNodeTypes: [Swift.String]?
    /// A list node types which you can use to scale up your cluster.
    public var scaleUpNodeTypes: [Swift.String]?

    public init(
        scaleDownNodeTypes: [Swift.String]? = nil,
        scaleUpNodeTypes: [Swift.String]? = nil
    )
    {
        self.scaleDownNodeTypes = scaleDownNodeTypes
        self.scaleUpNodeTypes = scaleUpNodeTypes
    }
}

struct ListAllowedNodeTypeUpdatesOutputBody: Swift.Equatable {
    let scaleUpNodeTypes: [Swift.String]?
    let scaleDownNodeTypes: [Swift.String]?
}

extension ListAllowedNodeTypeUpdatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scaleDownNodeTypes = "ScaleDownNodeTypes"
        case scaleUpNodeTypes = "ScaleUpNodeTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scaleUpNodeTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scaleUpNodeTypes)
        var scaleUpNodeTypesDecoded0:[Swift.String]? = nil
        if let scaleUpNodeTypesContainer = scaleUpNodeTypesContainer {
            scaleUpNodeTypesDecoded0 = [Swift.String]()
            for string0 in scaleUpNodeTypesContainer {
                if let string0 = string0 {
                    scaleUpNodeTypesDecoded0?.append(string0)
                }
            }
        }
        scaleUpNodeTypes = scaleUpNodeTypesDecoded0
        let scaleDownNodeTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scaleDownNodeTypes)
        var scaleDownNodeTypesDecoded0:[Swift.String]? = nil
        if let scaleDownNodeTypesContainer = scaleDownNodeTypesContainer {
            scaleDownNodeTypesDecoded0 = [Swift.String]()
            for string0 in scaleDownNodeTypesContainer {
                if let string0 = string0 {
                    scaleDownNodeTypesDecoded0?.append(string0)
                }
            }
        }
        scaleDownNodeTypes = scaleDownNodeTypesDecoded0
    }
}

enum ListAllowedNodeTypeUpdatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource for which you want the list of tags
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsOutput: Swift.Equatable {
    /// A list of tags as key-value pairs.
    public var tagList: [MemoryDBClientTypes.Tag]?

    public init(
        tagList: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let tagList: [MemoryDBClientTypes.Tag]?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidARN": return try await InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotNotFoundFault": return try await SnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NoOperationFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoOperationFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct NoOperationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoOperationFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoOperationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoOperationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.Node: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case createTime = "CreateTime"
        case endpoint = "Endpoint"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents an individual node within a cluster. Each node runs its own instance of the cluster's protocol-compliant caching software.
    public struct Node: Swift.Equatable {
        /// The Availability Zone in which the node resides
        public var availabilityZone: Swift.String?
        /// The date and time when the node was created.
        public var createTime: ClientRuntime.Date?
        /// The hostname for connecting to this node.
        public var endpoint: MemoryDBClientTypes.Endpoint?
        /// The node identifier. A node name is a numeric identifier (0001, 0002, etc.). The combination of cluster name, shard name and node name uniquely identifies every node used in a customer's Amazon account.
        public var name: Swift.String?
        /// The status of the service update on the node
        public var status: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            endpoint: MemoryDBClientTypes.Endpoint? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.createTime = createTime
            self.endpoint = endpoint
            self.name = name
            self.status = status
        }
    }

}

extension NodeQuotaForClusterExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NodeQuotaForClusterExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct NodeQuotaForClusterExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NodeQuotaForClusterExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NodeQuotaForClusterExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension NodeQuotaForClusterExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForCustomerExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NodeQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct NodeQuotaForCustomerExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NodeQuotaForCustomerExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NodeQuotaForCustomerExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension NodeQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case dataType = "DataType"
        case description = "Description"
        case minimumEngineVersion = "MinimumEngineVersion"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = self.allowedValues {
            try encodeContainer.encode(allowedValues, forKey: .allowedValues)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let minimumEngineVersion = self.minimumEngineVersion {
            try encodeContainer.encode(minimumEngineVersion, forKey: .minimumEngineVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
    }
}

extension MemoryDBClientTypes {
    /// Describes an individual setting that controls some aspect of MemoryDB behavior.
    public struct Parameter: Swift.Equatable {
        /// The valid range of values for the parameter.
        public var allowedValues: Swift.String?
        /// The parameter's data type
        public var dataType: Swift.String?
        /// A description of the parameter
        public var description: Swift.String?
        /// The earliest engine version to which the parameter can apply.
        public var minimumEngineVersion: Swift.String?
        /// The name of the parameter
        public var name: Swift.String?
        /// The value of the parameter
        public var value: Swift.String?

        public init(
            allowedValues: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            minimumEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.dataType = dataType
            self.description = description
            self.minimumEngineVersion = minimumEngineVersion
            self.name = name
            self.value = value
        }
    }

}

extension MemoryDBClientTypes.ParameterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case description = "Description"
        case family = "Family"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
    public struct ParameterGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the parameter group
        public var arn: Swift.String?
        /// A description of the parameter group
        public var description: Swift.String?
        /// The name of the parameter group family that this parameter group is compatible with.
        public var family: Swift.String?
        /// The name of the parameter group
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            family: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.family = family
            self.name = name
        }
    }

}

extension ParameterGroupAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParameterGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ParameterGroupAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterGroupAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParameterGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ParameterGroupNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterGroupNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ParameterGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParameterGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ParameterGroupQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterGroupQuotaExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ParameterNameValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension MemoryDBClientTypes {
    /// Describes a name-value pair that is used to update the value of a parameter.
    public struct ParameterNameValue: Swift.Equatable {
        /// The name of the parameter
        public var parameterName: Swift.String?
        /// The value of the parameter
        public var parameterValue: Swift.String?

        public init(
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension MemoryDBClientTypes.PendingModifiedServiceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceUpdateName = "ServiceUpdateName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceUpdateName = self.serviceUpdateName {
            try encodeContainer.encode(serviceUpdateName, forKey: .serviceUpdateName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceUpdateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateName)
        serviceUpdateName = serviceUpdateNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ServiceUpdateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MemoryDBClientTypes {
    /// Update action that has yet to be processed for the corresponding apply/stop request
    public struct PendingModifiedServiceUpdate: Swift.Equatable {
        /// The unique ID of the service update
        public var serviceUpdateName: Swift.String?
        /// The status of the service update
        public var status: MemoryDBClientTypes.ServiceUpdateStatus?

        public init(
            serviceUpdateName: Swift.String? = nil,
            status: MemoryDBClientTypes.ServiceUpdateStatus? = nil
        )
        {
            self.serviceUpdateName = serviceUpdateName
            self.status = status
        }
    }

}

extension PurchaseReservedNodesOfferingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeCount = "NodeCount"
        case reservationId = "ReservationId"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeCount = self.nodeCount {
            try encodeContainer.encode(nodeCount, forKey: .nodeCount)
        }
        if let reservationId = self.reservationId {
            try encodeContainer.encode(reservationId, forKey: .reservationId)
        }
        if let reservedNodesOfferingId = self.reservedNodesOfferingId {
            try encodeContainer.encode(reservedNodesOfferingId, forKey: .reservedNodesOfferingId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PurchaseReservedNodesOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PurchaseReservedNodesOfferingInput: Swift.Equatable {
    /// The number of node instances to reserve.
    public var nodeCount: Swift.Int?
    /// A customer-specified identifier to track this reservation.
    public var reservationId: Swift.String?
    /// The ID of the reserved node offering to purchase.
    /// This member is required.
    public var reservedNodesOfferingId: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        nodeCount: Swift.Int? = nil,
        reservationId: Swift.String? = nil,
        reservedNodesOfferingId: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.nodeCount = nodeCount
        self.reservationId = reservationId
        self.reservedNodesOfferingId = reservedNodesOfferingId
        self.tags = tags
    }
}

struct PurchaseReservedNodesOfferingInputBody: Swift.Equatable {
    let reservedNodesOfferingId: Swift.String?
    let reservationId: Swift.String?
    let nodeCount: Swift.Int?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension PurchaseReservedNodesOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeCount = "NodeCount"
        case reservationId = "ReservationId"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodesOfferingId)
        reservedNodesOfferingId = reservedNodesOfferingIdDecoded
        let reservationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationId)
        reservationId = reservationIdDecoded
        let nodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nodeCount)
        nodeCount = nodeCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PurchaseReservedNodesOfferingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PurchaseReservedNodesOfferingOutputBody = try responseDecoder.decode(responseBody: data)
            self.reservedNode = output.reservedNode
        } else {
            self.reservedNode = nil
        }
    }
}

public struct PurchaseReservedNodesOfferingOutput: Swift.Equatable {
    /// Represents the output of a PurchaseReservedNodesOffering operation.
    public var reservedNode: MemoryDBClientTypes.ReservedNode?

    public init(
        reservedNode: MemoryDBClientTypes.ReservedNode? = nil
    )
    {
        self.reservedNode = reservedNode
    }
}

struct PurchaseReservedNodesOfferingOutputBody: Swift.Equatable {
    let reservedNode: MemoryDBClientTypes.ReservedNode?
}

extension PurchaseReservedNodesOfferingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedNode = "ReservedNode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ReservedNode.self, forKey: .reservedNode)
        reservedNode = reservedNodeDecoded
    }
}

enum PurchaseReservedNodesOfferingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNodeAlreadyExists": return try await ReservedNodeAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNodeQuotaExceeded": return try await ReservedNodeQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNodesOfferingNotFound": return try await ReservedNodesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryDBClientTypes.RecurringCharge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if recurringChargeAmount != 0.0 {
            try encodeContainer.encode(recurringChargeAmount, forKey: .recurringChargeAmount)
        }
        if let recurringChargeFrequency = self.recurringChargeFrequency {
            try encodeContainer.encode(recurringChargeFrequency, forKey: .recurringChargeFrequency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .recurringChargeAmount) ?? 0.0
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension MemoryDBClientTypes {
    /// The recurring charge to run this reserved node.
    public struct RecurringCharge: Swift.Equatable {
        /// The amount of the recurring charge to run this reserved node.
        public var recurringChargeAmount: Swift.Double
        /// The frequency of the recurring price charged to run this reserved node.
        public var recurringChargeFrequency: Swift.String?

        public init(
            recurringChargeAmount: Swift.Double = 0.0,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }

}

extension MemoryDBClientTypes.ReplicaConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaCount = "ReplicaCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if replicaCount != 0 {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount) ?? 0
        replicaCount = replicaCountDecoded
    }
}

extension MemoryDBClientTypes {
    /// A request to configure the number of replicas in a shard
    public struct ReplicaConfigurationRequest: Swift.Equatable {
        /// The number of replicas to scale up or down to
        public var replicaCount: Swift.Int

        public init(
            replicaCount: Swift.Int = 0
        )
        {
            self.replicaCount = replicaCount
        }
    }

}

extension MemoryDBClientTypes.ReservedNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case nodeCount = "NodeCount"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case recurringCharges = "RecurringCharges"
        case reservationId = "ReservationId"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
        case startTime = "StartTime"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if fixedPrice != 0.0 {
            try encodeContainer.encode(fixedPrice, forKey: .fixedPrice)
        }
        if nodeCount != 0 {
            try encodeContainer.encode(nodeCount, forKey: .nodeCount)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let offeringType = self.offeringType {
            try encodeContainer.encode(offeringType, forKey: .offeringType)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringcharge0 in recurringCharges {
                try recurringChargesContainer.encode(recurringcharge0)
            }
        }
        if let reservationId = self.reservationId {
            try encodeContainer.encode(reservationId, forKey: .reservationId)
        }
        if let reservedNodesOfferingId = self.reservedNodesOfferingId {
            try encodeContainer.encode(reservedNodesOfferingId, forKey: .reservedNodesOfferingId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationId)
        reservationId = reservationIdDecoded
        let reservedNodesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodesOfferingId)
        reservedNodesOfferingId = reservedNodesOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedPrice) ?? 0.0
        fixedPrice = fixedPriceDecoded
        let nodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nodeCount) ?? 0
        nodeCount = nodeCountDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[MemoryDBClientTypes.RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [MemoryDBClientTypes.RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents the output of a PurchaseReservedNodesOffering operation.
    public struct ReservedNode: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the reserved node.
        public var arn: Swift.String?
        /// The duration of the reservation in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this reserved node.
        public var fixedPrice: Swift.Double
        /// The number of nodes that have been reserved.
        public var nodeCount: Swift.Int
        /// The node type for the reserved nodes.
        public var nodeType: Swift.String?
        /// The offering type of this reserved node.
        public var offeringType: Swift.String?
        /// The recurring price charged to run this reserved node.
        public var recurringCharges: [MemoryDBClientTypes.RecurringCharge]?
        /// A customer-specified identifier to track this reservation.
        public var reservationId: Swift.String?
        /// The ID of the reserved node offering to purchase.
        public var reservedNodesOfferingId: Swift.String?
        /// The time the reservation started.
        public var startTime: ClientRuntime.Date?
        /// The state of the reserved node.
        public var state: Swift.String?

        public init(
            arn: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            nodeCount: Swift.Int = 0,
            nodeType: Swift.String? = nil,
            offeringType: Swift.String? = nil,
            recurringCharges: [MemoryDBClientTypes.RecurringCharge]? = nil,
            reservationId: Swift.String? = nil,
            reservedNodesOfferingId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: Swift.String? = nil
        )
        {
            self.arn = arn
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.nodeCount = nodeCount
            self.nodeType = nodeType
            self.offeringType = offeringType
            self.recurringCharges = recurringCharges
            self.reservationId = reservationId
            self.reservedNodesOfferingId = reservedNodesOfferingId
            self.startTime = startTime
            self.state = state
        }
    }

}

extension ReservedNodeAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReservedNodeAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You already have a reservation with the given identifier.
public struct ReservedNodeAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodeAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReservedNodeAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedNodeAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReservedNodeNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested node does not exist.
public struct ReservedNodeNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodeNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReservedNodeNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedNodeNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedNodeQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReservedNodeQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request cannot be processed because it would exceed the user's node quota.
public struct ReservedNodeQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodeQuotaExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReservedNodeQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedNodeQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ReservedNodesOffering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case nodeType = "NodeType"
        case offeringType = "OfferingType"
        case recurringCharges = "RecurringCharges"
        case reservedNodesOfferingId = "ReservedNodesOfferingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if fixedPrice != 0.0 {
            try encodeContainer.encode(fixedPrice, forKey: .fixedPrice)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let offeringType = self.offeringType {
            try encodeContainer.encode(offeringType, forKey: .offeringType)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringcharge0 in recurringCharges {
                try recurringChargesContainer.encode(recurringcharge0)
            }
        }
        if let reservedNodesOfferingId = self.reservedNodesOfferingId {
            try encodeContainer.encode(reservedNodesOfferingId, forKey: .reservedNodesOfferingId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedNodesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNodesOfferingId)
        reservedNodesOfferingId = reservedNodesOfferingIdDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedPrice) ?? 0.0
        fixedPrice = fixedPriceDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[MemoryDBClientTypes.RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [MemoryDBClientTypes.RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
    }
}

extension MemoryDBClientTypes {
    /// The offering type of this node.
    public struct ReservedNodesOffering: Swift.Equatable {
        /// The duration of the reservation in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this reserved node.
        public var fixedPrice: Swift.Double
        /// The node type for the reserved nodes. For more information, see [Supported node types](https://docs.aws.amazon.com/memorydb/latest/devguide/nodes.reserved.html#reserved-nodes-supported).
        public var nodeType: Swift.String?
        /// The offering type of this reserved node.
        public var offeringType: Swift.String?
        /// The recurring price charged to run this reserved node.
        public var recurringCharges: [MemoryDBClientTypes.RecurringCharge]?
        /// The offering identifier.
        public var reservedNodesOfferingId: Swift.String?

        public init(
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            nodeType: Swift.String? = nil,
            offeringType: Swift.String? = nil,
            recurringCharges: [MemoryDBClientTypes.RecurringCharge]? = nil,
            reservedNodesOfferingId: Swift.String? = nil
        )
        {
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.nodeType = nodeType
            self.offeringType = offeringType
            self.recurringCharges = recurringCharges
            self.reservedNodesOfferingId = reservedNodesOfferingId
        }
    }

}

extension ReservedNodesOfferingNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReservedNodesOfferingNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested node offering does not exist.
public struct ReservedNodesOfferingNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNodesOfferingNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReservedNodesOfferingNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedNodesOfferingNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResetParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allParameters = "AllParameters"
        case parameterGroupName = "ParameterGroupName"
        case parameterNames = "ParameterNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allParameters = self.allParameters {
            try encodeContainer.encode(allParameters, forKey: .allParameters)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterNames = parameterNames {
            var parameterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterNames)
            for string0 in parameterNames {
                try parameterNamesContainer.encode(string0)
            }
        }
    }
}

extension ResetParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetParameterGroupInput: Swift.Equatable {
    /// If true, all parameters in the parameter group are reset to their default values. If false, only the parameters listed by ParameterNames are reset to their default values.
    public var allParameters: Swift.Bool?
    /// The name of the parameter group to reset.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// An array of parameter names to reset to their default values. If AllParameters is true, do not use ParameterNames. If AllParameters is false, you must specify the name of at least one parameter to reset.
    public var parameterNames: [Swift.String]?

    public init(
        allParameters: Swift.Bool? = nil,
        parameterGroupName: Swift.String? = nil,
        parameterNames: [Swift.String]? = nil
    )
    {
        self.allParameters = allParameters
        self.parameterGroupName = parameterGroupName
        self.parameterNames = parameterNames
    }
}

struct ResetParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let allParameters: Swift.Bool?
    let parameterNames: [Swift.String]?
}

extension ResetParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allParameters = "AllParameters"
        case parameterGroupName = "ParameterGroupName"
        case parameterNames = "ParameterNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let allParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allParameters)
        allParameters = allParametersDecoded
        let parameterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterNames)
        var parameterNamesDecoded0:[Swift.String]? = nil
        if let parameterNamesContainer = parameterNamesContainer {
            parameterNamesDecoded0 = [Swift.String]()
            for string0 in parameterNamesContainer {
                if let string0 = string0 {
                    parameterNamesDecoded0?.append(string0)
                }
            }
        }
        parameterNames = parameterNamesDecoded0
    }
}

extension ResetParameterGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetParameterGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct ResetParameterGroupOutput: Swift.Equatable {
    /// The parameter group being reset.
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct ResetParameterGroupOutputBody: Swift.Equatable {
    let parameterGroup: MemoryDBClientTypes.ParameterGroup?
}

extension ResetParameterGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

enum ResetParameterGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterGroupState": return try await InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryDBClientTypes.ReshardingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotMigration = "SlotMigration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotMigration = self.slotMigration {
            try encodeContainer.encode(slotMigration, forKey: .slotMigration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotMigrationDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.SlotMigration.self, forKey: .slotMigration)
        slotMigration = slotMigrationDecoded
    }
}

extension MemoryDBClientTypes {
    /// The status of the online resharding
    public struct ReshardingStatus: Swift.Equatable {
        /// The status of the online resharding slot migration
        public var slotMigration: MemoryDBClientTypes.SlotMigration?

        public init(
            slotMigration: MemoryDBClientTypes.SlotMigration? = nil
        )
        {
            self.slotMigration = slotMigration
        }
    }

}

extension MemoryDBClientTypes.SecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupId = "SecurityGroupId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents a single security group and its status.
    public struct SecurityGroupMembership: Swift.Equatable {
        /// The identifier of the security group.
        public var securityGroupId: Swift.String?
        /// The status of the security group membership. The status changes whenever a security group is modified, or when the security groups assigned to a cluster are modified.
        public var status: Swift.String?

        public init(
            securityGroupId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.securityGroupId = securityGroupId
            self.status = status
        }
    }

}

extension ServiceLinkedRoleNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceLinkedRoleNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceLinkedRoleNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLinkedRoleNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceLinkedRoleNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceLinkedRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ServiceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpdateStartDate = "AutoUpdateStartDate"
        case clusterName = "ClusterName"
        case description = "Description"
        case nodesUpdated = "NodesUpdated"
        case releaseDate = "ReleaseDate"
        case serviceUpdateName = "ServiceUpdateName"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoUpdateStartDate = self.autoUpdateStartDate {
            try encodeContainer.encodeTimestamp(autoUpdateStartDate, format: .epochSeconds, forKey: .autoUpdateStartDate)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodesUpdated = self.nodesUpdated {
            try encodeContainer.encode(nodesUpdated, forKey: .nodesUpdated)
        }
        if let releaseDate = self.releaseDate {
            try encodeContainer.encodeTimestamp(releaseDate, format: .epochSeconds, forKey: .releaseDate)
        }
        if let serviceUpdateName = self.serviceUpdateName {
            try encodeContainer.encode(serviceUpdateName, forKey: .serviceUpdateName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let serviceUpdateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateName)
        serviceUpdateName = serviceUpdateNameDecoded
        let releaseDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ServiceUpdateStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ServiceUpdateType.self, forKey: .type)
        type = typeDecoded
        let nodesUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodesUpdated)
        nodesUpdated = nodesUpdatedDecoded
        let autoUpdateStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .autoUpdateStartDate)
        autoUpdateStartDate = autoUpdateStartDateDecoded
    }
}

extension MemoryDBClientTypes {
    /// An update that you can apply to your MemoryDB clusters.
    public struct ServiceUpdate: Swift.Equatable {
        /// The date at which the service update will be automatically applied
        public var autoUpdateStartDate: ClientRuntime.Date?
        /// The name of the cluster to which the service update applies
        public var clusterName: Swift.String?
        /// Provides details of the service update
        public var description: Swift.String?
        /// A list of nodes updated by the service update
        public var nodesUpdated: Swift.String?
        /// The date when the service update is initially available
        public var releaseDate: ClientRuntime.Date?
        /// The unique ID of the service update
        public var serviceUpdateName: Swift.String?
        /// The status of the service update
        public var status: MemoryDBClientTypes.ServiceUpdateStatus?
        /// Reflects the nature of the service update
        public var type: MemoryDBClientTypes.ServiceUpdateType?

        public init(
            autoUpdateStartDate: ClientRuntime.Date? = nil,
            clusterName: Swift.String? = nil,
            description: Swift.String? = nil,
            nodesUpdated: Swift.String? = nil,
            releaseDate: ClientRuntime.Date? = nil,
            serviceUpdateName: Swift.String? = nil,
            status: MemoryDBClientTypes.ServiceUpdateStatus? = nil,
            type: MemoryDBClientTypes.ServiceUpdateType? = nil
        )
        {
            self.autoUpdateStartDate = autoUpdateStartDate
            self.clusterName = clusterName
            self.description = description
            self.nodesUpdated = nodesUpdated
            self.releaseDate = releaseDate
            self.serviceUpdateName = serviceUpdateName
            self.status = status
            self.type = type
        }
    }

}

extension ServiceUpdateNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUpdateNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceUpdateNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUpdateNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUpdateNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUpdateNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.ServiceUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceUpdateNameToApply = "ServiceUpdateNameToApply"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceUpdateNameToApply = self.serviceUpdateNameToApply {
            try encodeContainer.encode(serviceUpdateNameToApply, forKey: .serviceUpdateNameToApply)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceUpdateNameToApplyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateNameToApply)
        serviceUpdateNameToApply = serviceUpdateNameToApplyDecoded
    }
}

extension MemoryDBClientTypes {
    /// A request to apply a service update
    public struct ServiceUpdateRequest: Swift.Equatable {
        /// The unique ID of the service update
        public var serviceUpdateNameToApply: Swift.String?

        public init(
            serviceUpdateNameToApply: Swift.String? = nil
        )
        {
            self.serviceUpdateNameToApply = serviceUpdateNameToApply
        }
    }

}

extension MemoryDBClientTypes {
    public enum ServiceUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case notApplied
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceUpdateStatus] {
            return [
                .complete,
                .inProgress,
                .notApplied,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "complete"
            case .inProgress: return "in-progress"
            case .notApplied: return "available"
            case .scheduled: return "scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceUpdateStatus(rawValue: rawValue) ?? ServiceUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension MemoryDBClientTypes {
    public enum ServiceUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case securityUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceUpdateType] {
            return [
                .securityUpdate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .securityUpdate: return "security-update"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceUpdateType(rawValue: rawValue) ?? ServiceUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension MemoryDBClientTypes.Shard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case nodes = "Nodes"
        case numberOfNodes = "NumberOfNodes"
        case slots = "Slots"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for node0 in nodes {
                try nodesContainer.encode(node0)
            }
        }
        if let numberOfNodes = self.numberOfNodes {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if let slots = self.slots {
            try encodeContainer.encode(slots, forKey: .slots)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let slotsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slots)
        slots = slotsDecoded
        let nodesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[MemoryDBClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [MemoryDBClientTypes.Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents a collection of nodes in a cluster. One node in the node group is the read/write primary node. All the other nodes are read-only Replica nodes.
    public struct Shard: Swift.Equatable {
        /// The name of the shard
        public var name: Swift.String?
        /// A list containing information about individual nodes within the shard
        public var nodes: [MemoryDBClientTypes.Node]?
        /// The number of nodes in the shard
        public var numberOfNodes: Swift.Int?
        /// The keyspace for this shard.
        public var slots: Swift.String?
        /// The current state of this replication group - creating, available, modifying, deleting.
        public var status: Swift.String?

        public init(
            name: Swift.String? = nil,
            nodes: [MemoryDBClientTypes.Node]? = nil,
            numberOfNodes: Swift.Int? = nil,
            slots: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.name = name
            self.nodes = nodes
            self.numberOfNodes = numberOfNodes
            self.slots = slots
            self.status = status
        }
    }

}

extension MemoryDBClientTypes.ShardConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaCount = "ReplicaCount"
        case slots = "Slots"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let slots = self.slots {
            try encodeContainer.encode(slots, forKey: .slots)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slots)
        slots = slotsDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
    }
}

extension MemoryDBClientTypes {
    /// Shard configuration options. Each shard configuration has the following: Slots and ReplicaCount.
    public struct ShardConfiguration: Swift.Equatable {
        /// The number of read replica nodes in this shard.
        public var replicaCount: Swift.Int?
        /// A string that specifies the keyspace for a particular node group. Keyspaces range from 0 to 16,383. The string is in the format startkey-endkey.
        public var slots: Swift.String?

        public init(
            replicaCount: Swift.Int? = nil,
            slots: Swift.String? = nil
        )
        {
            self.replicaCount = replicaCount
            self.slots = slots
        }
    }

}

extension MemoryDBClientTypes.ShardConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardCount = "ShardCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if shardCount != 0 {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCount) ?? 0
        shardCount = shardCountDecoded
    }
}

extension MemoryDBClientTypes {
    /// A request to configure the sharding properties of a cluster
    public struct ShardConfigurationRequest: Swift.Equatable {
        /// The number of shards in the cluster
        public var shardCount: Swift.Int

        public init(
            shardCount: Swift.Int = 0
        )
        {
            self.shardCount = shardCount
        }
    }

}

extension MemoryDBClientTypes.ShardDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case name = "Name"
        case size = "Size"
        case snapshotCreationTime = "SnapshotCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let snapshotCreationTime = self.snapshotCreationTime {
            try encodeContainer.encodeTimestamp(snapshotCreationTime, format: .epochSeconds, forKey: .snapshotCreationTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ShardConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .size)
        size = sizeDecoded
        let snapshotCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreationTime)
        snapshotCreationTime = snapshotCreationTimeDecoded
    }
}

extension MemoryDBClientTypes {
    /// Provides details of a shard in a snapshot
    public struct ShardDetail: Swift.Equatable {
        /// The configuration details of the shard
        public var configuration: MemoryDBClientTypes.ShardConfiguration?
        /// The name of the shard
        public var name: Swift.String?
        /// The size of the shard's snapshot
        public var size: Swift.String?
        /// The date and time that the shard's snapshot was created
        public var snapshotCreationTime: ClientRuntime.Date?

        public init(
            configuration: MemoryDBClientTypes.ShardConfiguration? = nil,
            name: Swift.String? = nil,
            size: Swift.String? = nil,
            snapshotCreationTime: ClientRuntime.Date? = nil
        )
        {
            self.configuration = configuration
            self.name = name
            self.size = size
            self.snapshotCreationTime = snapshotCreationTime
        }
    }

}

extension ShardNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ShardNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ShardNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ShardNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ShardNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ShardNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShardsPerClusterQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ShardsPerClusterQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ShardsPerClusterQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ShardsPerClusterQuotaExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ShardsPerClusterQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ShardsPerClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.SlotMigration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressPercentage = "ProgressPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if progressPercentage != 0.0 {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .progressPercentage) ?? 0.0
        progressPercentage = progressPercentageDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents the progress of an online resharding operation.
    public struct SlotMigration: Swift.Equatable {
        /// The percentage of the slot migration that is complete.
        public var progressPercentage: Swift.Double

        public init(
            progressPercentage: Swift.Double = 0.0
        )
        {
            self.progressPercentage = progressPercentage
        }
    }

}

extension MemoryDBClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case clusterConfiguration = "ClusterConfiguration"
        case dataTiering = "DataTiering"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case source = "Source"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clusterConfiguration = self.clusterConfiguration {
            try encodeContainer.encode(clusterConfiguration, forKey: .clusterConfiguration)
        }
        if let dataTiering = self.dataTiering {
            try encodeContainer.encode(dataTiering.rawValue, forKey: .dataTiering)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clusterConfigurationDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ClusterConfiguration.self, forKey: .clusterConfiguration)
        clusterConfiguration = clusterConfigurationDecoded
        let dataTieringDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.DataTieringStatus.self, forKey: .dataTiering)
        dataTiering = dataTieringDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
    public struct Snapshot: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the snapshot.
        public var arn: Swift.String?
        /// The configuration of the cluster from which the snapshot was taken
        public var clusterConfiguration: MemoryDBClientTypes.ClusterConfiguration?
        /// Enables data tiering. Data tiering is only supported for clusters using the r6gd node type. This parameter must be set when using r6gd nodes. For more information, see [Data tiering](https://docs.aws.amazon.com/memorydb/latest/devguide/data-tiering.html).
        public var dataTiering: MemoryDBClientTypes.DataTieringStatus?
        /// The ID of the KMS key used to encrypt the snapshot.
        public var kmsKeyId: Swift.String?
        /// The name of the snapshot
        public var name: Swift.String?
        /// Indicates whether the snapshot is from an automatic backup (automated) or was created manually (manual).
        public var source: Swift.String?
        /// The status of the snapshot. Valid values: creating | available | restoring | copying | deleting.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            clusterConfiguration: MemoryDBClientTypes.ClusterConfiguration? = nil,
            dataTiering: MemoryDBClientTypes.DataTieringStatus? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            source: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.clusterConfiguration = clusterConfiguration
            self.dataTiering = dataTiering
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.source = source
            self.status = status
        }
    }

}

extension SnapshotAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapshotAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SnapshotAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotAlreadyExistsFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SnapshotAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapshotNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SnapshotNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SnapshotNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapshotQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SnapshotQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotQuotaExceededFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SnapshotQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acl
        case cluster
        case node
        case parameterGroup
        case subnetGroup
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .acl,
                .cluster,
                .node,
                .parameterGroup,
                .subnetGroup,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acl: return "acl"
            case .cluster: return "cluster"
            case .node: return "node"
            case .parameterGroup: return "parameter-group"
            case .subnetGroup: return "subnet-group"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension MemoryDBClientTypes.Subnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.AvailabilityZone.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents the subnet associated with a cluster. This parameter refers to subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with MemoryDB.
    public struct Subnet: Swift.Equatable {
        /// The Availability Zone where the subnet resides
        public var availabilityZone: MemoryDBClientTypes.AvailabilityZone?
        /// The unique identifier for the subnet.
        public var identifier: Swift.String?

        public init(
            availabilityZone: MemoryDBClientTypes.AvailabilityZone? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.identifier = identifier
        }
    }

}

extension MemoryDBClientTypes.SubnetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case description = "Description"
        case name = "Name"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[MemoryDBClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [MemoryDBClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MemoryDBClientTypes {
    /// Represents the output of one of the following operations:
    ///
    /// * CreateSubnetGroup
    ///
    /// * UpdateSubnetGroup
    ///
    ///
    /// A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.
    public struct SubnetGroup: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the subnet group.
        public var arn: Swift.String?
        /// A description of the subnet group
        public var description: Swift.String?
        /// The name of the subnet group
        public var name: Swift.String?
        /// A list of subnets associated with the subnet group.
        public var subnets: [MemoryDBClientTypes.Subnet]?
        /// The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            subnets: [MemoryDBClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SubnetGroupAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetGroupAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupInUseFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetGroupInUseFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetGroupInUseFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetGroupInUseFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupInUseFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetGroupNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetGroupQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetGroupQuotaExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetInUseBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetNotAllowedFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetNotAllowedFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetNotAllowedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetNotAllowedFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetNotAllowedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetNotAllowedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct SubnetQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetQuotaExceededFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MemoryDBClientTypes {
    /// A tag that can be added to an MemoryDB resource. Tags are composed of a Key/Value pair. You can use tags to categorize and track all your MemoryDB resources. When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. A tag with a null Value is permitted. For more information, see [Tagging your MemoryDB resources](https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging-resources.html)
    public struct Tag: Swift.Equatable {
        /// The key for the tag. May not be null.
        public var key: Swift.String?
        /// The tag's value. May be null.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TagNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagQuotaPerResourceExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagQuotaPerResourceExceededBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TagQuotaPerResourceExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagQuotaPerResourceExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagQuotaPerResourceExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagQuotaPerResourceExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which the tags are to be added
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    /// This member is required.
    public var tags: [MemoryDBClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [MemoryDBClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct TagResourceOutput: Swift.Equatable {
    /// A list of tags as key-value pairs.
    public var tagList: [MemoryDBClientTypes.Tag]?

    public init(
        tagList: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct TagResourceOutputBody: Swift.Equatable {
    let tagList: [MemoryDBClientTypes.Tag]?
}

extension TagResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidARN": return try await InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotNotFoundFault": return try await SnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagQuotaPerResourceExceeded": return try await TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestFailoverNotAvailableFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestFailoverNotAvailableFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TestFailoverNotAvailableFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TestFailoverNotAvailableFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TestFailoverNotAvailableFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension TestFailoverNotAvailableFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MemoryDBClientTypes.UnprocessedCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MemoryDBClientTypes {
    /// A cluster whose updates have failed
    public struct UnprocessedCluster: Swift.Equatable {
        /// The name of the cluster
        public var clusterName: Swift.String?
        /// The error message associated with the update failure
        public var errorMessage: Swift.String?
        /// The error type associated with the update failure
        public var errorType: Swift.String?

        public init(
            clusterName: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil
        )
        {
            self.clusterName = clusterName
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which the tags are to be removed
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of keys of the tags that are to be removed
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UntagResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct UntagResourceOutput: Swift.Equatable {
    /// The list of tags removed
    public var tagList: [MemoryDBClientTypes.Tag]?

    public init(
        tagList: [MemoryDBClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct UntagResourceOutputBody: Swift.Equatable {
    let tagList: [MemoryDBClientTypes.Tag]?
}

extension UntagResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[MemoryDBClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [MemoryDBClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidARN": return try await InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotNotFoundFault": return try await SnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagNotFound": return try await TagNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateACLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case userNamesToAdd = "UserNamesToAdd"
        case userNamesToRemove = "UserNamesToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
        if let userNamesToAdd = userNamesToAdd {
            var userNamesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userNamesToAdd)
            for username0 in userNamesToAdd {
                try userNamesToAddContainer.encode(username0)
            }
        }
        if let userNamesToRemove = userNamesToRemove {
            var userNamesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userNamesToRemove)
            for username0 in userNamesToRemove {
                try userNamesToRemoveContainer.encode(username0)
            }
        }
    }
}

extension UpdateACLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateACLInput: Swift.Equatable {
    /// The name of the Access Control List
    /// This member is required.
    public var aclName: Swift.String?
    /// The list of users to add to the Access Control List
    public var userNamesToAdd: [Swift.String]?
    /// The list of users to remove from the Access Control List
    public var userNamesToRemove: [Swift.String]?

    public init(
        aclName: Swift.String? = nil,
        userNamesToAdd: [Swift.String]? = nil,
        userNamesToRemove: [Swift.String]? = nil
    )
    {
        self.aclName = aclName
        self.userNamesToAdd = userNamesToAdd
        self.userNamesToRemove = userNamesToRemove
    }
}

struct UpdateACLInputBody: Swift.Equatable {
    let aclName: Swift.String?
    let userNamesToAdd: [Swift.String]?
    let userNamesToRemove: [Swift.String]?
}

extension UpdateACLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case userNamesToAdd = "UserNamesToAdd"
        case userNamesToRemove = "UserNamesToRemove"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
        let userNamesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userNamesToAdd)
        var userNamesToAddDecoded0:[Swift.String]? = nil
        if let userNamesToAddContainer = userNamesToAddContainer {
            userNamesToAddDecoded0 = [Swift.String]()
            for string0 in userNamesToAddContainer {
                if let string0 = string0 {
                    userNamesToAddDecoded0?.append(string0)
                }
            }
        }
        userNamesToAdd = userNamesToAddDecoded0
        let userNamesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userNamesToRemove)
        var userNamesToRemoveDecoded0:[Swift.String]? = nil
        if let userNamesToRemoveContainer = userNamesToRemoveContainer {
            userNamesToRemoveDecoded0 = [Swift.String]()
            for string0 in userNamesToRemoveContainer {
                if let string0 = string0 {
                    userNamesToRemoveDecoded0?.append(string0)
                }
            }
        }
        userNamesToRemove = userNamesToRemoveDecoded0
    }
}

extension UpdateACLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateACLOutputBody = try responseDecoder.decode(responseBody: data)
            self.acl = output.acl
        } else {
            self.acl = nil
        }
    }
}

public struct UpdateACLOutput: Swift.Equatable {
    /// The updated Access Control List
    public var acl: MemoryDBClientTypes.ACL?

    public init(
        acl: MemoryDBClientTypes.ACL? = nil
    )
    {
        self.acl = acl
    }
}

struct UpdateACLOutputBody: Swift.Equatable {
    let acl: MemoryDBClientTypes.ACL?
}

extension UpdateACLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acl = "ACL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ACL.self, forKey: .acl)
        acl = aclDecoded
    }
}

enum UpdateACLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DefaultUserRequired": return try await DefaultUserRequired(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateUserName": return try await DuplicateUserNameFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidACLState": return try await InvalidACLStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case clusterName = "ClusterName"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case maintenanceWindow = "MaintenanceWindow"
        case nodeType = "NodeType"
        case parameterGroupName = "ParameterGroupName"
        case replicaConfiguration = "ReplicaConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case shardConfiguration = "ShardConfiguration"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicStatus = "SnsTopicStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclName = self.aclName {
            try encodeContainer.encode(aclName, forKey: .aclName)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let replicaConfiguration = self.replicaConfiguration {
            try encodeContainer.encode(replicaConfiguration, forKey: .replicaConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let shardConfiguration = self.shardConfiguration {
            try encodeContainer.encode(shardConfiguration, forKey: .shardConfiguration)
        }
        if let snapshotRetentionLimit = self.snapshotRetentionLimit {
            try encodeContainer.encode(snapshotRetentionLimit, forKey: .snapshotRetentionLimit)
        }
        if let snapshotWindow = self.snapshotWindow {
            try encodeContainer.encode(snapshotWindow, forKey: .snapshotWindow)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let snsTopicStatus = self.snsTopicStatus {
            try encodeContainer.encode(snsTopicStatus, forKey: .snsTopicStatus)
        }
    }
}

extension UpdateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateClusterInput: Swift.Equatable {
    /// The Access Control List that is associated with the cluster
    public var aclName: Swift.String?
    /// The name of the cluster to update
    /// This member is required.
    public var clusterName: Swift.String?
    /// The description of the cluster to update
    public var description: Swift.String?
    /// The upgraded version of the engine to be run on the nodes. You can upgrade to a newer engine version, but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster and create it anew with the earlier engine version.
    public var engineVersion: Swift.String?
    /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:
    ///
    /// * sun
    ///
    /// * mon
    ///
    /// * tue
    ///
    /// * wed
    ///
    /// * thu
    ///
    /// * fri
    ///
    /// * sat
    ///
    ///
    /// Example: sun:23:00-mon:01:30
    public var maintenanceWindow: Swift.String?
    /// A valid node type that you want to scale this cluster up or down to.
    public var nodeType: Swift.String?
    /// The name of the parameter group to update
    public var parameterGroupName: Swift.String?
    /// The number of replicas that will reside in each shard
    public var replicaConfiguration: MemoryDBClientTypes.ReplicaConfigurationRequest?
    /// The SecurityGroupIds to update
    public var securityGroupIds: [Swift.String]?
    /// The number of shards in the cluster
    public var shardConfiguration: MemoryDBClientTypes.ShardConfigurationRequest?
    /// The number of days for which MemoryDB retains automatic cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
    public var snapshotRetentionLimit: Swift.Int?
    /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your cluster.
    public var snapshotWindow: Swift.String?
    /// The SNS topic ARN to update
    public var snsTopicArn: Swift.String?
    /// The status of the Amazon SNS notification topic. Notifications are sent only if the status is active.
    public var snsTopicStatus: Swift.String?

    public init(
        aclName: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        maintenanceWindow: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        replicaConfiguration: MemoryDBClientTypes.ReplicaConfigurationRequest? = nil,
        securityGroupIds: [Swift.String]? = nil,
        shardConfiguration: MemoryDBClientTypes.ShardConfigurationRequest? = nil,
        snapshotRetentionLimit: Swift.Int? = nil,
        snapshotWindow: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil,
        snsTopicStatus: Swift.String? = nil
    )
    {
        self.aclName = aclName
        self.clusterName = clusterName
        self.description = description
        self.engineVersion = engineVersion
        self.maintenanceWindow = maintenanceWindow
        self.nodeType = nodeType
        self.parameterGroupName = parameterGroupName
        self.replicaConfiguration = replicaConfiguration
        self.securityGroupIds = securityGroupIds
        self.shardConfiguration = shardConfiguration
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.snapshotWindow = snapshotWindow
        self.snsTopicArn = snsTopicArn
        self.snsTopicStatus = snsTopicStatus
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let description: Swift.String?
    let securityGroupIds: [Swift.String]?
    let maintenanceWindow: Swift.String?
    let snsTopicArn: Swift.String?
    let snsTopicStatus: Swift.String?
    let parameterGroupName: Swift.String?
    let snapshotWindow: Swift.String?
    let snapshotRetentionLimit: Swift.Int?
    let nodeType: Swift.String?
    let engineVersion: Swift.String?
    let replicaConfiguration: MemoryDBClientTypes.ReplicaConfigurationRequest?
    let shardConfiguration: MemoryDBClientTypes.ShardConfigurationRequest?
    let aclName: Swift.String?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclName = "ACLName"
        case clusterName = "ClusterName"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case maintenanceWindow = "MaintenanceWindow"
        case nodeType = "NodeType"
        case parameterGroupName = "ParameterGroupName"
        case replicaConfiguration = "ReplicaConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case shardConfiguration = "ShardConfiguration"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicStatus = "SnsTopicStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsTopicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicStatus)
        snsTopicStatus = snsTopicStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let replicaConfigurationDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ReplicaConfigurationRequest.self, forKey: .replicaConfiguration)
        replicaConfiguration = replicaConfigurationDecoded
        let shardConfigurationDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ShardConfigurationRequest.self, forKey: .shardConfiguration)
        shardConfiguration = shardConfigurationDecoded
        let aclNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aclName)
        aclName = aclNameDecoded
    }
}

extension UpdateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct UpdateClusterOutput: Swift.Equatable {
    /// The updated cluster
    public var cluster: MemoryDBClientTypes.Cluster?

    public init(
        cluster: MemoryDBClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct UpdateClusterOutputBody: Swift.Equatable {
    let cluster: MemoryDBClientTypes.Cluster?
}

extension UpdateClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

enum UpdateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ACLNotFound": return try await ACLNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterNotFound": return try await ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClusterQuotaForCustomerExceeded": return try await ClusterQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidACLState": return try await InvalidACLStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClusterState": return try await InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidKMSKeyFault": return try await InvalidKMSKeyFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNodeState": return try await InvalidNodeStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidVPCNetworkStateFault": return try await InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NodeQuotaForClusterExceeded": return try await NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NodeQuotaForCustomerExceeded": return try await NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoOperationFault": return try await NoOperationFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ShardsPerClusterQuotaExceeded": return try await ShardsPerClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterNameValues = parameterNameValues {
            var parameterNameValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterNameValues)
            for parameternamevalue0 in parameterNameValues {
                try parameterNameValuesContainer.encode(parameternamevalue0)
            }
        }
    }
}

extension UpdateParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateParameterGroupInput: Swift.Equatable {
    /// The name of the parameter group to update.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// An array of parameter names and values for the parameter update. You must supply at least one parameter name and value; subsequent arguments are optional. A maximum of 20 parameters may be updated per request.
    /// This member is required.
    public var parameterNameValues: [MemoryDBClientTypes.ParameterNameValue]?

    public init(
        parameterGroupName: Swift.String? = nil,
        parameterNameValues: [MemoryDBClientTypes.ParameterNameValue]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }
}

struct UpdateParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let parameterNameValues: [MemoryDBClientTypes.ParameterNameValue]?
}

extension UpdateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterNameValuesContainer = try containerValues.decodeIfPresent([MemoryDBClientTypes.ParameterNameValue?].self, forKey: .parameterNameValues)
        var parameterNameValuesDecoded0:[MemoryDBClientTypes.ParameterNameValue]? = nil
        if let parameterNameValuesContainer = parameterNameValuesContainer {
            parameterNameValuesDecoded0 = [MemoryDBClientTypes.ParameterNameValue]()
            for structure0 in parameterNameValuesContainer {
                if let structure0 = structure0 {
                    parameterNameValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterNameValues = parameterNameValuesDecoded0
    }
}

extension UpdateParameterGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateParameterGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct UpdateParameterGroupOutput: Swift.Equatable {
    /// The updated parameter group
    public var parameterGroup: MemoryDBClientTypes.ParameterGroup?

    public init(
        parameterGroup: MemoryDBClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct UpdateParameterGroupOutputBody: Swift.Equatable {
    let parameterGroup: MemoryDBClientTypes.ParameterGroup?
}

extension UpdateParameterGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

enum UpdateParameterGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterGroupState": return try await InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParameterGroupNotFound": return try await ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }
}

extension UpdateSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSubnetGroupInput: Swift.Equatable {
    /// A description of the subnet group
    public var description: Swift.String?
    /// The name of the subnet group
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// The EC2 subnet IDs for the subnet group.
    public var subnetIds: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct UpdateSubnetGroupInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
    let description: Swift.String?
    let subnetIds: [Swift.String]?
}

extension UpdateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension UpdateSubnetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubnetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct UpdateSubnetGroupOutput: Swift.Equatable {
    /// The updated subnet group
    public var subnetGroup: MemoryDBClientTypes.SubnetGroup?

    public init(
        subnetGroup: MemoryDBClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct UpdateSubnetGroupOutputBody: Swift.Equatable {
    let subnetGroup: MemoryDBClientTypes.SubnetGroup?
}

extension UpdateSubnetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

enum UpdateSubnetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleNotFoundFault": return try await ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetGroupNotFoundFault": return try await SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetInUse": return try await SubnetInUse(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetNotAllowedFault": return try await SubnetNotAllowedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetQuotaExceededFault": return try await SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessString = "AccessString"
        case authenticationMode = "AuthenticationMode"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessString = self.accessString {
            try encodeContainer.encode(accessString, forKey: .accessString)
        }
        if let authenticationMode = self.authenticationMode {
            try encodeContainer.encode(authenticationMode, forKey: .authenticationMode)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// Access permissions string used for this user.
    public var accessString: Swift.String?
    /// Denotes the user's authentication properties, such as whether it requires a password to authenticate.
    public var authenticationMode: MemoryDBClientTypes.AuthenticationMode?
    /// The name of the user
    /// This member is required.
    public var userName: Swift.String?

    public init(
        accessString: Swift.String? = nil,
        authenticationMode: MemoryDBClientTypes.AuthenticationMode? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessString = accessString
        self.authenticationMode = authenticationMode
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationMode: MemoryDBClientTypes.AuthenticationMode?
    let accessString: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessString = "AccessString"
        case authenticationMode = "AuthenticationMode"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationModeDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.AuthenticationMode.self, forKey: .authenticationMode)
        authenticationMode = authenticationModeDecoded
        let accessStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessString)
        accessString = accessStringDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct UpdateUserOutput: Swift.Equatable {
    /// The updated user
    public var user: MemoryDBClientTypes.User?

    public init(
        user: MemoryDBClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct UpdateUserOutputBody: Swift.Equatable {
    let user: MemoryDBClientTypes.User?
}

extension UpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombination": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValue": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUserState": return try await InvalidUserStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserNotFound": return try await UserNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryDBClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclNames = "ACLNames"
        case arn = "ARN"
        case accessString = "AccessString"
        case authentication = "Authentication"
        case minimumEngineVersion = "MinimumEngineVersion"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclNames = aclNames {
            var aclNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aclNames)
            for aclname0 in aclNames {
                try aclNamesContainer.encode(aclname0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let accessString = self.accessString {
            try encodeContainer.encode(accessString, forKey: .accessString)
        }
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let minimumEngineVersion = self.minimumEngineVersion {
            try encodeContainer.encode(minimumEngineVersion, forKey: .minimumEngineVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let accessStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessString)
        accessString = accessStringDecoded
        let aclNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aclNames)
        var aclNamesDecoded0:[Swift.String]? = nil
        if let aclNamesContainer = aclNamesContainer {
            aclNamesDecoded0 = [Swift.String]()
            for string0 in aclNamesContainer {
                if let string0 = string0 {
                    aclNamesDecoded0?.append(string0)
                }
            }
        }
        aclNames = aclNamesDecoded0
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(MemoryDBClientTypes.Authentication.self, forKey: .authentication)
        authentication = authenticationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MemoryDBClientTypes {
    /// You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.
    public struct User: Swift.Equatable {
        /// Access permissions string used for this user.
        public var accessString: Swift.String?
        /// The names of the Access Control Lists to which the user belongs
        public var aclNames: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the user.
        public var arn: Swift.String?
        /// Denotes whether the user requires a password to authenticate.
        public var authentication: MemoryDBClientTypes.Authentication?
        /// The minimum engine version supported for the user
        public var minimumEngineVersion: Swift.String?
        /// The name of the user
        public var name: Swift.String?
        /// Indicates the user status. Can be "active", "modifying" or "deleting".
        public var status: Swift.String?

        public init(
            accessString: Swift.String? = nil,
            aclNames: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            authentication: MemoryDBClientTypes.Authentication? = nil,
            minimumEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.accessString = accessString
            self.aclNames = aclNames
            self.arn = arn
            self.authentication = authentication
            self.minimumEngineVersion = minimumEngineVersion
            self.name = name
            self.status = status
        }
    }

}

extension UserAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct UserAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UserAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct UserNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UserNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct UserQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserQuotaExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UserQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
