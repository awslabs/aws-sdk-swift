// Code generated by smithy-swift-codegen. DO NOT EDIT!

import class ClientRuntime.Waiter
import enum ClientRuntime.JMESUtils
import protocol ClientRuntime.ServiceError
import struct ClientRuntime.WaiterConfiguration
import struct ClientRuntime.WaiterOptions
import struct ClientRuntime.WaiterOutcome

extension LexModelsV2Client {

    static func botAvailableWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeBotInput, DescribeBotOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeBotInput, DescribeBotOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotInput, result: Swift.Result<DescribeBotOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Available"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Available")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotInput, result: Swift.Result<DescribeBotOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotInput, result: Swift.Result<DescribeBotOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotInput, result: Swift.Result<DescribeBotOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Inactive"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Inactive")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeBotInput, DescribeBotOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotAvailable event on the describeBot operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotAvailable(options: ClientRuntime.WaiterOptions, input: DescribeBotInput) async throws -> ClientRuntime.WaiterOutcome<DescribeBotOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botAvailableWaiterConfig(), operation: self.describeBot(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botAliasAvailableWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeBotAliasInput, DescribeBotAliasOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeBotAliasInput, DescribeBotAliasOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotAliasInput, result: Swift.Result<DescribeBotAliasOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botAliasStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Available"
                guard case .success(let output) = result else { return false }
                let botAliasStatus = output.botAliasStatus
                return ClientRuntime.JMESUtils.compare(botAliasStatus, ==, "Available")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotAliasInput, result: Swift.Result<DescribeBotAliasOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botAliasStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botAliasStatus = output.botAliasStatus
                return ClientRuntime.JMESUtils.compare(botAliasStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotAliasInput, result: Swift.Result<DescribeBotAliasOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botAliasStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botAliasStatus = output.botAliasStatus
                return ClientRuntime.JMESUtils.compare(botAliasStatus, ==, "Deleting")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeBotAliasInput, DescribeBotAliasOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotAliasAvailable event on the describeBotAlias operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotAliasInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotAliasAvailable(options: ClientRuntime.WaiterOptions, input: DescribeBotAliasInput) async throws -> ClientRuntime.WaiterOutcome<DescribeBotAliasOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botAliasAvailableWaiterConfig(), operation: self.describeBotAlias(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botLocaleBuiltWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Built"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Built")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "NotBuilt"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "NotBuilt")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotLocaleBuilt event on the describeBotLocale operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotLocaleInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotLocaleBuilt(options: ClientRuntime.WaiterOptions, input: DescribeBotLocaleInput) async throws -> ClientRuntime.WaiterOutcome<DescribeBotLocaleOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botLocaleBuiltWaiterConfig(), operation: self.describeBotLocale(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botLocaleCreatedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Built"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Built")
            }),
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ReadyExpressTesting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "ReadyExpressTesting")
            }),
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "NotBuilt"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "NotBuilt")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Failed")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotLocaleCreated event on the describeBotLocale operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotLocaleInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotLocaleCreated(options: ClientRuntime.WaiterOptions, input: DescribeBotLocaleInput) async throws -> ClientRuntime.WaiterOutcome<DescribeBotLocaleOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botLocaleCreatedWaiterConfig(), operation: self.describeBotLocale(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botLocaleExpressTestingAvailableWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Built"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Built")
            }),
            .init(state: .success, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "ReadyExpressTesting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "ReadyExpressTesting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotLocaleInput, result: Swift.Result<DescribeBotLocaleOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botLocaleStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "NotBuilt"
                guard case .success(let output) = result else { return false }
                let botLocaleStatus = output.botLocaleStatus
                return ClientRuntime.JMESUtils.compare(botLocaleStatus, ==, "NotBuilt")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeBotLocaleInput, DescribeBotLocaleOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotLocaleExpressTestingAvailable event on the describeBotLocale operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotLocaleInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotLocaleExpressTestingAvailable(options: ClientRuntime.WaiterOptions, input: DescribeBotLocaleInput) async throws -> ClientRuntime.WaiterOutcome<DescribeBotLocaleOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botLocaleExpressTestingAvailableWaiterConfig(), operation: self.describeBotLocale(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botVersionAvailableWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeBotVersionInput, DescribeBotVersionOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeBotVersionInput, DescribeBotVersionOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBotVersionInput, result: Swift.Result<DescribeBotVersionOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Available"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Available")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotVersionInput, result: Swift.Result<DescribeBotVersionOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeBotVersionInput, result: Swift.Result<DescribeBotVersionOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "botStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let botStatus = output.botStatus
                return ClientRuntime.JMESUtils.compare(botStatus, ==, "Failed")
            }),
            .init(state: .retry, matcher: { (input: DescribeBotVersionInput, result: Swift.Result<DescribeBotVersionOutput, Swift.Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ClientRuntime.ServiceError)?.typeName == "ResourceNotFoundException"
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeBotVersionInput, DescribeBotVersionOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotVersionAvailable event on the describeBotVersion operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBotVersionInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotVersionAvailable(options: ClientRuntime.WaiterOptions, input: DescribeBotVersionInput) async throws -> ClientRuntime.WaiterOutcome<DescribeBotVersionOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botVersionAvailableWaiterConfig(), operation: self.describeBotVersion(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botExportCompletedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeExportInput, DescribeExportOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeExportInput, DescribeExportOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeExportInput, result: Swift.Result<DescribeExportOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "exportStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let exportStatus = output.exportStatus
                return ClientRuntime.JMESUtils.compare(exportStatus, ==, "Completed")
            }),
            .init(state: .failure, matcher: { (input: DescribeExportInput, result: Swift.Result<DescribeExportOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "exportStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let exportStatus = output.exportStatus
                return ClientRuntime.JMESUtils.compare(exportStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeExportInput, result: Swift.Result<DescribeExportOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "exportStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let exportStatus = output.exportStatus
                return ClientRuntime.JMESUtils.compare(exportStatus, ==, "Failed")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeExportInput, DescribeExportOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotExportCompleted event on the describeExport operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeExportInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotExportCompleted(options: ClientRuntime.WaiterOptions, input: DescribeExportInput) async throws -> ClientRuntime.WaiterOutcome<DescribeExportOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botExportCompletedWaiterConfig(), operation: self.describeExport(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func botImportCompletedWaiterConfig() throws -> ClientRuntime.WaiterConfiguration<DescribeImportInput, DescribeImportOutput> {
        let acceptors: [ClientRuntime.WaiterConfiguration<DescribeImportInput, DescribeImportOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImportInput, result: Swift.Result<DescribeImportOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "importStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let importStatus = output.importStatus
                return ClientRuntime.JMESUtils.compare(importStatus, ==, "Completed")
            }),
            .init(state: .failure, matcher: { (input: DescribeImportInput, result: Swift.Result<DescribeImportOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "importStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Deleting"
                guard case .success(let output) = result else { return false }
                let importStatus = output.importStatus
                return ClientRuntime.JMESUtils.compare(importStatus, ==, "Deleting")
            }),
            .init(state: .failure, matcher: { (input: DescribeImportInput, result: Swift.Result<DescribeImportOutput, Swift.Error>) -> Bool in
                // JMESPath expression: "importStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let importStatus = output.importStatus
                return ClientRuntime.JMESUtils.compare(importStatus, ==, "Failed")
            }),
        ]
        return try ClientRuntime.WaiterConfiguration<DescribeImportInput, DescribeImportOutput>(acceptors: acceptors, minDelay: 10.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BotImportCompleted event on the describeImport operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImportInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBotImportCompleted(options: ClientRuntime.WaiterOptions, input: DescribeImportInput) async throws -> ClientRuntime.WaiterOutcome<DescribeImportOutput> {
        let waiter = ClientRuntime.Waiter(config: try Self.botImportCompletedWaiterConfig(), operation: self.describeImport(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
